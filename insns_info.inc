/** -*-c-*-
  This file contains instruction information for yarv instruction sequence.

  ----
  This file is auto generated by insns2vm.rb
  DO NOT TOUCH!

  If you want to fix something, you must edit 'template/insns_info.inc.tmpl'
  or tool/insns2vm.rb
 */

#define TS_OFFSET 'O'
#define TS_NUM 'N'
#define TS_LINDEX 'L'
#define TS_VALUE 'V'
#define TS_ID 'I'
#define TS_GENTRY 'G'
#define TS_IC 'K'
#define TS_CALLINFO 'C'
#define TS_CALLCACHE 'E'
#define TS_CDHASH 'H'
#define TS_ISEQ 'S'
#define TS_VARIABLE '.'
#define TS_FUNCPTR 'F'

static const unsigned short insn_name_info_offset[] = {
    0,
    4,
    13,
    22,
    36,
    50,
    61,
    72,
    92,
    112,
    129,
    146,
    158,
    170,
    180,
    190,
    197,
    205,
    215,
    232,
    240,
    250,
    264,
    273,
    286,
    295,
    302,
    311,
    320,
    332,
    344,
    355,
    363,
    372,
    376,
    380,
    385,
    390,
    398,
    404,
    409,
    414,
    426,
    434,
    445,
    458,
    472,
    484,
    489,
    504,
    519,
    536,
    553,
    576,
    588,
    600,
    606,
    612,
    617,
    626,
    639,
    649,
    662,
    677,
    692,
    697,
    715,
    724,
    734,
    743,
    751,
    759,
    766,
    774,
    781,
    788,
    795,
    802,
    811,
    820,
    829,
    843,
    857,
    868,
    877,
    889,
    898,
    906,
    923,
    940,
    960,
    967,
    974,
    993,
    1012,
    1031,
    1050,
    1078,
    1106,
    1116,
    1131,
    1146,
    1166,
    1186,
    1203,
    1220,
    1246,
    1272,
    1295,
    1318,
    1336,
    1354,
    1370,
    1386,
    1399,
    1413,
    1429,
    1452,
    1466,
    1482,
    1502,
    1517,
    1536,
    1551,
    1564,
    1579,
    1594,
    1612,
    1630,
    1647,
    1661,
    1676,
    1686,
    1696,
    1707,
    1718,
    1732,
    1744,
    1755,
    1766,
    1784,
    1798,
    1815,
    1834,
    1854,
    1872,
    1883,
    1904,
    1925,
    1948,
    1971,
    2000,
    2018,
    2036,
    2048,
    2060,
    2071,
    2086,
    2105,
    2121,
    2140,
    2161,
    2182,
    2193,
    2217,
    2232,
    2248,
    2263,
    2277,
    2291,
    2304,
    2318,
    2331,
    2344,
    2357,
    2370,
    2385,
    2400,
    2415,
    2435,
    2455,
    2472,
    2487,
    2505,
    2520,
    2534,
    2557,
    2580,
    2606,
    2619,
    2632,
    2657,
    2682,
    2707,
    2732,
    2766,
};

ASSERT_VM_INSTRUCTION_SIZE(insn_name_info_offset);

static const char insn_name_info_base[2800] = ""
    "nop\0"
    "getlocal\0"
    "setlocal\0"
    "getblockparam\0"
    "setblockparam\0"
    "getspecial\0"
    "setspecial\0"
    "getinstancevariable\0"
    "setinstancevariable\0"
    "getclassvariable\0"
    "setclassvariable\0"
    "getconstant\0"
    "setconstant\0"
    "getglobal\0"
    "setglobal\0"
    "putnil\0"
    "putself\0"
    "putobject\0"
    "putspecialobject\0"
    "putiseq\0"
    "putstring\0"
    "concatstrings\0"
    "tostring\0"
    "freezestring\0"
    "toregexp\0"
    "intern\0"
    "newarray\0"
    "duparray\0"
    "expandarray\0"
    "concatarray\0"
    "splatarray\0"
    "newhash\0"
    "newrange\0"
    "pop\0"
    "dup\0"
    "dupn\0"
    "swap\0"
    "reverse\0"
    "reput\0"
    "topn\0"
    "setn\0"
    "adjuststack\0"
    "defined\0"
    "checkmatch\0"
    "checkkeyword\0"
    "tracecoverage\0"
    "defineclass\0"
    "send\0"
    "opt_str_freeze\0"
    "opt_str_uminus\0"
    "opt_newarray_max\0"
    "opt_newarray_min\0"
    "opt_send_without_block\0"
    "invokesuper\0"
    "invokeblock\0"
    "leave\0"
    "throw\0"
    "jump\0"
    "branchif\0"
    "branchunless\0"
    "branchnil\0"
    "branchiftype\0"
    "getinlinecache\0"
    "setinlinecache\0"
    "once\0"
    "opt_case_dispatch\0"
    "opt_plus\0"
    "opt_minus\0"
    "opt_mult\0"
    "opt_div\0"
    "opt_mod\0"
    "opt_eq\0"
    "opt_neq\0"
    "opt_lt\0"
    "opt_le\0"
    "opt_gt\0"
    "opt_ge\0"
    "opt_ltlt\0"
    "opt_aref\0"
    "opt_aset\0"
    "opt_aset_with\0"
    "opt_aref_with\0"
    "opt_length\0"
    "opt_size\0"
    "opt_empty_p\0"
    "opt_succ\0"
    "opt_not\0"
    "opt_regexpmatch1\0"
    "opt_regexpmatch2\0"
    "opt_call_c_function\0"
    "bitblt\0"
    "answer\0"
    "getlocal_OP__WC__0\0"
    "getlocal_OP__WC__1\0"
    "setlocal_OP__WC__0\0"
    "setlocal_OP__WC__1\0"
    "putobject_OP_INT2FIX_O_0_C_\0"
    "putobject_OP_INT2FIX_O_1_C_\0"
    "trace_nop\0"
    "trace_getlocal\0"
    "trace_setlocal\0"
    "trace_getblockparam\0"
    "trace_setblockparam\0"
    "trace_getspecial\0"
    "trace_setspecial\0"
    "trace_getinstancevariable\0"
    "trace_setinstancevariable\0"
    "trace_getclassvariable\0"
    "trace_setclassvariable\0"
    "trace_getconstant\0"
    "trace_setconstant\0"
    "trace_getglobal\0"
    "trace_setglobal\0"
    "trace_putnil\0"
    "trace_putself\0"
    "trace_putobject\0"
    "trace_putspecialobject\0"
    "trace_putiseq\0"
    "trace_putstring\0"
    "trace_concatstrings\0"
    "trace_tostring\0"
    "trace_freezestring\0"
    "trace_toregexp\0"
    "trace_intern\0"
    "trace_newarray\0"
    "trace_duparray\0"
    "trace_expandarray\0"
    "trace_concatarray\0"
    "trace_splatarray\0"
    "trace_newhash\0"
    "trace_newrange\0"
    "trace_pop\0"
    "trace_dup\0"
    "trace_dupn\0"
    "trace_swap\0"
    "trace_reverse\0"
    "trace_reput\0"
    "trace_topn\0"
    "trace_setn\0"
    "trace_adjuststack\0"
    "trace_defined\0"
    "trace_checkmatch\0"
    "trace_checkkeyword\0"
    "trace_tracecoverage\0"
    "trace_defineclass\0"
    "trace_send\0"
    "trace_opt_str_freeze\0"
    "trace_opt_str_uminus\0"
    "trace_opt_newarray_max\0"
    "trace_opt_newarray_min\0"
    "trace_opt_send_without_block\0"
    "trace_invokesuper\0"
    "trace_invokeblock\0"
    "trace_leave\0"
    "trace_throw\0"
    "trace_jump\0"
    "trace_branchif\0"
    "trace_branchunless\0"
    "trace_branchnil\0"
    "trace_branchiftype\0"
    "trace_getinlinecache\0"
    "trace_setinlinecache\0"
    "trace_once\0"
    "trace_opt_case_dispatch\0"
    "trace_opt_plus\0"
    "trace_opt_minus\0"
    "trace_opt_mult\0"
    "trace_opt_div\0"
    "trace_opt_mod\0"
    "trace_opt_eq\0"
    "trace_opt_neq\0"
    "trace_opt_lt\0"
    "trace_opt_le\0"
    "trace_opt_gt\0"
    "trace_opt_ge\0"
    "trace_opt_ltlt\0"
    "trace_opt_aref\0"
    "trace_opt_aset\0"
    "trace_opt_aset_with\0"
    "trace_opt_aref_with\0"
    "trace_opt_length\0"
    "trace_opt_size\0"
    "trace_opt_empty_p\0"
    "trace_opt_succ\0"
    "trace_opt_not\0"
    "trace_opt_regexpmatch1\0"
    "trace_opt_regexpmatch2\0"
    "trace_opt_call_c_function\0"
    "trace_bitblt\0"
    "trace_answer\0"
    "trace_getlocal_OP__WC__0\0"
    "trace_getlocal_OP__WC__1\0"
    "trace_setlocal_OP__WC__0\0"
    "trace_setlocal_OP__WC__1\0"
    "trace_putobject_OP_INT2FIX_O_0_C_\0"
    "trace_putobject_OP_INT2FIX_O_1_C_\0"
;

#define insn_name_info insn_name_info_base+insn_name_info_offset

static const char insn_operand_info[][8] = {
    "\1""",
    "\3""LN",
    "\3""LN",
    "\3""LN",
    "\3""LN",
    "\3""NN",
    "\2""N",
    "\3""IK",
    "\3""IK",
    "\2""I",
    "\2""I",
    "\2""I",
    "\2""I",
    "\2""G",
    "\2""G",
    "\1""",
    "\1""",
    "\2""V",
    "\2""N",
    "\2""S",
    "\2""V",
    "\2""N",
    "\1""",
    "\2""V",
    "\3""NN",
    "\1""",
    "\2""N",
    "\2""V",
    "\3""NN",
    "\1""",
    "\2""V",
    "\2""N",
    "\2""N",
    "\1""",
    "\1""",
    "\2""N",
    "\1""",
    "\2""N",
    "\1""",
    "\2""N",
    "\2""N",
    "\2""N",
    "\4""NVV",
    "\2""N",
    "\3""LL",
    "\3""NV",
    "\4""ISN",
    "\4""CES",
    "\2""V",
    "\2""V",
    "\2""N",
    "\2""N",
    "\3""CE",
    "\4""CES",
    "\2""C",
    "\1""",
    "\2""N",
    "\2""O",
    "\2""O",
    "\2""O",
    "\2""O",
    "\3""NO",
    "\3""OK",
    "\2""K",
    "\3""SK",
    "\3""HO",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\5""CECE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\4""CEV",
    "\4""CEV",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\2""V",
    "\3""CE",
    "\2""F",
    "\1""",
    "\1""",
    "\2""L",
    "\2""L",
    "\2""L",
    "\2""L",
    "\1""",
    "\1""",
    "\1""",
    "\3""LN",
    "\3""LN",
    "\3""LN",
    "\3""LN",
    "\3""NN",
    "\2""N",
    "\3""IK",
    "\3""IK",
    "\2""I",
    "\2""I",
    "\2""I",
    "\2""I",
    "\2""G",
    "\2""G",
    "\1""",
    "\1""",
    "\2""V",
    "\2""N",
    "\2""S",
    "\2""V",
    "\2""N",
    "\1""",
    "\2""V",
    "\3""NN",
    "\1""",
    "\2""N",
    "\2""V",
    "\3""NN",
    "\1""",
    "\2""V",
    "\2""N",
    "\2""N",
    "\1""",
    "\1""",
    "\2""N",
    "\1""",
    "\2""N",
    "\1""",
    "\2""N",
    "\2""N",
    "\2""N",
    "\4""NVV",
    "\2""N",
    "\3""LL",
    "\3""NV",
    "\4""ISN",
    "\4""CES",
    "\2""V",
    "\2""V",
    "\2""N",
    "\2""N",
    "\3""CE",
    "\4""CES",
    "\2""C",
    "\1""",
    "\2""N",
    "\2""O",
    "\2""O",
    "\2""O",
    "\2""O",
    "\3""NO",
    "\3""OK",
    "\2""K",
    "\3""SK",
    "\3""HO",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\5""CECE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\4""CEV",
    "\4""CEV",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\3""CE",
    "\2""V",
    "\3""CE",
    "\2""F",
    "\1""",
    "\1""",
    "\2""L",
    "\2""L",
    "\2""L",
    "\2""L",
    "\1""",
    "\1""",
};

ASSERT_VM_INSTRUCTION_SIZE(insn_operand_info);

#ifdef USE_INSN_RET_NUM
static const unsigned short insn_stack_push_num_info[] = {
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    2,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    2,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
};

ASSERT_VM_INSTRUCTION_SIZE(insn_stack_push_num_info);
#endif

#ifdef USE_INSN_STACK_INCREASE
static int
insn_stack_increase(int depth, int insn, VALUE *opes)
{
    switch (insn) {
      case BIN(nop): {
	return depth + 0;
      }
      case BIN(getlocal): {
	return depth + 1;
      }
      case BIN(setlocal): {
	return depth + -1;
      }
      case BIN(getblockparam): {
	return depth + 1;
      }
      case BIN(setblockparam): {
	return depth + -1;
      }
      case BIN(getspecial): {
	return depth + 1;
      }
      case BIN(setspecial): {
	return depth + -1;
      }
      case BIN(getinstancevariable): {
	return depth + 1;
      }
      case BIN(setinstancevariable): {
	return depth + -1;
      }
      case BIN(getclassvariable): {
	return depth + 1;
      }
      case BIN(setclassvariable): {
	return depth + -1;
      }
      case BIN(getconstant): {
	return depth + 0;
      }
      case BIN(setconstant): {
	return depth + -2;
      }
      case BIN(getglobal): {
	return depth + 1;
      }
      case BIN(setglobal): {
	return depth + -1;
      }
      case BIN(putnil): {
	return depth + 1;
      }
      case BIN(putself): {
	return depth + 1;
      }
      case BIN(putobject): {
	return depth + 1;
      }
      case BIN(putspecialobject): {
	return depth + 1;
      }
      case BIN(putiseq): {
	return depth + 1;
      }
      case BIN(putstring): {
	return depth + 1;
      }
      case BIN(concatstrings): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(tostring): {
	return depth + -1;
      }
      case BIN(freezestring): {
	return depth + 0;
      }
      case BIN(toregexp): {
	int inc = 0;
        int cnt = FIX2INT(opes[1]);
        inc += 1 - cnt;;
        return depth + inc;
      }
      case BIN(intern): {
	return depth + 0;
      }
      case BIN(newarray): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(duparray): {
	return depth + 1;
      }
      case BIN(expandarray): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        int flag = FIX2INT(opes[1]);
        inc += num - 1 + (flag & 1 ? 1 : 0);;
        return depth + inc;
      }
      case BIN(concatarray): {
	return depth + -1;
      }
      case BIN(splatarray): {
	return depth + 0;
      }
      case BIN(newhash): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(newrange): {
	return depth + -1;
      }
      case BIN(pop): {
	return depth + -1;
      }
      case BIN(dup): {
	return depth + 1;
      }
      case BIN(dupn): {
	int inc = 0;
        int n = FIX2INT(opes[0]);
        inc += n;;
        return depth + inc;
      }
      case BIN(swap): {
	return depth + 0;
      }
      case BIN(reverse): {
	int inc = 0;
        inc += 0;;
        return depth + inc;
      }
      case BIN(reput): {
	int inc = 0;
        inc += 0;;
        return depth + inc;
      }
      case BIN(topn): {
	int inc = 0;
        inc += 1;;
        return depth + inc;
      }
      case BIN(setn): {
	int inc = 0;
        inc += 0;
        return depth + inc;
      }
      case BIN(adjuststack): {
	int inc = 0;
        int n = FIX2INT(opes[0]);
        inc -= n;
        return depth + inc;
      }
      case BIN(defined): {
	return depth + 0;
      }
      case BIN(checkmatch): {
	return depth + -1;
      }
      case BIN(checkkeyword): {
	return depth + 1;
      }
      case BIN(tracecoverage): {
	return depth + 0;
      }
      case BIN(defineclass): {
	return depth + -1;
      }
      case BIN(send): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += - (int)(ci->orig_argc + ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0));;
        return depth + inc;
      }
      case BIN(opt_str_freeze): {
	return depth + 1;
      }
      case BIN(opt_str_uminus): {
	return depth + 1;
      }
      case BIN(opt_newarray_max): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(opt_newarray_min): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(opt_send_without_block): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += -ci->orig_argc;;
        return depth + inc;
      }
      case BIN(invokesuper): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += - (int)(ci->orig_argc + ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0));;
        return depth + inc;
      }
      case BIN(invokeblock): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += 1 - ci->orig_argc;;
        return depth + inc;
      }
      case BIN(leave): {
	return depth + 0;
      }
      case BIN(throw): {
	return depth + 0;
      }
      case BIN(jump): {
	return depth + 0;
      }
      case BIN(branchif): {
	return depth + -1;
      }
      case BIN(branchunless): {
	return depth + -1;
      }
      case BIN(branchnil): {
	return depth + -1;
      }
      case BIN(branchiftype): {
	return depth + -1;
      }
      case BIN(getinlinecache): {
	return depth + 1;
      }
      case BIN(setinlinecache): {
	return depth + 0;
      }
      case BIN(once): {
	return depth + 1;
      }
      case BIN(opt_case_dispatch): {
	int inc = 0;
        inc += -1;;
        return depth + inc;
      }
      case BIN(opt_plus): {
	return depth + -1;
      }
      case BIN(opt_minus): {
	return depth + -1;
      }
      case BIN(opt_mult): {
	return depth + -1;
      }
      case BIN(opt_div): {
	return depth + -1;
      }
      case BIN(opt_mod): {
	return depth + -1;
      }
      case BIN(opt_eq): {
	return depth + -1;
      }
      case BIN(opt_neq): {
	return depth + -1;
      }
      case BIN(opt_lt): {
	return depth + -1;
      }
      case BIN(opt_le): {
	return depth + -1;
      }
      case BIN(opt_gt): {
	return depth + -1;
      }
      case BIN(opt_ge): {
	return depth + -1;
      }
      case BIN(opt_ltlt): {
	return depth + -1;
      }
      case BIN(opt_aref): {
	return depth + -1;
      }
      case BIN(opt_aset): {
	return depth + -2;
      }
      case BIN(opt_aset_with): {
	return depth + -1;
      }
      case BIN(opt_aref_with): {
	return depth + 0;
      }
      case BIN(opt_length): {
	return depth + 0;
      }
      case BIN(opt_size): {
	return depth + 0;
      }
      case BIN(opt_empty_p): {
	return depth + 0;
      }
      case BIN(opt_succ): {
	return depth + 0;
      }
      case BIN(opt_not): {
	return depth + 0;
      }
      case BIN(opt_regexpmatch1): {
	return depth + 0;
      }
      case BIN(opt_regexpmatch2): {
	return depth + -1;
      }
      case BIN(opt_call_c_function): {
	return depth + 0;
      }
      case BIN(bitblt): {
	return depth + 1;
      }
      case BIN(answer): {
	return depth + 1;
      }
      case BIN(getlocal_OP__WC__0): {
	return depth + 1;
      }
      case BIN(getlocal_OP__WC__1): {
	return depth + 1;
      }
      case BIN(setlocal_OP__WC__0): {
	return depth + -1;
      }
      case BIN(setlocal_OP__WC__1): {
	return depth + -1;
      }
      case BIN(putobject_OP_INT2FIX_O_0_C_): {
	return depth + 1;
      }
      case BIN(putobject_OP_INT2FIX_O_1_C_): {
	return depth + 1;
      }
      case BIN(trace_nop): {
	return depth + 0;
      }
      case BIN(trace_getlocal): {
	return depth + 1;
      }
      case BIN(trace_setlocal): {
	return depth + -1;
      }
      case BIN(trace_getblockparam): {
	return depth + 1;
      }
      case BIN(trace_setblockparam): {
	return depth + -1;
      }
      case BIN(trace_getspecial): {
	return depth + 1;
      }
      case BIN(trace_setspecial): {
	return depth + -1;
      }
      case BIN(trace_getinstancevariable): {
	return depth + 1;
      }
      case BIN(trace_setinstancevariable): {
	return depth + -1;
      }
      case BIN(trace_getclassvariable): {
	return depth + 1;
      }
      case BIN(trace_setclassvariable): {
	return depth + -1;
      }
      case BIN(trace_getconstant): {
	return depth + 0;
      }
      case BIN(trace_setconstant): {
	return depth + -2;
      }
      case BIN(trace_getglobal): {
	return depth + 1;
      }
      case BIN(trace_setglobal): {
	return depth + -1;
      }
      case BIN(trace_putnil): {
	return depth + 1;
      }
      case BIN(trace_putself): {
	return depth + 1;
      }
      case BIN(trace_putobject): {
	return depth + 1;
      }
      case BIN(trace_putspecialobject): {
	return depth + 1;
      }
      case BIN(trace_putiseq): {
	return depth + 1;
      }
      case BIN(trace_putstring): {
	return depth + 1;
      }
      case BIN(trace_concatstrings): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_tostring): {
	return depth + -1;
      }
      case BIN(trace_freezestring): {
	return depth + 0;
      }
      case BIN(trace_toregexp): {
	int inc = 0;
        int cnt = FIX2INT(opes[1]);
        inc += 1 - cnt;;
        return depth + inc;
      }
      case BIN(trace_intern): {
	return depth + 0;
      }
      case BIN(trace_newarray): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_duparray): {
	return depth + 1;
      }
      case BIN(trace_expandarray): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        int flag = FIX2INT(opes[1]);
        inc += num - 1 + (flag & 1 ? 1 : 0);;
        return depth + inc;
      }
      case BIN(trace_concatarray): {
	return depth + -1;
      }
      case BIN(trace_splatarray): {
	return depth + 0;
      }
      case BIN(trace_newhash): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_newrange): {
	return depth + -1;
      }
      case BIN(trace_pop): {
	return depth + -1;
      }
      case BIN(trace_dup): {
	return depth + 1;
      }
      case BIN(trace_dupn): {
	int inc = 0;
        int n = FIX2INT(opes[0]);
        inc += n;;
        return depth + inc;
      }
      case BIN(trace_swap): {
	return depth + 0;
      }
      case BIN(trace_reverse): {
	int inc = 0;
        inc += 0;;
        return depth + inc;
      }
      case BIN(trace_reput): {
	int inc = 0;
        inc += 0;;
        return depth + inc;
      }
      case BIN(trace_topn): {
	int inc = 0;
        inc += 1;;
        return depth + inc;
      }
      case BIN(trace_setn): {
	int inc = 0;
        inc += 0;
        return depth + inc;
      }
      case BIN(trace_adjuststack): {
	int inc = 0;
        int n = FIX2INT(opes[0]);
        inc -= n;
        return depth + inc;
      }
      case BIN(trace_defined): {
	return depth + 0;
      }
      case BIN(trace_checkmatch): {
	return depth + -1;
      }
      case BIN(trace_checkkeyword): {
	return depth + 1;
      }
      case BIN(trace_tracecoverage): {
	return depth + 0;
      }
      case BIN(trace_defineclass): {
	return depth + -1;
      }
      case BIN(trace_send): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += - (int)(ci->orig_argc + ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0));;
        return depth + inc;
      }
      case BIN(trace_opt_str_freeze): {
	return depth + 1;
      }
      case BIN(trace_opt_str_uminus): {
	return depth + 1;
      }
      case BIN(trace_opt_newarray_max): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_opt_newarray_min): {
	int inc = 0;
        int num = FIX2INT(opes[0]);
        inc += 1 - num;;
        return depth + inc;
      }
      case BIN(trace_opt_send_without_block): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += -ci->orig_argc;;
        return depth + inc;
      }
      case BIN(trace_invokesuper): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += - (int)(ci->orig_argc + ((ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0));;
        return depth + inc;
      }
      case BIN(trace_invokeblock): {
	int inc = 0;
        CALL_INFO ci = (CALL_INFO)(opes[0]);
        inc += 1 - ci->orig_argc;;
        return depth + inc;
      }
      case BIN(trace_leave): {
	return depth + 0;
      }
      case BIN(trace_throw): {
	return depth + 0;
      }
      case BIN(trace_jump): {
	return depth + 0;
      }
      case BIN(trace_branchif): {
	return depth + -1;
      }
      case BIN(trace_branchunless): {
	return depth + -1;
      }
      case BIN(trace_branchnil): {
	return depth + -1;
      }
      case BIN(trace_branchiftype): {
	return depth + -1;
      }
      case BIN(trace_getinlinecache): {
	return depth + 1;
      }
      case BIN(trace_setinlinecache): {
	return depth + 0;
      }
      case BIN(trace_once): {
	return depth + 1;
      }
      case BIN(trace_opt_case_dispatch): {
	int inc = 0;
        inc += -1;;
        return depth + inc;
      }
      case BIN(trace_opt_plus): {
	return depth + -1;
      }
      case BIN(trace_opt_minus): {
	return depth + -1;
      }
      case BIN(trace_opt_mult): {
	return depth + -1;
      }
      case BIN(trace_opt_div): {
	return depth + -1;
      }
      case BIN(trace_opt_mod): {
	return depth + -1;
      }
      case BIN(trace_opt_eq): {
	return depth + -1;
      }
      case BIN(trace_opt_neq): {
	return depth + -1;
      }
      case BIN(trace_opt_lt): {
	return depth + -1;
      }
      case BIN(trace_opt_le): {
	return depth + -1;
      }
      case BIN(trace_opt_gt): {
	return depth + -1;
      }
      case BIN(trace_opt_ge): {
	return depth + -1;
      }
      case BIN(trace_opt_ltlt): {
	return depth + -1;
      }
      case BIN(trace_opt_aref): {
	return depth + -1;
      }
      case BIN(trace_opt_aset): {
	return depth + -2;
      }
      case BIN(trace_opt_aset_with): {
	return depth + -1;
      }
      case BIN(trace_opt_aref_with): {
	return depth + 0;
      }
      case BIN(trace_opt_length): {
	return depth + 0;
      }
      case BIN(trace_opt_size): {
	return depth + 0;
      }
      case BIN(trace_opt_empty_p): {
	return depth + 0;
      }
      case BIN(trace_opt_succ): {
	return depth + 0;
      }
      case BIN(trace_opt_not): {
	return depth + 0;
      }
      case BIN(trace_opt_regexpmatch1): {
	return depth + 0;
      }
      case BIN(trace_opt_regexpmatch2): {
	return depth + -1;
      }
      case BIN(trace_opt_call_c_function): {
	return depth + 0;
      }
      case BIN(trace_bitblt): {
	return depth + 1;
      }
      case BIN(trace_answer): {
	return depth + 1;
      }
      case BIN(trace_getlocal_OP__WC__0): {
	return depth + 1;
      }
      case BIN(trace_getlocal_OP__WC__1): {
	return depth + 1;
      }
      case BIN(trace_setlocal_OP__WC__0): {
	return depth + -1;
      }
      case BIN(trace_setlocal_OP__WC__1): {
	return depth + -1;
      }
      case BIN(trace_putobject_OP_INT2FIX_O_0_C_): {
	return depth + 1;
      }
      case BIN(trace_putobject_OP_INT2FIX_O_1_C_): {
	return depth + 1;
      }
      default:
	rb_bug("insn_sp_increase: unreachable");
    }
    return 0;
}
#endif

/* some utilities */

static int
insn_len(VALUE insn)
{
    return (unsigned char)insn_operand_info[(int)insn][0];
}

static const char *
insn_name(VALUE insn)
{
    return insn_name_info[(int)insn];
}

static const char *
insn_op_types(VALUE insn)
{
    return insn_operand_info[(int)insn]+1;
}

static int
insn_op_type(VALUE insn, long pos)
{
    int len = insn_len(insn) - 1;
    if (pos < len) {
	return insn_operand_info[(int)insn][pos+1];
    }
    else{
	return 0;
    }
}

#ifdef USE_INSN_RET_NUM
static int
insn_ret_num(VALUE insn)
{
    return insn_stack_push_num_info[(int)insn];
}
#endif
