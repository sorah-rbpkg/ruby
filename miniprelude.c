/* -*-c-*-
 THIS FILE WAS AUTOGENERATED BY template/prelude.c.tmpl. DO NOT EDIT.

 sources: ./ast, ./dir, ./gc, ./numeric, ./io, ./marshal, ./rjit, ./rjit_c, ./pack, ./trace_point, ./warning, ./array, ./kernel, ./ractor, ./symbol, ./timev, ./thread_sync, ./nilclass, ./prelude, ./gem_prelude, ./yjit
*/
#include "internal.h"
#include "internal/ruby_parser.h"
#include "internal/warnings.h"
#include "iseq.h"
#include "ruby/ruby.h"
#include "vm_core.h"

COMPILER_WARNING_PUSH
#if __has_warning("-Wstring-concatenation")
COMPILER_WARNING_IGNORED(-Wstring-concatenation)
#endif

static const char prelude_name0[] = "<internal:ast>";
static const struct {
    char L0[508]; /* 1..88 */
    char L88[498]; /* 89..148 */
    char L148[491]; /* 149..191 */
    char L191[465]; /* 192..266 */
    char L266[242]; /* 267..277 */
} prelude_code0 = {
#line 1 "ast.rb"
""/* for ast.c */
""
""/* AbstractSyntaxTree provides methods to parse Ruby code into */
""/* abstract syntax trees. The nodes in the tree */
""/* are instances of RubyVM::AbstractSyntaxTree::Node. */
""/*  */
""/* This module is MRI specific as it exposes implementation details */
""/* of the MRI abstract syntax tree. */
""/*  */
""/* This module is experimental and its API is not stable, therefore it might */
""/* change without notice. As examples, the order of children nodes is not */
""/* guaranteed, the number of children nodes might change, there is no way to */
""/* access children nodes by name, etc. */
""/*  */
""/* If you are looking for a stable API or an API working under multiple Ruby */
""/* implementations, consider using the _parser_ gem or Ripper. If you would */
""/* like to make RubyVM::AbstractSyntaxTree stable, please join the discussion */
""/* at https://bugs.ruby-lang.org/issues/14844. */
""/*  */
"module RubyVM::AbstractSyntaxTree\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.parse(string, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false) -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*  */
"\n"/*  Parses the given _string_ into an abstract syntax tree, */
"\n"/*  returning the root node of that tree. */
"\n"/*  */
"\n"/*    RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\") */
"\n"/*    # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-1:9> */
"\n"/*  */
"\n"/*  If <tt>keep_script_lines: true</tt> option is provided, the text of the parsed */
"\n"/*  source is associated with nodes and is available via Node#script_lines. */
"\n"/*  */
"\n"/*  If <tt>keep_tokens: true</tt> option is provided, Node#tokens are populated. */
"\n"/*  */
"\n"/*  SyntaxError is raised if the given _string_ is invalid syntax. To overwrite this */
"\n"/*  behavior, <tt>error_tolerant: true</tt> can be provided. In this case, the parser */
"\n"/*  will produce a tree where expressions with syntax errors would be represented by */
"\n"/*  Node with <tt>type=:ERROR</tt>. */
"\n"/*  */
"\n"/*     root = RubyVM::AbstractSyntaxTree.parse(\"x = 1; p(x; y=2\") */
"\n"/*     # <internal:ast>:33:in `parse': syntax error, unexpected ';', expecting ')' (SyntaxError) */
"\n"/*     # x = 1; p(x; y=2 */
"\n"/*     #           ^ */
"\n"/*  */
"\n"/*     root = RubyVM::AbstractSyntaxTree.parse(\"x = 1; p(x; y=2\", error_tolerant: true) */
"\n"/*     # (SCOPE@1:0-1:15 */
"\n"/*     #  tbl: [:x, :y] */
"\n"/*     #  args: nil */
"\n"/*     #  body: (BLOCK@1:0-1:15 (LASGN@1:0-1:5 :x (LIT@1:4-1:5 1)) (ERROR@1:7-1:11) (LASGN@1:12-1:15 :y (LIT@1:14-1:15 2)))) */
"\n"/*     root.children.last.children */
"\n"/*     # [(LASGN@1:0-1:5 :x (LIT@1:4-1:5 1)), */
"\n"/*     #  (ERROR@1:7-1:11), */
"\n"/*     #  (LASGN@1:12-1:15 :y (LIT@1:14-1:15 2))] */
"\n"/*  */
"\n"/*  Note that parsing continues even after the errored expression. */
"\n"/*  */
"  def self.parse string, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false\n"
"    Primitive.ast_s_parse string, keep_script_lines, error_tolerant, keep_tokens\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.parse_file(pathname, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false) -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*  */
"\n"/*   Reads the file from _pathname_, then parses it like ::parse, */
"\n"/*   returning the root node of the abstract syntax tree. */
"\n"/*  */
"\n"/*   SyntaxError is raised if _pathname_'s contents are not */
"\n"/*   valid Ruby syntax. */
"\n"/*  */
"\n"/*     RubyVM::AbstractSyntaxTree.parse_file(\"my-app/app.rb\") */
"\n"/*     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-31:3> */
"\n"/*  */
"\n"/*   See ::parse for explanation of keyword argument meaning and usage. */
"  def self.parse_file pathname, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false\n"
"    Primitive.ast_s_parse_file pathname, keep_script_lines, error_tolerant, keep_tokens\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.of(proc, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false)   -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*     RubyVM::AbstractSyntaxTree.of(method, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false) -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*  */
"\n"/*   Returns AST nodes of the given _proc_ or _method_. */
"\n"/*  */
"\n"/*     RubyVM::AbstractSyntaxTree.of(proc {1 + 2}) */
"\n"/*     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:35-1:42> */
"\n"/*  */
"\n"/*     def hello */
,
#line 89 "ast.rb"
"\n"/*       puts \"hello, world\" */
"\n"/*     end */
"\n"/*  */
"\n"/*     RubyVM::AbstractSyntaxTree.of(method(:hello)) */
"\n"/*     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-3:3> */
"\n"/*  */
"\n"/*   See ::parse for explanation of keyword argument meaning and usage. */
"  def self.of body, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false\n"
"    Primitive.ast_s_of body, keep_script_lines, error_tolerant, keep_tokens\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.node_id_for_backtrace_location(backtrace_location)   -> integer */
"\n"/*  */
"\n"/*   Returns the node id for the given backtrace location. */
"\n"/*  */
"\n"/*     begin */
"\n"/*       raise */
"\n"/*     rescue =>  e */
"\n"/*       loc = e.backtrace_locations.first */
"\n"/*       RubyVM::AbstractSyntaxTree.node_id_for_backtrace_location(loc) */
"\n"/*     end # => 0 */
"  def self.node_id_for_backtrace_location backtrace_location\n"
"    Primitive.node_id_for_backtrace_location backtrace_location\n"
"  end\n"
"\n"
"\n"/* RubyVM::AbstractSyntaxTree::Node instances are created by parse methods in */
"\n"/* RubyVM::AbstractSyntaxTree. */
"\n"/*  */
"\n"/* This class is MRI specific. */
"\n"/*  */
"  class Node\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.type -> symbol */
"\n"/*  */
"\n"/*  Returns the type of this node as a symbol. */
"\n"/*  */
"\n"/*    root = RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\") */
"\n"/*    root.type # => :SCOPE */
"\n"/*    lasgn = root.children[2] */
"\n"/*    lasgn.type # => :LASGN */
"\n"/*    call = lasgn.children[1] */
"\n"/*    call.type # => :OPCALL */
"    def type\n"
"      Primitive.ast_node_type\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.first_lineno -> integer */
"\n"/*  */
"\n"/*  The line number in the source code where this AST's text began. */
"    def first_lineno\n"
"      Primitive.ast_node_first_lineno\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.first_column -> integer */
"\n"/*  */
"\n"/*  The column number in the source code where this AST's text began. */
,
#line 149 "ast.rb"
"    def first_column\n"
"      Primitive.ast_node_first_column\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.last_lineno -> integer */
"\n"/*  */
"\n"/*  The line number in the source code where this AST's text ended. */
"    def last_lineno\n"
"      Primitive.ast_node_last_lineno\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.last_column -> integer */
"\n"/*  */
"\n"/*  The column number in the source code where this AST's text ended. */
"    def last_column\n"
"      Primitive.ast_node_last_column\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.tokens -> array */
"\n"/*  */
"\n"/*  Returns tokens corresponding to the location of the node. */
"\n"/*  Returns +nil+ if +keep_tokens+ is not enabled when #parse method is called. */
"\n"/*  */
"\n"/*    root = RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\", keep_tokens: true) */
"\n"/*    root.tokens # => [[0, :tIDENTIFIER, \"x\", [1, 0, 1, 1]], [1, :tSP, \" \", [1, 1, 1, 2]], ...] */
"\n"/*    root.tokens.map{_1[2]}.join # => \"x = 1 + 2\" */
"\n"/*  */
"\n"/*  Token is an array of: */
"\n"/*  */
"\n"/*  - id */
"\n"/*  - token type */
"\n"/*  - source code text */
"\n"/*  - location [ first_lineno, first_column, last_lineno, last_column ] */
"    def tokens\n"
"      return nil unless all_tokens\n"
"\n"
"      all_tokens.each_with_object([]) do |token, a|\n"
"        loc = token.last\n"
"        if ([first_lineno, first_column] <=> [loc[0], loc[1]]) <= 0 &&\n"
"           ([last_lineno, last_column]   <=> [loc[2], loc[3]]) >= 0\n"
,
#line 192 "ast.rb"
"           a << token\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.all_tokens -> array */
"\n"/*  */
"\n"/*  Returns all tokens for the input script regardless the receiver node. */
"\n"/*  Returns +nil+ if +keep_tokens+ is not enabled when #parse method is called. */
"\n"/*  */
"\n"/*    root = RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\", keep_tokens: true) */
"\n"/*    root.all_tokens # => [[0, :tIDENTIFIER, \"x\", [1, 0, 1, 1]], [1, :tSP, \" \", [1, 1, 1, 2]], ...] */
"\n"/*    root.children[-1].all_tokens # => [[0, :tIDENTIFIER, \"x\", [1, 0, 1, 1]], [1, :tSP, \" \", [1, 1, 1, 2]], ...] */
"    def all_tokens\n"
"      Primitive.ast_node_all_tokens\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.children -> array */
"\n"/*  */
"\n"/*  Returns AST nodes under this one.  Each kind of node */
"\n"/*  has different children, depending on what kind of node it is. */
"\n"/*  */
"\n"/*  The returned array may contain other nodes or <code>nil</code>. */
"    def children\n"
"      Primitive.ast_node_children\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.inspect -> string */
"\n"/*  */
"\n"/*  Returns debugging information about this node as a string. */
"    def inspect\n"
"      Primitive.ast_node_inspect\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.node_id -> integer */
"\n"/*  */
"\n"/*  Returns an internal node_id number. */
"\n"/*  Note that this is an API for ruby internal use, debugging, */
"\n"/*  and research. Do not use this for any other purpose. */
"\n"/*  The compatibility is not guaranteed. */
"    def node_id\n"
"      Primitive.ast_node_node_id\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.script_lines -> array */
"\n"/*  */
"\n"/*  Returns the original source code as an array of lines. */
"\n"/*  */
"\n"/*  Note that this is an API for ruby internal use, debugging, */
"\n"/*  and research. Do not use this for any other purpose. */
"\n"/*  The compatibility is not guaranteed. */
"    def script_lines\n"
"      Primitive.ast_node_script_lines\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.source -> string */
"\n"/*  */
"\n"/*  Returns the code fragment that corresponds to this AST. */
"\n"/*  */
"\n"/*  Note that this is an API for ruby internal use, debugging, */
"\n"/*  and research. Do not use this for any other purpose. */
"\n"/*  The compatibility is not guaranteed. */
"\n"/*  */
"\n"/*  Also note that this API may return an incomplete code fragment */
"\n"/*  that does not parse; for example, a here document following */
"\n"/*  an expression may be dropped. */
"    def source\n"
"      lines = script_lines\n"
"      if lines\n"
,
#line 267 "ast.rb"
"        lines = lines[first_lineno - 1 .. last_lineno - 1]\n"
"        lines[-1] = lines[-1].byteslice(0...last_column)\n"
"        lines[0] = lines[0].byteslice(first_column..-1)\n"
"        lines.join\n"
"      else\n"
"        nil\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
#line 312 "miniprelude.c"
};

static const char prelude_name1[] = "<internal:dir>";
static const struct {
    char L0[508]; /* 1..266 */
    char L266[466]; /* 267..506 */
} prelude_code1 = {
#line 1 "dir.rb"
""/* An object of class \\Dir represents a directory in the underlying file system. */
""/*  */
""/* It consists mainly of: */
""/*  */
""/* - A string _path_, given when the object is created, */
""/*   that specifies a directory in the underlying file system; */
""/*   method #path returns the path. */
""/* - A collection of string <i>entry names</i>, */
""/*   each of which is the name of a directory or file in the underlying file system; */
""/*   the entry names may be retrieved */
""/*   in an {array-like fashion}[rdoc-ref:Dir@Dir+As+Array-Like] */
""/*   or in a {stream-like fashion}[rdoc-ref:Dir@Dir+As+Stream-Like]. */
""/*  */
""/* == About the Examples */
""/*  */
""/* Some examples on this page use this simple file tree: */
""/*  */
""/*   example/ */
""/*   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 config.h */
""/*   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 lib/ */
""/*   \xE2\x94\x82   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 song/ */
""/*   \xE2\x94\x82   \xE2\x94\x82   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 karaoke.rb */
""/*   \xE2\x94\x82   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 song.rb */
""/*   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 main.rb */
""/*  */
""/* Others use the file tree for the */
""/* {Ruby project itself}[https://github.com/ruby/ruby]. */
""/*  */
""/* == \\Dir As \\Array-Like */
""/*  */
""/* A \\Dir object is in some ways array-like: */
""/*  */
""/* - It has instance methods #children, #each, and #each_child. */
""/* - It includes {module Enumerable}[rdoc-ref:Enumerable@What-27s+Here]. */
""/*  */
""/* == \\Dir As Stream-Like */
""/*  */
""/* A \\Dir object is in some ways stream-like. */
""/*  */
""/* The stream is initially open for reading, */
""/* but may be closed manually (using method #close), */
""/* and will be closed on block exit if created by Dir.open called with a block. */
""/* The closed stream may not be further manipulated, */
""/* and may not be reopened. */
""/*  */
""/* The stream has a _position_, which is the index of an entry in the directory: */
""/*  */
""/* - The initial position is zero (before the first entry). */
""/* - \\Method #tell (aliased as #pos) returns the position. */
""/* - \\Method #pos= sets the position (but ignores a value outside the stream), */
""/*   and returns the position. */
""/* - \\Method #seek is like #pos=, but returns +self+ (convenient for chaining). */
""/* - \\Method #read, if not at end-of-stream, reads the next entry and increments */
""/*   the position; */
""/*   if at end-of-stream, does not increment the position. */
""/* - \\Method #rewind sets the position to zero. */
""/*  */
""/* Examples (using the {simple file tree}[rdoc-ref:Dir@About+the+Examples]): */
""/*  */
""/*   dir = Dir.new('example') # => #<Dir:example> */
""/*   dir.pos                  # => 0 */
""/*  */
""/*   dir.read # => \".\" */
""/*   dir.read # => \"..\" */
""/*   dir.read # => \"config.h\" */
""/*   dir.read # => \"lib\" */
""/*   dir.read # => \"main.rb\" */
""/*   dir.pos  # => 5 */
""/*   dir.read # => nil */
""/*   dir.pos  # => 5 */
""/*  */
""/*   dir.rewind # => #<Dir:example> */
""/*   dir.pos    # => 0 */
""/*  */
""/*   dir.pos = 3 # => 3 */
""/*   dir.pos     # => 3 */
""/*  */
""/*   dir.seek(4) # => #<Dir:example> */
""/*   dir.pos     # => 4 */
""/*  */
""/*   dir.close # => nil */
""/*   dir.read  # Raises IOError. */
""/*  */
""/* == What's Here */
""/*  */
""/* First, what's elsewhere. \\Class \\Dir: */
""/*  */
""/* - Inherits from {class Object}[rdoc-ref:Object@What-27s+Here]. */
""/* - Includes {module Enumerable}[rdoc-ref:Enumerable@What-27s+Here], */
""/*   which provides dozens of additional methods. */
""/*  */
""/* Here, class \\Dir provides methods that are useful for: */
""/*  */
""/* - {Reading}[rdoc-ref:Dir@Reading] */
""/* - {Setting}[rdoc-ref:Dir@Setting] */
""/* - {Querying}[rdoc-ref:Dir@Querying] */
""/* - {Iterating}[rdoc-ref:Dir@Iterating] */
""/* - {Other}[rdoc-ref:Dir@Other] */
""/*  */
""/* === Reading */
""/*  */
""/* - #close: Closes the directory stream for +self+. */
""/* - #pos=: Sets the position in the directory stream for +self+. */
""/* - #read: Reads and returns the next entry in the directory stream for +self+. */
""/* - #rewind: Sets the position in the directory stream for +self+ to the first entry. */
""/* - #seek: Sets the position in the directory stream for +self+ */
""/*   the entry at the given offset. */
""/*  */
""/* === Setting */
""/*  */
""/* - ::chdir: Changes the working directory of the current process */
""/*   to the given directory. */
""/* - ::chroot: Changes the file-system root for the current process */
""/*   to the given directory. */
""/*  */
""/* === Querying */
""/*  */
""/* - ::[]: Same as ::glob without the ability to pass flags. */
""/* - ::children: Returns an array of names of the children */
""/*   (both files and directories) of the given directory, */
""/*   but not including <tt>.</tt> or <tt>..</tt>. */
""/* - ::empty?: Returns whether the given path is an empty directory. */
""/* - ::entries: Returns an array of names of the children */
""/*   (both files and directories) of the given directory, */
""/*   including <tt>.</tt> and <tt>..</tt>. */
""/* - ::exist?: Returns whether the given path is a directory. */
""/* - ::getwd (aliased as #pwd): Returns the path to the current working directory. */
""/* - ::glob: Returns an array of file paths matching the given pattern and flags. */
""/* - ::home: Returns the home directory path for a given user or the current user. */
""/* - #children: Returns an array of names of the children */
""/*   (both files and directories) of +self+, */
""/*   but not including <tt>.</tt> or <tt>..</tt>. */
""/* - #fileno: Returns the integer file descriptor for +self+. */
""/* - #path (aliased as #to_path): Returns the path used to create +self+. */
""/* - #tell (aliased as #pos): Returns the integer position */
""/*   in the directory stream for +self+. */
""/*  */
""/* === Iterating */
""/*  */
""/* - ::each_child: Calls the given block with each entry in the given directory, */
""/*   but not including <tt>.</tt> or <tt>..</tt>. */
""/* - ::foreach: Calls the given block with each entry in the given directory, */
""/*   including <tt>.</tt> and <tt>..</tt>. */
""/* - #each: Calls the given block with each entry in +self+, */
""/*   including <tt>.</tt> and <tt>..</tt>. */
""/* - #each_child: Calls the given block with each entry in +self+, */
""/*   but not including <tt>.</tt> or <tt>..</tt>. */
""/*  */
""/* === Other */
""/*  */
""/* - ::mkdir: Creates a directory at the given path, with optional permissions. */
""/* - ::new: Returns a new \\Dir for the given path, with optional encoding. */
""/* - ::open: Same as ::new, but if a block is given, yields the \\Dir to the block, */
""/*   closing it upon block exit. */
""/* - ::unlink (aliased as ::delete and ::rmdir): Removes the given directory. */
""/* - #inspect: Returns a string description of +self+. */
""/*  */
"class Dir\n"
"\n"/* call-seq: */
"\n"/*   Dir.open(dirpath) -> dir */
"\n"/*   Dir.open(dirpath, encoding: nil) -> dir */
"\n"/*   Dir.open(dirpath) {|dir| ... } -> object */
"\n"/*   Dir.open(dirpath, encoding: nil) {|dir| ... } -> object */
"\n"/*  */
"\n"/* Creates a new \\Dir object _dir_ for the directory at +dirpath+. */
"\n"/*  */
"\n"/* With no block, the method equivalent to Dir.new(dirpath, encoding): */
"\n"/*  */
"\n"/*   Dir.open('.') # => #<Dir:.> */
"\n"/*  */
"\n"/* With a block given, the block is called with the created _dir_; */
"\n"/* on block exit _dir_ is closed and the block's value is returned: */
"\n"/*  */
"\n"/*   Dir.open('.') {|dir| dir.inspect } # => \"#<Dir:.>\" */
"\n"/*  */
"\n"/* The value given with optional keyword argument +encoding+ */
"\n"/* specifies the encoding for the directory entry names; */
"\n"/* if +nil+ (the default), the file system's encoding is used: */
"\n"/*  */
"\n"/*   Dir.open('.').read.encoding                       # => #<Encoding:UTF-8> */
"\n"/*   Dir.open('.', encoding: 'US-ASCII').read.encoding # => #<Encoding:US-ASCII> */
"\n"/*  */
"  def self.open(name, encoding: nil, &block)\n"
"    dir = Primitive.dir_s_open(name, encoding)\n"
"    if block\n"
"      begin\n"
"        yield dir\n"
"      ensure\n"
"        Primitive.dir_s_close(dir)\n"
"      end\n"
"    else\n"
"      dir\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Dir.new(dirpath) -> dir */
"\n"/*   Dir.new(dirpath, encoding: nil) -> dir */
"\n"/*  */
"\n"/* Returns a new \\Dir object for the directory at +dirpath+: */
"\n"/*  */
"\n"/*   Dir.new('.') # => #<Dir:.> */
"\n"/*  */
"\n"/* The value given with optional keyword argument +encoding+ */
"\n"/* specifies the encoding for the directory entry names; */
"\n"/* if +nil+ (the default), the file system's encoding is used: */
"\n"/*  */
"\n"/*   Dir.new('.').read.encoding                       # => #<Encoding:UTF-8> */
"\n"/*   Dir.new('.', encoding: 'US-ASCII').read.encoding # => #<Encoding:US-ASCII> */
"\n"/*  */
"  def initialize(name, encoding: nil)\n"
"    Primitive.dir_initialize(name, encoding)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Dir[*patterns, base: nil, sort: true] -> array */
"\n"/*  */
"\n"/* Calls Dir.glob with argument +patterns+ */
"\n"/* and the values of keyword arguments +base+ and +sort+; */
"\n"/* returns the array of selected entry names. */
"\n"/*  */
"  def self.[](*args, base: nil, sort: true)\n"
"    Primitive.dir_s_aref(args, base, sort)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Dir.glob(*patterns, flags: 0, base: nil, sort: true) -> array */
"\n"/*   Dir.glob(*patterns, flags: 0, base: nil, sort: true) {|entry_name| ... } -> nil */
"\n"/*  */
"\n"/* Forms an array _entry_names_ of the entry names selected by the arguments. */
"\n"/*  */
"\n"/* Argument +patterns+ is a string pattern or an array of string patterns; */
"\n"/* note that these are not regexps; see below. */
"\n"/*  */
"\n"/* Notes for the following examples: */
"\n"/*  */
"\n"/* - <tt>'*'</tt> is the pattern that matches any entry name */
"\n"/*   except those that begin with <tt>'.'</tt>. */
"\n"/* - We use method Array#take to shorten returned arrays */
"\n"/*   that otherwise would be very large. */
"\n"/*  */
"\n"/* With no block, returns array _entry_names_; */
"\n"/* example (using the {simple file tree}[rdoc-ref:Dir@About+the+Examples]): */
"\n"/*  */
"\n"/*   Dir.glob('*') # => [\"config.h\", \"lib\", \"main.rb\"] */
"\n"/*  */
"\n"/* With a block, calls the block with each of the _entry_names_ */
"\n"/* and returns +nil+: */
"\n"/*  */
"\n"/*   Dir.glob('*') {|entry_name| puts entry_name } # => nil */
"\n"/*  */
"\n"/* Output: */
"\n"/*  */
"\n"/*   config.h */
"\n"/*   lib */
"\n"/*   main.rb */
"\n"/*  */
"\n"/* If optional keyword argument +flags+ is given, */
"\n"/* the value modifies the matching; see below. */
"\n"/*  */
"\n"/* If optional keyword argument +base+ is given, */
"\n"/* its value specifies the base directory. */
"\n"/* Each pattern string specifies entries relative to the base directory; */
"\n"/* the default is <tt>'.'</tt>. */
"\n"/* The base directory is not prepended to the entry names in the result: */
"\n"/*  */
,
#line 267 "dir.rb"
"\n"/*   Dir.glob(pattern, base: 'lib').take(5) */
"\n"/*   # => [\"abbrev.gemspec\", \"abbrev.rb\", \"base64.gemspec\", \"base64.rb\", \"benchmark.gemspec\"] */
"\n"/*   Dir.glob(pattern, base: 'lib/irb').take(5) */
"\n"/*   # => [\"cmd\", \"color.rb\", \"color_printer.rb\", \"completion.rb\", \"context.rb\"] */
"\n"/*  */
"\n"/* If optional keyword +sort+ is given, its value specifies whether */
"\n"/* the array is to be sorted; the default is +true+. */
"\n"/* Passing value +false+ with that keyword disables sorting */
"\n"/* (though the underlying file system may already have sorted the array). */
"\n"/*  */
"\n"/* <b>Patterns</b> */
"\n"/*  */
"\n"/* Each pattern string is expanded */
"\n"/* according to certain metacharacters; */
"\n"/* examples below use the {Ruby file tree}[rdoc-ref:Dir@About+the+Examples]: */
"\n"/*  */
"\n"/* - <tt>'*'</tt>: Matches any substring in an entry name, */
"\n"/*   similar in meaning to regexp <tt>/.*\/mx</tt>; */
"\n"/*   may be restricted by other values in the pattern strings: */
"\n"/*  */
"\n"/*   - <tt>'*'</tt> matches all entry names: */
"\n"/*  */
"\n"/*       Dir.glob('*').take(3)  # => [\"BSDL\", \"CONTRIBUTING.md\", \"COPYING\"] */
"\n"/*  */
"\n"/*   - <tt>'c*'</tt> matches entry names beginning with <tt>'c'</tt>: */
"\n"/*  */
"\n"/*       Dir.glob('c*').take(3) # => [\"CONTRIBUTING.md\", \"COPYING\", \"COPYING.ja\"] */
"\n"/*  */
"\n"/*   - <tt>'*c'</tt> matches entry names ending with <tt>'c'</tt>: */
"\n"/*  */
"\n"/*       Dir.glob('*c').take(3) # => [\"addr2line.c\", \"array.c\", \"ast.c\"] */
"\n"/*  */
"\n"/*   - <tt>'\\*c\\*'</tt> matches entry names that contain <tt>'c'</tt>, */
"\n"/*     even at the beginning or end: */
"\n"/*  */
"\n"/*       Dir.glob('*c*').take(3) # => [\"CONTRIBUTING.md\", \"COPYING\", \"COPYING.ja\"] */
"\n"/*  */
"\n"/*   Does not match Unix-like hidden entry names (\"dot files\"). */
"\n"/*   To include those in the matched entry names, */
"\n"/*   use flag IO::FNM_DOTMATCH or something like <tt>'{*,.*}'</tt>. */
"\n"/*  */
"\n"/*  - <tt>'**'</tt>: Matches entry names recursively */
"\n"/*    if followed by  the slash character <tt>'/'</tt>: */
"\n"/*  */
"\n"/*      Dir.glob('**\/').take(3) # => [\"basictest/\", \"benchmark/\", \"benchmark/gc/\"] */
"\n"/*  */
"\n"/*    If the string pattern contains other characters */
"\n"/*    or is not followed by a slash character, */
"\n"/*    it is equivalent to <tt>'*'</tt>. */
"\n"/*  */
"\n"/* - <tt>'?'</tt> Matches any single character; */
"\n"/*   similar in meaning to regexp <tt>/./</tt>: */
"\n"/*  */
"\n"/*     Dir.glob('io.?') # => [\"io.c\"] */
"\n"/*  */
"\n"/* - <tt>'[_set_]'</tt>: Matches any one character in the string _set_; */
"\n"/*   behaves like a {Regexp character class}[rdoc-ref:Regexp@Character+Classes], */
"\n"/*   including set negation (<tt>'[^a-z]'</tt>): */
"\n"/*  */
"\n"/*     Dir.glob('*.[a-z][a-z]').take(3) */
"\n"/*     # => [\"CONTRIBUTING.md\", \"COPYING.ja\", \"KNOWNBUGS.rb\"] */
"\n"/*  */
"\n"/* - <tt>'{_abc_,_xyz_}'</tt>: */
"\n"/*   Matches either string _abc_ or string _xyz_; */
"\n"/*   behaves like {Regexp alternation}[rdoc-ref:Regexp@Alternation]: */
"\n"/*  */
"\n"/*     Dir.glob('{LEGAL,BSDL}') # => [\"LEGAL\", \"BSDL\"] */
"\n"/*  */
"\n"/*   More than two alternatives may be given. */
"\n"/*  */
"\n"/* - <tt>\\\\</tt>: Escapes the following metacharacter. */
"\n"/*  */
"\n"/*   Note that on Windows, the backslash character may not be used */
"\n"/*   in a string pattern: */
"\n"/*   <tt>Dir['c:\\\\foo*']</tt> will not work, use <tt>Dir['c:/foo*']</tt> instead. */
"\n"/*  */
"\n"/* More examples (using the {simple file tree}[rdoc-ref:Dir@About+the+Examples]): */
"\n"/*  */
"\n"/*   # We're in the example directory. */
"\n"/*   File.basename(Dir.pwd) # => \"example\" */
"\n"/*   Dir.glob('config.?')              # => [\"config.h\"] */
"\n"/*   Dir.glob('*.[a-z][a-z]')          # => [\"main.rb\"] */
"\n"/*   Dir.glob('*.[^r]*')               # => [\"config.h\"] */
"\n"/*   Dir.glob('*.{rb,h}')              # => [\"main.rb\", \"config.h\"] */
"\n"/*   Dir.glob('*')                     # => [\"config.h\", \"lib\", \"main.rb\"] */
"\n"/*   Dir.glob('*', File::FNM_DOTMATCH) # => [\".\", \"config.h\", \"lib\", \"main.rb\"] */
"\n"/*   Dir.glob([\"*.rb\", \"*.h\"])         # => [\"main.rb\", \"config.h\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/\*.rb') */
"\n"/*   => [\"lib/song/karaoke.rb\", \"lib/song.rb\", \"main.rb\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/\*.rb', base: 'lib')  #   => [\"song/karaoke.rb\", \"song.rb\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/lib')                # => [\"lib\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/lib/\**\/\*.rb')        # => [\"lib/song/karaoke.rb\", \"lib/song.rb\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/lib/\*.rb')           # => [\"lib/song.rb\"] */
"\n"/*  */
"\n"/* <b>Flags</b> */
"\n"/*  */
"\n"/* If optional keyword argument +flags+ is given (the default is zero -- no flags), */
"\n"/* its value should be the bitwise OR of one or more of the constants */
"\n"/* defined in module File::Constants. */
"\n"/*  */
"\n"/* Example: */
"\n"/*  */
"\n"/*   flags = File::FNM_EXTGLOB | File::FNM_DOTMATCH */
"\n"/*  */
"\n"/* Specifying flags can extend, restrict, or otherwise modify the matching. */
"\n"/*  */
"\n"/* The flags for this method (other constants in File::Constants do not apply): */
"\n"/*  */
"\n"/* - File::FNM_DOTMATCH: */
"\n"/*   specifies that entry names beginning with <tt>'.'</tt> */
"\n"/*   should be considered for matching: */
"\n"/*  */
"\n"/*     Dir.glob('*').take(5) */
"\n"/*     # => [\"BSDL\", \"CONTRIBUTING.md\", \"COPYING\", \"COPYING.ja\", \"GPL\"] */
"\n"/*     Dir.glob('*', flags: File::FNM_DOTMATCH).take(5) */
"\n"/*     # => [\".\", \".appveyor.yml\", \".cirrus.yml\", \".dir-locals.el\", \".document\"] */
"\n"/*  */
"\n"/* - File::FNM_EXTGLOB: */
"\n"/*   enables the pattern extension */
"\n"/*   <tt>'{_a_,_b_}'</tt>, which matches pattern _a_ and pattern _b_; */
"\n"/*   behaves like a */
"\n"/*   {regexp union}[rdoc-ref:Regexp.union] */
"\n"/*   (e.g., <tt>'(?:_a_|_b_)'</tt>): */
"\n"/*  */
"\n"/*     pattern = '{LEGAL,BSDL}' */
"\n"/*     Dir.glob(pattern)      # => [\"LEGAL\", \"BSDL\"] */
"\n"/*  */
"\n"/* - File::FNM_NOESCAPE: */
"\n"/*   specifies that escaping with the backslash character <tt>'\\'</tt> */
"\n"/*   is disabled; the character is not an escape character. */
"\n"/*  */
"\n"/* - File::FNM_PATHNAME: */
"\n"/*   specifies that metacharacters <tt>'*'</tt> and <tt>'?'</tt> */
"\n"/*   do not match directory separators. */
"\n"/*  */
"\n"/* - File::FNM_SHORTNAME: */
"\n"/*   specifies that patterns may match short names if they exist; Windows only. */
"\n"/*  */
"  def self.glob(pattern, _flags = 0, flags: _flags, base: nil, sort: true)\n"
"    Primitive.dir_s_glob(pattern, flags, base, sort)\n"
"  end\n"
"end\n"
"\n"
"class << File\n"
"\n"/* call-seq: */
"\n"/*    File.fnmatch( pattern, path, [flags] ) -> (true or false) */
"\n"/*    File.fnmatch?( pattern, path, [flags] ) -> (true or false) */
"\n"/*  */
"\n"/* Returns true if +path+ matches against +pattern+.  The pattern is not a */
"\n"/* regular expression; instead it follows rules similar to shell filename */
"\n"/* globbing.  It may contain the following metacharacters: */
"\n"/*  */
"\n"/* <code>*</code>:: */
"\n"/*   Matches any file. Can be restricted by other values in the glob. */
"\n"/*   Equivalent to <code>/.*\/x</code> in regexp. */
"\n"/*  */
"\n"/*   <code>*</code>::    Matches all regular files */
"\n"/*   <code>c*</code>::   Matches all files beginning with <code>c</code> */
"\n"/*   <code>*c</code>::   Matches all files ending with <code>c</code> */
"\n"/*   <code>\\*c*</code>:: Matches all files that have <code>c</code> in them */
"\n"/*                       (including at the beginning or end). */
"\n"/*  */
"\n"/*   To match hidden files (that start with a <code>.</code>) set the */
"\n"/*   File::FNM_DOTMATCH flag. */
"\n"/*  */
"\n"/* <code>**</code>:: */
"\n"/*   Matches directories recursively or files expansively. */
"\n"/*  */
"\n"/* <code>?</code>:: */
"\n"/*   Matches any one character. Equivalent to <code>/.{1}/</code> in regexp. */
"\n"/*  */
"\n"/* <code>[set]</code>:: */
"\n"/*   Matches any one character in +set+.  Behaves exactly like character sets */
"\n"/*   in Regexp, including set negation (<code>[^a-z]</code>). */
"\n"/*  */
"\n"/* <code>\\\\</code>:: */
"\n"/*   Escapes the next metacharacter. */
"\n"/*  */
"\n"/* <code>{a,b}</code>:: */
"\n"/*   Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled. */
"\n"/*   Behaves like a Regexp union (<code>(?:a|b)</code>). */
"\n"/*  */
"\n"/* +flags+ is a bitwise OR of the <code>FNM_XXX</code> constants. The same */
"\n"/* glob pattern and flags are used by Dir::glob. */
"\n"/*  */
"\n"/* Examples: */
"\n"/*  */
"\n"/*    File.fnmatch('cat',       'cat')        #=> true  # match entire string */
"\n"/*    File.fnmatch('cat',       'category')   #=> false # only match partial string */
"\n"/*  */
"\n"/*    File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default */
"\n"/*    File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB */
"\n"/*  */
"\n"/*    File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character */
"\n"/*    File.fnmatch('c??t',    'cat')          #=> false # ditto */
"\n"/*    File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters */
"\n"/*    File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto */
"\n"/*    File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression */
"\n"/*    File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!') */
"\n"/*  */
"\n"/*    File.fnmatch('cat', 'CAT')                     #=> false # case sensitive */
"\n"/*    File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive */
"\n"/*    File.fnmatch('cat', 'CAT', File::FNM_SYSCASE)  #=> true or false # depends on the system default */
"\n"/*  */
"\n"/*    File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME */
"\n"/*    File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto */
"\n"/*    File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto */
"\n"/*  */
"\n"/*    File.fnmatch('\\?',   '?')                       #=> true  # escaped wildcard becomes ordinary */
"\n"/*    File.fnmatch('\\a',   'a')                       #=> true  # escaped ordinary remains ordinary */
"\n"/*    File.fnmatch('\\a',   '\\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\\' ordinary */
"\n"/*    File.fnmatch('[\\?]', '?')                       #=> true  # can escape inside bracket expression */
"\n"/*  */
"\n"/*    File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading */
"\n"/*    File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default. */
"\n"/*    File.fnmatch('.*',  '.profile')                      #=> true */
"\n"/*  */
"\n"/*    File.fnmatch('**\/\*.rb', 'main.rb')                  #=> false */
"\n"/*    File.fnmatch('**\/\*.rb', './main.rb')                #=> false */
"\n"/*    File.fnmatch('**\/\*.rb', 'lib/song.rb')              #=> true */
"\n"/*    File.fnmatch('**.rb', 'main.rb')                    #=> true */
"\n"/*    File.fnmatch('**.rb', './main.rb')                  #=> false */
"\n"/*    File.fnmatch('**.rb', 'lib/song.rb')                #=> true */
"\n"/*    File.fnmatch('*',     'dave/.profile')              #=> true */
"\n"/*  */
"\n"/*    File.fnmatch('**\/foo', 'a/b/c/foo', File::FNM_PATHNAME)     #=> true */
"\n"/*    File.fnmatch('**\/foo', '/a/b/c/foo', File::FNM_PATHNAME)    #=> true */
"\n"/*    File.fnmatch('**\/foo', 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true */
"\n"/*    File.fnmatch('**\/foo', 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false */
"\n"/*    File.fnmatch('**\/foo', 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true */
"  def fnmatch(pattern, path, flags = 0)\n"
"  end\n"
"  alias fnmatch? fnmatch\n"
"end if false\n"
#line 828 "miniprelude.c"
};

static const char prelude_name2[] = "<internal:gc>";
static const struct {
    char L0[498]; /* 1..76 */
    char L76[507]; /* 77..253 */
    char L253[506]; /* 254..299 */
    char L299[476]; /* 300..330 */
    char L330[39]; /* 331..333 */
} prelude_code2 = {
#line 1 "gc.rb"
""/* for gc.c */
""
""/*  The \\GC module provides an interface to Ruby's mark and */
""/*  sweep garbage collection mechanism. */
""/*  */
""/*  Some of the underlying methods are also available via the ObjectSpace */
""/*  module. */
""/*  */
""/*  You may obtain information about the operation of the \\GC through */
""/*  GC::Profiler. */
"module GC\n"
"\n"
"\n"/* Initiates garbage collection, even if manually disabled. */
"\n"/*  */
"\n"/* The +full_mark+ keyword argument determines whether or not to perform a */
"\n"/* major garbage collection cycle. When set to +true+, a major garbage */
"\n"/* collection cycle is ran, meaning all objects are marked. When set to */
"\n"/* +false+, a minor garbage collection cycle is ran, meaning only young */
"\n"/* objects are marked. */
"\n"/*  */
"\n"/* The +immediate_mark+ keyword argument determines whether or not to perform */
"\n"/* incremental marking. When set to +true+, marking is completed during the */
"\n"/* call to this method. When set to +false+, marking is performed in steps */
"\n"/* that is interleaved with future Ruby code execution, so marking might not */
"\n"/* be completed during this method call. Note that if +full_mark+ is +false+ */
"\n"/* then marking will always be immediate, regardless of the value of */
"\n"/* +immediate_mark+. */
"\n"/*  */
"\n"/* The +immedate_sweep+ keyword argument determines whether or not to defer */
"\n"/* sweeping (using lazy sweep). When set to +true+, sweeping is performed in */
"\n"/* steps that is interleaved with future Ruby code execution, so sweeping might */
"\n"/* not be completed during this method call. When set to +false+, sweeping is */
"\n"/* completed during the call to this method. */
"\n"/*  */
"\n"/* Note: These keyword arguments are implementation and version dependent. They */
"\n"/* are not guaranteed to be future-compatible, and may be ignored if the */
"\n"/* underlying implementation does not support them. */
"  def self.start full_mark: true, immediate_mark: true, immediate_sweep: true\n"
"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
"  end\n"
"\n"
"\n"/* Alias of GC.start */
"  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.enable    -> true or false */
"\n"/*  */
"\n"/*  Enables garbage collection, returning +true+ if garbage */
"\n"/*  collection was previously disabled. */
"\n"/*  */
"\n"/*     GC.disable   #=> false */
"\n"/*     GC.enable    #=> true */
"\n"/*     GC.enable    #=> false */
"\n"/*  */
"  def self.enable\n"
"    Primitive.gc_enable\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.disable    -> true or false */
"\n"/*  */
"\n"/*  Disables garbage collection, returning +true+ if garbage */
"\n"/*  collection was already disabled. */
"\n"/*  */
"\n"/*     GC.disable   #=> false */
"\n"/*     GC.disable   #=> true */
"  def self.disable\n"
"    Primitive.gc_disable\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    GC.stress\t    -> integer, true or false */
"\n"/*  */
"\n"/*  Returns current status of \\GC stress mode. */
,
#line 77 "gc.rb"
"  def self.stress\n"
"    Primitive.gc_stress_get\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    GC.stress = flag          -> flag */
"\n"/*  */
"\n"/*  Updates the \\GC stress mode. */
"\n"/*  */
"\n"/*  When stress mode is enabled, the \\GC is invoked at every \\GC opportunity: */
"\n"/*  all memory and object allocations. */
"\n"/*  */
"\n"/*  Enabling stress mode will degrade performance, it is only for debugging. */
"\n"/*  */
"\n"/*  flag can be true, false, or an integer bit-ORed following flags. */
"\n"/*    0x01:: no major GC */
"\n"/*    0x02:: no immediate sweep */
"\n"/*    0x04:: full mark after malloc/calloc/realloc */
"  def self.stress=(flag)\n"
"    Primitive.gc_stress_set_m flag\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.count -> Integer */
"\n"/*  */
"\n"/*  The number of times \\GC occurred. */
"\n"/*  */
"\n"/*  It returns the number of times \\GC occurred since the process started. */
"  def self.count\n"
"    Primitive.gc_count\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     GC.stat -> Hash */
"\n"/*     GC.stat(hash) -> Hash */
"\n"/*     GC.stat(:key) -> Numeric */
"\n"/*  */
"\n"/*  Returns a Hash containing information about the \\GC. */
"\n"/*  */
"\n"/*  The contents of the hash are implementation specific and may change in */
"\n"/*  the future without notice. */
"\n"/*  */
"\n"/*  The hash includes information about internal statistics about \\GC such as: */
"\n"/*  */
"\n"/*  [count] */
"\n"/*    The total number of garbage collections ran since application start */
"\n"/*    (count includes both minor and major garbage collections) */
"\n"/*  [time] */
"\n"/*    The total time spent in garbage collections (in milliseconds) */
"\n"/*  [heap_allocated_pages] */
"\n"/*    The total number of +:heap_eden_pages+ + +:heap_tomb_pages+ */
"\n"/*  [heap_sorted_length] */
"\n"/*    The number of pages that can fit into the buffer that holds references to */
"\n"/*    all pages */
"\n"/*  [heap_allocatable_pages] */
"\n"/*    The total number of pages the application could allocate without additional \\GC */
"\n"/*  [heap_available_slots] */
"\n"/*    The total number of slots in all +:heap_allocated_pages+ */
"\n"/*  [heap_live_slots] */
"\n"/*    The total number of slots which contain live objects */
"\n"/*  [heap_free_slots] */
"\n"/*    The total number of slots which do not contain live objects */
"\n"/*  [heap_final_slots] */
"\n"/*    The total number of slots with pending finalizers to be run */
"\n"/*  [heap_marked_slots] */
"\n"/*    The total number of objects marked in the last \\GC */
"\n"/*  [heap_eden_pages] */
"\n"/*    The total number of pages which contain at least one live slot */
"\n"/*  [heap_tomb_pages] */
"\n"/*    The total number of pages which do not contain any live slots */
"\n"/*  [total_allocated_pages] */
"\n"/*    The cumulative number of pages allocated since application start */
"\n"/*  [total_freed_pages] */
"\n"/*    The cumulative number of pages freed since application start */
"\n"/*  [total_allocated_objects] */
"\n"/*    The cumulative number of objects allocated since application start */
"\n"/*  [total_freed_objects] */
"\n"/*    The cumulative number of objects freed since application start */
"\n"/*  [malloc_increase_bytes] */
"\n"/*    Amount of memory allocated on the heap for objects. Decreased by any \\GC */
"\n"/*  [malloc_increase_bytes_limit] */
"\n"/*    When +:malloc_increase_bytes+ crosses this limit, \\GC is triggered */
"\n"/*  [minor_gc_count] */
"\n"/*    The total number of minor garbage collections run since process start */
"\n"/*  [major_gc_count] */
"\n"/*    The total number of major garbage collections run since process start */
"\n"/*  [compact_count] */
"\n"/*    The total number of compactions run since process start */
"\n"/*  [read_barrier_faults] */
"\n"/*    The total number of times the read barrier was triggered during */
"\n"/*    compaction */
"\n"/*  [total_moved_objects] */
"\n"/*    The total number of objects compaction has moved */
"\n"/*  [remembered_wb_unprotected_objects] */
"\n"/*    The total number of objects without write barriers */
"\n"/*  [remembered_wb_unprotected_objects_limit] */
"\n"/*    When +:remembered_wb_unprotected_objects+ crosses this limit, */
"\n"/*    major \\GC is triggered */
"\n"/*  [old_objects] */
"\n"/*    Number of live, old objects which have survived at least 3 garbage collections */
"\n"/*  [old_objects_limit] */
"\n"/*    When +:old_objects+ crosses this limit, major \\GC is triggered */
"\n"/*  [oldmalloc_increase_bytes] */
"\n"/*    Amount of memory allocated on the heap for objects. Decreased by major \\GC */
"\n"/*  [oldmalloc_increase_bytes_limit] */
"\n"/*    When +:old_malloc_increase_bytes+ crosses this limit, major \\GC is triggered */
"\n"/*  */
"\n"/*  If the optional argument, hash, is given, */
"\n"/*  it is overwritten and returned. */
"\n"/*  This is intended to avoid probe effect. */
"\n"/*  */
"\n"/*  This method is only expected to work on CRuby. */
"  def self.stat hash_or_key = nil\n"
"    Primitive.gc_stat hash_or_key\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    GC.stat_heap -> Hash */
"\n"/*    GC.stat_heap(nil, hash) -> Hash */
"\n"/*    GC.stat_heap(heap_name) -> Hash */
"\n"/*    GC.stat_heap(heap_name, hash) -> Hash */
"\n"/*    GC.stat_heap(heap_name, :key) -> Numeric */
"\n"/*  */
"\n"/* Returns information for heaps in the \\GC. */
"\n"/*  */
"\n"/* If the first optional argument, +heap_name+, is passed in and not +nil+, it */
"\n"/* returns a +Hash+ containing information about the particular heap. */
"\n"/* Otherwise, it will return a +Hash+ with heap names as keys and */
"\n"/* a +Hash+ containing information about the heap as values. */
"\n"/*  */
"\n"/* If the second optional argument, +hash_or_key+, is given as +Hash+, it will */
"\n"/* be overwritten and returned. This is intended to avoid the probe effect. */
"\n"/*  */
"\n"/* If both optional arguments are passed in and the second optional argument is */
"\n"/* a symbol, it will return a +Numeric+ of the value for the particular heap. */
"\n"/*  */
"\n"/* On CRuby, +heap_name+ is of the type +Integer+ but may be of type +String+ */
"\n"/* on other implementations. */
"\n"/*  */
"\n"/* The contents of the hash are implementation specific and may change in */
"\n"/* the future without notice. */
"\n"/*  */
"\n"/* If the optional argument, hash, is given, it is overwritten and returned. */
"\n"/*  */
"\n"/* This method is only expected to work on CRuby. */
"\n"/*  */
"\n"/* The hash includes the following keys about the internal information in */
"\n"/* the \\GC: */
"\n"/*  */
"\n"/* [slot_size] */
"\n"/*   The slot size of the heap in bytes. */
"\n"/* [heap_allocatable_pages] */
"\n"/*   The number of pages that can be allocated without triggering a new */
"\n"/*   garbage collection cycle. */
"\n"/* [heap_eden_pages] */
"\n"/*   The number of pages in the eden heap. */
"\n"/* [heap_eden_slots] */
"\n"/*   The total number of slots in all of the pages in the eden heap. */
"\n"/* [heap_tomb_pages] */
"\n"/*   The number of pages in the tomb heap. The tomb heap only contains pages */
"\n"/*   that do not have any live objects. */
"\n"/* [heap_tomb_slots] */
"\n"/*   The total number of slots in all of the pages in the tomb heap. */
"\n"/* [total_allocated_pages] */
"\n"/*   The total number of pages that have been allocated in the heap. */
"\n"/* [total_freed_pages] */
"\n"/*   The total number of pages that have been freed and released back to the */
"\n"/*   system in the heap. */
"\n"/* [force_major_gc_count] */
"\n"/*   The number of times major garbage collection cycles this heap has forced */
"\n"/*   to start due to running out of free slots. */
"\n"/* [force_incremental_marking_finish_count] */
"\n"/*   The number of times this heap has forced incremental marking to complete */
"\n"/*   due to running out of pooled slots. */
"\n"/*  */
"  def self.stat_heap heap_name = nil, hash_or_key = nil\n"
"    Primitive.gc_stat_heap heap_name, hash_or_key\n"
,
#line 254 "gc.rb"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*     GC.latest_gc_info -> hash */
"\n"/*     GC.latest_gc_info(hash) -> hash */
"\n"/*     GC.latest_gc_info(:major_by) -> :malloc */
"\n"/*  */
"\n"/* Returns information about the most recent garbage collection. */
"\n"/*  */
"\n"/* If the optional argument, hash, is given, */
"\n"/* it is overwritten and returned. */
"\n"/* This is intended to avoid probe effect. */
"  def self.latest_gc_info hash_or_key = nil\n"
"    Primitive.gc_latest_gc_info hash_or_key\n"
"  end\n"
"\n"
"  if respond_to?(:compact)\n"
"\n"/* call-seq: */
"\n"/*    GC.verify_compaction_references(toward: nil, double_heap: false) -> hash */
"\n"/*  */
"\n"/* Verify compaction reference consistency. */
"\n"/*  */
"\n"/* This method is implementation specific.  During compaction, objects that */
"\n"/* were moved are replaced with T_MOVED objects.  No object should have a */
"\n"/* reference to a T_MOVED object after compaction. */
"\n"/*  */
"\n"/* This function expands the heap to ensure room to move all objects, */
"\n"/* compacts the heap to make sure everything moves, updates all references, */
"\n"/* then performs a full \\GC.  If any object contains a reference to a T_MOVED */
"\n"/* object, that object should be pushed on the mark stack, and will */
"\n"/* make a SEGV. */
"    def self.verify_compaction_references(toward: nil, double_heap: false, expand_heap: false)\n"
"      Primitive.gc_verify_compaction_references(double_heap, expand_heap, toward == :empty)\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    GC.measure_total_time = true/false */
"\n"/*  */
"\n"/* Enable to measure \\GC time. */
"\n"/* You can get the result with <tt>GC.stat(:time)</tt>. */
"\n"/* Note that \\GC time measurement can cause some performance overhead. */
"  def self.measure_total_time=(flag)\n"
"    Primitive.cstmt! %{\n"
"      rb_objspace.flags.measure_gc = RTEST(flag) ? TRUE : FALSE;\n"
"      return flag;\n"
,
#line 300 "gc.rb"
"    }\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    GC.measure_total_time -> true/false */
"\n"/*  */
"\n"/* Return measure_total_time flag (default: +true+). */
"\n"/* Note that measurement can affect the application performance. */
"  def self.measure_total_time\n"
"    Primitive.cexpr! %{\n"
"      RBOOL(rb_objspace.flags.measure_gc)\n"
"    }\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    GC.total_time -> int */
"\n"/*  */
"\n"/* Return measured \\GC total time in nano seconds. */
"  def self.total_time\n"
"    Primitive.cexpr! %{\n"
"      ULL2NUM(rb_objspace.profile.marking_time_ns + rb_objspace.profile.sweeping_time_ns)\n"
"    }\n"
"  end\n"
"end\n"
"\n"
"module ObjectSpace\n"
"\n"/* Alias of GC.start */
"  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
"  end\n"
"\n"
,
#line 331 "gc.rb"
"  module_function :garbage_collect\n"
"end\n"
#line 1180 "miniprelude.c"
};

static const char prelude_name3[] = "<internal:numeric>";
static const struct {
    char L0[507]; /* 1..101 */
    char L101[508]; /* 102..200 */
    char L200[503]; /* 201..284 */
    char L284[507]; /* 285..357 */
    char L357[216]; /* 358..373 */
} prelude_code3 = {
#line 1 "numeric.rb"
"class Numeric\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    real? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is a real number (i.e. not Complex). */
"\n"/*  */
"  def real?\n"
"    true\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   real -> self */
"\n"/*  */
"\n"/* Returns +self+. */
"\n"/*  */
"  def real\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    integer? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is an Integer. */
"\n"/*  */
"\n"/*    1.0.integer? # => false */
"\n"/*    1.integer?   # => true */
"\n"/*  */
"  def integer?\n"
"    false\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    finite? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is a finite number, +false+ otherwise. */
"\n"/*  */
"  def finite?\n"
"    true\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    infinite? -> -1, 1, or nil */
"\n"/*  */
"\n"/*  Returns +nil+, -1, or 1 depending on whether +self+ is */
"\n"/*  finite, <tt>-Infinity</tt>, or <tt>+Infinity</tt>. */
"\n"/*  */
"  def infinite?\n"
"    nil\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   imag -> 0 */
"\n"/*  */
"\n"/* Returns zero. */
"\n"/*  */
"  def imaginary\n"
"    0\n"
"  end\n"
"\n"
"  alias imag imaginary\n"
"\n"
"\n"/* call-seq: */
"\n"/*   conj -> self */
"\n"/*  */
"\n"/* Returns +self+. */
"\n"/*  */
"  def conjugate\n"
"    self\n"
"  end\n"
"\n"
"  alias conj conjugate\n"
"end\n"
"\n"
"class Integer\n"
"\n"/* call-seq: */
"\n"/*    -int -> integer */
"\n"/*  */
"\n"/* Returns +self+, negated. */
"  def -@\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_uminus(self)'\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   ~int -> integer */
"\n"/*  */
"\n"/* One's complement: */
"\n"/* returns the value of +self+ with each bit inverted. */
"\n"/*  */
"\n"/* Because an integer value is conceptually of infinite length, */
"\n"/* the result acts as if it had an infinite number of */
"\n"/* one bits to the left. */
"\n"/* In hex representations, this is displayed */
"\n"/* as two periods to the left of the digits: */
"\n"/*  */
"\n"/*   sprintf(\"%X\", ~0x1122334455)    # => \"..FEEDDCCBBAA\" */
"\n"/*  */
"  def ~\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_comp(self)'\n"
,
#line 102 "numeric.rb"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   abs -> integer */
"\n"/*  */
"\n"/* Returns the absolute value of +self+. */
"\n"/*  */
"\n"/*   (-12345).abs # => 12345 */
"\n"/*   -12345.abs   # => 12345 */
"\n"/*   12345.abs    # => 12345 */
"\n"/*  */
"  def abs\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_abs(self)'\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   bit_length -> integer */
"\n"/*  */
"\n"/* Returns the number of bits of the value of +self+, */
"\n"/* which is the bit position of the highest-order bit */
"\n"/* that is different from the sign bit */
"\n"/* (where the least significant bit has bit position 1). */
"\n"/* If there is no such bit (zero or minus one), returns zero. */
"\n"/*  */
"\n"/* This method returns <tt>ceil(log2(self < 0 ? -self : self + 1))</tt>>. */
"\n"/*  */
"\n"/*   (-2**1000-1).bit_length   # => 1001 */
"\n"/*   (-2**1000).bit_length     # => 1000 */
"\n"/*   (-2**1000+1).bit_length   # => 1000 */
"\n"/*   (-2**12-1).bit_length     # => 13 */
"\n"/*   (-2**12).bit_length       # => 12 */
"\n"/*   (-2**12+1).bit_length     # => 12 */
"\n"/*   -0x101.bit_length         # => 9 */
"\n"/*   -0x100.bit_length         # => 8 */
"\n"/*   -0xff.bit_length          # => 8 */
"\n"/*   -2.bit_length             # => 1 */
"\n"/*   -1.bit_length             # => 0 */
"\n"/*   0.bit_length              # => 0 */
"\n"/*   1.bit_length              # => 1 */
"\n"/*   0xff.bit_length           # => 8 */
"\n"/*   0x100.bit_length          # => 9 */
"\n"/*   (2**12-1).bit_length      # => 12 */
"\n"/*   (2**12).bit_length        # => 13 */
"\n"/*   (2**12+1).bit_length      # => 13 */
"\n"/*   (2**1000-1).bit_length    # => 1000 */
"\n"/*   (2**1000).bit_length      # => 1001 */
"\n"/*   (2**1000+1).bit_length    # => 1001 */
"\n"/*  */
"\n"/* For \\Integer _n_, */
"\n"/* this method can be used to detect overflow in Array#pack: */
"\n"/*  */
"\n"/*   if n.bit_length < 32 */
"\n"/*     [n].pack('l') # No overflow. */
"\n"/*   else */
"\n"/*     raise 'Overflow' */
"\n"/*   end */
"\n"/*  */
"  def bit_length\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_bit_length(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    even? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is an even number, +false+ otherwise. */
"  def even?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_even_p(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    integer? -> true */
"\n"/*  */
"\n"/*  Since +self+ is already an \\Integer, always returns +true+. */
"  def integer?\n"
"    true\n"
"  end\n"
"\n"
"  alias magnitude abs\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    odd? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is an odd number, +false+ otherwise. */
"  def odd?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_odd_p(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    ord -> self */
"\n"/*  */
"\n"/*  Returns +self+; */
"\n"/*  intended for compatibility to character literals in Ruby 1.9. */
"  def ord\n"
"    self\n"
"  end\n"
,
#line 201 "numeric.rb"
"\n"
"\n"/*  call-seq: */
"\n"/*    size -> integer */
"\n"/*  */
"\n"/*  Returns the number of bytes in the machine representation of +self+; */
"\n"/*  the value is system-dependent: */
"\n"/*  */
"\n"/*    1.size             # => 8 */
"\n"/*    -1.size            # => 8 */
"\n"/*    2147483647.size    # => 8 */
"\n"/*    (256**10 - 1).size # => 10 */
"\n"/*    (256**20 - 1).size # => 20 */
"\n"/*    (256**40 - 1).size # => 40 */
"\n"/*  */
"  def size\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_size(self)'\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   times {|i| ... } -> self */
"\n"/*   times            -> enumerator */
"\n"/*  */
"\n"/* Calls the given block +self+ times with each integer in <tt>(0..self-1)</tt>: */
"\n"/*  */
"\n"/*   a = [] */
"\n"/*   5.times {|i| a.push(i) } # => 5 */
"\n"/*   a                        # => [0, 1, 2, 3, 4] */
"\n"/*  */
"\n"/* With no block given, returns an Enumerator. */
"  def times\n"
"    unless block_given?\n"
"      return to_enum(:times) { self < 0 ? 0 : self }\n"
"    end\n"
"    i = 0\n"
"    while i < self\n"
"      yield i\n"
"      i = i.succ\n"
"    end\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    to_i -> self */
"\n"/*  */
"\n"/*  Returns +self+ (which is already an \\Integer). */
"  def to_i\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    to_int -> self */
"\n"/*  */
"\n"/*  Returns +self+ (which is already an \\Integer). */
"  def to_int\n"
"    self\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   zero? -> true or false */
"\n"/*  */
"\n"/* Returns +true+ if +self+ has a zero value, +false+ otherwise. */
"  def zero?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_zero_p(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    ceildiv(numeric) -> integer */
"\n"/*  */
"\n"/*  Returns the result of division +self+ by +numeric+. */
"\n"/*  rounded up to the nearest integer. */
"\n"/*  */
"\n"/*    3.ceildiv(3)   # => 1 */
"\n"/*    4.ceildiv(3)   # => 2 */
"\n"/*  */
"\n"/*    4.ceildiv(-3)  # => -1 */
"\n"/*    -4.ceildiv(3)  # => -1 */
"\n"/*    -4.ceildiv(-3) # => 2 */
"\n"/*  */
"\n"/*    3.ceildiv(1.2) # => 3 */
"\n"/*  */
"  def ceildiv(other)\n"
"    -div(0 - other)\n"
,
#line 285 "numeric.rb"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*   numerator -> self */
"\n"/*  */
"\n"/* Returns +self+. */
"\n"/*  */
"  def numerator\n"
"    self\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   denominator -> 1 */
"\n"/*  */
"\n"/* Returns +1+. */
"  def denominator\n"
"    1\n"
"  end\n"
"end\n"
"\n"
"class Float\n"
"\n"
"\n"/* call-seq: */
"\n"/*   to_f -> self */
"\n"/*  */
"\n"/*  Returns +self+ (which is already a \\Float). */
"  def to_f\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    float.abs ->  float */
"\n"/*  */
"\n"/*  Returns the absolute value of +self+: */
"\n"/*  */
"\n"/*    (-34.56).abs # => 34.56 */
"\n"/*    -34.56.abs   # => 34.56 */
"\n"/*    34.56.abs    # => 34.56 */
"\n"/*  */
"  def abs\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_float_abs(self)'\n"
"  end\n"
"\n"
"  def magnitude\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_float_abs(self)'\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   -float -> float */
"\n"/*  */
"\n"/* Returns +self+, negated. */
"\n"/*  */
"  def -@\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_float_uminus(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    zero? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is 0.0, +false+ otherwise. */
"  def zero?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'RBOOL(FLOAT_ZERO_P(self))'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    positive? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is greater than 0, +false+ otherwise. */
,
#line 358 "numeric.rb"
"  def positive?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'RBOOL(RFLOAT_VALUE(self) > 0.0)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    negative? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is less than 0, +false+ otherwise. */
"  def negative?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'RBOOL(RFLOAT_VALUE(self) < 0.0)'\n"
"  end\n"
"\n"
"end\n"
#line 1572 "miniprelude.c"
};

static const char prelude_name4[] = "<internal:io>";
static const struct {
    char L0[449]; /* 1..137 */
} prelude_code4 = {
#line 1 "io.rb"
"class IO\n"
"\n"/* other IO methods are defined in io.c */
"\n"
"\n"/* call-seq: */
"\n"/*    ios.read_nonblock(maxlen [, options])              -> string */
"\n"/*    ios.read_nonblock(maxlen, outbuf [, options])      -> outbuf */
"\n"/*  */
"\n"/* Reads at most <i>maxlen</i> bytes from <em>ios</em> using */
"\n"/* the read(2) system call after O_NONBLOCK is set for */
"\n"/* the underlying file descriptor. */
"\n"/*  */
"\n"/* If the optional <i>outbuf</i> argument is present, */
"\n"/* it must reference a String, which will receive the data. */
"\n"/* The <i>outbuf</i> will contain only the received data after the method call */
"\n"/* even if it is not empty at the beginning. */
"\n"/*  */
"\n"/* read_nonblock just calls the read(2) system call. */
"\n"/* It causes all errors the read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. */
"\n"/* The caller should care such errors. */
"\n"/*  */
"\n"/* If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, */
"\n"/* it is extended by IO::WaitReadable. */
"\n"/* So IO::WaitReadable can be used to rescue the exceptions for retrying */
"\n"/* read_nonblock. */
"\n"/*  */
"\n"/* read_nonblock causes EOFError on EOF. */
"\n"/*  */
"\n"/* On some platforms, such as Windows, non-blocking mode is not supported */
"\n"/* on IO objects other than sockets. In such cases, Errno::EBADF will */
"\n"/* be raised. */
"\n"/*  */
"\n"/* If the read byte buffer is not empty, */
"\n"/* read_nonblock reads from the buffer like readpartial. */
"\n"/* In this case, the read(2) system call is not called. */
"\n"/*  */
"\n"/* When read_nonblock raises an exception kind of IO::WaitReadable, */
"\n"/* read_nonblock should not be called */
"\n"/* until io is readable for avoiding busy loop. */
"\n"/* This can be done as follows. */
"\n"/*  */
"\n"/*   # emulates blocking read (readpartial). */
"\n"/*   begin */
"\n"/*     result = io.read_nonblock(maxlen) */
"\n"/*   rescue IO::WaitReadable */
"\n"/*     IO.select([io]) */
"\n"/*     retry */
"\n"/*   end */
"\n"/*  */
"\n"/* Although IO#read_nonblock doesn't raise IO::WaitWritable. */
"\n"/* OpenSSL::Buffering#read_nonblock can raise IO::WaitWritable. */
"\n"/* If IO and SSL should be used polymorphically, */
"\n"/* IO::WaitWritable should be rescued too. */
"\n"/* See the document of OpenSSL::Buffering#read_nonblock for sample code. */
"\n"/*  */
"\n"/* Note that this method is identical to readpartial */
"\n"/* except the non-blocking flag is set. */
"\n"/*  */
"\n"/* By specifying a keyword argument _exception_ to +false+, you can indicate */
"\n"/* that read_nonblock should not raise an IO::WaitReadable exception, but */
"\n"/* return the symbol +:wait_readable+ instead. At EOF, it will return nil */
"\n"/* instead of raising EOFError. */
"  def read_nonblock(len, buf = nil, exception: true)\n"
"    Primitive.io_read_nonblock(len, buf, exception)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    ios.write_nonblock(string)   -> integer */
"\n"/*    ios.write_nonblock(string [, options])   -> integer */
"\n"/*  */
"\n"/* Writes the given string to <em>ios</em> using */
"\n"/* the write(2) system call after O_NONBLOCK is set for */
"\n"/* the underlying file descriptor. */
"\n"/*  */
"\n"/* It returns the number of bytes written. */
"\n"/*  */
"\n"/* write_nonblock just calls the write(2) system call. */
"\n"/* It causes all errors the write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. */
"\n"/* The result may also be smaller than string.length (partial write). */
"\n"/* The caller should care such errors and partial write. */
"\n"/*  */
"\n"/* If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, */
"\n"/* it is extended by IO::WaitWritable. */
"\n"/* So IO::WaitWritable can be used to rescue the exceptions for retrying write_nonblock. */
"\n"/*  */
"\n"/*   # Creates a pipe. */
"\n"/*   r, w = IO.pipe */
"\n"/*  */
"\n"/*   # write_nonblock writes only 65536 bytes and return 65536. */
"\n"/*   # (The pipe size is 65536 bytes on this environment.) */
"\n"/*   s = \"a\" * 100000 */
"\n"/*   p w.write_nonblock(s)     #=> 65536 */
"\n"/*  */
"\n"/*   # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN). */
"\n"/*   p w.write_nonblock(\"b\")   # Resource temporarily unavailable (Errno::EAGAIN) */
"\n"/*  */
"\n"/* If the write buffer is not empty, it is flushed at first. */
"\n"/*  */
"\n"/* When write_nonblock raises an exception kind of IO::WaitWritable, */
"\n"/* write_nonblock should not be called */
"\n"/* until io is writable for avoiding busy loop. */
"\n"/* This can be done as follows. */
"\n"/*  */
"\n"/*   begin */
"\n"/*     result = io.write_nonblock(string) */
"\n"/*   rescue IO::WaitWritable, Errno::EINTR */
"\n"/*     IO.select(nil, [io]) */
"\n"/*     retry */
"\n"/*   end */
"\n"/*  */
"\n"/* Note that this doesn't guarantee to write all data in string. */
"\n"/* The length written is reported as result and it should be checked later. */
"\n"/*  */
"\n"/* On some platforms such as Windows, write_nonblock is not supported */
"\n"/* according to the kind of the IO object. */
"\n"/* In such cases, write_nonblock raises <code>Errno::EBADF</code>. */
"\n"/*  */
"\n"/* By specifying a keyword argument _exception_ to +false+, you can indicate */
"\n"/* that write_nonblock should not raise an IO::WaitWritable exception, but */
"\n"/* return the symbol +:wait_writable+ instead. */
"  def write_nonblock(buf, exception: true)\n"
"    Primitive.io_write_nonblock(buf, exception)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   readline(sep = $/, chomp: false)   -> string */
"\n"/*   readline(limit, chomp: false)      -> string */
"\n"/*   readline(sep, limit, chomp: false) -> string */
"\n"/*  */
"\n"/* Reads a line as with IO#gets, but raises EOFError if already at end-of-stream. */
"\n"/*  */
"\n"/* Optional keyword argument +chomp+ specifies whether line separators */
"\n"/* are to be omitted. */
"  def readline(sep = $/, limit = nil, chomp: false)\n"
"    Primitive.io_readline(sep, limit, chomp)\n"
"  end\n"
"end\n"
#line 1716 "miniprelude.c"
};

static const char prelude_name5[] = "<internal:marshal>";
static const struct {
    char L0[202]; /* 1..41 */
} prelude_code5 = {
#line 1 "marshal.rb"
"module Marshal\n"
"\n"/* call-seq: */
"\n"/*    load(source, proc = nil, freeze: false) -> obj */
"\n"/*    restore(source, proc = nil, freeze: false) -> obj */
"\n"/*  */
"\n"/* Returns the result of converting the serialized data in source into a */
"\n"/* Ruby object (possibly with associated subordinate objects). source */
"\n"/* may be either an instance of IO or an object that responds to */
"\n"/* to_str. If proc is specified, each object will be passed to the proc, as the object */
"\n"/* is being deserialized. */
"\n"/*  */
"\n"/* Never pass untrusted data (including user supplied input) to this method. */
"\n"/* Please see the overview for further details. */
"\n"/*  */
"\n"/* If the <tt>freeze: true</tt> argument is passed, deserialized object would */
"\n"/* be deeply frozen. Note that it may lead to more efficient memory usage due to */
"\n"/* frozen strings deduplication: */
"\n"/*  */
"\n"/*    serialized = Marshal.dump(['value1', 'value2', 'value1', 'value2']) */
"\n"/*  */
"\n"/*    deserialized = Marshal.load(serialized) */
"\n"/*    deserialized.map(&:frozen?) */
"\n"/*    # => [false, false, false, false] */
"\n"/*    deserialized.map(&:object_id) */
"\n"/*    # => [1023900, 1023920, 1023940, 1023960] -- 4 different objects */
"\n"/*  */
"\n"/*    deserialized = Marshal.load(serialized, freeze: true) */
"\n"/*    deserialized.map(&:frozen?) */
"\n"/*    # => [true, true, true, true] */
"\n"/*    deserialized.map(&:object_id) */
"\n"/*    # => [1039360, 1039380, 1039360, 1039380] -- only 2 different objects, object_ids repeating */
"\n"/*  */
"  def self.load(source, proc = nil, freeze: false)\n"
"    Primitive.marshal_load(source, proc, freeze)\n"
"  end\n"
"\n"
"  class << self\n"
"    alias restore load\n"
"  end\n"
"end\n"
#line 1764 "miniprelude.c"
};

static const char prelude_name6[] = "<internal:rjit>";
static const struct {
    char L0[498]; /* 1..31 */
    char L31[197]; /* 32..42 */
} prelude_code6 = {
#line 1 "rjit.rb"
"module RubyVM::RJIT\n"
"\n"/* Return true if \\RJIT is enabled. */
"  def self.enabled?\n"
"    Primitive.cexpr! 'RBOOL(rb_rjit_enabled)'\n"
"  end\n"
"\n"
"\n"/* Start JIT compilation after \\--rjit-disable. */
"  def self.enable\n"
"    Primitive.cstmt! %{\n"
"      rb_rjit_call_p = true;\n"
"      return Qnil;\n"
"    }\n"
"  end\n"
"\n"
"  if Primitive.rjit_stats_enabled_p\n"
"    at_exit do\n"
"      Primitive.rjit_stop_stats\n"
"      print_stats\n"
"    end\n"
"  end\n"
"  if Primitive.rjit_trace_exits_enabled_p\n"
"    at_exit do\n"
"      Primitive.rjit_stop_stats\n"
"      dump_trace_exits\n"
"    end\n"
"  end\n"
"end\n"
"\n"
"if RubyVM::RJIT.enabled?\n"
"  begin\n"
"    require 'fiddle'\n"
,
#line 32 "rjit.rb"
"    require 'fiddle/import'\n"
"  rescue LoadError\n"
"    return\n"/* miniruby doesn't support RJIT */
"  end\n"
"\n"
"  require 'ruby_vm/rjit/c_type'\n"
"  require 'ruby_vm/rjit/compiler'\n"
"  require 'ruby_vm/rjit/hooks'\n"
"  require 'ruby_vm/rjit/stats'\n"
"end\n"
#line 1816 "miniprelude.c"
};

static const char prelude_name7[] = "<internal:rjit_c>";
static const struct {
    char L0[470]; /* 1..24 */
    char L24[506]; /* 25..45 */
    char L45[504]; /* 46..62 */
    char L62[499]; /* 63..78 */
    char L78[473]; /* 79..95 */
    char L95[480]; /* 96..109 */
    char L109[488]; /* 110..124 */
    char L124[478]; /* 125..144 */
    char L144[499]; /* 145..160 */
    char L160[462]; /* 161..175 */
    char L175[463]; /* 176..189 */
    char L189[470]; /* 190..201 */
    char L201[502]; /* 202..215 */
    char L215[499]; /* 216..232 */
    char L232[495]; /* 233..248 */
    char L248[488]; /* 249..271 */
    char L271[502]; /* 272..294 */
    char L294[413]; /* 295..311 */
    char L311[420]; /* 312..322 */
    char L322[503]; /* 323..343 */
    char L343[486]; /* 344..354 */
    char L354[456]; /* 355..362 */
    char L362[507]; /* 363..369 */
    char L369[488]; /* 370..375 */
    char L375[406]; /* 376..379 */
    char L379[445]; /* 380..384 */
    char L384[472]; /* 385..390 */
    char L390[454]; /* 391..396 */
    char L396[503]; /* 397..403 */
    char L403[483]; /* 404..410 */
    char L410[501]; /* 411..417 */
    char L417[460]; /* 418..423 */
    char L423[476]; /* 424..429 */
    char L429[498]; /* 430..435 */
    char L435[445]; /* 436..440 */
    char L440[502]; /* 441..446 */
    char L446[449]; /* 447..451 */
    char L451[508]; /* 452..468 */
    char L468[506]; /* 469..495 */
    char L495[493]; /* 496..518 */
    char L518[476]; /* 519..539 */
    char L539[508]; /* 540..559 */
    char L559[470]; /* 560..579 */
    char L579[455]; /* 580..599 */
    char L599[478]; /* 600..619 */
    char L619[473]; /* 620..639 */
    char L639[476]; /* 640..659 */
    char L659[507]; /* 660..679 */
    char L679[463]; /* 680..699 */
    char L699[487]; /* 700..719 */
    char L719[490]; /* 720..738 */
    char L738[499]; /* 739..758 */
    char L758[446]; /* 759..775 */
    char L775[471]; /* 776..795 */
    char L795[485]; /* 796..812 */
    char L812[430]; /* 813..819 */
    char L819[467]; /* 820..833 */
    char L833[492]; /* 834..844 */
    char L844[463]; /* 845..850 */
    char L850[477]; /* 851..861 */
    char L861[489]; /* 862..868 */
    char L868[493]; /* 869..880 */
    char L880[400]; /* 881..887 */
    char L887[504]; /* 888..900 */
    char L900[508]; /* 901..908 */
    char L908[408]; /* 909..912 */
    char L912[500]; /* 913..920 */
    char L920[457]; /* 921..928 */
    char L928[507]; /* 929..934 */
    char L934[496]; /* 935..950 */
    char L950[456]; /* 951..963 */
    char L963[379]; /* 964..966 */
    char L966[413]; /* 967..974 */
    char L974[461]; /* 975..982 */
    char L982[419]; /* 983..985 */
    char L985[446]; /* 986..993 */
    char L993[419]; /* 994..996 */
    char L996[459]; /* 997..1005 */
    char L1005[478]; /* 1006..1011 */
    char L1011[442]; /* 1012..1022 */
    char L1022[486]; /* 1023..1027 */
    char L1027[395]; /* 1028..1035 */
    char L1035[429]; /* 1036..1043 */
    char L1043[465]; /* 1044..1050 */
    char L1050[391]; /* 1051..1058 */
    char L1058[493]; /* 1059..1062 */
    char L1062[447]; /* 1063..1070 */
    char L1070[458]; /* 1071..1074 */
    char L1074[474]; /* 1075..1082 */
    char L1082[432]; /* 1083..1085 */
    char L1085[423]; /* 1086..1088 */
    char L1088[474]; /* 1089..1091 */
    char L1091[438]; /* 1092..1094 */
    char L1094[438]; /* 1095..1097 */
    char L1097[408]; /* 1098..1100 */
    char L1100[435]; /* 1101..1104 */
    char L1104[453]; /* 1105..1111 */
    char L1111[496]; /* 1112..1119 */
    char L1119[497]; /* 1120..1126 */
    char L1126[439]; /* 1127..1134 */
    char L1134[373]; /* 1135..1137 */
    char L1137[420]; /* 1138..1140 */
    char L1140[426]; /* 1141..1143 */
    char L1143[498]; /* 1144..1147 */
    char L1147[443]; /* 1148..1150 */
    char L1150[490]; /* 1151..1154 */
    char L1154[472]; /* 1155..1158 */
    char L1158[382]; /* 1159..1161 */
    char L1161[437]; /* 1162..1164 */
    char L1164[427]; /* 1165..1167 */
    char L1167[476]; /* 1168..1172 */
    char L1172[446]; /* 1173..1176 */
    char L1176[491]; /* 1177..1184 */
    char L1184[452]; /* 1185..1188 */
    char L1188[505]; /* 1189..1196 */
    char L1196[487]; /* 1197..1200 */
    char L1200[490]; /* 1201..1208 */
    char L1208[446]; /* 1209..1213 */
    char L1213[378]; /* 1214..1218 */
    char L1218[421]; /* 1219..1223 */
    char L1223[473]; /* 1224..1239 */
    char L1239[484]; /* 1240..1248 */
    char L1248[468]; /* 1249..1256 */
    char L1256[491]; /* 1257..1263 */
    char L1263[481]; /* 1264..1272 */
    char L1272[472]; /* 1273..1281 */
    char L1281[452]; /* 1282..1289 */
    char L1289[494]; /* 1290..1293 */
    char L1293[418]; /* 1294..1301 */
    char L1301[429]; /* 1302..1309 */
    char L1309[467]; /* 1310..1325 */
    char L1325[508]; /* 1326..1330 */
    char L1330[420]; /* 1331..1334 */
    char L1334[418]; /* 1335..1342 */
    char L1342[476]; /* 1343..1345 */
    char L1345[358]; /* 1346..1347 */
    char L1347[358]; /* 1348..1349 */
    char L1349[350]; /* 1350..1351 */
    char L1351[484]; /* 1352..1354 */
    char L1354[466]; /* 1355..1357 */
    char L1357[484]; /* 1358..1360 */
    char L1360[434]; /* 1361..1363 */
    char L1363[432]; /* 1364..1366 */
    char L1366[450]; /* 1367..1369 */
    char L1369[502]; /* 1370..1372 */
    char L1372[462]; /* 1373..1375 */
    char L1375[470]; /* 1376..1378 */
    char L1378[486]; /* 1379..1381 */
    char L1381[332]; /* 1382..1383 */
    char L1383[374]; /* 1384..1385 */
    char L1385[492]; /* 1386..1388 */
    char L1388[488]; /* 1389..1391 */
    char L1391[500]; /* 1392..1394 */
    char L1394[352]; /* 1395..1396 */
    char L1396[340]; /* 1397..1398 */
    char L1398[374]; /* 1399..1400 */
    char L1400[504]; /* 1401..1403 */
    char L1403[498]; /* 1404..1406 */
    char L1406[484]; /* 1407..1409 */
    char L1409[470]; /* 1410..1412 */
    char L1412[366]; /* 1413..1414 */
    char L1414[386]; /* 1415..1416 */
    char L1416[348]; /* 1417..1418 */
    char L1418[344]; /* 1419..1420 */
    char L1420[358]; /* 1421..1422 */
    char L1422[346]; /* 1423..1424 */
    char L1424[494]; /* 1425..1427 */
    char L1427[468]; /* 1428..1430 */
    char L1430[504]; /* 1431..1433 */
    char L1433[342]; /* 1434..1435 */
    char L1435[352]; /* 1436..1437 */
    char L1437[364]; /* 1438..1439 */
    char L1439[478]; /* 1440..1442 */
    char L1442[488]; /* 1443..1445 */
    char L1445[476]; /* 1446..1448 */
    char L1448[486]; /* 1449..1451 */
    char L1451[464]; /* 1452..1454 */
    char L1454[476]; /* 1455..1457 */
    char L1457[336]; /* 1458..1459 */
    char L1459[364]; /* 1460..1461 */
    char L1461[506]; /* 1462..1464 */
    char L1464[445]; /* 1465..1476 */
    char L1476[493]; /* 1477..1480 */
    char L1480[474]; /* 1481..1492 */
    char L1492[469]; /* 1493..1496 */
    char L1496[493]; /* 1497..1500 */
    char L1500[475]; /* 1501..1504 */
    char L1504[455]; /* 1505..1507 */
    char L1507[494]; /* 1508..1511 */
    char L1511[375]; /* 1512..1514 */
    char L1514[455]; /* 1515..1519 */
    char L1519[486]; /* 1520..1524 */
    char L1524[437]; /* 1525..1529 */
    char L1529[479]; /* 1530..1533 */
    char L1533[346]; /* 1534..1536 */
    char L1536[477]; /* 1537..1546 */
    char L1546[499]; /* 1547..1570 */
    char L1570[506]; /* 1571..1601 */
    char L1601[483]; /* 1602..1629 */
    char L1629[505]; /* 1630..1659 */
    char L1659[480]; /* 1660..1686 */
    char L1686[146]; /* 1687..1696 */
} prelude_code7 = {
#line 1 "rjit_c.rb"
""/* frozen_string_literal: true */
""/* Part of this file is generated by tool/rjit/bindgen.rb. */
""/* Run `make rjit-bindgen` to update code between \"RJIT bindgen begin\" and \"RJIT bindgen end\". */
"module RubyVM::RJIT\n"/* :nodoc: all */
"\n"/*  */
"\n"/* Main: Used by RJIT */
"\n"/*  */
"\n"/* This `class << C` section is for calling C functions with Primitive. */
"\n"/* For importing variables or macros, use tool/rjit/bindgen.rb instead. */
"  class << C = Module.new\n"
"    def mmap(mem_size)\n"
"      Primitive.cexpr! 'SIZET2NUM((size_t)rjit_reserve_addr_space(NUM2UINT(mem_size)))'\n"
"    end\n"
"\n"
"    def mprotect_write(mem_block, mem_size)\n"
"      Primitive.mprotect_write(mem_block, mem_size)\n"
"    end\n"
"\n"
"    def mprotect_exec(mem_block, mem_size)\n"
"      Primitive.mprotect_exec(mem_block, mem_size)\n"
"    end\n"
"\n"
"    def rjit_insn_exits\n"
"      addr = Primitive.cexpr! 'SIZET2NUM((size_t)rjit_insn_exits)'\n"
,
#line 25 "rjit_c.rb"
"      CType::Immediate.parse(\"size_t\").new(addr)\n"
"    end\n"
"\n"
"    def rb_rjit_counters\n"
"      addr = Primitive.cexpr! 'SIZET2NUM((size_t)&rb_rjit_counters)'\n"
"      rb_rjit_runtime_counters.new(addr)\n"
"    end\n"
"\n"
"\n"/* @param from [Integer] - From address */
"\n"/* @param to [Integer]   - To address */
"    def dump_disasm(from, to, test: false)\n"
"      Primitive.dump_disasm(from, to, test)\n"
"    end\n"
"\n"
"\n"/* Convert a Ruby object to a VALUE in Integer */
"    def to_value(obj)\n"
"      Primitive.cexpr! 'SIZET2NUM((size_t)obj)'\n"
"    end\n"
"\n"
"    def BASIC_OP_UNREDEFINED_P(op, klass)\n"
"      Primitive.cexpr! 'RBOOL(BASIC_OP_UNREDEFINED_P(NUM2INT(op), NUM2INT(klass)))'\n"
,
#line 46 "rjit_c.rb"
"    end\n"
"\n"
"    def rb_iseq_line_no(iseq, pos)\n"
"      _iseq_addr = iseq.to_i\n"
"      Primitive.cexpr! 'UINT2NUM(rb_iseq_line_no((const rb_iseq_t *)NUM2SIZET(_iseq_addr), NUM2SIZET(pos)))'\n"
"    end\n"
"\n"
"    def rb_class_of(obj)\n"
"      Primitive.cexpr! 'rb_class_of(obj)'\n"
"    end\n"
"\n"
"    def rb_callable_method_entry(klass, mid)\n"
"      cme_addr = Primitive.cexpr! 'SIZET2NUM((size_t)rb_callable_method_entry(klass, NUM2UINT(mid)))'\n"
"      return nil if cme_addr == 0\n"
"      rb_callable_method_entry_t.new(cme_addr)\n"
"    end\n"
"\n"
,
#line 63 "rjit_c.rb"
"    def METHOD_ENTRY_VISI(cme)\n"
"      _cme_addr = cme.to_i\n"
"      Primitive.cexpr! 'UINT2NUM(METHOD_ENTRY_VISI((const rb_callable_method_entry_t *)NUM2SIZET(_cme_addr)))'\n"
"    end\n"
"\n"
"    def rb_simple_iseq_p(iseq)\n"
"      _iseq_addr = iseq.to_i\n"
"      Primitive.cexpr! 'RBOOL(rb_simple_iseq_p((rb_iseq_t *)NUM2SIZET(_iseq_addr)))'\n"
"    end\n"
"\n"
"    def SPECIAL_CONST_P(obj)\n"
"      _value = to_value(obj)\n"
"      Primitive.cexpr! 'RBOOL(SPECIAL_CONST_P((VALUE)NUM2SIZET(_value)))'\n"
"    end\n"
"\n"
"    def BUILTIN_TYPE(obj)\n"
,
#line 79 "rjit_c.rb"
"      _value = to_value(obj)\n"
"      Primitive.cexpr! 'INT2NUM(BUILTIN_TYPE((VALUE)NUM2SIZET(_value)))'\n"
"    end\n"
"\n"
"    def RB_TYPE_P(obj, type)\n"
"      Primitive.cexpr! 'RBOOL(RB_TYPE_P(obj, NUM2UINT(type)))'\n"
"    end\n"
"\n"
"    def rb_shape_get_shape_id(obj)\n"
"      _value = to_value(obj)\n"
"      Primitive.cexpr! 'UINT2NUM((unsigned int)rb_shape_get_shape_id((VALUE)NUM2SIZET(_value)))'\n"
"    end\n"
"\n"
"    def rb_shape_id_offset\n"
"      Primitive.cexpr! 'INT2NUM(rb_shape_id_offset())'\n"
"    end\n"
"\n"
,
#line 96 "rjit_c.rb"
"    def rb_shape_get_iv_index(shape_id, ivar_id)\n"
"      Primitive.cstmt! %{\n"
"        rb_shape_t *shape = rb_shape_get_shape_by_id((shape_id_t)NUM2SIZET(shape_id));\n"
"        attr_index_t index;\n"
"        bool found = rb_shape_get_iv_index(shape, (ID)NUM2SIZET(ivar_id), &index);\n"
"        return found ? UINT2NUM(index) : Qnil;\n"
"      }\n"
"    end\n"
"\n"
"    def FL_TEST_RAW(obj, flags)\n"
"      Primitive.cexpr! 'RBOOL(FL_TEST_RAW(obj, (VALUE)NUM2SIZET(flags)))'\n"
"    end\n"
"\n"
"    def FL_TEST(obj, flags)\n"
,
#line 110 "rjit_c.rb"
"      Primitive.cexpr! 'RBOOL(FL_TEST(obj, (VALUE)NUM2SIZET(flags)))'\n"
"    end\n"
"\n"
"    def rjit_for_each_iseq(&block)\n"
"      Primitive.rjit_for_each_iseq(block)\n"
"    end\n"
"\n"
"    def get_symbol_id(name)\n"
"      Primitive.cexpr! 'SIZET2NUM((size_t)rb_get_symbol_id(name))'\n"
"    end\n"
"\n"
"    def rb_vm_frame_method_entry(cfp)\n"
"      _cfp = cfp.to_i\n"
"      cme_addr = Primitive.cexpr! 'SIZET2NUM((size_t)rb_vm_frame_method_entry((const rb_control_frame_t *)NUM2SIZET(_cfp)))'\n"
"      return nil if cme_addr == 0\n"
,
#line 125 "rjit_c.rb"
"      rb_callable_method_entry_t.new(cme_addr)\n"
"    end\n"
"\n"
"    def rb_class_get_superclass(klass)\n"
"      Primitive.cexpr! 'rb_class_get_superclass(klass)'\n"
"    end\n"
"\n"
"    def ID2SYM(id)\n"
"      Primitive.cexpr! 'ID2SYM((ID)NUM2SIZET(id))'\n"
"    end\n"
"\n"
"    def obj_is_kind_of(obj, c)\n"
"      Primitive.cexpr! 'rb_obj_is_kind_of(obj, c)'\n"
"    end\n"
"\n"
"    def imemo_type_p(ptr, type)\n"
"      _ptr = ptr.to_i\n"
"      Primitive.cexpr! 'RBOOL(imemo_type_p((VALUE)NUM2SIZET(_ptr), NUM2UINT(type)))'\n"
"    end\n"
"\n"
,
#line 145 "rjit_c.rb"
"    def rb_iseq_only_optparam_p(iseq)\n"
"      _iseq = iseq.to_i\n"
"      Primitive.cstmt! %{\n"
"        extern bool rb_iseq_only_optparam_p(const rb_iseq_t *iseq);\n"
"        return RBOOL(rb_iseq_only_optparam_p((rb_iseq_t *)NUM2SIZET(_iseq)));\n"
"      }\n"
"    end\n"
"\n"
"    def rb_iseq_only_kwparam_p(iseq)\n"
"      _iseq = iseq.to_i\n"
"      Primitive.cstmt! %{\n"
"        extern bool rb_iseq_only_kwparam_p(const rb_iseq_t *iseq);\n"
"        return RBOOL(rb_iseq_only_kwparam_p((rb_iseq_t *)NUM2SIZET(_iseq)));\n"
"      }\n"
"    end\n"
"\n"
,
#line 161 "rjit_c.rb"
"    def rb_obj_frozen_p(obj)\n"
"      Primitive.cexpr! 'rb_obj_frozen_p(obj)'\n"
"    end\n"
"\n"
"    def rb_intern(str)\n"
"      Primitive.cexpr! 'SIZET2NUM((size_t)rb_intern(RSTRING_PTR(str)))'\n"
"    end\n"
"\n"
"    def rb_method_entry_at(klass, mid)\n"
"      me_addr = Primitive.cexpr! 'SIZET2NUM((size_t)rb_method_entry_at(klass, (ID)NUM2SIZET(mid)))'\n"
"      me_addr == 0 ? nil : rb_method_entry_t.new(me_addr)\n"
"    end\n"
"\n"
"    def rb_shape_get_next(shape, obj, id)\n"
"      _shape = shape.to_i\n"
,
#line 176 "rjit_c.rb"
"      shape_addr = Primitive.cexpr! 'SIZET2NUM((size_t)rb_shape_get_next((rb_shape_t *)NUM2SIZET(_shape), obj, (ID)NUM2SIZET(id)))'\n"
"      rb_shape_t.new(shape_addr)\n"
"    end\n"
"\n"
"    def rb_shape_id(shape)\n"
"      _shape = shape.to_i\n"
"      Primitive.cexpr! 'SIZET2NUM((size_t)rb_shape_id((rb_shape_t *)NUM2SIZET(_shape)))'\n"
"    end\n"
"\n"
"    def rb_class_attached_object(klass)\n"
"      Primitive.cexpr! 'rb_class_attached_object(klass)'\n"
"    end\n"
"\n"
"    def rb_singleton_class(obj)\n"
,
#line 190 "rjit_c.rb"
"      Primitive.cexpr! 'rb_singleton_class(obj)'\n"
"    end\n"
"\n"
"    def rb_aliased_callable_method_entry(cme)\n"
"      _cme = cme.to_i\n"
"      cme_addr = Primitive.cstmt! %{\n"
"        extern const rb_callable_method_entry_t * rb_aliased_callable_method_entry(const rb_callable_method_entry_t *me);\n"
"        return SIZET2NUM((size_t)rb_aliased_callable_method_entry((const rb_callable_method_entry_t *)NUM2SIZET(_cme)));\n"
"      }\n"
"      rb_callable_method_entry_t.new(cme_addr)\n"
"    end\n"
"\n"
,
#line 202 "rjit_c.rb"
"    def rb_yjit_get_proc_ptr(proc_addr)\n"
"      proc_t_addr = Primitive.cstmt! %{\n"
"        extern rb_proc_t * rjit_get_proc_ptr(VALUE procv);\n"
"        return SIZET2NUM((size_t)rjit_get_proc_ptr((VALUE)NUM2SIZET(proc_addr)));\n"
"      }\n"
"      rb_proc_t.new(proc_t_addr)\n"
"    end\n"
"\n"
"    def rb_shape_get_shape_by_id(shape_id)\n"
"      _shape_id = shape_id.to_i\n"
"      shape_addr = Primitive.cexpr! 'SIZET2NUM((VALUE)rb_shape_get_shape_by_id((shape_id_t)NUM2UINT(_shape_id)))'\n"
"      rb_shape_t.new(shape_addr)\n"
"    end\n"
"\n"
,
#line 216 "rjit_c.rb"
"    def rb_iseq_check(iseq)\n"
"      _iseq_addr = iseq.to_i\n"
"      iseq_addr = Primitive.cexpr! 'SIZET2NUM((VALUE)rb_iseq_check((rb_iseq_t *)NUM2SIZET(_iseq_addr)))'\n"
"      rb_iseq_t.new(iseq_addr)\n"
"    end\n"
"\n"
"    def rb_iseq_path(iseq)\n"
"      _iseq_addr = iseq.to_i\n"
"      Primitive.cexpr! 'rb_iseq_path((rb_iseq_t *)NUM2SIZET(_iseq_addr))'\n"
"    end\n"
"\n"
"    def vm_ci_argc(ci)\n"
"      _ci_addr = ci.to_i\n"
"      Primitive.cexpr! 'UINT2NUM(vm_ci_argc((CALL_INFO)NUM2SIZET(_ci_addr)))'\n"
"    end\n"
"\n"
"    def vm_ci_flag(ci)\n"
,
#line 233 "rjit_c.rb"
"      _ci_addr = ci.to_i\n"
"      Primitive.cexpr! 'UINT2NUM(vm_ci_flag((CALL_INFO)NUM2SIZET(_ci_addr)))'\n"
"    end\n"
"\n"
"    def vm_ci_kwarg(ci)\n"
"      _ci_addr = ci.to_i\n"
"      kwarg_addr = Primitive.cexpr! 'SIZET2NUM((size_t)vm_ci_kwarg((CALL_INFO)NUM2SIZET(_ci_addr)))'\n"
"      kwarg_addr == 0 ? nil : rb_callinfo_kwarg.new(kwarg_addr)\n"
"    end\n"
"\n"
"    def vm_ci_mid(ci)\n"
"      _ci_addr = ci.to_i\n"
"      Primitive.cexpr! 'SIZET2NUM((size_t)vm_ci_mid((CALL_INFO)NUM2SIZET(_ci_addr)))'\n"
"    end\n"
"\n"
"    def rjit_opts\n"
,
#line 249 "rjit_c.rb"
"      addr = Primitive.cexpr! 'SIZET2NUM((VALUE)&rb_rjit_opts)'\n"
"      rb_rjit_options.new(addr)\n"
"    end\n"
"\n"
"    def rjit_cancel_all(reason)\n"
"      Primitive.cstmt! %{\n"
"        rb_rjit_cancel_all(RSTRING_PTR(reason));\n"
"        return Qnil;\n"
"      }\n"
"    end\n"
"\n"
"\n"/* Convert an encoded VM pointer to an insn BIN. */
"    def rb_vm_insn_decode(encoded)\n"
"\n"/* Using rb_vm_insn_addr2opcode to return trace_ insns */
"      Primitive.cexpr! 'INT2NUM(rb_vm_insn_addr2opcode((void *)NUM2SIZET(encoded)))'\n"
"    end\n"
"\n"
"\n"/* Convert Integer VALUE to an actual Ruby object */
"    def to_ruby(value)\n"
"      Primitive.cexpr! '(VALUE)NUM2SIZET(value)'\n"
"    end\n"
"\n"
"    def HAVE_LIBCAPSTONE\n"
,
#line 272 "rjit_c.rb"
"      Primitive.cstmt! %{\n"
"        #ifdef HAVE_LIBCAPSTONE\n"
"          return Qtrue;\n"
"        #else\n"
"          return Qfalse;\n"
"        #endif\n"
"      }\n"
"    end\n"
"\n"
"    def rjit_exit_traces\n"
"      Primitive.cexpr! 'rjit_exit_traces()'\n"
"    end\n"
"\n"
"    def rb_vm_ep_local_ep(ep)\n"
"      _ep = ep.to_i\n"
"      lep_addr = Primitive.cexpr! 'SIZET2NUM((size_t)rb_vm_ep_local_ep((const VALUE *)NUM2SIZET(_ep)))'\n"
"      C.VALUE.new(lep_addr)\n"
"    end\n"
"\n"
"    def rb_hash_keys(hash)\n"
"      Primitive.cexpr! 'rb_hash_keys(hash)'\n"
"    end\n"
"\n"
,
#line 295 "rjit_c.rb"
"    def rb_hash_stlike_lookup(hash, key)\n"
"      Primitive.cstmt! %{\n"
"        VALUE result = Qnil;\n"
"        rb_hash_stlike_lookup(hash, key, &result);\n"
"        return result;\n"
"      }\n"
"    end\n"
"\n"
"    def rb_obj_class(obj)\n"
"      Primitive.cexpr! 'rb_obj_class(obj)'\n"
"    end\n"
"\n"
"    def rb_sym2id(sym)\n"
"      Primitive.cexpr! 'SIZET2NUM((size_t)rb_sym2id(sym))'\n"
"    end\n"
"\n"
"    def rb_callable_method_entry_or_negative(klass, mid)\n"
,
#line 312 "rjit_c.rb"
"      cme_addr = Primitive.cexpr! 'SIZET2NUM((size_t)rb_callable_method_entry_or_negative(klass, (ID)NUM2SIZET(mid)))'\n"
"      return nil if cme_addr == 0\n"
"      rb_callable_method_entry_t.new(cme_addr)\n"
"    end\n"
"\n"
"    def rb_method_basic_definition_p(klass, mid)\n"
"      Primitive.cexpr! 'RBOOL(rb_method_basic_definition_p(klass, (ID)NUM2SIZET(mid)))'\n"
"    end\n"
"\n"
"    def UNDEFINED_METHOD_ENTRY_P(cme)\n"
"      _cme_addr = cme.to_i\n"
,
#line 323 "rjit_c.rb"
"      Primitive.cexpr! 'RBOOL(UNDEFINED_METHOD_ENTRY_P((const rb_callable_method_entry_t *)NUM2SIZET(_cme_addr)))'\n"
"    end\n"
"\n"
"    def RCLASS_ORIGIN(klass)\n"
"      Primitive.cexpr! 'RCLASS_ORIGIN(klass)'\n"
"    end\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* Utilities: Not used by RJIT, but useful for debugging */
"\n"/*  */
"  class << C\n"
"\n"/* Convert insn BINs to encoded VM pointers. */
"    def rb_vm_insn_encode(bin)\n"
"      Primitive.cexpr! 'SIZET2NUM((VALUE)rb_vm_get_insns_address_table()[NUM2INT(bin)])'\n"
"    end\n"
"\n"
"\n"/* Convert RubyVM::InstructionSequence to C.rb_iseq_t. */
"    def rb_iseqw_to_iseq(iseqw)\n"
"      iseq_addr = Primitive.cexpr! 'SIZET2NUM((VALUE)rb_iseqw_to_iseq(iseqw))'\n"
"      rb_iseq_t.new(iseq_addr)\n"
,
#line 344 "rjit_c.rb"
"    end\n"
"  end\n"
"\n"
"\n"/* # RJIT bindgen begin ### */
"\n"
"  C::UNLIMITED_ARGUMENTS = Primitive.cexpr! %q{ LONG2NUM(UNLIMITED_ARGUMENTS) }\n"
"  C::VM_ENV_DATA_INDEX_ME_CREF = Primitive.cexpr! %q{ LONG2NUM(VM_ENV_DATA_INDEX_ME_CREF) }\n"
"  C::VM_ENV_DATA_INDEX_SPECVAL = Primitive.cexpr! %q{ LONG2NUM(VM_ENV_DATA_INDEX_SPECVAL) }\n"
"  C::ARRAY_REDEFINED_OP_FLAG = Primitive.cexpr! %q{ SIZET2NUM(ARRAY_REDEFINED_OP_FLAG) }\n"
"  C::BOP_AND = Primitive.cexpr! %q{ SIZET2NUM(BOP_AND) }\n"
"  C::BOP_AREF = Primitive.cexpr! %q{ SIZET2NUM(BOP_AREF) }\n"
,
#line 355 "rjit_c.rb"
"  C::BOP_EQ = Primitive.cexpr! %q{ SIZET2NUM(BOP_EQ) }\n"
"  C::BOP_EQQ = Primitive.cexpr! %q{ SIZET2NUM(BOP_EQQ) }\n"
"  C::BOP_FREEZE = Primitive.cexpr! %q{ SIZET2NUM(BOP_FREEZE) }\n"
"  C::BOP_GE = Primitive.cexpr! %q{ SIZET2NUM(BOP_GE) }\n"
"  C::BOP_GT = Primitive.cexpr! %q{ SIZET2NUM(BOP_GT) }\n"
"  C::BOP_LE = Primitive.cexpr! %q{ SIZET2NUM(BOP_LE) }\n"
"  C::BOP_LT = Primitive.cexpr! %q{ SIZET2NUM(BOP_LT) }\n"
"  C::BOP_MINUS = Primitive.cexpr! %q{ SIZET2NUM(BOP_MINUS) }\n"
,
#line 363 "rjit_c.rb"
"  C::BOP_MOD = Primitive.cexpr! %q{ SIZET2NUM(BOP_MOD) }\n"
"  C::BOP_OR = Primitive.cexpr! %q{ SIZET2NUM(BOP_OR) }\n"
"  C::BOP_PLUS = Primitive.cexpr! %q{ SIZET2NUM(BOP_PLUS) }\n"
"  C::BUILTIN_ATTR_LEAF = Primitive.cexpr! %q{ SIZET2NUM(BUILTIN_ATTR_LEAF) }\n"
"  C::BUILTIN_ATTR_NO_GC = Primitive.cexpr! %q{ SIZET2NUM(BUILTIN_ATTR_NO_GC) }\n"
"  C::HASH_REDEFINED_OP_FLAG = Primitive.cexpr! %q{ SIZET2NUM(HASH_REDEFINED_OP_FLAG) }\n"
"  C::INTEGER_REDEFINED_OP_FLAG = Primitive.cexpr! %q{ SIZET2NUM(INTEGER_REDEFINED_OP_FLAG) }\n"
,
#line 370 "rjit_c.rb"
"  C::INVALID_SHAPE_ID = Primitive.cexpr! %q{ SIZET2NUM(INVALID_SHAPE_ID) }\n"
"  C::METHOD_VISI_PRIVATE = Primitive.cexpr! %q{ SIZET2NUM(METHOD_VISI_PRIVATE) }\n"
"  C::METHOD_VISI_PROTECTED = Primitive.cexpr! %q{ SIZET2NUM(METHOD_VISI_PROTECTED) }\n"
"  C::METHOD_VISI_PUBLIC = Primitive.cexpr! %q{ SIZET2NUM(METHOD_VISI_PUBLIC) }\n"
"  C::METHOD_VISI_UNDEF = Primitive.cexpr! %q{ SIZET2NUM(METHOD_VISI_UNDEF) }\n"
"  C::OBJ_TOO_COMPLEX_SHAPE_ID = Primitive.cexpr! %q{ SIZET2NUM(OBJ_TOO_COMPLEX_SHAPE_ID) }\n"
,
#line 376 "rjit_c.rb"
"  C::OPTIMIZED_METHOD_TYPE_BLOCK_CALL = Primitive.cexpr! %q{ SIZET2NUM(OPTIMIZED_METHOD_TYPE_BLOCK_CALL) }\n"
"  C::OPTIMIZED_METHOD_TYPE_CALL = Primitive.cexpr! %q{ SIZET2NUM(OPTIMIZED_METHOD_TYPE_CALL) }\n"
"  C::OPTIMIZED_METHOD_TYPE_SEND = Primitive.cexpr! %q{ SIZET2NUM(OPTIMIZED_METHOD_TYPE_SEND) }\n"
"  C::OPTIMIZED_METHOD_TYPE_STRUCT_AREF = Primitive.cexpr! %q{ SIZET2NUM(OPTIMIZED_METHOD_TYPE_STRUCT_AREF) }\n"
,
#line 380 "rjit_c.rb"
"  C::OPTIMIZED_METHOD_TYPE_STRUCT_ASET = Primitive.cexpr! %q{ SIZET2NUM(OPTIMIZED_METHOD_TYPE_STRUCT_ASET) }\n"
"  C::RARRAY_EMBED_FLAG = Primitive.cexpr! %q{ SIZET2NUM(RARRAY_EMBED_FLAG) }\n"
"  C::RARRAY_EMBED_LEN_MASK = Primitive.cexpr! %q{ SIZET2NUM(RARRAY_EMBED_LEN_MASK) }\n"
"  C::RARRAY_EMBED_LEN_SHIFT = Primitive.cexpr! %q{ SIZET2NUM(RARRAY_EMBED_LEN_SHIFT) }\n"
"  C::RHASH_PASS_AS_KEYWORDS = Primitive.cexpr! %q{ SIZET2NUM(RHASH_PASS_AS_KEYWORDS) }\n"
,
#line 385 "rjit_c.rb"
"  C::RMODULE_IS_REFINEMENT = Primitive.cexpr! %q{ SIZET2NUM(RMODULE_IS_REFINEMENT) }\n"
"  C::ROBJECT_EMBED = Primitive.cexpr! %q{ SIZET2NUM(ROBJECT_EMBED) }\n"
"  C::RSTRUCT_EMBED_LEN_MASK = Primitive.cexpr! %q{ SIZET2NUM(RSTRUCT_EMBED_LEN_MASK) }\n"
"  C::RUBY_ENCODING_MASK = Primitive.cexpr! %q{ SIZET2NUM(RUBY_ENCODING_MASK) }\n"
"  C::RUBY_EVENT_CLASS = Primitive.cexpr! %q{ SIZET2NUM(RUBY_EVENT_CLASS) }\n"
"  C::RUBY_EVENT_C_CALL = Primitive.cexpr! %q{ SIZET2NUM(RUBY_EVENT_C_CALL) }\n"
,
#line 391 "rjit_c.rb"
"  C::RUBY_EVENT_C_RETURN = Primitive.cexpr! %q{ SIZET2NUM(RUBY_EVENT_C_RETURN) }\n"
"  C::RUBY_FIXNUM_FLAG = Primitive.cexpr! %q{ SIZET2NUM(RUBY_FIXNUM_FLAG) }\n"
"  C::RUBY_FLONUM_FLAG = Primitive.cexpr! %q{ SIZET2NUM(RUBY_FLONUM_FLAG) }\n"
"  C::RUBY_FLONUM_MASK = Primitive.cexpr! %q{ SIZET2NUM(RUBY_FLONUM_MASK) }\n"
"  C::RUBY_FL_FREEZE = Primitive.cexpr! %q{ SIZET2NUM(RUBY_FL_FREEZE) }\n"
"  C::RUBY_FL_SINGLETON = Primitive.cexpr! %q{ SIZET2NUM(RUBY_FL_SINGLETON) }\n"
,
#line 397 "rjit_c.rb"
"  C::RUBY_IMMEDIATE_MASK = Primitive.cexpr! %q{ SIZET2NUM(RUBY_IMMEDIATE_MASK) }\n"
"  C::RUBY_SPECIAL_SHIFT = Primitive.cexpr! %q{ SIZET2NUM(RUBY_SPECIAL_SHIFT) }\n"
"  C::RUBY_SYMBOL_FLAG = Primitive.cexpr! %q{ SIZET2NUM(RUBY_SYMBOL_FLAG) }\n"
"  C::RUBY_T_ARRAY = Primitive.cexpr! %q{ SIZET2NUM(RUBY_T_ARRAY) }\n"
"  C::RUBY_T_CLASS = Primitive.cexpr! %q{ SIZET2NUM(RUBY_T_CLASS) }\n"
"  C::RUBY_T_HASH = Primitive.cexpr! %q{ SIZET2NUM(RUBY_T_HASH) }\n"
"  C::RUBY_T_ICLASS = Primitive.cexpr! %q{ SIZET2NUM(RUBY_T_ICLASS) }\n"
,
#line 404 "rjit_c.rb"
"  C::RUBY_T_MASK = Primitive.cexpr! %q{ SIZET2NUM(RUBY_T_MASK) }\n"
"  C::RUBY_T_MODULE = Primitive.cexpr! %q{ SIZET2NUM(RUBY_T_MODULE) }\n"
"  C::RUBY_T_OBJECT = Primitive.cexpr! %q{ SIZET2NUM(RUBY_T_OBJECT) }\n"
"  C::RUBY_T_STRING = Primitive.cexpr! %q{ SIZET2NUM(RUBY_T_STRING) }\n"
"  C::RUBY_T_SYMBOL = Primitive.cexpr! %q{ SIZET2NUM(RUBY_T_SYMBOL) }\n"
"  C::SHAPE_FLAG_SHIFT = Primitive.cexpr! %q{ SIZET2NUM(SHAPE_FLAG_SHIFT) }\n"
"  C::SHAPE_FROZEN = Primitive.cexpr! %q{ SIZET2NUM(SHAPE_FROZEN) }\n"
,
#line 411 "rjit_c.rb"
"  C::SHAPE_ID_NUM_BITS = Primitive.cexpr! %q{ SIZET2NUM(SHAPE_ID_NUM_BITS) }\n"
"  C::SHAPE_IVAR = Primitive.cexpr! %q{ SIZET2NUM(SHAPE_IVAR) }\n"
"  C::SHAPE_MASK = Primitive.cexpr! %q{ SIZET2NUM(SHAPE_MASK) }\n"
"  C::SHAPE_ROOT = Primitive.cexpr! %q{ SIZET2NUM(SHAPE_ROOT) }\n"
"  C::STRING_REDEFINED_OP_FLAG = Primitive.cexpr! %q{ SIZET2NUM(STRING_REDEFINED_OP_FLAG) }\n"
"  C::T_OBJECT = Primitive.cexpr! %q{ SIZET2NUM(T_OBJECT) }\n"
"  C::VM_BLOCK_HANDLER_NONE = Primitive.cexpr! %q{ SIZET2NUM(VM_BLOCK_HANDLER_NONE) }\n"
,
#line 418 "rjit_c.rb"
"  C::VM_CALL_ARGS_BLOCKARG = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_ARGS_BLOCKARG) }\n"
"  C::VM_CALL_ARGS_SPLAT = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_ARGS_SPLAT) }\n"
"  C::VM_CALL_FCALL = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_FCALL) }\n"
"  C::VM_CALL_KWARG = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_KWARG) }\n"
"  C::VM_CALL_KW_SPLAT = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_KW_SPLAT) }\n"
"  C::VM_CALL_KW_SPLAT_MUT = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_KW_SPLAT_MUT) }\n"
,
#line 424 "rjit_c.rb"
"  C::VM_CALL_KW_SPLAT_bit = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_KW_SPLAT_bit) }\n"
"  C::VM_CALL_OPT_SEND = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_OPT_SEND) }\n"
"  C::VM_CALL_TAILCALL = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_TAILCALL) }\n"
"  C::VM_CALL_TAILCALL_bit = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_TAILCALL_bit) }\n"
"  C::VM_CALL_ZSUPER = Primitive.cexpr! %q{ SIZET2NUM(VM_CALL_ZSUPER) }\n"
"  C::VM_ENV_DATA_INDEX_FLAGS = Primitive.cexpr! %q{ SIZET2NUM(VM_ENV_DATA_INDEX_FLAGS) }\n"
,
#line 430 "rjit_c.rb"
"  C::VM_ENV_DATA_SIZE = Primitive.cexpr! %q{ SIZET2NUM(VM_ENV_DATA_SIZE) }\n"
"  C::VM_ENV_FLAG_LOCAL = Primitive.cexpr! %q{ SIZET2NUM(VM_ENV_FLAG_LOCAL) }\n"
"  C::VM_ENV_FLAG_WB_REQUIRED = Primitive.cexpr! %q{ SIZET2NUM(VM_ENV_FLAG_WB_REQUIRED) }\n"
"  C::VM_FRAME_FLAG_BMETHOD = Primitive.cexpr! %q{ SIZET2NUM(VM_FRAME_FLAG_BMETHOD) }\n"
"  C::VM_FRAME_FLAG_CFRAME = Primitive.cexpr! %q{ SIZET2NUM(VM_FRAME_FLAG_CFRAME) }\n"
"  C::VM_FRAME_FLAG_CFRAME_KW = Primitive.cexpr! %q{ SIZET2NUM(VM_FRAME_FLAG_CFRAME_KW) }\n"
,
#line 436 "rjit_c.rb"
"  C::VM_FRAME_FLAG_LAMBDA = Primitive.cexpr! %q{ SIZET2NUM(VM_FRAME_FLAG_LAMBDA) }\n"
"  C::VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM = Primitive.cexpr! %q{ SIZET2NUM(VM_FRAME_FLAG_MODIFIED_BLOCK_PARAM) }\n"
"  C::VM_FRAME_MAGIC_BLOCK = Primitive.cexpr! %q{ SIZET2NUM(VM_FRAME_MAGIC_BLOCK) }\n"
"  C::VM_FRAME_MAGIC_CFUNC = Primitive.cexpr! %q{ SIZET2NUM(VM_FRAME_MAGIC_CFUNC) }\n"
"  C::VM_FRAME_MAGIC_METHOD = Primitive.cexpr! %q{ SIZET2NUM(VM_FRAME_MAGIC_METHOD) }\n"
,
#line 441 "rjit_c.rb"
"  C::VM_METHOD_TYPE_ALIAS = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_ALIAS) }\n"
"  C::VM_METHOD_TYPE_ATTRSET = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_ATTRSET) }\n"
"  C::VM_METHOD_TYPE_BMETHOD = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_BMETHOD) }\n"
"  C::VM_METHOD_TYPE_CFUNC = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_CFUNC) }\n"
"  C::VM_METHOD_TYPE_ISEQ = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_ISEQ) }\n"
"  C::VM_METHOD_TYPE_IVAR = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_IVAR) }\n"
,
#line 447 "rjit_c.rb"
"  C::VM_METHOD_TYPE_MISSING = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_MISSING) }\n"
"  C::VM_METHOD_TYPE_NOTIMPLEMENTED = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_NOTIMPLEMENTED) }\n"
"  C::VM_METHOD_TYPE_OPTIMIZED = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_OPTIMIZED) }\n"
"  C::VM_METHOD_TYPE_REFINED = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_REFINED) }\n"
"  C::VM_METHOD_TYPE_UNDEF = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_UNDEF) }\n"
,
#line 452 "rjit_c.rb"
"  C::VM_METHOD_TYPE_ZSUPER = Primitive.cexpr! %q{ SIZET2NUM(VM_METHOD_TYPE_ZSUPER) }\n"
"  C::VM_SPECIAL_OBJECT_VMCORE = Primitive.cexpr! %q{ SIZET2NUM(VM_SPECIAL_OBJECT_VMCORE) }\n"
"\n"
"  def C.block_type_iseq\n"
"    Primitive.cexpr! %q{ SIZET2NUM(block_type_iseq) }\n"
"  end\n"
"\n"
"  def C.idRespond_to_missing\n"
"    Primitive.cexpr! %q{ SIZET2NUM(idRespond_to_missing) }\n"
"  end\n"
"\n"
"  def C.imemo_callinfo\n"
"    Primitive.cexpr! %q{ SIZET2NUM(imemo_callinfo) }\n"
"  end\n"
"\n"
"  def C.imemo_iseq\n"
"    Primitive.cexpr! %q{ SIZET2NUM(imemo_iseq) }\n"
,
#line 469 "rjit_c.rb"
"  end\n"
"\n"
"  def C.rb_block_param_proxy\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_block_param_proxy) }\n"
"  end\n"
"\n"
"  def C.rb_cArray\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_cArray) }\n"
"  end\n"
"\n"
"  def C.rb_cFalseClass\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_cFalseClass) }\n"
"  end\n"
"\n"
"  def C.rb_cFloat\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_cFloat) }\n"
"  end\n"
"\n"
"  def C.rb_cInteger\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_cInteger) }\n"
"  end\n"
"\n"
"  def C.rb_cNilClass\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_cNilClass) }\n"
"  end\n"
"\n"
"  def C.rb_cString\n"
,
#line 496 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_cString) }\n"
"  end\n"
"\n"
"  def C.rb_cSymbol\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_cSymbol) }\n"
"  end\n"
"\n"
"  def C.rb_cTrueClass\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_cTrueClass) }\n"
"  end\n"
"\n"
"  def C.rb_mRubyVMFrozenCore\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_mRubyVMFrozenCore) }\n"
"  end\n"
"\n"
"  def C.rb_rjit_global_events\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_rjit_global_events) }\n"
"  end\n"
"\n"
"  def C.rb_vm_insns_count\n"
"    Primitive.cexpr! %q{ SIZET2NUM(rb_vm_insns_count) }\n"
"  end\n"
"\n"
,
#line 519 "rjit_c.rb"
"  def C.rb_ary_clear\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ary_clear) }\n"
"  end\n"
"\n"
"  def C.rb_ary_dup\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ary_dup) }\n"
"  end\n"
"\n"
"  def C.rb_ary_entry_internal\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ary_entry_internal) }\n"
"  end\n"
"\n"
"  def C.rb_ary_push\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ary_push) }\n"
"  end\n"
"\n"
"  def C.rb_ary_resurrect\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ary_resurrect) }\n"
"  end\n"
"\n"
"  def C.rb_ary_store\n"
,
#line 540 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ary_store) }\n"
"  end\n"
"\n"
"  def C.rb_ary_tmp_new_from_values\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ary_tmp_new_from_values) }\n"
"  end\n"
"\n"
"  def C.rb_ary_unshift_m\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ary_unshift_m) }\n"
"  end\n"
"\n"
"  def C.rb_backref_get\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_backref_get) }\n"
"  end\n"
"\n"
"  def C.rb_ec_ary_new_from_values\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ec_ary_new_from_values) }\n"
"  end\n"
"\n"
"  def C.rb_ec_str_resurrect\n"
,
#line 560 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ec_str_resurrect) }\n"
"  end\n"
"\n"
"  def C.rb_ensure_iv_list_size\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ensure_iv_list_size) }\n"
"  end\n"
"\n"
"  def C.rb_fix_aref\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_fix_aref) }\n"
"  end\n"
"\n"
"  def C.rb_fix_div_fix\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_fix_div_fix) }\n"
"  end\n"
"\n"
"  def C.rb_fix_mod_fix\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_fix_mod_fix) }\n"
"  end\n"
"\n"
"  def C.rb_fix_mul_fix\n"
,
#line 580 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_fix_mul_fix) }\n"
"  end\n"
"\n"
"  def C.rb_gc_writebarrier\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_gc_writebarrier) }\n"
"  end\n"
"\n"
"  def C.rb_get_symbol_id\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_get_symbol_id) }\n"
"  end\n"
"\n"
"  def C.rb_gvar_get\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_gvar_get) }\n"
"  end\n"
"\n"
"  def C.rb_hash_aref\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_hash_aref) }\n"
"  end\n"
"\n"
"  def C.rb_hash_aset\n"
,
#line 600 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_hash_aset) }\n"
"  end\n"
"\n"
"  def C.rb_hash_bulk_insert\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_hash_bulk_insert) }\n"
"  end\n"
"\n"
"  def C.rb_hash_new\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_hash_new) }\n"
"  end\n"
"\n"
"  def C.rb_hash_new_with_size\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_hash_new_with_size) }\n"
"  end\n"
"\n"
"  def C.rb_hash_resurrect\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_hash_resurrect) }\n"
"  end\n"
"\n"
"  def C.rb_ivar_defined\n"
,
#line 620 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ivar_defined) }\n"
"  end\n"
"\n"
"  def C.rb_ivar_get\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_ivar_get) }\n"
"  end\n"
"\n"
"  def C.rb_obj_as_string_result\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_obj_as_string_result) }\n"
"  end\n"
"\n"
"  def C.rb_obj_is_kind_of\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_obj_is_kind_of) }\n"
"  end\n"
"\n"
"  def C.rb_range_new\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_range_new) }\n"
"  end\n"
"\n"
"  def C.rb_reg_last_match\n"
,
#line 640 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_reg_last_match) }\n"
"  end\n"
"\n"
"  def C.rb_reg_match_last\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_reg_match_last) }\n"
"  end\n"
"\n"
"  def C.rb_reg_match_post\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_reg_match_post) }\n"
"  end\n"
"\n"
"  def C.rb_reg_match_pre\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_reg_match_pre) }\n"
"  end\n"
"\n"
"  def C.rb_reg_new_ary\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_reg_new_ary) }\n"
"  end\n"
"\n"
"  def C.rb_reg_nth_match\n"
,
#line 660 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_reg_nth_match) }\n"
"  end\n"
"\n"
"  def C.rb_rjit_branch_stub_hit\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_rjit_branch_stub_hit) }\n"
"  end\n"
"\n"
"  def C.rb_rjit_entry_stub_hit\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_rjit_entry_stub_hit) }\n"
"  end\n"
"\n"
"  def C.rb_str_buf_append\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_str_buf_append) }\n"
"  end\n"
"\n"
"  def C.rb_str_bytesize\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_str_bytesize) }\n"
"  end\n"
"\n"
"  def C.rb_str_concat_literals\n"
,
#line 680 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_str_concat_literals) }\n"
"  end\n"
"\n"
"  def C.rb_str_dup\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_str_dup) }\n"
"  end\n"
"\n"
"  def C.rb_str_eql_internal\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_str_eql_internal) }\n"
"  end\n"
"\n"
"  def C.rb_str_getbyte\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_str_getbyte) }\n"
"  end\n"
"\n"
"  def C.rb_str_intern\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_str_intern) }\n"
"  end\n"
"\n"
"  def C.rb_sym_to_proc\n"
,
#line 700 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_sym_to_proc) }\n"
"  end\n"
"\n"
"  def C.rb_vm_bh_to_procval\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_bh_to_procval) }\n"
"  end\n"
"\n"
"  def C.rb_vm_concat_array\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_concat_array) }\n"
"  end\n"
"\n"
"  def C.rb_vm_defined\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_defined) }\n"
"  end\n"
"\n"
"  def C.rb_vm_get_ev_const\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_get_ev_const) }\n"
"  end\n"
"\n"
"  def C.rb_vm_getclassvariable\n"
,
#line 720 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_getclassvariable) }\n"
"  end\n"
"\n"
"  def C.rb_vm_ic_hit_p\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_ic_hit_p) }\n"
"  end\n"
"\n"
"  def C.rb_vm_opt_newarray_hash\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_opt_newarray_hash) }\n"
"  end\n"
"\n"
"  def C.rb_vm_opt_newarray_max\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_opt_newarray_max) }\n"
"  end\n"
"\n"
"  def C.rb_vm_opt_newarray_min\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_opt_newarray_min) }\n"
"  end\n"
"\n"
,
#line 739 "rjit_c.rb"
"  def C.rb_vm_set_ivar_id\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_set_ivar_id) }\n"
"  end\n"
"\n"
"  def C.rb_vm_setclassvariable\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_setclassvariable) }\n"
"  end\n"
"\n"
"  def C.rb_vm_setinstancevariable\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_setinstancevariable) }\n"
"  end\n"
"\n"
"  def C.rb_vm_splat_array\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_splat_array) }\n"
"  end\n"
"\n"
"  def C.rb_vm_throw\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_throw) }\n"
"  end\n"
"\n"
,
#line 759 "rjit_c.rb"
"  def C.rb_vm_yield_with_cfunc\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rb_vm_yield_with_cfunc) }\n"
"  end\n"
"\n"
"  def C.rjit_build_kwhash\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rjit_build_kwhash) }\n"
"  end\n"
"\n"
"  def C.rjit_full_cfunc_return\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rjit_full_cfunc_return) }\n"
"  end\n"
"\n"
"  def C.rjit_optimized_call\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rjit_optimized_call) }\n"
"  end\n"
"\n"
"  def C.rjit_rb_ary_subseq_length\n"
,
#line 776 "rjit_c.rb"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rjit_rb_ary_subseq_length) }\n"
"  end\n"
"\n"
"  def C.rjit_record_exit_stack\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rjit_record_exit_stack) }\n"
"  end\n"
"\n"
"  def C.rjit_str_neq_internal\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rjit_str_neq_internal) }\n"
"  end\n"
"\n"
"  def C.rjit_str_simple_append\n"
"    Primitive.cexpr! %q{ SIZET2NUM((size_t)rjit_str_simple_append) }\n"
"  end\n"
"\n"
"  def C.CALL_DATA\n"
"    @CALL_DATA ||= self.rb_call_data\n"
"  end\n"
"\n"
"  def C.IC\n"
,
#line 796 "rjit_c.rb"
"    @IC ||= self.iseq_inline_constant_cache\n"
"  end\n"
"\n"
"  def C.ID\n"
"    @ID ||= CType::Immediate.parse(\"unsigned long\")\n"
"  end\n"
"\n"
"  def C.IVC\n"
"    @IVC ||= self.iseq_inline_iv_cache_entry\n"
"  end\n"
"\n"
"  def C.RArray\n"
"    @RArray ||= CType::Struct.new(\n"
"      \"RArray\", Primitive.cexpr!(\"SIZEOF(struct RArray)\"),\n"
"      basic: [self.RBasic, Primitive.cexpr!(\"OFFSETOF((*((struct RArray *)NULL)), basic)\")],\n"
"      as: [CType::Union.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct RArray *)NULL)->as)\"),\n"
,
#line 813 "rjit_c.rb"
"        heap: CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct RArray *)NULL)->as.heap)\"),\n"
"          len: [CType::Immediate.parse(\"long\"), Primitive.cexpr!(\"OFFSETOF(((struct RArray *)NULL)->as.heap, len)\")],\n"
"          aux: [CType::Union.new(\n"
"            \"\", Primitive.cexpr!(\"SIZEOF(((struct RArray *)NULL)->as.heap.aux)\"),\n"
"            capa: CType::Immediate.parse(\"long\"),\n"
"            shared_root: self.VALUE,\n"
,
#line 820 "rjit_c.rb"
"          ), Primitive.cexpr!(\"OFFSETOF(((struct RArray *)NULL)->as.heap, aux)\")],\n"
"          ptr: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF(((struct RArray *)NULL)->as.heap, ptr)\")],\n"
"        ),\n"
"        ary: CType::Array.new { self.VALUE },\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct RArray *)NULL)), as)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.RB_BUILTIN\n"
"    @RB_BUILTIN ||= self.rb_builtin_function\n"
"  end\n"
"\n"
"  def C.RBasic\n"
"    @RBasic ||= CType::Struct.new(\n"
,
#line 834 "rjit_c.rb"
"      \"RBasic\", Primitive.cexpr!(\"SIZEOF(struct RBasic)\"),\n"
"      flags: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct RBasic *)NULL)), flags)\")],\n"
"      klass: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct RBasic *)NULL)), klass)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.RObject\n"
"    @RObject ||= CType::Struct.new(\n"
"      \"RObject\", Primitive.cexpr!(\"SIZEOF(struct RObject)\"),\n"
"      basic: [self.RBasic, Primitive.cexpr!(\"OFFSETOF((*((struct RObject *)NULL)), basic)\")],\n"
"      as: [CType::Union.new(\n"
,
#line 845 "rjit_c.rb"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct RObject *)NULL)->as)\"),\n"
"        heap: CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct RObject *)NULL)->as.heap)\"),\n"
"          ivptr: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF(((struct RObject *)NULL)->as.heap, ivptr)\")],\n"
"          iv_index_tbl: [CType::Pointer.new { self.rb_id_table }, Primitive.cexpr!(\"OFFSETOF(((struct RObject *)NULL)->as.heap, iv_index_tbl)\")],\n"
"        ),\n"
,
#line 851 "rjit_c.rb"
"        ary: CType::Array.new { self.VALUE },\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct RObject *)NULL)), as)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.RString\n"
"    @RString ||= CType::Struct.new(\n"
"      \"RString\", Primitive.cexpr!(\"SIZEOF(struct RString)\"),\n"
"      basic: [self.RBasic, Primitive.cexpr!(\"OFFSETOF((*((struct RString *)NULL)), basic)\")],\n"
"      len: [CType::Immediate.parse(\"long\"), Primitive.cexpr!(\"OFFSETOF((*((struct RString *)NULL)), len)\")],\n"
"      as: [CType::Union.new(\n"
,
#line 862 "rjit_c.rb"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct RString *)NULL)->as)\"),\n"
"        heap: CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct RString *)NULL)->as.heap)\"),\n"
"          ptr: [CType::Pointer.new { CType::Immediate.parse(\"char\") }, Primitive.cexpr!(\"OFFSETOF(((struct RString *)NULL)->as.heap, ptr)\")],\n"
"          aux: [CType::Union.new(\n"
"            \"\", Primitive.cexpr!(\"SIZEOF(((struct RString *)NULL)->as.heap.aux)\"),\n"
"            capa: CType::Immediate.parse(\"long\"),\n"
,
#line 869 "rjit_c.rb"
"            shared: self.VALUE,\n"
"          ), Primitive.cexpr!(\"OFFSETOF(((struct RString *)NULL)->as.heap, aux)\")],\n"
"        ),\n"
"        embed: CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct RString *)NULL)->as.embed)\"),\n"
"          ary: [CType::Array.new { CType::Immediate.parse(\"char\") }, Primitive.cexpr!(\"OFFSETOF(((struct RString *)NULL)->as.embed, ary)\")],\n"
"        ),\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct RString *)NULL)), as)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.RStruct\n"
,
#line 881 "rjit_c.rb"
"    @RStruct ||= CType::Struct.new(\n"
"      \"RStruct\", Primitive.cexpr!(\"SIZEOF(struct RStruct)\"),\n"
"      basic: [self.RBasic, Primitive.cexpr!(\"OFFSETOF((*((struct RStruct *)NULL)), basic)\")],\n"
"      as: [CType::Union.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct RStruct *)NULL)->as)\"),\n"
"        heap: CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct RStruct *)NULL)->as.heap)\"),\n"
,
#line 888 "rjit_c.rb"
"          len: [CType::Immediate.parse(\"long\"), Primitive.cexpr!(\"OFFSETOF(((struct RStruct *)NULL)->as.heap, len)\")],\n"
"          ptr: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF(((struct RStruct *)NULL)->as.heap, ptr)\")],\n"
"        ),\n"
"        ary: CType::Array.new { self.VALUE },\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct RStruct *)NULL)), as)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.attr_index_t\n"
"    @attr_index_t ||= CType::Immediate.parse(\"uint32_t\")\n"
"  end\n"
"\n"
"  def C.iseq_inline_constant_cache\n"
,
#line 901 "rjit_c.rb"
"    @iseq_inline_constant_cache ||= CType::Struct.new(\n"
"      \"iseq_inline_constant_cache\", Primitive.cexpr!(\"SIZEOF(struct iseq_inline_constant_cache)\"),\n"
"      entry: [CType::Pointer.new { self.iseq_inline_constant_cache_entry }, Primitive.cexpr!(\"OFFSETOF((*((struct iseq_inline_constant_cache *)NULL)), entry)\")],\n"
"      segments: [CType::Pointer.new { self.ID }, Primitive.cexpr!(\"OFFSETOF((*((struct iseq_inline_constant_cache *)NULL)), segments)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.iseq_inline_constant_cache_entry\n"
,
#line 909 "rjit_c.rb"
"    @iseq_inline_constant_cache_entry ||= CType::Struct.new(\n"
"      \"iseq_inline_constant_cache_entry\", Primitive.cexpr!(\"SIZEOF(struct iseq_inline_constant_cache_entry)\"),\n"
"      flags: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct iseq_inline_constant_cache_entry *)NULL)), flags)\")],\n"
"      value: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct iseq_inline_constant_cache_entry *)NULL)), value)\")],\n"
,
#line 913 "rjit_c.rb"
"      _unused1: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct iseq_inline_constant_cache_entry *)NULL)), _unused1)\")],\n"
"      _unused2: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct iseq_inline_constant_cache_entry *)NULL)), _unused2)\")],\n"
"      ic_cref: [CType::Pointer.new { self.rb_cref_t }, Primitive.cexpr!(\"OFFSETOF((*((struct iseq_inline_constant_cache_entry *)NULL)), ic_cref)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.iseq_inline_iv_cache_entry\n"
"    @iseq_inline_iv_cache_entry ||= CType::Struct.new(\n"
,
#line 921 "rjit_c.rb"
"      \"iseq_inline_iv_cache_entry\", Primitive.cexpr!(\"SIZEOF(struct iseq_inline_iv_cache_entry)\"),\n"
"      value: [CType::Immediate.parse(\"uintptr_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct iseq_inline_iv_cache_entry *)NULL)), value)\")],\n"
"      iv_set_name: [self.ID, Primitive.cexpr!(\"OFFSETOF((*((struct iseq_inline_iv_cache_entry *)NULL)), iv_set_name)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.iseq_inline_storage_entry\n"
"    @iseq_inline_storage_entry ||= CType::Union.new(\n"
,
#line 929 "rjit_c.rb"
"      \"iseq_inline_storage_entry\", Primitive.cexpr!(\"SIZEOF(union iseq_inline_storage_entry)\"),\n"
"      once: CType::Struct.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((union iseq_inline_storage_entry *)NULL)->once)\"),\n"
"        running_thread: [CType::Pointer.new { self.rb_thread_struct }, Primitive.cexpr!(\"OFFSETOF(((union iseq_inline_storage_entry *)NULL)->once, running_thread)\")],\n"
"        value: [self.VALUE, Primitive.cexpr!(\"OFFSETOF(((union iseq_inline_storage_entry *)NULL)->once, value)\")],\n"
"      ),\n"
,
#line 935 "rjit_c.rb"
"      ic_cache: self.iseq_inline_constant_cache,\n"
"      iv_cache: self.iseq_inline_iv_cache_entry,\n"
"    )\n"
"  end\n"
"\n"
"  def C.method_optimized_type\n"
"    @method_optimized_type ||= CType::Immediate.parse(\"int\")\n"
"  end\n"
"\n"
"  def C.rb_block\n"
"    @rb_block ||= CType::Struct.new(\n"
"      \"rb_block\", Primitive.cexpr!(\"SIZEOF(struct rb_block)\"),\n"
"      as: [CType::Union.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_block *)NULL)->as)\"),\n"
"        captured: self.rb_captured_block,\n"
"        symbol: self.VALUE,\n"
,
#line 951 "rjit_c.rb"
"        proc: self.VALUE,\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_block *)NULL)), as)\")],\n"
"      type: [self.rb_block_type, Primitive.cexpr!(\"OFFSETOF((*((struct rb_block *)NULL)), type)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_block_type\n"
"    @rb_block_type ||= CType::Immediate.parse(\"int\")\n"
"  end\n"
"\n"
"  def C.rb_builtin_function\n"
"    @rb_builtin_function ||= CType::Struct.new(\n"
"      \"rb_builtin_function\", Primitive.cexpr!(\"SIZEOF(struct rb_builtin_function)\"),\n"
,
#line 964 "rjit_c.rb"
"      func_ptr: [CType::Immediate.parse(\"void *\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_builtin_function *)NULL)), func_ptr)\")],\n"
"      argc: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_builtin_function *)NULL)), argc)\")],\n"
"      index: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_builtin_function *)NULL)), index)\")],\n"
,
#line 967 "rjit_c.rb"
"      name: [CType::Pointer.new { CType::Immediate.parse(\"char\") }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_builtin_function *)NULL)), name)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_call_data\n"
"    @rb_call_data ||= CType::Struct.new(\n"
"      \"rb_call_data\", Primitive.cexpr!(\"SIZEOF(struct rb_call_data)\"),\n"
"      ci: [CType::Pointer.new { self.rb_callinfo }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_call_data *)NULL)), ci)\")],\n"
,
#line 975 "rjit_c.rb"
"      cc: [CType::Pointer.new { self.rb_callcache }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_call_data *)NULL)), cc)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_callable_method_entry_struct\n"
"    @rb_callable_method_entry_struct ||= CType::Struct.new(\n"
"      \"rb_callable_method_entry_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_callable_method_entry_struct)\"),\n"
"      flags: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), flags)\")],\n"
,
#line 983 "rjit_c.rb"
"      defined_class: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), defined_class)\"), true],\n"
"      def: [CType::Pointer.new { self.rb_method_definition_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), def)\")],\n"
"      called_id: [self.ID, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), called_id)\")],\n"
,
#line 986 "rjit_c.rb"
"      owner: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), owner)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_callable_method_entry_t\n"
"    @rb_callable_method_entry_t ||= CType::Struct.new(\n"
"      \"rb_callable_method_entry_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_callable_method_entry_struct)\"),\n"
"      flags: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), flags)\")],\n"
,
#line 994 "rjit_c.rb"
"      defined_class: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), defined_class)\"), true],\n"
"      def: [CType::Pointer.new { self.rb_method_definition_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), def)\")],\n"
"      called_id: [self.ID, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), called_id)\")],\n"
,
#line 997 "rjit_c.rb"
"      owner: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callable_method_entry_struct *)NULL)), owner)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_callcache\n"
"    @rb_callcache ||= CType::Struct.new(\n"
"      \"rb_callcache\", Primitive.cexpr!(\"SIZEOF(struct rb_callcache)\"),\n"
"      flags: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callcache *)NULL)), flags)\")],\n"
"      klass: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callcache *)NULL)), klass)\")],\n"
,
#line 1006 "rjit_c.rb"
"      cme_: [CType::Pointer.new { self.rb_callable_method_entry_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callcache *)NULL)), cme_)\")],\n"
"      call_: [self.vm_call_handler, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callcache *)NULL)), call_)\")],\n"
"      aux_: [CType::Union.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_callcache *)NULL)->aux_)\"),\n"
"        attr: CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_callcache *)NULL)->aux_.attr)\"),\n"
,
#line 1012 "rjit_c.rb"
"          value: [CType::Immediate.parse(\"uintptr_t\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_callcache *)NULL)->aux_.attr, value)\")],\n"
"        ),\n"
"        method_missing_reason: self.method_missing_reason,\n"
"        v: self.VALUE,\n"
"        bf: CType::Pointer.new { self.rb_builtin_function },\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_callcache *)NULL)), aux_)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_callinfo\n"
"    @rb_callinfo ||= CType::Struct.new(\n"
,
#line 1023 "rjit_c.rb"
"      \"rb_callinfo\", Primitive.cexpr!(\"SIZEOF(struct rb_callinfo)\"),\n"
"      flags: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callinfo *)NULL)), flags)\")],\n"
"      kwarg: [CType::Pointer.new { self.rb_callinfo_kwarg }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callinfo *)NULL)), kwarg)\")],\n"
"      mid: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callinfo *)NULL)), mid)\")],\n"
"      flag: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callinfo *)NULL)), flag)\")],\n"
,
#line 1028 "rjit_c.rb"
"      argc: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_callinfo *)NULL)), argc)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_callinfo_kwarg\n"
"    @rb_callinfo_kwarg ||= CType::Struct.new(\n"
"      \"rb_callinfo_kwarg\", Primitive.cexpr!(\"SIZEOF(struct rb_callinfo_kwarg)\"),\n"
"      keyword_len: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_callinfo_kwarg *)NULL)), keyword_len)\")],\n"
,
#line 1036 "rjit_c.rb"
"      references: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_callinfo_kwarg *)NULL)), references)\")],\n"
"      keywords: [CType::Immediate.parse(\"void *\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_callinfo_kwarg *)NULL)), keywords)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_captured_block\n"
"    @rb_captured_block ||= CType::Struct.new(\n"
"      \"rb_captured_block\", Primitive.cexpr!(\"SIZEOF(struct rb_captured_block)\"),\n"
,
#line 1044 "rjit_c.rb"
"      self: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_captured_block *)NULL)), self)\")],\n"
"      ep: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_captured_block *)NULL)), ep)\")],\n"
"      code: [CType::Union.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_captured_block *)NULL)->code)\"),\n"
"        iseq: CType::Pointer.new { self.rb_iseq_t },\n"
"        ifunc: CType::Pointer.new { self.vm_ifunc },\n"
"        val: self.VALUE,\n"
,
#line 1051 "rjit_c.rb"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_captured_block *)NULL)), code)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_control_frame_t\n"
"    @rb_control_frame_t ||= CType::Struct.new(\n"
"      \"rb_control_frame_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_control_frame_struct)\"),\n"
"      pc: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_control_frame_struct *)NULL)), pc)\")],\n"
,
#line 1059 "rjit_c.rb"
"      sp: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_control_frame_struct *)NULL)), sp)\")],\n"
"      iseq: [CType::Pointer.new { self.rb_iseq_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_control_frame_struct *)NULL)), iseq)\")],\n"
"      self: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_control_frame_struct *)NULL)), self)\")],\n"
"      ep: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_control_frame_struct *)NULL)), ep)\")],\n"
,
#line 1063 "rjit_c.rb"
"      block_code: [CType::Immediate.parse(\"void *\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_control_frame_struct *)NULL)), block_code)\")],\n"
"      jit_return: [CType::Pointer.new { CType::Immediate.parse(\"void\") }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_control_frame_struct *)NULL)), jit_return)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_cref_t\n"
"    @rb_cref_t ||= CType::Struct.new(\n"
"      \"rb_cref_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_cref_struct)\"),\n"
,
#line 1071 "rjit_c.rb"
"      flags: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_cref_struct *)NULL)), flags)\")],\n"
"      refinements: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_cref_struct *)NULL)), refinements)\")],\n"
"      klass_or_self: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_cref_struct *)NULL)), klass_or_self)\")],\n"
"      next: [CType::Pointer.new { self.rb_cref_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_cref_struct *)NULL)), next)\")],\n"
,
#line 1075 "rjit_c.rb"
"      scope_visi: [self.rb_scope_visibility_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_cref_struct *)NULL)), scope_visi)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_execution_context_struct\n"
"    @rb_execution_context_struct ||= CType::Struct.new(\n"
"      \"rb_execution_context_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_execution_context_struct)\"),\n"
"      vm_stack: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), vm_stack)\")],\n"
,
#line 1083 "rjit_c.rb"
"      vm_stack_size: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), vm_stack_size)\")],\n"
"      cfp: [CType::Pointer.new { self.rb_control_frame_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), cfp)\")],\n"
"      tag: [CType::Pointer.new { self.rb_vm_tag }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), tag)\")],\n"
,
#line 1086 "rjit_c.rb"
"      interrupt_flag: [self.rb_atomic_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), interrupt_flag)\")],\n"
"      interrupt_mask: [self.rb_atomic_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), interrupt_mask)\")],\n"
"      fiber_ptr: [CType::Pointer.new { self.rb_fiber_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), fiber_ptr)\")],\n"
,
#line 1089 "rjit_c.rb"
"      thread_ptr: [CType::Pointer.new { self.rb_thread_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), thread_ptr)\")],\n"
"      local_storage: [CType::Pointer.new { self.rb_id_table }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), local_storage)\")],\n"
"      local_storage_recursive_hash: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), local_storage_recursive_hash)\")],\n"
,
#line 1092 "rjit_c.rb"
"      local_storage_recursive_hash_for_trace: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), local_storage_recursive_hash_for_trace)\")],\n"
"      storage: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), storage)\")],\n"
"      root_lep: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), root_lep)\")],\n"
,
#line 1095 "rjit_c.rb"
"      root_svar: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), root_svar)\")],\n"
"      ensure_list: [CType::Pointer.new { self.rb_ensure_list_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), ensure_list)\")],\n"
"      trace_arg: [CType::Pointer.new { self.rb_trace_arg_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), trace_arg)\")],\n"
,
#line 1098 "rjit_c.rb"
"      errinfo: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), errinfo)\")],\n"
"      passed_block_handler: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), passed_block_handler)\")],\n"
"      raised_flag: [CType::Immediate.parse(\"uint8_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), raised_flag)\")],\n"
,
#line 1101 "rjit_c.rb"
"      private_const_reference: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), private_const_reference)\")],\n"
"      machine: [CType::Struct.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_execution_context_struct *)NULL)->machine)\"),\n"
"        stack_start: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF(((struct rb_execution_context_struct *)NULL)->machine, stack_start)\")],\n"
,
#line 1105 "rjit_c.rb"
"        stack_end: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF(((struct rb_execution_context_struct *)NULL)->machine, stack_end)\")],\n"
"        stack_maxsize: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_execution_context_struct *)NULL)->machine, stack_maxsize)\")],\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_execution_context_struct *)NULL)), machine)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_execution_context_t\n"
,
#line 1112 "rjit_c.rb"
"    @rb_execution_context_t ||= self.rb_execution_context_struct\n"
"  end\n"
"\n"
"  def C.rb_iseq_constant_body\n"
"    @rb_iseq_constant_body ||= CType::Struct.new(\n"
"      \"rb_iseq_constant_body\", Primitive.cexpr!(\"SIZEOF(struct rb_iseq_constant_body)\"),\n"
"      type: [self.rb_iseq_type, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), type)\")],\n"
"      iseq_size: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), iseq_size)\")],\n"
,
#line 1120 "rjit_c.rb"
"      iseq_encoded: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), iseq_encoded)\")],\n"
"      param: [CType::Struct.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_iseq_constant_body *)NULL)->param)\"),\n"
"        flags: [CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_iseq_constant_body *)NULL)->param.flags)\"),\n"
"          has_lead: [CType::BitField.new(1, 0), 0],\n"
"          has_opt: [CType::BitField.new(1, 1), 1],\n"
,
#line 1127 "rjit_c.rb"
"          has_rest: [CType::BitField.new(1, 2), 2],\n"
"          has_post: [CType::BitField.new(1, 3), 3],\n"
"          has_kw: [CType::BitField.new(1, 4), 4],\n"
"          has_kwrest: [CType::BitField.new(1, 5), 5],\n"
"          has_block: [CType::BitField.new(1, 6), 6],\n"
"          ambiguous_param0: [CType::BitField.new(1, 7), 7],\n"
"          accepts_no_kwarg: [CType::BitField.new(1, 0), 8],\n"
"          ruby2_keywords: [CType::BitField.new(1, 1), 9],\n"
,
#line 1135 "rjit_c.rb"
"        ), Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, flags)\")],\n"
"        size: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, size)\")],\n"
"        lead_num: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, lead_num)\")],\n"
,
#line 1138 "rjit_c.rb"
"        opt_num: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, opt_num)\")],\n"
"        rest_start: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, rest_start)\")],\n"
"        post_start: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, post_start)\")],\n"
,
#line 1141 "rjit_c.rb"
"        post_num: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, post_num)\")],\n"
"        block_start: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, block_start)\")],\n"
"        opt_table: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, opt_table)\")],\n"
,
#line 1144 "rjit_c.rb"
"        keyword: [CType::Pointer.new { self.rb_iseq_param_keyword }, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->param, keyword)\")],\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), param)\")],\n"
"      location: [self.rb_iseq_location_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), location)\")],\n"
"      insns_info: [self.iseq_insn_info, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), insns_info)\")],\n"
,
#line 1148 "rjit_c.rb"
"      local_table: [CType::Pointer.new { self.ID }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), local_table)\")],\n"
"      catch_table: [CType::Pointer.new { self.iseq_catch_table }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), catch_table)\")],\n"
"      parent_iseq: [CType::Pointer.new { self.rb_iseq_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), parent_iseq)\")],\n"
,
#line 1151 "rjit_c.rb"
"      local_iseq: [CType::Pointer.new { self.rb_iseq_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), local_iseq)\")],\n"
"      is_entries: [CType::Pointer.new { self.iseq_inline_storage_entry }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), is_entries)\")],\n"
"      call_data: [CType::Pointer.new { self.rb_call_data }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), call_data)\")],\n"
"      variable: [CType::Struct.new(\n"
,
#line 1155 "rjit_c.rb"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_iseq_constant_body *)NULL)->variable)\"),\n"
"        flip_count: [self.rb_snum_t, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->variable, flip_count)\")],\n"
"        script_lines: [self.VALUE, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->variable, script_lines)\")],\n"
"        coverage: [self.VALUE, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->variable, coverage)\")],\n"
,
#line 1159 "rjit_c.rb"
"        pc2branchindex: [self.VALUE, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->variable, pc2branchindex)\")],\n"
"        original_iseq: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_constant_body *)NULL)->variable, original_iseq)\")],\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), variable)\")],\n"
,
#line 1162 "rjit_c.rb"
"      local_table_size: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), local_table_size)\")],\n"
"      ic_size: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), ic_size)\")],\n"
"      ise_size: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), ise_size)\")],\n"
,
#line 1165 "rjit_c.rb"
"      ivc_size: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), ivc_size)\")],\n"
"      icvarc_size: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), icvarc_size)\")],\n"
"      ci_size: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), ci_size)\")],\n"
,
#line 1168 "rjit_c.rb"
"      stack_max: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), stack_max)\")],\n"
"      builtin_attrs: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), builtin_attrs)\")],\n"
"      mark_bits: [CType::Union.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_iseq_constant_body *)NULL)->mark_bits)\"),\n"
"        list: CType::Pointer.new { self.iseq_bits_t },\n"
,
#line 1173 "rjit_c.rb"
"        single: self.iseq_bits_t,\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), mark_bits)\")],\n"
"      outer_variables: [CType::Pointer.new { self.rb_id_table }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), outer_variables)\")],\n"
"      mandatory_only_iseq: [CType::Pointer.new { self.rb_iseq_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), mandatory_only_iseq)\")],\n"
,
#line 1177 "rjit_c.rb"
"      jit_entry: [self.rb_jit_func_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), jit_entry)\")],\n"
"      jit_entry_calls: [CType::Immediate.parse(\"unsigned long\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), jit_entry_calls)\")],\n"
"      rjit_blocks: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_constant_body *)NULL)), rjit_blocks)\"), true],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_iseq_location_t\n"
"    @rb_iseq_location_t ||= CType::Struct.new(\n"
,
#line 1185 "rjit_c.rb"
"      \"rb_iseq_location_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_iseq_location_struct)\"),\n"
"      pathobj: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_location_struct *)NULL)), pathobj)\"), true],\n"
"      base_label: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_location_struct *)NULL)), base_label)\"), true],\n"
"      label: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_location_struct *)NULL)), label)\"), true],\n"
,
#line 1189 "rjit_c.rb"
"      first_lineno: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_location_struct *)NULL)), first_lineno)\")],\n"
"      node_id: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_location_struct *)NULL)), node_id)\")],\n"
"      code_location: [self.rb_code_location_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_location_struct *)NULL)), code_location)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_iseq_param_keyword\n"
"    @rb_iseq_param_keyword ||= CType::Struct.new(\n"
,
#line 1197 "rjit_c.rb"
"      \"rb_iseq_param_keyword\", Primitive.cexpr!(\"SIZEOF(struct rb_iseq_param_keyword)\"),\n"
"      num: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_param_keyword *)NULL)), num)\")],\n"
"      required_num: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_param_keyword *)NULL)), required_num)\")],\n"
"      bits_start: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_param_keyword *)NULL)), bits_start)\")],\n"
,
#line 1201 "rjit_c.rb"
"      rest_start: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_param_keyword *)NULL)), rest_start)\")],\n"
"      table: [CType::Pointer.new { self.ID }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_param_keyword *)NULL)), table)\")],\n"
"      default_values: [CType::Pointer.new { self.VALUE }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_param_keyword *)NULL)), default_values)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_iseq_struct\n"
"    @rb_iseq_struct ||= CType::Struct.new(\n"
,
#line 1209 "rjit_c.rb"
"      \"rb_iseq_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_iseq_struct)\"),\n"
"      flags: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_struct *)NULL)), flags)\")],\n"
"      wrapper: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_struct *)NULL)), wrapper)\")],\n"
"      body: [CType::Pointer.new { self.rb_iseq_constant_body }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_struct *)NULL)), body)\")],\n"
"      aux: [CType::Union.new(\n"
,
#line 1214 "rjit_c.rb"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_iseq_struct *)NULL)->aux)\"),\n"
"        compile_data: CType::Pointer.new { self.iseq_compile_data },\n"
"        loader: CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_iseq_struct *)NULL)->aux.loader)\"),\n"
"          obj: [self.VALUE, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_struct *)NULL)->aux.loader, obj)\")],\n"
,
#line 1219 "rjit_c.rb"
"          index: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_struct *)NULL)->aux.loader, index)\")],\n"
"        ),\n"
"        exec: CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_iseq_struct *)NULL)->aux.exec)\"),\n"
"          local_hooks: [CType::Pointer.new { self.rb_hook_list_struct }, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_struct *)NULL)->aux.exec, local_hooks)\")],\n"
,
#line 1224 "rjit_c.rb"
"          global_trace_events: [self.rb_event_flag_t, Primitive.cexpr!(\"OFFSETOF(((struct rb_iseq_struct *)NULL)->aux.exec, global_trace_events)\")],\n"
"        ),\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_iseq_struct *)NULL)), aux)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_iseq_t\n"
"    @rb_iseq_t ||= self.rb_iseq_struct\n"
"  end\n"
"\n"
"  def C.rb_jit_func_t\n"
"    @rb_jit_func_t ||= CType::Immediate.parse(\"void *\")\n"
"  end\n"
"\n"
"  def C.rb_method_attr_t\n"
"    @rb_method_attr_t ||= CType::Struct.new(\n"
,
#line 1240 "rjit_c.rb"
"      \"rb_method_attr_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_method_attr_struct)\"),\n"
"      id: [self.ID, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_attr_struct *)NULL)), id)\")],\n"
"      location: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_attr_struct *)NULL)), location)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_method_bmethod_t\n"
"    @rb_method_bmethod_t ||= CType::Struct.new(\n"
"      \"rb_method_bmethod_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_method_bmethod_struct)\"),\n"
,
#line 1249 "rjit_c.rb"
"      proc: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_bmethod_struct *)NULL)), proc)\")],\n"
"      hooks: [CType::Pointer.new { self.rb_hook_list_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_bmethod_struct *)NULL)), hooks)\")],\n"
"      defined_ractor: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_bmethod_struct *)NULL)), defined_ractor)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_method_cfunc_t\n"
"    @rb_method_cfunc_t ||= CType::Struct.new(\n"
,
#line 1257 "rjit_c.rb"
"      \"rb_method_cfunc_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_method_cfunc_struct)\"),\n"
"      func: [CType::Immediate.parse(\"void *\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_cfunc_struct *)NULL)), func)\")],\n"
"      invoker: [CType::Immediate.parse(\"void *\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_cfunc_struct *)NULL)), invoker)\")],\n"
"      argc: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_cfunc_struct *)NULL)), argc)\")],\n"
"    )\n"
"  end\n"
"\n"
,
#line 1264 "rjit_c.rb"
"  def C.rb_method_definition_struct\n"
"    @rb_method_definition_struct ||= CType::Struct.new(\n"
"      \"rb_method_definition_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_method_definition_struct)\"),\n"
"      type: [CType::BitField.new(4, 0), 0],\n"
"      iseq_overload: [CType::BitField.new(1, 4), 4],\n"
"      no_redef_warning: [CType::BitField.new(1, 5), 5],\n"
"      aliased: [CType::BitField.new(1, 6), 6],\n"
"      reference_count: [CType::BitField.new(28, 0), 32],\n"
"      body: [CType::Union.new(\n"
,
#line 1273 "rjit_c.rb"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_method_definition_struct *)NULL)->body)\"),\n"
"        iseq: self.rb_method_iseq_t,\n"
"        cfunc: self.rb_method_cfunc_t,\n"
"        attr: self.rb_method_attr_t,\n"
"        alias: self.rb_method_alias_t,\n"
"        refined: self.rb_method_refined_t,\n"
"        bmethod: self.rb_method_bmethod_t,\n"
"        optimized: self.rb_method_optimized_t,\n"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_definition_struct *)NULL)), body)\")],\n"
,
#line 1282 "rjit_c.rb"
"      original_id: [self.ID, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_definition_struct *)NULL)), original_id)\")],\n"
"      method_serial: [CType::Immediate.parse(\"uintptr_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_definition_struct *)NULL)), method_serial)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_method_entry_t\n"
"    @rb_method_entry_t ||= CType::Struct.new(\n"
"      \"rb_method_entry_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_method_entry_struct)\"),\n"
,
#line 1290 "rjit_c.rb"
"      flags: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_entry_struct *)NULL)), flags)\")],\n"
"      defined_class: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_entry_struct *)NULL)), defined_class)\")],\n"
"      def: [CType::Pointer.new { self.rb_method_definition_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_entry_struct *)NULL)), def)\")],\n"
"      called_id: [self.ID, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_entry_struct *)NULL)), called_id)\")],\n"
,
#line 1294 "rjit_c.rb"
"      owner: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_entry_struct *)NULL)), owner)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_method_iseq_t\n"
"    @rb_method_iseq_t ||= CType::Struct.new(\n"
"      \"rb_method_iseq_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_method_iseq_struct)\"),\n"
"      iseqptr: [CType::Pointer.new { self.rb_iseq_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_iseq_struct *)NULL)), iseqptr)\")],\n"
,
#line 1302 "rjit_c.rb"
"      cref: [CType::Pointer.new { self.rb_cref_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_iseq_struct *)NULL)), cref)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_method_optimized_t\n"
"    @rb_method_optimized_t ||= CType::Struct.new(\n"
"      \"rb_method_optimized\", Primitive.cexpr!(\"SIZEOF(struct rb_method_optimized)\"),\n"
"      type: [self.method_optimized_type, Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_optimized *)NULL)), type)\")],\n"
,
#line 1310 "rjit_c.rb"
"      index: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_method_optimized *)NULL)), index)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_method_type_t\n"
"    @rb_method_type_t ||= CType::Immediate.parse(\"int\")\n"
"  end\n"
"\n"
"  def C.rb_proc_t\n"
"    @rb_proc_t ||= CType::Struct.new(\n"
"      \"\", Primitive.cexpr!(\"SIZEOF(rb_proc_t)\"),\n"
"      block: [self.rb_block, Primitive.cexpr!(\"OFFSETOF((*((rb_proc_t *)NULL)), block)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_rjit_options\n"
,
#line 1326 "rjit_c.rb"
"    @rb_rjit_options ||= CType::Struct.new(\n"
"      \"rb_rjit_options\", Primitive.cexpr!(\"SIZEOF(struct rb_rjit_options)\"),\n"
"      on: [self._Bool, Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_options *)NULL)), on)\")],\n"
"      exec_mem_size: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_options *)NULL)), exec_mem_size)\")],\n"
"      call_threshold: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_options *)NULL)), call_threshold)\")],\n"
,
#line 1331 "rjit_c.rb"
"      stats: [self._Bool, Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_options *)NULL)), stats)\")],\n"
"      disable: [self._Bool, Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_options *)NULL)), disable)\")],\n"
"      trace: [self._Bool, Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_options *)NULL)), trace)\")],\n"
"      trace_exits: [self._Bool, Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_options *)NULL)), trace_exits)\")],\n"
,
#line 1335 "rjit_c.rb"
"      dump_disasm: [self._Bool, Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_options *)NULL)), dump_disasm)\")],\n"
"      verify_ctx: [self._Bool, Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_options *)NULL)), verify_ctx)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_rjit_runtime_counters\n"
"    @rb_rjit_runtime_counters ||= CType::Struct.new(\n"
"      \"rb_rjit_runtime_counters\", Primitive.cexpr!(\"SIZEOF(struct rb_rjit_runtime_counters)\"),\n"
,
#line 1343 "rjit_c.rb"
"      rjit_insns_count: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), rjit_insns_count)\")],\n"
"      send_args_splat_kw_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_args_splat_kw_splat)\")],\n"
"      send_args_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_args_splat)\")],\n"
,
#line 1346 "rjit_c.rb"
"      send_args_splat_not_array: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_args_splat_not_array)\")],\n"
"      send_args_splat_length_not_equal: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_args_splat_length_not_equal)\")],\n"
,
#line 1348 "rjit_c.rb"
"      send_args_splat_cfunc_var_args: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_args_splat_cfunc_var_args)\")],\n"
"      send_args_splat_arity_error: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_args_splat_arity_error)\")],\n"
,
#line 1350 "rjit_c.rb"
"      send_args_splat_ruby2_hash: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_args_splat_ruby2_hash)\")],\n"
"      send_args_splat_cfunc_zuper: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_args_splat_cfunc_zuper)\")],\n"
,
#line 1352 "rjit_c.rb"
"      send_args_splat_cfunc_ruby2_keywords: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_args_splat_cfunc_ruby2_keywords)\")],\n"
"      send_kw_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_kw_splat)\")],\n"
"      send_kwarg: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_kwarg)\")],\n"
,
#line 1355 "rjit_c.rb"
"      send_klass_megamorphic: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_klass_megamorphic)\")],\n"
"      send_missing_cme: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_missing_cme)\")],\n"
"      send_private: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_private)\")],\n"
,
#line 1358 "rjit_c.rb"
"      send_protected_check_failed: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_protected_check_failed)\")],\n"
"      send_tailcall: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_tailcall)\")],\n"
"      send_notimplemented: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_notimplemented)\")],\n"
,
#line 1361 "rjit_c.rb"
"      send_missing: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_missing)\")],\n"
"      send_bmethod: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_bmethod)\")],\n"
"      send_alias: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_alias)\")],\n"
,
#line 1364 "rjit_c.rb"
"      send_undef: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_undef)\")],\n"
"      send_zsuper: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_zsuper)\")],\n"
"      send_refined: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_refined)\")],\n"
,
#line 1367 "rjit_c.rb"
"      send_stackoverflow: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_stackoverflow)\")],\n"
"      send_arity: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_arity)\")],\n"
"      send_c_tracing: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_c_tracing)\")],\n"
,
#line 1370 "rjit_c.rb"
"      send_is_a_class_mismatch: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_is_a_class_mismatch)\")],\n"
"      send_instance_of_class_mismatch: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_instance_of_class_mismatch)\")],\n"
"      send_keywords: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_keywords)\")],\n"
,
#line 1373 "rjit_c.rb"
"      send_blockiseq: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_blockiseq)\")],\n"
"      send_block_handler: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_block_handler)\")],\n"
"      send_block_setup: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_block_setup)\")],\n"
,
#line 1376 "rjit_c.rb"
"      send_block_not_nil: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_block_not_nil)\")],\n"
"      send_block_not_proxy: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_block_not_proxy)\")],\n"
"      send_block_arg: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_block_arg)\")],\n"
,
#line 1379 "rjit_c.rb"
"      send_iseq_kwparam: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_kwparam)\")],\n"
"      send_iseq_accepts_no_kwarg: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_accepts_no_kwarg)\")],\n"
"      send_iseq_has_opt: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_has_opt)\")],\n"
,
#line 1382 "rjit_c.rb"
"      send_iseq_has_kwrest: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_has_kwrest)\")],\n"
"      send_iseq_ruby2_keywords: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_ruby2_keywords)\")],\n"
,
#line 1384 "rjit_c.rb"
"      send_iseq_has_rest_and_captured: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_has_rest_and_captured)\")],\n"
"      send_iseq_has_rest_and_kw_supplied: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_has_rest_and_kw_supplied)\")],\n"
,
#line 1386 "rjit_c.rb"
"      send_iseq_has_no_kw: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_has_no_kw)\")],\n"
"      send_iseq_zsuper: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_zsuper)\")],\n"
"      send_iseq_materialized_block: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_materialized_block)\")],\n"
,
#line 1389 "rjit_c.rb"
"      send_iseq_has_rest: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_has_rest)\")],\n"
"      send_iseq_block_arg0_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_block_arg0_splat)\")],\n"
"      send_iseq_kw_call: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_kw_call)\")],\n"
,
#line 1392 "rjit_c.rb"
"      send_iseq_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_splat)\")],\n"
"      send_iseq_has_rest_and_optional: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_has_rest_and_optional)\")],\n"
"      send_iseq_arity_error: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_arity_error)\")],\n"
,
#line 1395 "rjit_c.rb"
"      send_iseq_missing_optional_kw: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_missing_optional_kw)\")],\n"
"      send_iseq_too_many_kwargs: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_too_many_kwargs)\")],\n"
,
#line 1397 "rjit_c.rb"
"      send_iseq_kwargs_mismatch: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_kwargs_mismatch)\")],\n"
"      send_iseq_splat_with_kw: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_splat_with_kw)\")],\n"
,
#line 1399 "rjit_c.rb"
"      send_iseq_splat_arity_error: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_splat_arity_error)\")],\n"
"      send_iseq_has_rest_and_splat_not_equal: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_iseq_has_rest_and_splat_not_equal)\")],\n"
,
#line 1401 "rjit_c.rb"
"      send_cfunc_variadic: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_cfunc_variadic)\")],\n"
"      send_cfunc_too_many_args: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_cfunc_too_many_args)\")],\n"
"      send_cfunc_ruby_array_varg: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_cfunc_ruby_array_varg)\")],\n"
,
#line 1404 "rjit_c.rb"
"      send_cfunc_splat_with_kw: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_cfunc_splat_with_kw)\")],\n"
"      send_cfunc_tracing: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_cfunc_tracing)\")],\n"
"      send_cfunc_argc_mismatch: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_cfunc_argc_mismatch)\")],\n"
,
#line 1407 "rjit_c.rb"
"      send_cfunc_toomany_args: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_cfunc_toomany_args)\")],\n"
"      send_attrset_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_attrset_splat)\")],\n"
"      send_attrset_kwarg: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_attrset_kwarg)\")],\n"
,
#line 1410 "rjit_c.rb"
"      send_attrset_method: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_attrset_method)\")],\n"
"      send_ivar_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_ivar_splat)\")],\n"
"      send_ivar_opt_send: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_ivar_opt_send)\")],\n"
,
#line 1413 "rjit_c.rb"
"      send_optimized_send_no_args: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_send_no_args)\")],\n"
"      send_optimized_send_not_sym_or_str: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_send_not_sym_or_str)\")],\n"
,
#line 1415 "rjit_c.rb"
"      send_optimized_send_mid_class_changed: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_send_mid_class_changed)\")],\n"
"      send_optimized_send_mid_id_changed: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_send_mid_id_changed)\")],\n"
,
#line 1417 "rjit_c.rb"
"      send_optimized_send_null_mid: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_send_null_mid)\")],\n"
"      send_optimized_send_send: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_send_send)\")],\n"
,
#line 1419 "rjit_c.rb"
"      send_optimized_call_block: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_call_block)\")],\n"
"      send_optimized_call_kwarg: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_call_kwarg)\")],\n"
,
#line 1421 "rjit_c.rb"
"      send_optimized_call_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_call_splat)\")],\n"
"      send_optimized_struct_aref_error: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_struct_aref_error)\")],\n"
,
#line 1423 "rjit_c.rb"
"      send_optimized_block_call: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_block_call)\")],\n"
"      send_optimized_struct_aset: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_optimized_struct_aset)\")],\n"
,
#line 1425 "rjit_c.rb"
"      send_bmethod_not_iseq: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_bmethod_not_iseq)\")],\n"
"      send_bmethod_blockarg: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), send_bmethod_blockarg)\")],\n"
"      invokesuper_me_changed: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokesuper_me_changed)\")],\n"
,
#line 1428 "rjit_c.rb"
"      invokesuper_block: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokesuper_block)\")],\n"
"      invokeblock_none: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_none)\")],\n"
"      invokeblock_symbol: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_symbol)\")],\n"
,
#line 1431 "rjit_c.rb"
"      invokeblock_proc: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_proc)\")],\n"
"      invokeblock_tag_changed: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_tag_changed)\")],\n"
"      invokeblock_iseq_block_changed: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_iseq_block_changed)\")],\n"
,
#line 1434 "rjit_c.rb"
"      invokeblock_iseq_arity: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_iseq_arity)\")],\n"
"      invokeblock_iseq_arg0_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_iseq_arg0_splat)\")],\n"
,
#line 1436 "rjit_c.rb"
"      invokeblock_ifunc_args_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_ifunc_args_splat)\")],\n"
"      invokeblock_ifunc_kw_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_ifunc_kw_splat)\")],\n"
,
#line 1438 "rjit_c.rb"
"      invokeblock_iseq_arg0_args_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_iseq_arg0_args_splat)\")],\n"
"      invokeblock_iseq_arg0_has_kw: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), invokeblock_iseq_arg0_has_kw)\")],\n"
,
#line 1440 "rjit_c.rb"
"      getivar_megamorphic: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), getivar_megamorphic)\")],\n"
"      getivar_not_heap: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), getivar_not_heap)\")],\n"
"      getivar_special_const: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), getivar_special_const)\")],\n"
,
#line 1443 "rjit_c.rb"
"      getivar_too_complex: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), getivar_too_complex)\")],\n"
"      optaref_arg_not_fixnum: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), optaref_arg_not_fixnum)\")],\n"
"      optaref_argc_not_one: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), optaref_argc_not_one)\")],\n"
,
#line 1446 "rjit_c.rb"
"      optaref_recv_not_array: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), optaref_recv_not_array)\")],\n"
"      optaref_recv_not_hash: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), optaref_recv_not_hash)\")],\n"
"      optaref_send: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), optaref_send)\")],\n"
,
#line 1449 "rjit_c.rb"
"      optgetconst_not_cached: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), optgetconst_not_cached)\")],\n"
"      optgetconst_cref: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), optgetconst_cref)\")],\n"
"      optgetconst_cache_miss: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), optgetconst_cache_miss)\")],\n"
,
#line 1452 "rjit_c.rb"
"      setivar_frozen: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), setivar_frozen)\")],\n"
"      setivar_not_heap: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), setivar_not_heap)\")],\n"
"      setivar_megamorphic: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), setivar_megamorphic)\")],\n"
,
#line 1455 "rjit_c.rb"
"      setivar_too_complex: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), setivar_too_complex)\")],\n"
"      expandarray_splat: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), expandarray_splat)\")],\n"
"      expandarray_postarg: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), expandarray_postarg)\")],\n"
,
#line 1458 "rjit_c.rb"
"      expandarray_not_array: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), expandarray_not_array)\")],\n"
"      expandarray_rhs_too_small: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), expandarray_rhs_too_small)\")],\n"
,
#line 1460 "rjit_c.rb"
"      getblockpp_block_param_modified: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), getblockpp_block_param_modified)\")],\n"
"      getblockpp_block_handler_none: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), getblockpp_block_handler_none)\")],\n"
,
#line 1462 "rjit_c.rb"
"      getblockpp_not_gc_guarded: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), getblockpp_not_gc_guarded)\")],\n"
"      getblockpp_not_iseq_block: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), getblockpp_not_iseq_block)\")],\n"
"      compiled_block_count: [CType::Immediate.parse(\"size_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_rjit_runtime_counters *)NULL)), compiled_block_count)\")],\n"
,
#line 1465 "rjit_c.rb"
"    )\n"
"  end\n"
"\n"
"  def C.rb_serial_t\n"
"    @rb_serial_t ||= CType::Immediate.parse(\"unsigned long long\")\n"
"  end\n"
"\n"
"  def C.rb_shape\n"
"    @rb_shape ||= CType::Struct.new(\n"
"      \"rb_shape\", Primitive.cexpr!(\"SIZEOF(struct rb_shape)\"),\n"
"      edges: [CType::Pointer.new { self.rb_id_table }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_shape *)NULL)), edges)\")],\n"
"      edge_name: [self.ID, Primitive.cexpr!(\"OFFSETOF((*((struct rb_shape *)NULL)), edge_name)\")],\n"
,
#line 1477 "rjit_c.rb"
"      next_iv_index: [self.attr_index_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_shape *)NULL)), next_iv_index)\")],\n"
"      capacity: [CType::Immediate.parse(\"uint32_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_shape *)NULL)), capacity)\")],\n"
"      type: [CType::Immediate.parse(\"uint8_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_shape *)NULL)), type)\")],\n"
"      size_pool_index: [CType::Immediate.parse(\"uint8_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_shape *)NULL)), size_pool_index)\")],\n"
,
#line 1481 "rjit_c.rb"
"      parent_id: [self.shape_id_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_shape *)NULL)), parent_id)\")],\n"
"      ancestor_index: [CType::Pointer.new { self.redblack_node_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_shape *)NULL)), ancestor_index)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.rb_shape_t\n"
"    @rb_shape_t ||= self.rb_shape\n"
"  end\n"
"\n"
"  def C.rb_thread_struct\n"
"    @rb_thread_struct ||= CType::Struct.new(\n"
"      \"rb_thread_struct\", Primitive.cexpr!(\"SIZEOF(struct rb_thread_struct)\"),\n"
,
#line 1493 "rjit_c.rb"
"      lt_node: [self.ccan_list_node, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), lt_node)\")],\n"
"      self: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), self)\")],\n"
"      ractor: [CType::Pointer.new { self.rb_ractor_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), ractor)\")],\n"
"      vm: [CType::Pointer.new { self.rb_vm_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), vm)\")],\n"
,
#line 1497 "rjit_c.rb"
"      nt: [CType::Pointer.new { self.rb_native_thread }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), nt)\")],\n"
"      ec: [CType::Pointer.new { self.rb_execution_context_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), ec)\")],\n"
"      sched: [self.rb_thread_sched_item, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), sched)\")],\n"
"      serial: [self.rb_atomic_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), serial)\")],\n"
,
#line 1501 "rjit_c.rb"
"      last_status: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), last_status)\")],\n"
"      calling: [CType::Pointer.new { self.rb_calling_info }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), calling)\")],\n"
"      top_self: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), top_self)\")],\n"
"      top_wrapper: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), top_wrapper)\")],\n"
,
#line 1505 "rjit_c.rb"
"      priority: [CType::Immediate.parse(\"int8_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), priority)\")],\n"
"      running_time_us: [CType::Immediate.parse(\"uint32_t\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), running_time_us)\")],\n"
"      blocking_region_buffer: [CType::Pointer.new { CType::Immediate.parse(\"void\") }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), blocking_region_buffer)\")],\n"
,
#line 1508 "rjit_c.rb"
"      thgroup: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), thgroup)\")],\n"
"      value: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), value)\")],\n"
"      pending_interrupt_queue: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), pending_interrupt_queue)\")],\n"
"      pending_interrupt_mask_stack: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), pending_interrupt_mask_stack)\")],\n"
,
#line 1512 "rjit_c.rb"
"      interrupt_lock: [self.rb_nativethread_lock_t, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), interrupt_lock)\")],\n"
"      unblock: [self.rb_unblock_callback, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), unblock)\")],\n"
"      locking_mutex: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), locking_mutex)\")],\n"
,
#line 1515 "rjit_c.rb"
"      keeping_mutexes: [CType::Pointer.new { self.rb_mutex_struct }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), keeping_mutexes)\")],\n"
"      join_list: [CType::Pointer.new { self.rb_waiting_list }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), join_list)\")],\n"
"      invoke_arg: [CType::Union.new(\n"
"        \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_thread_struct *)NULL)->invoke_arg)\"),\n"
"        proc: CType::Struct.new(\n"
,
#line 1520 "rjit_c.rb"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_thread_struct *)NULL)->invoke_arg.proc)\"),\n"
"          proc: [self.VALUE, Primitive.cexpr!(\"OFFSETOF(((struct rb_thread_struct *)NULL)->invoke_arg.proc, proc)\")],\n"
"          args: [self.VALUE, Primitive.cexpr!(\"OFFSETOF(((struct rb_thread_struct *)NULL)->invoke_arg.proc, args)\")],\n"
"          kw_splat: [CType::Immediate.parse(\"int\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_thread_struct *)NULL)->invoke_arg.proc, kw_splat)\")],\n"
"        ),\n"
,
#line 1525 "rjit_c.rb"
"        func: CType::Struct.new(\n"
"          \"\", Primitive.cexpr!(\"SIZEOF(((struct rb_thread_struct *)NULL)->invoke_arg.func)\"),\n"
"          func: [CType::Immediate.parse(\"void *\"), Primitive.cexpr!(\"OFFSETOF(((struct rb_thread_struct *)NULL)->invoke_arg.func, func)\")],\n"
"          arg: [CType::Pointer.new { CType::Immediate.parse(\"void\") }, Primitive.cexpr!(\"OFFSETOF(((struct rb_thread_struct *)NULL)->invoke_arg.func, arg)\")],\n"
"        ),\n"
,
#line 1530 "rjit_c.rb"
"      ), Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), invoke_arg)\")],\n"
"      invoke_type: [self.thread_invoke_type, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), invoke_type)\")],\n"
"      stat_insn_usage: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), stat_insn_usage)\")],\n"
"      root_fiber: [CType::Pointer.new { self.rb_fiber_t }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), root_fiber)\")],\n"
,
#line 1534 "rjit_c.rb"
"      scheduler: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), scheduler)\")],\n"
"      blocking: [CType::Immediate.parse(\"unsigned int\"), Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), blocking)\")],\n"
"      name: [self.VALUE, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), name)\")],\n"
,
#line 1537 "rjit_c.rb"
"      specific_storage: [CType::Pointer.new { CType::Pointer.new { CType::Immediate.parse(\"void\") } }, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), specific_storage)\")],\n"
"      ext_config: [self.rb_ext_config, Primitive.cexpr!(\"OFFSETOF((*((struct rb_thread_struct *)NULL)), ext_config)\")],\n"
"    )\n"
"  end\n"
"\n"
"  def C.VALUE\n"
"    @VALUE ||= CType::Immediate.find(Primitive.cexpr!(\"SIZEOF(VALUE)\"), Primitive.cexpr!(\"SIGNED_TYPE_P(VALUE)\"))\n"
"  end\n"
"\n"
"  def C.shape_id_t\n"
,
#line 1547 "rjit_c.rb"
"    @shape_id_t ||= CType::Immediate.find(Primitive.cexpr!(\"SIZEOF(shape_id_t)\"), Primitive.cexpr!(\"SIGNED_TYPE_P(shape_id_t)\"))\n"
"  end\n"
"\n"
"  def C.rb_id_table\n"
"    CType::Stub.new(:rb_id_table)\n"
"  end\n"
"\n"
"  def C.vm_call_handler\n"
"    CType::Stub.new(:vm_call_handler)\n"
"  end\n"
"\n"
"  def C.method_missing_reason\n"
"    CType::Stub.new(:method_missing_reason)\n"
"  end\n"
"\n"
"  def C.vm_ifunc\n"
"    CType::Stub.new(:vm_ifunc)\n"
"  end\n"
"\n"
"  def C.rb_cref_struct\n"
"    CType::Stub.new(:rb_cref_struct)\n"
"  end\n"
"\n"
"  def C.rb_scope_visibility_t\n"
,
#line 1571 "rjit_c.rb"
"    CType::Stub.new(:rb_scope_visibility_t)\n"
"  end\n"
"\n"
"  def C.rb_vm_tag\n"
"    CType::Stub.new(:rb_vm_tag)\n"
"  end\n"
"\n"
"  def C.rb_atomic_t\n"
"    CType::Stub.new(:rb_atomic_t)\n"
"  end\n"
"\n"
"  def C.rb_fiber_t\n"
"    CType::Stub.new(:rb_fiber_t)\n"
"  end\n"
"\n"
"  def C.rb_ensure_list_t\n"
"    CType::Stub.new(:rb_ensure_list_t)\n"
"  end\n"
"\n"
"  def C.rb_trace_arg_struct\n"
"    CType::Stub.new(:rb_trace_arg_struct)\n"
"  end\n"
"\n"
"  def C.rb_iseq_type\n"
"    CType::Stub.new(:rb_iseq_type)\n"
"  end\n"
"\n"
"  def C.iseq_insn_info\n"
"    CType::Stub.new(:iseq_insn_info)\n"
"  end\n"
"\n"
,
#line 1602 "rjit_c.rb"
"  def C.iseq_catch_table\n"
"    CType::Stub.new(:iseq_catch_table)\n"
"  end\n"
"\n"
"  def C.rb_snum_t\n"
"    CType::Stub.new(:rb_snum_t)\n"
"  end\n"
"\n"
"  def C.iseq_bits_t\n"
"    CType::Stub.new(:iseq_bits_t)\n"
"  end\n"
"\n"
"  def C.rb_code_location_t\n"
"    CType::Stub.new(:rb_code_location_t)\n"
"  end\n"
"\n"
"  def C.iseq_compile_data\n"
"    CType::Stub.new(:iseq_compile_data)\n"
"  end\n"
"\n"
"  def C.rb_hook_list_struct\n"
"    CType::Stub.new(:rb_hook_list_struct)\n"
"  end\n"
"\n"
"  def C.rb_event_flag_t\n"
"    CType::Stub.new(:rb_event_flag_t)\n"
"  end\n"
"\n"
,
#line 1630 "rjit_c.rb"
"  def C.rb_method_alias_t\n"
"    CType::Stub.new(:rb_method_alias_t)\n"
"  end\n"
"\n"
"  def C.rb_method_refined_t\n"
"    CType::Stub.new(:rb_method_refined_t)\n"
"  end\n"
"\n"
"  def C._Bool\n"
"    CType::Bool.new\n"
"  end\n"
"\n"
"  def C.redblack_node_t\n"
"    CType::Stub.new(:redblack_node_t)\n"
"  end\n"
"\n"
"  def C.ccan_list_node\n"
"    CType::Stub.new(:ccan_list_node)\n"
"  end\n"
"\n"
"  def C.rb_ractor_t\n"
"    CType::Stub.new(:rb_ractor_t)\n"
"  end\n"
"\n"
"  def C.rb_vm_t\n"
"    CType::Stub.new(:rb_vm_t)\n"
"  end\n"
"\n"
"  def C.rb_native_thread\n"
"    CType::Stub.new(:rb_native_thread)\n"
,
#line 1660 "rjit_c.rb"
"  end\n"
"\n"
"  def C.rb_thread_sched_item\n"
"    CType::Stub.new(:rb_thread_sched_item)\n"
"  end\n"
"\n"
"  def C.rb_calling_info\n"
"    CType::Stub.new(:rb_calling_info)\n"
"  end\n"
"\n"
"  def C.rb_nativethread_lock_t\n"
"    CType::Stub.new(:rb_nativethread_lock_t)\n"
"  end\n"
"\n"
"  def C.rb_unblock_callback\n"
"    CType::Stub.new(:rb_unblock_callback)\n"
"  end\n"
"\n"
"  def C.rb_mutex_struct\n"
"    CType::Stub.new(:rb_mutex_struct)\n"
"  end\n"
"\n"
"  def C.rb_waiting_list\n"
"    CType::Stub.new(:rb_waiting_list)\n"
"  end\n"
"\n"
"  def C.thread_invoke_type\n"
,
#line 1687 "rjit_c.rb"
"    CType::Stub.new(:thread_invoke_type)\n"
"  end\n"
"\n"
"  def C.rb_ext_config\n"
"    CType::Stub.new(:rb_ext_config)\n"
"  end\n"
"\n"
"\n"/* # RJIT bindgen end ### */
"end if Primitive.rjit_enabled_p\n"
#line 4122 "miniprelude.c"
};

static const char prelude_name8[] = "<internal:pack>";
static const struct {
    char L0[273]; /* 1..32 */
} prelude_code8 = {
#line 1 "pack.rb"
"class Array\n"
"\n"/*  call-seq: */
"\n"/*    pack(template, buffer: nil) -> string */
"\n"/*  */
"\n"/*  Formats each element in +self+ into a binary string; returns that string. */
"\n"/*  See {Packed Data}[rdoc-ref:packed_data.rdoc]. */
"  def pack(fmt, buffer: nil)\n"
"    Primitive.pack_pack(fmt, buffer)\n"
"  end\n"
"end\n"
"\n"
"class String\n"
"\n"/* call-seq: */
"\n"/*   unpack(template, offset: 0) -> array */
"\n"/*  */
"\n"/*  Extracts data from +self+, forming objects that become the elements of a new array; */
"\n"/*  returns that array. */
"\n"/*  See {Packed Data}[rdoc-ref:packed_data.rdoc]. */
"  def unpack(fmt, offset: 0)\n"
"    Primitive.pack_unpack(fmt, offset)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   unpack1(template, offset: 0) -> object */
"\n"/*  */
"\n"/*  Like String#unpack, but unpacks and returns only the first extracted object. */
"\n"/*  See {Packed Data}[rdoc-ref:packed_data.rdoc]. */
"  def unpack1(fmt, offset: 0)\n"
"    Primitive.pack_unpack1(fmt, offset)\n"
"  end\n"
"end\n"
#line 4161 "miniprelude.c"
};

static const char prelude_name9[] = "<internal:trace_point>";
static const struct {
    char L0[508]; /* 1..237 */
    char L237[506]; /* 238..327 */
    char L327[495]; /* 328..401 */
    char L401[215]; /* 402..419 */
} prelude_code9 = {
#line 1 "trace_point.rb"
""/* loaded from vm_trace.c */
""
""/* A class that provides the functionality of Kernel#set_trace_func in a */
""/* nice Object-Oriented API. */
""/*  */
""/* == Example */
""/*  */
""/* We can use TracePoint to gather information specifically for exceptions: */
""/*  */
""/*     trace = TracePoint.new(:raise) do |tp| */
""/* \tp [tp.lineno, tp.event, tp.raised_exception] */
""/*     end */
""/*     #=> #<TracePoint:disabled> */
""/*  */
""/*     trace.enable */
""/*     #=> false */
""/*  */
""/*     0 / 0 */
""/*     #=> [5, :raise, #<ZeroDivisionError: divided by 0>] */
""/*  */
""/* == Events */
""/*  */
""/* If you don't specify the type of events you want to listen for, */
""/* TracePoint will include all available events. */
""/*  */
""/* *Note* do not depend on current event set, as this list is subject to */
""/* change. Instead, it is recommended you specify the type of events you */
""/* want to use. */
""/*  */
""/* To filter what is traced, you can pass any of the following as +events+: */
""/*  */
""/* +:line+:: execute an expression or statement on a new line */
""/* +:class+:: start a class or module definition */
""/* +:end+:: finish a class or module definition */
""/* +:call+:: call a Ruby method */
""/* +:return+:: return from a Ruby method */
""/* +:c_call+:: call a C-language routine */
""/* +:c_return+:: return from a C-language routine */
""/* +:raise+:: raise an exception */
""/* +:rescue+:: rescue an exception */
""/* +:b_call+:: event hook at block entry */
""/* +:b_return+:: event hook at block ending */
""/* +:a_call+:: event hook at all calls (+call+, +b_call+, and +c_call+) */
""/* +:a_return+:: event hook at all returns (+return+, +b_return+, and +c_return+) */
""/* +:thread_begin+:: event hook at thread beginning */
""/* +:thread_end+:: event hook at thread ending */
""/* +:fiber_switch+:: event hook at fiber switch */
""/* +:script_compiled+:: new Ruby code compiled (with +eval+, +load+ or +require+) */
""/*  */
"class TracePoint\n"
"\n"/* call-seq: */
"\n"/* TracePoint.new(*events) { |obj| block }\t    -> obj */
"\n"/*  */
"\n"/* Returns a new TracePoint object, not enabled by default. */
"\n"/*  */
"\n"/* Next, in order to activate the trace, you must use TracePoint#enable */
"\n"/*  */
"\n"/* trace = TracePoint.new(:call) do |tp| */
"\n"/*     p [tp.lineno, tp.defined_class, tp.method_id, tp.event] */
"\n"/* end */
"\n"/* #=> #<TracePoint:disabled> */
"\n"/*  */
"\n"/* trace.enable */
"\n"/* #=> false */
"\n"/*  */
"\n"/* puts \"Hello, TracePoint!\" */
"\n"/* # ... */
"\n"/* # [48, IRB::Notifier::AbstractNotifier, :printf, :call] */
"\n"/* # ... */
"\n"/*  */
"\n"/* When you want to deactivate the trace, you must use TracePoint#disable */
"\n"/*  */
"\n"/* trace.disable */
"\n"/*  */
"\n"/* See TracePoint@Events for possible events and more information. */
"\n"/*  */
"\n"/* A block must be given, otherwise an ArgumentError is raised. */
"\n"/*  */
"\n"/* If the trace method isn't included in the given events filter, a */
"\n"/* RuntimeError is raised. */
"\n"/*  */
"\n"/* TracePoint.trace(:line) do |tp| */
"\n"/*     p tp.raised_exception */
"\n"/* end */
"\n"/* #=> RuntimeError: 'raised_exception' not supported by this event */
"\n"/*  */
"\n"/* If the trace method is called outside block, a RuntimeError is raised. */
"\n"/*  */
"\n"/*      TracePoint.trace(:line) do |tp| */
"\n"/*        $tp = tp */
"\n"/*      end */
"\n"/*      $tp.lineno #=> access from outside (RuntimeError) */
"\n"/*  */
"\n"/* Access from other threads is also forbidden. */
"\n"/*  */
"  def self.new(*events)\n"
"    Primitive.tracepoint_new_s(events)\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    trace.inspect  -> string */
"\n"/*  */
"\n"/*  Return a string containing a human-readable TracePoint */
"\n"/*  status. */
"  def inspect\n"
"    Primitive.tracepoint_inspect\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/* TracePoint.stat -> obj */
"\n"/*  */
"\n"/*  Returns internal information of TracePoint. */
"\n"/*  */
"\n"/*  The contents of the returned value are implementation specific. */
"\n"/*  It may be changed in future. */
"\n"/*  */
"\n"/*  This method is only for debugging TracePoint itself. */
"  def self.stat\n"
"    Primitive.tracepoint_stat_s\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    TracePoint.trace(*events) { |obj| block }\t-> obj */
"\n"/*  */
"\n"/* A convenience method for TracePoint.new, that activates the trace */
"\n"/* automatically. */
"\n"/*  */
"\n"/*     trace = TracePoint.trace(:call) { |tp| [tp.lineno, tp.event] } */
"\n"/*     #=> #<TracePoint:enabled> */
"\n"/*  */
"\n"/*     trace.enabled? #=> true */
"\n"/*  */
"  def self.trace(*events)\n"
"    Primitive.tracepoint_trace_s(events)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   TracePoint.allow_reentry { block } */
"\n"/*  */
"\n"/* In general, while a TracePoint callback is running, */
"\n"/* other registered callbacks are not called to avoid */
"\n"/* confusion by reentrance. */
"\n"/* This method allows the reentrance in a given block. */
"\n"/* This method should be used carefully, otherwise the callback */
"\n"/* can be easily called infinitely. */
"\n"/*  */
"\n"/* If this method is called when the reentrance is already allowed, */
"\n"/* it raises a RuntimeError. */
"\n"/*  */
"\n"/* <b>Example:</b> */
"\n"/*  */
"\n"/*   # Without reentry */
"\n"/*   # --------------- */
"\n"/*  */
"\n"/*   line_handler = TracePoint.new(:line) do |tp| */
"\n"/*     next if tp.path != __FILE__ # only work in this file */
"\n"/*     puts \"Line handler\" */
"\n"/*     binding.eval(\"class C; end\") */
"\n"/*   end.enable */
"\n"/*  */
"\n"/*   class_handler = TracePoint.new(:class) do |tp| */
"\n"/*     puts \"Class handler\" */
"\n"/*   end.enable */
"\n"/*  */
"\n"/*   class B */
"\n"/*   end */
"\n"/*  */
"\n"/*   # This script will print \"Class handler\" only once: when inside :line */
"\n"/*   # handler, all other handlers are ignored */
"\n"/*  */
"\n"/*  */
"\n"/*   # With reentry */
"\n"/*   # ------------ */
"\n"/*  */
"\n"/*   line_handler = TracePoint.new(:line) do |tp| */
"\n"/*     next if tp.path != __FILE__ # only work in this file */
"\n"/*     next if (__LINE__..__LINE__+3).cover?(tp.lineno) # don't be invoked from itself */
"\n"/*     puts \"Line handler\" */
"\n"/*     TracePoint.allow_reentry { binding.eval(\"class C; end\") } */
"\n"/*   end.enable */
"\n"/*  */
"\n"/*   class_handler = TracePoint.new(:class) do |tp| */
"\n"/*     puts \"Class handler\" */
"\n"/*   end.enable */
"\n"/*  */
"\n"/*   class B */
"\n"/*   end */
"\n"/*  */
"\n"/*   # This wil print \"Class handler\" twice: inside allow_reentry block in :line */
"\n"/*   # handler, other handlers are enabled. */
"\n"/*  */
"\n"/* Note that the example shows the principal effect of the method, but its */
"\n"/* practical usage is for debugging libraries that sometimes require other libraries */
"\n"/* hooks to not be affected by debugger being inside trace point handling. Precautions */
"\n"/* should be taken against infinite recursion in this case (note that we needed to filter */
"\n"/* out calls by itself from :line handler, otherwise it will call itself infinitely). */
"\n"/*  */
"  def self.allow_reentry\n"
"    Primitive.tracepoint_allow_reentry\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    trace.enable(target: nil, target_line: nil, target_thread: nil)    -> true or false */
"\n"/*    trace.enable(target: nil, target_line: nil, target_thread: :default) { block }  -> obj */
"\n"/*  */
"\n"/* Activates the trace. */
"\n"/*  */
"\n"/* Returns +true+ if trace was enabled. */
"\n"/* Returns +false+ if trace was disabled. */
"\n"/*  */
"\n"/*   trace.enabled?  #=> false */
"\n"/*   trace.enable    #=> false (previous state) */
"\n"/*                   #   trace is enabled */
"\n"/*   trace.enabled?  #=> true */
"\n"/*   trace.enable    #=> true (previous state) */
"\n"/*                   #   trace is still enabled */
"\n"/*  */
"\n"/* If a block is given, the trace will only be enabled during the block call. */
"\n"/* If target and target_line are both nil, then target_thread will default */
"\n"/* to the current thread if a block is given. */
"\n"/*  */
"\n"/*    trace.enabled? */
"\n"/*    #=> false */
"\n"/*  */
"\n"/*    trace.enable do */
"\n"/*      trace.enabled? */
"\n"/*      # only enabled for this block and thread */
"\n"/*    end */
"\n"/*  */
"\n"/*    trace.enabled? */
"\n"/*    #=> false */
"\n"/*  */
"\n"/* +target+, +target_line+ and +target_thread+ parameters are used to */
"\n"/* limit tracing only to specified code objects. +target+ should be a */
"\n"/* code object for which RubyVM::InstructionSequence.of will return */
"\n"/* an instruction sequence. */
"\n"/*  */
,
#line 238 "trace_point.rb"
"\n"/*    t = TracePoint.new(:line) { |tp| p tp } */
"\n"/*  */
"\n"/*    def m1 */
"\n"/*      p 1 */
"\n"/*    end */
"\n"/*  */
"\n"/*    def m2 */
"\n"/*      p 2 */
"\n"/*    end */
"\n"/*  */
"\n"/*    t.enable(target: method(:m1)) */
"\n"/*  */
"\n"/*    m1 */
"\n"/*    # prints #<TracePoint:line test.rb:4 in `m1'> */
"\n"/*    m2 */
"\n"/*    # prints nothing */
"\n"/*  */
"\n"/* Note: You cannot access event hooks within the +enable+ block. */
"\n"/*  */
"\n"/*    trace.enable { p tp.lineno } */
"\n"/*    #=> RuntimeError: access from outside */
"\n"/*  */
"  def enable(target: nil, target_line: nil, target_thread: :default)\n"
"    Primitive.tracepoint_enable_m(target, target_line, target_thread)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/* trace.disable\t\t-> true or false */
"\n"/* trace.disable { block } -> obj */
"\n"/*  */
"\n"/* Deactivates the trace */
"\n"/*  */
"\n"/* Return true if trace was enabled. */
"\n"/* Return false if trace was disabled. */
"\n"/*  */
"\n"/* trace.enabled?\t#=> true */
"\n"/* trace.disable\t#=> true (previous status) */
"\n"/* trace.enabled?\t#=> false */
"\n"/* trace.disable\t#=> false */
"\n"/*  */
"\n"/* If a block is given, the trace will only be disable within the scope of the */
"\n"/* block. */
"\n"/*  */
"\n"/* trace.enabled? */
"\n"/* #=> true */
"\n"/*  */
"\n"/* trace.disable do */
"\n"/*     trace.enabled? */
"\n"/*     # only disabled for this block */
"\n"/* end */
"\n"/*  */
"\n"/* trace.enabled? */
"\n"/* #=> true */
"\n"/*  */
"\n"/* Note: You cannot access event hooks within the block. */
"\n"/*  */
"\n"/* trace.disable { p tp.lineno } */
"\n"/* #=> RuntimeError: access from outside */
"  def disable\n"
"    Primitive.tracepoint_disable_m\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/* trace.enabled?\t    -> true or false */
"\n"/*  */
"\n"/* The current status of the trace */
"  def enabled?\n"
"    Primitive.tracepoint_enabled_p\n"
"  end\n"
"\n"
"\n"/* Type of event */
"\n"/*  */
"\n"/* See TracePoint@Events for more information. */
"  def event\n"
"    Primitive.tracepoint_attr_event\n"
"  end\n"
"\n"
"\n"/* Line number of the event */
"  def lineno\n"
"    Primitive.tracepoint_attr_lineno\n"
"  end\n"
"\n"
"\n"/* Path of the file being run */
"  def path\n"
"    Primitive.tracepoint_attr_path\n"
"  end\n"
"\n"
"\n"/* Return the parameters definition of the method or block that the */
"\n"/* current hook belongs to. Format is the same as for Method#parameters */
"  def parameters\n"
,
#line 328 "trace_point.rb"
"    Primitive.tracepoint_attr_parameters\n"
"  end\n"
"\n"
"\n"/* Return the name at the definition of the method being called */
"  def method_id\n"
"    Primitive.tracepoint_attr_method_id\n"
"  end\n"
"\n"
"\n"/* Return the called name of the method being called */
"  def callee_id\n"
"    Primitive.tracepoint_attr_callee_id\n"
"  end\n"
"\n"
"\n"/* Return class or module of the method being called. */
"\n"/*  */
"\n"/* class C; def foo; end; end */
"\n"/* \ttrace = TracePoint.new(:call) do |tp| */
"\n"/* \t  p tp.defined_class #=> C */
"\n"/* \tend.enable do */
"\n"/* \t  C.new.foo */
"\n"/* \tend */
"\n"/*  */
"\n"/* If method is defined by a module, then that module is returned. */
"\n"/*  */
"\n"/* module M; def foo; end; end */
"\n"/* \tclass C; include M; end; */
"\n"/* \ttrace = TracePoint.new(:call) do |tp| */
"\n"/* \t  p tp.defined_class #=> M */
"\n"/* \tend.enable do */
"\n"/* \t  C.new.foo */
"\n"/* \tend */
"\n"/*  */
"\n"/* <b>Note:</b> #defined_class returns singleton class. */
"\n"/*  */
"\n"/* 6th block parameter of Kernel#set_trace_func passes original class */
"\n"/* of attached by singleton class. */
"\n"/*  */
"\n"/* <b>This is a difference between Kernel#set_trace_func and TracePoint.</b> */
"\n"/*  */
"\n"/* class C; def self.foo; end; end */
"\n"/* \ttrace = TracePoint.new(:call) do |tp| */
"\n"/* \t  p tp.defined_class #=> #<Class:C> */
"\n"/* \tend.enable do */
"\n"/* \t  C.foo */
"\n"/* \tend */
"  def defined_class\n"
"    Primitive.tracepoint_attr_defined_class\n"
"  end\n"
"\n"
"\n"/* Return the generated binding object from event. */
"\n"/*  */
"\n"/* Note that for +:c_call+ and +:c_return+ events, the method will return */
"\n"/* +nil+, since C methods themselves do not have bindings. */
"  def binding\n"
"    Primitive.tracepoint_attr_binding\n"
"  end\n"
"\n"
"\n"/* Return the trace object during event */
"\n"/*  */
"\n"/* Same as the following, except it returns the correct object (the method */
"\n"/* receiver) for +:c_call+ and +:c_return+ events: */
"\n"/*  */
"\n"/*   trace.binding.eval('self') */
"  def self\n"
"    Primitive.tracepoint_attr_self\n"
"  end\n"
"\n"
"\n"/*  Return value from +:return+, +:c_return+, and +:b_return+ event */
"  def return_value\n"
"    Primitive.tracepoint_attr_return_value\n"
"  end\n"
"\n"
"\n"/* Value from exception raised on the +:raise+ event, or rescued on the +:rescue+ event. */
"  def raised_exception\n"
,
#line 402 "trace_point.rb"
"    Primitive.tracepoint_attr_raised_exception\n"
"  end\n"
"\n"
"\n"/* Compiled source code (String) on *eval methods on the +:script_compiled+ event. */
"\n"/* If loaded from a file, it will return nil. */
"  def eval_script\n"
"    Primitive.tracepoint_attr_eval_script\n"
"  end\n"
"\n"
"\n"/* Compiled instruction sequence represented by a RubyVM::InstructionSequence instance */
"\n"/* on the +:script_compiled+ event. */
"\n"/*  */
"\n"/* Note that this method is MRI specific. */
"  def instruction_sequence\n"
"    Primitive.tracepoint_attr_instruction_sequence\n"
"  end\n"
"end\n"
#line 4596 "miniprelude.c"
};

static const char prelude_name10[] = "<internal:warning>";
static const struct {
    char L0[182]; /* 1..54 */
} prelude_code10 = {
#line 1 "warning.rb"
""/* encoding: utf-8 */
""/* frozen-string-literal: true */
""
"module Kernel\n"
"  module_function\n"
"\n"
"\n"/* call-seq: */
"\n"/*    warn(*msgs, uplevel: nil, category: nil)   -> nil */
"\n"/*  */
"\n"/* If warnings have been disabled (for example with the */
"\n"/* <code>-W0</code> flag), does nothing.  Otherwise, */
"\n"/* converts each of the messages to strings, appends a newline */
"\n"/* character to the string if the string does not end in a newline, */
"\n"/* and calls Warning.warn with the string. */
"\n"/*  */
"\n"/*    warn(\"warning 1\", \"warning 2\") */
"\n"/*  */
"\n"/* <em>produces:</em> */
"\n"/*  */
"\n"/*    warning 1 */
"\n"/*    warning 2 */
"\n"/*  */
"\n"/* If the <code>uplevel</code> keyword argument is given, the string will */
"\n"/* be prepended with information for the given caller frame in */
"\n"/* the same format used by the <code>rb_warn</code> C function. */
"\n"/*  */
"\n"/*    # In baz.rb */
"\n"/*    def foo */
"\n"/*      warn(\"invalid call to foo\", uplevel: 1) */
"\n"/*    end */
"\n"/*  */
"\n"/*    def bar */
"\n"/*      foo */
"\n"/*    end */
"\n"/*  */
"\n"/*    bar */
"\n"/*  */
"\n"/* <em>produces:</em> */
"\n"/*  */
"\n"/*    baz.rb:6: warning: invalid call to foo */
"\n"/*  */
"\n"/* If <code>category</code> keyword argument is given, passes the category */
"\n"/* to <code>Warning.warn</code>.  The category given must be be one of the */
"\n"/* following categories: */
"\n"/*  */
"\n"/* :deprecated :: Used for warning for deprecated functionality that may */
"\n"/*                be removed in the future. */
"\n"/* :experimental :: Used for experimental features that may change in */
"\n"/*                  future releases. */
"  def warn(*msgs, uplevel: nil, category: nil)\n"
"    Primitive.rb_warn_m(msgs, uplevel, category)\n"
"  end\n"
"end\n"
#line 4657 "miniprelude.c"
};

static const char prelude_name11[] = "<internal:array>";
static const struct {
    char L0[493]; /* 1..102 */
    char L102[478]; /* 103..150 */
    char L150[175]; /* 151..158 */
} prelude_code11 = {
#line 1 "array.rb"
"class Array\n"
"\n"/* call-seq: */
"\n"/*    array.shuffle!(random: Random) -> array */
"\n"/*  */
"\n"/* Shuffles the elements of +self+ in place. */
"\n"/*    a = [1, 2, 3] #=> [1, 2, 3] */
"\n"/*    a.shuffle!    #=> [2, 3, 1] */
"\n"/*    a             #=> [2, 3, 1] */
"\n"/*  */
"\n"/* The optional +random+ argument will be used as the random number generator: */
"\n"/*    a.shuffle!(random: Random.new(1))  #=> [1, 3, 2] */
"  def shuffle!(random: Random)\n"
"    Primitive.rb_ary_shuffle_bang(random)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    array.shuffle(random: Random) -> new_ary */
"\n"/*  */
"\n"/* Returns a new array with elements of +self+ shuffled. */
"\n"/*    a = [1, 2, 3] #=> [1, 2, 3] */
"\n"/*    a.shuffle     #=> [2, 3, 1] */
"\n"/*    a             #=> [1, 2, 3] */
"\n"/*  */
"\n"/* The optional +random+ argument will be used as the random number generator: */
"\n"/*    a.shuffle(random: Random.new(1))  #=> [1, 3, 2] */
"  def shuffle(random: Random)\n"
"    Primitive.rb_ary_shuffle(random)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    array.sample(random: Random) -> object */
"\n"/*    array.sample(n, random: Random) -> new_ary */
"\n"/*  */
"\n"/* Returns random elements from +self+. */
"\n"/*  */
"\n"/* When no arguments are given, returns a random element from +self+: */
"\n"/*    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] */
"\n"/*    a.sample # => 3 */
"\n"/*    a.sample # => 8 */
"\n"/* If +self+ is empty, returns +nil+. */
"\n"/*  */
"\n"/* When argument +n+ is given, returns a new \\Array containing +n+ random */
"\n"/* elements from +self+: */
"\n"/*    a.sample(3) # => [8, 9, 2] */
"\n"/*    a.sample(6) # => [9, 6, 10, 3, 1, 4] */
"\n"/* Returns no more than <tt>a.size</tt> elements */
"\n"/* (because no new duplicates are introduced): */
"\n"/*    a.sample(a.size * 2) # => [6, 4, 1, 8, 5, 9, 10, 2, 3, 7] */
"\n"/* But +self+ may contain duplicates: */
"\n"/*    a = [1, 1, 1, 2, 2, 3] */
"\n"/*    a.sample(a.size * 2) # => [1, 1, 3, 2, 1, 2] */
"\n"/* The argument +n+ must be a non-negative numeric value. */
"\n"/* The order of the result array is unrelated to the order of +self+. */
"\n"/* Returns a new empty \\Array if +self+ is empty. */
"\n"/*  */
"\n"/* The optional +random+ argument will be used as the random number generator: */
"\n"/*    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] */
"\n"/*    a.sample(random: Random.new(1))     #=> 6 */
"\n"/*    a.sample(4, random: Random.new(1))  #=> [6, 10, 9, 2] */
"  def sample(n = (ary = false), random: Random)\n"
"    if Primitive.mandatory_only?\n"
"\n"/* Primitive.cexpr! %{ rb_ary_sample(self, rb_cRandom, Qfalse, Qfalse) } */
"      Primitive.ary_sample0\n"
"    else\n"
"\n"/* Primitive.cexpr! %{ rb_ary_sample(self, random, n, ary) } */
"      Primitive.ary_sample(random, n, ary)\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   array.first -> object or nil */
"\n"/*   array.first(n) -> new_array */
"\n"/*  */
"\n"/* Returns elements from +self+; does not modify +self+. */
"\n"/*  */
"\n"/* When no argument is given, returns the first element: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.first # => :foo */
"\n"/*   a # => [:foo, \"bar\", 2] */
"\n"/*  */
"\n"/* If +self+ is empty, returns +nil+. */
"\n"/*  */
"\n"/* When non-negative Integer argument +n+ is given, */
"\n"/* returns the first +n+ elements in a new \\Array: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.first(2) # => [:foo, \"bar\"] */
"\n"/*  */
"\n"/* If <tt>n >= array.size</tt>, returns all elements: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.first(50) # => [:foo, \"bar\", 2] */
"\n"/*  */
"\n"/* If <tt>n == 0</tt> returns an new empty \\Array: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.first(0) # [] */
"\n"/*  */
"\n"/* Related: #last. */
"  def first n = unspecified = true\n"
"    if Primitive.mandatory_only?\n"
,
#line 103 "array.rb"
"      Primitive.attr! :leaf\n"
"      Primitive.cexpr! %q{ ary_first(self) }\n"
"    else\n"
"      if unspecified\n"
"        Primitive.cexpr! %q{ ary_first(self) }\n"
"      else\n"
"        Primitive.cexpr! %q{  ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_FIRST) }\n"
"      end\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   array.last  -> object or nil */
"\n"/*   array.last(n) -> new_array */
"\n"/*  */
"\n"/* Returns elements from +self+; +self+ is not modified. */
"\n"/*  */
"\n"/* When no argument is given, returns the last element: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.last # => 2 */
"\n"/*   a # => [:foo, \"bar\", 2] */
"\n"/*  */
"\n"/* If +self+ is empty, returns +nil+. */
"\n"/*  */
"\n"/* When non-negative Integer argument +n+ is given, */
"\n"/* returns the last +n+ elements in a new \\Array: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.last(2) # => [\"bar\", 2] */
"\n"/*  */
"\n"/* If <tt>n >= array.size</tt>, returns all elements: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.last(50) # => [:foo, \"bar\", 2] */
"\n"/*  */
"\n"/* If <tt>n == 0</tt>, returns an new empty \\Array: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.last(0) # [] */
"\n"/*  */
"\n"/* Related: #first. */
"  def last n = unspecified = true\n"
"    if Primitive.mandatory_only?\n"
"      Primitive.attr! :leaf\n"
"      Primitive.cexpr! %q{ ary_last(self) }\n"
"    else\n"
"      if unspecified\n"
,
#line 151 "array.rb"
"        Primitive.cexpr! %q{ ary_last(self) }\n"
"      else\n"
"        Primitive.cexpr! %q{ ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_LAST) }\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
#line 4828 "miniprelude.c"
};

static const char prelude_name12[] = "<internal:kernel>";
static const struct {
    char L0[446]; /* 1..130 */
    char L130[508]; /* 131..192 */
    char L192[464]; /* 193..313 */
} prelude_code12 = {
#line 1 "kernel.rb"
"module Kernel\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.class    -> class */
"\n"/*  */
"\n"/*  Returns the class of <i>obj</i>. This method must always be called */
"\n"/*  with an explicit receiver, as #class is also a reserved word in */
"\n"/*  Ruby. */
"\n"/*  */
"\n"/*     1.class      #=> Integer */
"\n"/*     self.class   #=> Object */
"\n"/* -- */
"\n"/* Equivalent to \\c Object\\#class in Ruby. */
"\n"/*  */
"\n"/* Returns the class of \\c obj, skipping singleton classes or module inclusions. */
"\n"/* ++ */
"\n"/*  */
"  def class\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_obj_class(self)'\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.clone(freeze: nil) -> an_object */
"\n"/*  */
"\n"/*  Produces a shallow copy of <i>obj</i>---the instance variables of */
"\n"/*  <i>obj</i> are copied, but not the objects they reference. */
"\n"/*  #clone copies the frozen value state of <i>obj</i>, unless the */
"\n"/*  +:freeze+ keyword argument is given with a false or true value. */
"\n"/*  See also the discussion under Object#dup. */
"\n"/*  */
"\n"/*     class Klass */
"\n"/*        attr_accessor :str */
"\n"/*     end */
"\n"/*     s1 = Klass.new      #=> #<Klass:0x401b3a38> */
"\n"/*     s1.str = \"Hello\"    #=> \"Hello\" */
"\n"/*     s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\"> */
"\n"/*     s2.str[1,4] = \"i\"   #=> \"i\" */
"\n"/*     s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\" */
"\n"/*     s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\" */
"\n"/*  */
"\n"/*  This method may have class-specific behavior.  If so, that */
"\n"/*  behavior will be documented under the #+initialize_copy+ method of */
"\n"/*  the class. */
"\n"/*  */
"  def clone(freeze: nil)\n"
"    Primitive.rb_obj_clone2(freeze)\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.frozen?    -> true or false */
"\n"/*  */
"\n"/*  Returns the freeze status of <i>obj</i>. */
"\n"/*  */
"\n"/*     a = [ \"a\", \"b\", \"c\" ] */
"\n"/*     a.freeze    #=> [\"a\", \"b\", \"c\"] */
"\n"/*     a.frozen?   #=> true */
"\n"/* -- */
"\n"/* Determines if the object is frozen. Equivalent to \\c Object\\#frozen? in Ruby. */
"\n"/* \\param[in] obj  the object to be determines */
"\n"/* \\retval Qtrue if frozen */
"\n"/* \\retval Qfalse if not frozen */
"\n"/* ++ */
"\n"/*  */
"  def frozen?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_obj_frozen_p(self)'\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.tap {|x| block }    -> obj */
"\n"/*  */
"\n"/*  Yields self to the block, and then returns self. */
"\n"/*  The primary purpose of this method is to \"tap into\" a method chain, */
"\n"/*  in order to perform operations on intermediate results within the chain. */
"\n"/*  */
"\n"/*     (1..10)                  .tap {|x| puts \"original: \#{x}\" } */
"\n"/*       .to_a                  .tap {|x| puts \"array:    \#{x}\" } */
"\n"/*       .select {|x| x.even? } .tap {|x| puts \"evens:    \#{x}\" } */
"\n"/*       .map {|x| x*x }        .tap {|x| puts \"squares:  \#{x}\" } */
"\n"/*  */
"\n"/* -- */
"\n"/* \\private */
"\n"/* ++ */
"\n"/*  */
"  def tap\n"
"    yield(self)\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.then {|x| block }          -> an_object */
"\n"/*  */
"\n"/*  Yields self to the block and returns the result of the block. */
"\n"/*  */
"\n"/*     3.next.then {|x| x**x }.to_s             #=> \"256\" */
"\n"/*  */
"\n"/*  Good usage for +then+ is value piping in method chains: */
"\n"/*  */
"\n"/*     require 'open-uri' */
"\n"/*     require 'json' */
"\n"/*  */
"\n"/*     construct_url(arguments). */
"\n"/*       then {|url| URI(url).read }. */
"\n"/*       then {|response| JSON.parse(response) } */
"\n"/*  */
"\n"/*  When called without block, the method returns +Enumerator+, */
"\n"/*  which can be used, for example, for conditional */
"\n"/*  circuit-breaking: */
"\n"/*  */
"\n"/*     # meets condition, no-op */
"\n"/*     1.then.detect(&:odd?)            # => 1 */
"\n"/*     # does not meet condition, drop value */
"\n"/*     2.then.detect(&:odd?)            # => nil */
"\n"/*  */
"\n"/*  Good usage for +then+ is value piping in method chains: */
"\n"/*  */
"\n"/*     require 'open-uri' */
"\n"/*     require 'json' */
"\n"/*  */
"\n"/*     construct_url(arguments). */
"\n"/*       then {|url| URI(url).read }. */
"\n"/*       then {|response| JSON.parse(response) } */
"\n"/*  */
"  def then\n"
"    unless block_given?\n"
,
#line 131 "kernel.rb"
"      return Primitive.cexpr! 'SIZED_ENUMERATOR(self, 0, 0, rb_obj_size)'\n"
"    end\n"
"    yield(self)\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.yield_self {|x| block }    -> an_object */
"\n"/*  */
"\n"/*  Yields self to the block and returns the result of the block. */
"\n"/*  */
"\n"/*     \"my string\".yield_self {|s| s.upcase }   #=> \"MY STRING\" */
"\n"/*  */
"  def yield_self\n"
"    unless block_given?\n"
"      return Primitive.cexpr! 'SIZED_ENUMERATOR(self, 0, 0, rb_obj_size)'\n"
"    end\n"
"    yield(self)\n"
"  end\n"
"\n"
"  module_function\n"
"\n"
"\n"/* call-seq: */
"\n"/*    loop { block } */
"\n"/*    loop            -> an_enumerator */
"\n"/*  */
"\n"/* Repeatedly executes the block. */
"\n"/*  */
"\n"/* If no block is given, an enumerator is returned instead. */
"\n"/*  */
"\n"/*    loop do */
"\n"/*      print \"Input: \" */
"\n"/*      line = gets */
"\n"/*      break if !line or line =~ /^q/i */
"\n"/*      # ... */
"\n"/*    end */
"\n"/*  */
"\n"/* StopIteration raised in the block breaks the loop.  In this case, */
"\n"/* loop returns the \"result\" value stored in the exception. */
"\n"/*  */
"\n"/*    enum = Enumerator.new { |y| */
"\n"/*      y << \"one\" */
"\n"/*      y << \"two\" */
"\n"/*      :ok */
"\n"/*    } */
"\n"/*  */
"\n"/*    result = loop { */
"\n"/*      puts enum.next */
"\n"/*    } #=> :ok */
"  def loop\n"
"    unless block_given?\n"
"      return enum_for(:loop) { Float::INFINITY }\n"
"    end\n"
"\n"
"    begin\n"
"      while true\n"
"        yield\n"
"      end\n"
"    rescue StopIteration => e\n"
"      e.result\n"
"    end\n"
"  end\n"
,
#line 193 "kernel.rb"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     Float(arg, exception: true)    -> float or nil */
"\n"/*  */
"\n"/*  Returns <i>arg</i> converted to a float. Numeric types are */
"\n"/*  converted directly, and with exception to String and */
"\n"/*  <code>nil</code> the rest are converted using */
"\n"/*  <i>arg</i><code>.to_f</code>.  Converting a String with invalid */
"\n"/*  characters will result in a ArgumentError.  Converting */
"\n"/*  <code>nil</code> generates a TypeError.  Exceptions can be */
"\n"/*  suppressed by passing <code>exception: false</code>. */
"\n"/*  */
"\n"/*     Float(1)                 #=> 1.0 */
"\n"/*     Float(\"123.456\")         #=> 123.456 */
"\n"/*     Float(\"123.0_badstring\") #=> ArgumentError: invalid value for Float(): \"123.0_badstring\" */
"\n"/*     Float(nil)               #=> TypeError: can't convert nil into Float */
"\n"/*     Float(\"123.0_badstring\", exception: false)  #=> nil */
"\n"/*  */
"  def Float(arg, exception: true)\n"
"    if Primitive.mandatory_only?\n"
"      Primitive.rb_f_float1(arg)\n"
"    else\n"
"      Primitive.rb_f_float(arg, exception)\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Integer(object, base = 0, exception: true) -> integer or nil */
"\n"/*  */
"\n"/* Returns an integer converted from +object+. */
"\n"/*  */
"\n"/* Tries to convert +object+ to an integer */
"\n"/* using +to_int+ first and +to_i+ second; */
"\n"/* see below for exceptions. */
"\n"/*  */
"\n"/* With a non-zero +base+, +object+ must be a string or convertible */
"\n"/* to a string. */
"\n"/*  */
"\n"/* ==== numeric objects */
"\n"/*  */
"\n"/* With integer argument +object+ given, returns +object+: */
"\n"/*  */
"\n"/*   Integer(1)                # => 1 */
"\n"/*   Integer(-1)               # => -1 */
"\n"/*  */
"\n"/* With floating-point argument +object+ given, */
"\n"/* returns +object+ truncated to an integer: */
"\n"/*  */
"\n"/*   Integer(1.9)              # => 1  # Rounds toward zero. */
"\n"/*   Integer(-1.9)             # => -1 # Rounds toward zero. */
"\n"/*  */
"\n"/* ==== string objects */
"\n"/*  */
"\n"/* With string argument +object+ and zero +base+ given, */
"\n"/* returns +object+ converted to an integer in base 10: */
"\n"/*  */
"\n"/*   Integer('100')    # => 100 */
"\n"/*   Integer('-100')   # => -100 */
"\n"/*  */
"\n"/* With +base+ zero, string +object+ may contain leading characters */
"\n"/* to specify the actual base (radix indicator): */
"\n"/*  */
"\n"/*   Integer('0100')  # => 64  # Leading '0' specifies base 8. */
"\n"/*   Integer('0b100') # => 4   # Leading '0b', specifies base 2. */
"\n"/*   Integer('0x100') # => 256 # Leading '0x' specifies base 16. */
"\n"/*  */
"\n"/* With a positive +base+ (in range 2..36) given, returns +object+ */
"\n"/* converted to an integer in the given base: */
"\n"/*  */
"\n"/*   Integer('100', 2)   # => 4 */
"\n"/*   Integer('100', 8)   # => 64 */
"\n"/*   Integer('-100', 16) # => -256 */
"\n"/*  */
"\n"/* With a negative +base+ (in range -36..-2) given, returns +object+ */
"\n"/* converted to an integer in the radix indicator if exists or */
"\n"/* +-base+: */
"\n"/*  */
"\n"/*   Integer('0x100', -2)   # => 256 */
"\n"/*   Integer('100', -2)     # => 4 */
"\n"/*   Integer('0b100', -8)   # => 4 */
"\n"/*   Integer('100', -8)     # => 64 */
"\n"/*   Integer('0o100', -10)  # => 64 */
"\n"/*   Integer('100', -10)    # => 100 */
"\n"/*  */
"\n"/* +base+ -1 is equal the -10 case. */
"\n"/*  */
"\n"/* When converting strings, surrounding whitespace and embedded underscores */
"\n"/* are allowed and ignored: */
"\n"/*  */
"\n"/*   Integer(' 100 ')      # => 100 */
"\n"/*   Integer('-1_0_0', 16) # => -256 */
"\n"/*  */
"\n"/* ==== other classes */
"\n"/*  */
"\n"/* Examples with +object+ of various other classes: */
"\n"/*  */
"\n"/*   Integer(Rational(9, 10)) # => 0  # Rounds toward zero. */
"\n"/*   Integer(Complex(2, 0))   # => 2  # Imaginary part must be zero. */
"\n"/*   Integer(Time.now)        # => 1650974042 */
"\n"/*  */
"\n"/* ==== keywords */
"\n"/*  */
"\n"/* With optional keyword argument +exception+ given as +true+ (the default): */
"\n"/*  */
"\n"/* - Raises TypeError if +object+ does not respond to +to_int+ or +to_i+. */
"\n"/* - Raises TypeError if +object+ is +nil+. */
"\n"/* - Raise ArgumentError if +object+ is an invalid string. */
"\n"/*  */
"\n"/* With +exception+ given as +false+, an exception of any kind is suppressed */
"\n"/* and +nil+ is returned. */
"\n"
"  def Integer(arg, base = 0, exception: true)\n"
"    if Primitive.mandatory_only?\n"
"      Primitive.rb_f_integer1(arg)\n"
"    else\n"
"      Primitive.rb_f_integer(arg, base, exception);\n"
"    end\n"
"  end\n"
"end\n"
#line 5154 "miniprelude.c"
};

static const char prelude_name13[] = "<internal:ractor>";
static const struct {
    char L0[502]; /* 1..281 */
    char L281[503]; /* 282..360 */
    char L360[465]; /* 361..442 */
    char L442[508]; /* 443..620 */
    char L620[503]; /* 621..719 */
    char L719[485]; /* 720..767 */
    char L767[487]; /* 768..838 */
    char L838[230]; /* 839..854 */
} prelude_code13 = {
#line 1 "ractor.rb"
""/* \\Ractor is an Actor-model abstraction for Ruby that provides thread-safe parallel execution. */
""/*  */
""/* Ractor.new makes a new \\Ractor, which can run in parallel. */
""/*  */
""/*     # The simplest ractor */
""/*     r = Ractor.new {puts \"I am in Ractor!\"} */
""/*     r.take # wait for it to finish */
""/*     # Here, \"I am in Ractor!\" is printed */
""/*  */
""/* Ractors do not share all objects with each other. There are two main benefits to this: across ractors, thread-safety */
""/* concerns such as data-races and race-conditions are not possible. The other benefit is parallelism. */
""/*  */
""/* To achieve this, object sharing is limited across ractors. */
""/* For example, unlike in threads, ractors can't access all the objects available in other ractors. Even objects normally */
""/* available through variables in the outer scope are prohibited from being used across ractors. */
""/*  */
""/*     a = 1 */
""/*     r = Ractor.new {puts \"I am in Ractor! a=\#{a}\"} */
""/*     # fails immediately with */
""/*     # ArgumentError (can not isolate a Proc because it accesses outer variables (a).) */
""/*  */
""/* The object must be explicitly shared: */
""/*     a = 1 */
""/*     r = Ractor.new(a) { |a1| puts \"I am in Ractor! a=\#{a1}\"} */
""/*  */
""/* On CRuby (the default implementation), Global Virtual Machine Lock (GVL) is held per ractor, so */
""/* ractors can perform in parallel without locking each other. This is unlike the situation with threads */
""/* on CRuby. */
""/*  */
""/* Instead of accessing shared state, objects should be passed to and from ractors by */
""/* sending and receiving them as messages. */
""/*  */
""/*     a = 1 */
""/*     r = Ractor.new do */
""/*       a_in_ractor = receive # receive blocks until somebody passes a message */
""/*       puts \"I am in Ractor! a=\#{a_in_ractor}\" */
""/*     end */
""/*     r.send(a)  # pass it */
""/*     r.take */
""/*     # Here, \"I am in Ractor! a=1\" is printed */
""/*  */
""/* There are two pairs of methods for sending/receiving messages: */
""/*  */
""/* * Ractor#send and Ractor.receive for when the _sender_ knows the receiver (push); */
""/* * Ractor.yield and Ractor#take for when the _receiver_ knows the sender (pull); */
""/*  */
""/* In addition to that, any arguments passed to Ractor.new are passed to the block and available there */
""/* as if received by Ractor.receive, and the last block value is sent outside of the */
""/* ractor as if sent by Ractor.yield. */
""/*  */
""/* A little demonstration of a classic ping-pong: */
""/*  */
""/*     server = Ractor.new(name: \"server\") do */
""/*       puts \"Server starts: \#{self.inspect}\" */
""/*       puts \"Server sends: ping\" */
""/*       Ractor.yield 'ping'                       # The server doesn't know the receiver and sends to whoever interested */
""/*       received = Ractor.receive                 # The server doesn't know the sender and receives from whoever sent */
""/*       puts \"Server received: \#{received}\" */
""/*     end */
""/*  */
""/*     client = Ractor.new(server) do |srv|        # The server is sent to the client, and available as srv */
""/*       puts \"Client starts: \#{self.inspect}\" */
""/*       received = srv.take                       # The client takes a message from the server */
""/*       puts \"Client received from \" \\ */
""/*            \"\#{srv.inspect}: \#{received}\" */
""/*       puts \"Client sends to \" \\ */
""/*            \"\#{srv.inspect}: pong\" */
""/*       srv.send 'pong'                           # The client sends a message to the server */
""/*     end */
""/*  */
""/*     [client, server].each(&:take)               # Wait until they both finish */
""/*  */
""/* This will output something like: */
""/*  */
""/*     Server starts: #<Ractor:#2 server test.rb:1 running> */
""/*     Server sends: ping */
""/*     Client starts: #<Ractor:#3 test.rb:8 running> */
""/*     Client received from #<Ractor:#2 server test.rb:1 blocking>: ping */
""/*     Client sends to #<Ractor:#2 server test.rb:1 blocking>: pong */
""/*     Server received: pong */
""/*  */
""/* Ractors receive their messages via the <em>incoming port</em>, and send them */
""/* to the <em>outgoing port</em>. Either one can be disabled with Ractor#close_incoming and */
""/* Ractor#close_outgoing, respectively. When a ractor terminates, its ports are closed */
""/* automatically. */
""/*  */
""/* == Shareable and unshareable objects */
""/*  */
""/* When an object is sent to and from a ractor, it's important to understand whether the */
""/* object is shareable or unshareable. Most Ruby objects are unshareable objects. Even */
""/* frozen objects can be unshareable if they contain (through their instance variables) unfrozen */
""/* objects. */
""/*  */
""/* Shareable objects are those which can be used by several threads without compromising */
""/* thread-safety, for example numbers, +true+ and +false+. Ractor.shareable? allows you to check this, */
""/* and Ractor.make_shareable tries to make the object shareable if it's not already, and gives an error */
""/* if it can't do it. */
""/*  */
""/*     Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are shareable */
""/*     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # frozen_string_literal: true */
""/*     Ractor.shareable?('foo'.freeze) #=> true */
""/*     Ractor.shareable?([Object.new].freeze) #=> false, inner object is unfrozen */
""/*  */
""/*     ary = ['hello', 'world'] */
""/*     ary.frozen?                 #=> false */
""/*     ary[0].frozen?              #=> false */
""/*     Ractor.make_shareable(ary) */
""/*     ary.frozen?                 #=> true */
""/*     ary[0].frozen?              #=> true */
""/*     ary[1].frozen?              #=> true */
""/*  */
""/* When a shareable object is sent (via #send or Ractor.yield), no additional processing occurs */
""/* on it. It just becomes usable by both ractors. When an unshareable object is sent, it can be */
""/* either _copied_ or _moved_. The first is the default, and it copies the object fully by */
""/* deep cloning (Object#clone) the non-shareable parts of its structure. */
""/*  */
""/*     data = ['foo', 'bar'.freeze] */
""/*     r = Ractor.new do */
""/*       data2 = Ractor.receive */
""/*       puts \"In ractor: \#{data2.object_id}, \#{data2[0].object_id}, \#{data2[1].object_id}\" */
""/*     end */
""/*     r.send(data) */
""/*     r.take */
""/*     puts \"Outside  : \#{data.object_id}, \#{data[0].object_id}, \#{data[1].object_id}\" */
""/*  */
""/* This will output something like: */
""/*  */
""/*     In ractor: 340, 360, 320 */
""/*     Outside  : 380, 400, 320 */
""/*  */
""/* Note that the object ids of the array and the non-frozen string inside the array have changed in */
""/* the ractor because they are different objects. The second array's element, which is a */
""/* shareable frozen string, is the same object. */
""/*  */
""/* Deep cloning of objects may be slow, and sometimes impossible. Alternatively, <tt>move: true</tt> may */
""/* be used during sending. This will <em>move</em> the unshareable object to the receiving ractor, making it */
""/* inaccessible to the sending ractor. */
""/*  */
""/*     data = ['foo', 'bar'] */
""/*     r = Ractor.new do */
""/*       data_in_ractor = Ractor.receive */
""/*       puts \"In ractor: \#{data_in_ractor.object_id}, \#{data_in_ractor[0].object_id}\" */
""/*     end */
""/*     r.send(data, move: true) */
""/*     r.take */
""/*     puts \"Outside: moved? \#{Ractor::MovedObject === data}\" */
""/*     puts \"Outside: \#{data.inspect}\" */
""/*  */
""/* This will output: */
""/*  */
""/*     In ractor: 100, 120 */
""/*     Outside: moved? true */
""/*     test.rb:9:in `method_missing': can not send any methods to a moved object (Ractor::MovedError) */
""/*  */
""/* Notice that even +inspect+ (and more basic methods like <tt>__id__</tt>) is inaccessible */
""/* on a moved object. */
""/*  */
""/* Class and Module objects are shareable so the class/module definitions are shared between ractors. */
""/* \\Ractor objects are also shareable. All operations on shareable objects are thread-safe, so the thread-safety property */
""/* will be kept. We can not define mutable shareable objects in Ruby, but C extensions can introduce them. */
""/*  */
""/* It is prohibited to access (get) instance variables of shareable objects in other ractors if the values of the */
""/* variables aren't shareable. This can occur because modules/classes are shareable, but they can have */
""/* instance variables whose values are not. In non-main ractors, it's also prohibited to set instance */
""/* variables on classes/modules (even if the value is shareable). */
""/*  */
""/*     class C */
""/*       class << self */
""/*         attr_accessor :tricky */
""/*       end */
""/*     end */
""/*  */
""/*     C.tricky = \"unshareable\".dup */
""/*  */
""/*     r = Ractor.new(C) do |cls| */
""/*       puts \"I see \#{cls}\" */
""/*       puts \"I can't see \#{cls.tricky}\" */
""/*       cls.tricky = true # doesn't get here, but this would also raise an error */
""/*     end */
""/*     r.take */
""/*     # I see C */
""/*     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError) */
""/*  */
""/* Ractors can access constants if they are shareable. The main \\Ractor is the only one that can */
""/* access non-shareable constants. */
""/*  */
""/*     GOOD = 'good'.freeze */
""/*     BAD = 'bad'.dup */
""/*  */
""/*     r = Ractor.new do */
""/*       puts \"GOOD=\#{GOOD}\" */
""/*       puts \"BAD=\#{BAD}\" */
""/*     end */
""/*     r.take */
""/*     # GOOD=good */
""/*     # can not access non-shareable objects in constant Object::BAD by non-main Ractor. (NameError) */
""/*  */
""/*     # Consider the same C class from above */
""/*  */
""/*     r = Ractor.new do */
""/*       puts \"I see \#{C}\" */
""/*       puts \"I can't see \#{C.tricky}\" */
""/*     end */
""/*     r.take */
""/*     # I see C */
""/*     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError) */
""/*  */
""/* See also the description of <tt># shareable_constant_value</tt> pragma in */
""/* {Comments syntax}[rdoc-ref:syntax/comments.rdoc] explanation. */
""/*  */
""/* == Ractors vs threads */
""/*  */
""/* Each ractor has its own main Thread. New threads can be created from inside ractors */
""/* (and, on CRuby, they share the GVL with other threads of this ractor). */
""/*  */
""/*     r = Ractor.new do */
""/*       a = 1 */
""/*       Thread.new {puts \"Thread in ractor: a=\#{a}\"}.join */
""/*     end */
""/*     r.take */
""/*     # Here \"Thread in ractor: a=1\" will be printed */
""/*  */
""/* == Note on code examples */
""/*  */
""/* In the examples below, sometimes we use the following method to wait for ractors that */
""/* are not currently blocked to finish (or to make progress). */
""/*  */
""/*     def wait */
""/*       sleep(0.1) */
""/*     end */
""/*  */
""/* It is **only for demonstration purposes** and shouldn't be used in a real code. */
""/* Most of the time, #take is used to wait for ractors to finish. */
""/*  */
""/* == Reference */
""/*  */
""/* See {Ractor design doc}[rdoc-ref:ractor.md] for more details. */
""/*  */
"class Ractor\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     Ractor.new(*args, name: nil) {|*args| block } -> ractor */
"\n"/*  */
"\n"/* Create a new \\Ractor with args and a block. */
"\n"/*  */
"\n"/* The given block (Proc) will be isolated (can't access any outer variables). +self+ */
"\n"/* inside the block will refer to the current \\Ractor. */
"\n"/*  */
"\n"/*    r = Ractor.new { puts \"Hi, I am \#{self.inspect}\" } */
"\n"/*    r.take */
"\n"/*    # Prints \"Hi, I am #<Ractor:#2 test.rb:1 running>\" */
"\n"/*  */
"\n"/* Any +args+ passed are propagated to the block arguments by the same rules as */
"\n"/* objects sent via #send/Ractor.receive. If an argument in +args+ is not shareable, it */
"\n"/* will be copied (via deep cloning, which might be inefficient). */
"\n"/*  */
"\n"/*    arg = [1, 2, 3] */
"\n"/*    puts \"Passing: \#{arg} (#\#{arg.object_id})\" */
"\n"/*    r = Ractor.new(arg) {|received_arg| */
"\n"/*      puts \"Received: \#{received_arg} (#\#{received_arg.object_id})\" */
"\n"/*    } */
"\n"/*    r.take */
"\n"/*    # Prints: */
"\n"/*    #   Passing: [1, 2, 3] (#280) */
"\n"/*    #   Received: [1, 2, 3] (#300) */
"\n"/*  */
"\n"/* Ractor's +name+ can be set for debugging purposes: */
"\n"/*  */
"\n"/*    r = Ractor.new(name: 'my ractor') {}; r.take */
"\n"/*    p r */
"\n"/*    #=> #<Ractor:#3 my ractor test.rb:1 terminated> */
"\n"/*  */
"  def self.new(*args, name: nil, &block)\n"
"    b = block\n"/* TODO: builtin bug */
"    raise ArgumentError, \"must be called with a block\" unless block\n"
"    if __builtin_cexpr!(\"RBOOL(ruby_single_main_ractor)\")\n"
"      warn(\"Ractor is experimental, and the behavior may change in future versions of Ruby! \" \\\n"
"           \"Also there are many implementation issues.\", uplevel: 0, category: :experimental)\n"
"    end\n"
"    loc = caller_locations(1, 1).first\n"
"    loc = \"#{loc.path}:#{loc.lineno}\"\n"
,
#line 282 "ractor.rb"
"    __builtin_ractor_create(loc, name, args, b)\n"
"  end\n"
"\n"
"\n"/* Returns the currently executing Ractor. */
"\n"/*  */
"\n"/*   Ractor.current #=> #<Ractor:#1 running> */
"  def self.current\n"
"    __builtin_cexpr! %q{\n"
"      rb_ractor_self(rb_ec_ractor_ptr(ec));\n"
"    }\n"
"  end\n"
"\n"
"\n"/* Returns the number of Ractors currently running or blocking (waiting). */
"\n"/*  */
"\n"/*    Ractor.count                   #=> 1 */
"\n"/*    r = Ractor.new(name: 'example') { Ractor.yield(1) } */
"\n"/*    Ractor.count                   #=> 2 (main + example ractor) */
"\n"/*    r.take                         # wait for Ractor.yield(1) */
"\n"/*    r.take                         # wait until r will finish */
"\n"/*    Ractor.count                   #=> 1 */
"  def self.count\n"
"    __builtin_cexpr! %q{\n"
"      ULONG2NUM(GET_VM()->ractor.cnt);\n"
"    }\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    Ractor.select(*ractors, [yield_value:, move: false]) -> [ractor or symbol, obj] */
"\n"/*  */
"\n"/* Wait for any ractor to have something in its outgoing port, read from this ractor, and */
"\n"/* then return that ractor and the object received. */
"\n"/*  */
"\n"/*    r1 = Ractor.new {Ractor.yield 'from 1'} */
"\n"/*    r2 = Ractor.new {Ractor.yield 'from 2'} */
"\n"/*  */
"\n"/*    r, obj = Ractor.select(r1, r2) */
"\n"/*  */
"\n"/*    puts \"received \#{obj.inspect} from \#{r.inspect}\" */
"\n"/*    # Prints: received \"from 1\" from #<Ractor:#2 test.rb:1 running> */
"\n"/*    # But could just as well print \"from r2\" here, either prints could be first. */
"\n"/*  */
"\n"/* If one of the given ractors is the current ractor, and it is selected, +r+ will contain */
"\n"/* the +:receive+ symbol instead of the ractor object. */
"\n"/*  */
"\n"/*    r1 = Ractor.new(Ractor.current) do |main| */
"\n"/*      main.send 'to main' */
"\n"/*      Ractor.yield 'from 1' */
"\n"/*    end */
"\n"/*    r2 = Ractor.new do */
"\n"/*      Ractor.yield 'from 2' */
"\n"/*    end */
"\n"/*  */
"\n"/*    r, obj = Ractor.select(r1, r2, Ractor.current) */
"\n"/*    puts \"received \#{obj.inspect} from \#{r.inspect}\" */
"\n"/*    # Could print: received \"to main\" from :receive */
"\n"/*  */
"\n"/* If +yield_value+ is provided, that value may be yielded if another ractor is calling #take. */
"\n"/* In this case, the pair <tt>[:yield, nil]</tt> is returned: */
"\n"/*  */
"\n"/*    r1 = Ractor.new(Ractor.current) do |main| */
"\n"/*      puts \"Received from main: \#{main.take}\" */
"\n"/*    end */
"\n"/*  */
"\n"/*    puts \"Trying to select\" */
"\n"/*    r, obj = Ractor.select(r1, Ractor.current, yield_value: 123) */
"\n"/*    wait */
"\n"/*    puts \"Received \#{obj.inspect} from \#{r.inspect}\" */
"\n"/*  */
"\n"/* This will print: */
"\n"/*  */
"\n"/*    Trying to select */
"\n"/*    Received from main: 123 */
"\n"/*    Received nil from :yield */
"\n"/*  */
"\n"/* +move+ boolean flag defines whether yielded value will be copied (default) or moved. */
"  def self.select(*ractors, yield_value: yield_unspecified = true, move: false)\n"
"    raise ArgumentError, 'specify at least one ractor or `yield_value`' if yield_unspecified && ractors.empty?\n"
"\n"
,
#line 361 "ractor.rb"
"    if ractors.delete Ractor.current\n"
"      do_receive = true\n"
"    else\n"
"      do_receive = false\n"
"    end\n"
"\n"
"    __builtin_ractor_select_internal ractors, do_receive, !yield_unspecified, yield_value, move\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    Ractor.receive -> msg */
"\n"/*  */
"\n"/* Receive a message from the incoming port of the current ractor (which was */
"\n"/* sent there by #send from another ractor). */
"\n"/*  */
"\n"/*     r = Ractor.new do */
"\n"/*       v1 = Ractor.receive */
"\n"/*       puts \"Received: \#{v1}\" */
"\n"/*     end */
"\n"/*     r.send('message1') */
"\n"/*     r.take */
"\n"/*     # Here will be printed: \"Received: message1\" */
"\n"/*  */
"\n"/* Alternatively, the private instance method +receive+ may be used: */
"\n"/*  */
"\n"/*     r = Ractor.new do */
"\n"/*       v1 = receive */
"\n"/*       puts \"Received: \#{v1}\" */
"\n"/*     end */
"\n"/*     r.send('message1') */
"\n"/*     r.take */
"\n"/*     # This prints: \"Received: message1\" */
"\n"/*  */
"\n"/* The method blocks if the queue is empty. */
"\n"/*  */
"\n"/*     r = Ractor.new do */
"\n"/*       puts \"Before first receive\" */
"\n"/*       v1 = Ractor.receive */
"\n"/*       puts \"Received: \#{v1}\" */
"\n"/*       v2 = Ractor.receive */
"\n"/*       puts \"Received: \#{v2}\" */
"\n"/*     end */
"\n"/*     wait */
"\n"/*     puts \"Still not received\" */
"\n"/*     r.send('message1') */
"\n"/*     wait */
"\n"/*     puts \"Still received only one\" */
"\n"/*     r.send('message2') */
"\n"/*     r.take */
"\n"/*  */
"\n"/* Output: */
"\n"/*  */
"\n"/*     Before first receive */
"\n"/*     Still not received */
"\n"/*     Received: message1 */
"\n"/*     Still received only one */
"\n"/*     Received: message2 */
"\n"/*  */
"\n"/* If close_incoming was called on the ractor, the method raises Ractor::ClosedError */
"\n"/* if there are no more messages in the incoming queue: */
"\n"/*  */
"\n"/*     Ractor.new do */
"\n"/*       close_incoming */
"\n"/*       receive */
"\n"/*     end */
"\n"/*     wait */
"\n"/*     # in `receive': The incoming port is already closed => #<Ractor:#2 test.rb:1 running> (Ractor::ClosedError) */
"\n"/*  */
"  def self.receive\n"
"    __builtin_cexpr! %q{\n"
"      ractor_receive(ec, rb_ec_ractor_ptr(ec))\n"
"    }\n"
"  end\n"
"\n"
"  class << self\n"
"    alias recv receive\n"
"  end\n"
"\n"
"\n"/* same as Ractor.receive */
"  private def receive\n"
"    __builtin_cexpr! %q{\n"
,
#line 443 "ractor.rb"
"      ractor_receive(ec, rb_ec_ractor_ptr(ec))\n"
"    }\n"
"  end\n"
"  alias recv receive\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    Ractor.receive_if {|msg| block } -> msg */
"\n"/*  */
"\n"/* Receive only a specific message. */
"\n"/*  */
"\n"/* Instead of Ractor.receive, Ractor.receive_if can be given a pattern (or any */
"\n"/* filter) in a block and you can choose the messages to accept that are available in */
"\n"/* your ractor's incoming queue. */
"\n"/*  */
"\n"/*     r = Ractor.new do */
"\n"/*       p Ractor.receive_if{|msg| msg.match?(/foo/)} #=> \"foo3\" */
"\n"/*       p Ractor.receive_if{|msg| msg.match?(/bar/)} #=> \"bar1\" */
"\n"/*       p Ractor.receive_if{|msg| msg.match?(/baz/)} #=> \"baz2\" */
"\n"/*     end */
"\n"/*     r << \"bar1\" */
"\n"/*     r << \"baz2\" */
"\n"/*     r << \"foo3\" */
"\n"/*     r.take */
"\n"/*  */
"\n"/* This will output: */
"\n"/*  */
"\n"/*     foo3 */
"\n"/*     bar1 */
"\n"/*     baz2 */
"\n"/*  */
"\n"/* If the block returns a truthy value, the message is removed from the incoming queue */
"\n"/* and returned. */
"\n"/* Otherwise, the message remains in the incoming queue and the next messages are checked */
"\n"/* by the given block. */
"\n"/*  */
"\n"/* If there are no messages left in the incoming queue, the method will */
"\n"/* block until new messages arrive. */
"\n"/*  */
"\n"/* If the block is escaped by break/return/exception/throw, the message is removed from */
"\n"/* the incoming queue as if a truthy value had been returned. */
"\n"/*  */
"\n"/*     r = Ractor.new do */
"\n"/*       val = Ractor.receive_if{|msg| msg.is_a?(Array)} */
"\n"/*       puts \"Received successfully: \#{val}\" */
"\n"/*     end */
"\n"/*  */
"\n"/*     r.send(1) */
"\n"/*     r.send('test') */
"\n"/*     wait */
"\n"/*     puts \"2 non-matching sent, nothing received\" */
"\n"/*     r.send([1, 2, 3]) */
"\n"/*     wait */
"\n"/*  */
"\n"/* Prints: */
"\n"/*  */
"\n"/*     2 non-matching sent, nothing received */
"\n"/*     Received successfully: [1, 2, 3] */
"\n"/*  */
"\n"/* Note that you can not call receive/receive_if in the given block recursively. */
"\n"/* You should not do any tasks in the block other than message filtration. */
"\n"/*  */
"\n"/*     Ractor.current << true */
"\n"/*     Ractor.receive_if{|msg| Ractor.receive} */
"\n"/*     #=> `receive': can not call receive/receive_if recursively (Ractor::Error) */
"\n"/*  */
"  def self.receive_if &b\n"
"    Primitive.ractor_receive_if b\n"
"  end\n"
"\n"
"\n"/* same as Ractor.receive_if */
"  private def receive_if &b\n"
"    Primitive.ractor_receive_if b\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    ractor.send(msg, move: false) -> self */
"\n"/*  */
"\n"/* Send a message to a Ractor's incoming queue to be accepted by Ractor.receive. */
"\n"/*  */
"\n"/*   r = Ractor.new do */
"\n"/*     value = Ractor.receive */
"\n"/*     puts \"Received \#{value}\" */
"\n"/*   end */
"\n"/*   r.send 'message' */
"\n"/*   # Prints: \"Received: message\" */
"\n"/*  */
"\n"/* The method is non-blocking (will return immediately even if the ractor is not ready */
"\n"/* to receive anything): */
"\n"/*  */
"\n"/*    r = Ractor.new {sleep(5)} */
"\n"/*    r.send('test') */
"\n"/*    puts \"Sent successfully\" */
"\n"/*    # Prints: \"Sent successfully\" immediately */
"\n"/*  */
"\n"/* An attempt to send to a ractor which already finished its execution will raise Ractor::ClosedError. */
"\n"/*  */
"\n"/*   r = Ractor.new {} */
"\n"/*   r.take */
"\n"/*   p r */
"\n"/*   # \"#<Ractor:#6 (irb):23 terminated>\" */
"\n"/*   r.send('test') */
"\n"/*   # Ractor::ClosedError (The incoming-port is already closed) */
"\n"/*  */
"\n"/* If close_incoming was called on the ractor, the method also raises Ractor::ClosedError. */
"\n"/*  */
"\n"/*    r =  Ractor.new do */
"\n"/*      sleep(500) */
"\n"/*      receive */
"\n"/*    end */
"\n"/*    r.close_incoming */
"\n"/*    r.send('test') */
"\n"/*    # Ractor::ClosedError (The incoming-port is already closed) */
"\n"/*    # The error is raised immediately, not when the ractor tries to receive */
"\n"/*  */
"\n"/* If the +obj+ is unshareable, by default it will be copied into the receiving ractor by deep cloning. */
"\n"/* If <tt>move: true</tt> is passed, the object is _moved_ into the receiving ractor and becomes */
"\n"/* inaccessible to the sender. */
"\n"/*  */
"\n"/*    r = Ractor.new {puts \"Received: \#{receive}\"} */
"\n"/*    msg = 'message' */
"\n"/*    r.send(msg, move: true) */
"\n"/*    r.take */
"\n"/*    p msg */
"\n"/*  */
"\n"/* This prints: */
"\n"/*  */
"\n"/*    Received: message */
"\n"/*    in `p': undefined method `inspect' for #<Ractor::MovedObject:0x000055c99b9b69b8> */
"\n"/*  */
"\n"/* All references to the object and its parts will become invalid to the sender. */
"\n"/*  */
"\n"/*    r = Ractor.new {puts \"Received: \#{receive}\"} */
"\n"/*    s = 'message' */
"\n"/*    ary = [s] */
"\n"/*    copy = ary.dup */
"\n"/*    r.send(ary, move: true) */
"\n"/*  */
"\n"/*    s.inspect */
"\n"/*    # Ractor::MovedError (can not send any methods to a moved object) */
"\n"/*    ary.class */
"\n"/*    # Ractor::MovedError (can not send any methods to a moved object) */
"\n"/*    copy.class */
"\n"/*    # => Array, it is different object */
"\n"/*    copy[0].inspect */
"\n"/*    # Ractor::MovedError (can not send any methods to a moved object) */
"\n"/*    # ...but its item was still a reference to `s`, which was moved */
"\n"/*  */
"\n"/* If the object is shareable, <tt>move: true</tt> has no effect on it: */
"\n"/*  */
"\n"/*    r = Ractor.new {puts \"Received: \#{receive}\"} */
"\n"/*    s = 'message'.freeze */
"\n"/*    r.send(s, move: true) */
"\n"/*    s.inspect #=> \"message\", still available */
"\n"/*  */
"  def send(obj, move: false)\n"
"    __builtin_cexpr! %q{\n"
"      ractor_send(ec, RACTOR_PTR(self), obj, move)\n"
"    }\n"
"  end\n"
"  alias << send\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     Ractor.yield(msg, move: false) -> nil */
"\n"/*  */
"\n"/* Send a message to the current ractor's outgoing port to be accepted by #take. */
"\n"/*  */
"\n"/*    r = Ractor.new {Ractor.yield 'Hello from ractor'} */
"\n"/*    puts r.take */
"\n"/*    # Prints: \"Hello from ractor\" */
"\n"/*  */
"\n"/* This method is blocking, and will return only when somebody consumes the */
"\n"/* sent message. */
"\n"/*  */
"\n"/*    r = Ractor.new do */
"\n"/*      Ractor.yield 'Hello from ractor' */
,
#line 621 "ractor.rb"
"\n"/*      puts \"Ractor: after yield\" */
"\n"/*    end */
"\n"/*    wait */
"\n"/*    puts \"Still not taken\" */
"\n"/*    puts r.take */
"\n"/*  */
"\n"/* This will print: */
"\n"/*  */
"\n"/*    Still not taken */
"\n"/*    Hello from ractor */
"\n"/*    Ractor: after yield */
"\n"/*  */
"\n"/* If the outgoing port was closed with #close_outgoing, the method will raise: */
"\n"/*  */
"\n"/*    r = Ractor.new do */
"\n"/*      close_outgoing */
"\n"/*      Ractor.yield 'Hello from ractor' */
"\n"/*    end */
"\n"/*    wait */
"\n"/*    # `yield': The outgoing-port is already closed (Ractor::ClosedError) */
"\n"/*  */
"\n"/* The meaning of the +move+ argument is the same as for #send. */
"  def self.yield(obj, move: false)\n"
"    __builtin_cexpr! %q{\n"
"      ractor_yield(ec, rb_ec_ractor_ptr(ec), obj, move)\n"
"    }\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     ractor.take -> msg */
"\n"/*  */
"\n"/* Get a message from the ractor's outgoing port, which was put there by Ractor.yield or at ractor's */
"\n"/* termination. */
"\n"/*  */
"\n"/*   r = Ractor.new do */
"\n"/*     Ractor.yield 'explicit yield' */
"\n"/*     'last value' */
"\n"/*   end */
"\n"/*   puts r.take #=> 'explicit yield' */
"\n"/*   puts r.take #=> 'last value' */
"\n"/*   puts r.take # Ractor::ClosedError (The outgoing-port is already closed) */
"\n"/*  */
"\n"/* The fact that the last value is also sent to the outgoing port means that +take+ can be used */
"\n"/* as an analog of Thread#join (\"just wait until ractor finishes\"). However, it will raise if */
"\n"/* somebody has already consumed that message. */
"\n"/*  */
"\n"/* If the outgoing port was closed with #close_outgoing, the method will raise Ractor::ClosedError. */
"\n"/*  */
"\n"/*    r = Ractor.new do */
"\n"/*      sleep(500) */
"\n"/*      Ractor.yield 'Hello from ractor' */
"\n"/*    end */
"\n"/*    r.close_outgoing */
"\n"/*    r.take */
"\n"/*    # Ractor::ClosedError (The outgoing-port is already closed) */
"\n"/*    # The error would be raised immediately, not when ractor will try to receive */
"\n"/*  */
"\n"/* If an uncaught exception is raised in the Ractor, it is propagated by take as a */
"\n"/* Ractor::RemoteError. */
"\n"/*  */
"\n"/*   r = Ractor.new {raise \"Something weird happened\"} */
"\n"/*  */
"\n"/*   begin */
"\n"/*     r.take */
"\n"/*   rescue => e */
"\n"/*     p e              #  => #<Ractor::RemoteError: thrown by remote Ractor.> */
"\n"/*     p e.ractor == r  # => true */
"\n"/*     p e.cause        # => #<RuntimeError: Something weird happened> */
"\n"/*   end */
"\n"/*  */
"\n"/* Ractor::ClosedError is a descendant of StopIteration, so the termination of the ractor will break */
"\n"/* out of any loops that receive this message without propagating the error: */
"\n"/*  */
"\n"/*     r = Ractor.new do */
"\n"/*       3.times {|i| Ractor.yield \"message \#{i}\"} */
"\n"/*       \"finishing\" */
"\n"/*     end */
"\n"/*  */
"\n"/*     loop {puts \"Received: \" + r.take} */
"\n"/*     puts \"Continue successfully\" */
"\n"/*  */
"\n"/* This will print: */
"\n"/*  */
"\n"/*     Received: message 0 */
"\n"/*     Received: message 1 */
"\n"/*     Received: message 2 */
"\n"/*     Received: finishing */
"\n"/*     Continue successfully */
"  def take\n"
"    __builtin_cexpr! %q{\n"
"      ractor_take(ec, RACTOR_PTR(self))\n"
"    }\n"
"  end\n"
"\n"
"  def inspect\n"
"    loc  = __builtin_cexpr! %q{ RACTOR_PTR(self)->loc }\n"
"    name = __builtin_cexpr! %q{ RACTOR_PTR(self)->name }\n"
"    id   = __builtin_cexpr! %q{ UINT2NUM(rb_ractor_id(RACTOR_PTR(self))) }\n"
,
#line 720 "ractor.rb"
"    status = __builtin_cexpr! %q{\n"
"      rb_str_new2(ractor_status_str(RACTOR_PTR(self)->status_))\n"
"    }\n"
"    \"#<Ractor:##{id}#{name ? ' '+name : ''}#{loc ? \" \" + loc : ''} #{status}>\"\n"
"  end\n"
"\n"
"  alias to_s inspect\n"
"\n"
"\n"/* The name set in Ractor.new, or +nil+. */
"  def name\n"
"    __builtin_cexpr! %q{RACTOR_PTR(self)->name}\n"
"  end\n"
"\n"
"  class RemoteError\n"
"    attr_reader :ractor\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     ractor.close_incoming -> true | false */
"\n"/*  */
"\n"/* Closes the incoming port and returns whether it was already closed. All further attempts */
"\n"/* to Ractor.receive in the ractor, and #send to the ractor will fail with Ractor::ClosedError. */
"\n"/*  */
"\n"/*   r = Ractor.new {sleep(500)} */
"\n"/*   r.close_incoming  #=> false */
"\n"/*   r.close_incoming  #=> true */
"\n"/*   r.send('test') */
"\n"/*   # Ractor::ClosedError (The incoming-port is already closed) */
"  def close_incoming\n"
"    __builtin_cexpr! %q{\n"
"      ractor_close_incoming(ec, RACTOR_PTR(self));\n"
"    }\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    ractor.close_outgoing -> true | false */
"\n"/*  */
"\n"/* Closes the outgoing port and returns whether it was already closed. All further attempts */
"\n"/* to Ractor.yield in the ractor, and #take from the ractor will fail with Ractor::ClosedError. */
"\n"/*  */
"\n"/*   r = Ractor.new {sleep(500)} */
"\n"/*   r.close_outgoing  #=> false */
"\n"/*   r.close_outgoing  #=> true */
"\n"/*   r.take */
"\n"/*   # Ractor::ClosedError (The outgoing-port is already closed) */
"  def close_outgoing\n"
,
#line 768 "ractor.rb"
"    __builtin_cexpr! %q{\n"
"      ractor_close_outgoing(ec, RACTOR_PTR(self));\n"
"    }\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    Ractor.shareable?(obj) -> true | false */
"\n"/*  */
"\n"/* Checks if the object is shareable by ractors. */
"\n"/*  */
"\n"/*     Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are frozen */
"\n"/*     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # frozen_string_literal: true */
"\n"/*     Ractor.shareable?('foo'.freeze) #=> true */
"\n"/*  */
"\n"/* See also the \"Shareable and unshareable objects\" section in the \\Ractor class docs. */
"  def self.shareable? obj\n"
"    __builtin_cexpr! %q{\n"
"      RBOOL(rb_ractor_shareable_p(obj));\n"
"    }\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    Ractor.make_shareable(obj, copy: false) -> shareable_obj */
"\n"/*  */
"\n"/* Make +obj+ shareable between ractors. */
"\n"/*  */
"\n"/* +obj+ and all the objects it refers to will be frozen, unless they are */
"\n"/* already shareable. */
"\n"/*  */
"\n"/* If +copy+ keyword is +true+, it will copy objects before freezing them, and will not */
"\n"/* modify +obj+ or its internal objects. */
"\n"/*  */
"\n"/* Note that the specification and implementation of this method are not */
"\n"/* mature and may be changed in the future. */
"\n"/*  */
"\n"/*   obj = ['test'] */
"\n"/*   Ractor.shareable?(obj)     #=> false */
"\n"/*   Ractor.make_shareable(obj) #=> [\"test\"] */
"\n"/*   Ractor.shareable?(obj)     #=> true */
"\n"/*   obj.frozen?                #=> true */
"\n"/*   obj[0].frozen?             #=> true */
"\n"/*  */
"\n"/*   # Copy vs non-copy versions: */
"\n"/*   obj1 = ['test'] */
"\n"/*   obj1s = Ractor.make_shareable(obj1) */
"\n"/*   obj1.frozen?                        #=> true */
"\n"/*   obj1s.object_id == obj1.object_id   #=> true */
"\n"/*   obj2 = ['test'] */
"\n"/*   obj2s = Ractor.make_shareable(obj2, copy: true) */
"\n"/*   obj2.frozen?                        #=> false */
"\n"/*   obj2s.frozen?                       #=> true */
"\n"/*   obj2s.object_id == obj2.object_id   #=> false */
"\n"/*   obj2s[0].object_id == obj2[0].object_id #=> false */
"\n"/*  */
"\n"/* See also the \"Shareable and unshareable objects\" section in the Ractor class docs. */
"  def self.make_shareable obj, copy: false\n"
"    if copy\n"
"      __builtin_cexpr! %q{\n"
"        rb_ractor_make_shareable_copy(obj);\n"
"      }\n"
"    else\n"
"      __builtin_cexpr! %q{\n"
"        rb_ractor_make_shareable(obj);\n"
"      }\n"
"    end\n"
"  end\n"
"\n"
"\n"/* get a value from ractor-local storage */
"  def [](sym)\n"
,
#line 839 "ractor.rb"
"    Primitive.ractor_local_value(sym)\n"
"  end\n"
"\n"
"\n"/* set a value in ractor-local storage */
"  def []=(sym, val)\n"
"    Primitive.ractor_local_value_set(sym, val)\n"
"  end\n"
"\n"
"\n"/* returns main ractor */
"  def self.main\n"
"    __builtin_cexpr! %q{\n"
"      rb_ractor_self(GET_VM()->ractor.main_ractor);\n"
"    }\n"
"  end\n"
"end\n"
#line 6036 "miniprelude.c"
};

static const char prelude_name14[] = "<internal:symbol>";
static const struct {
    char L0[74]; /* 1..14 */
} prelude_code14 = {
#line 1 "symbol.rb"
"class Symbol\n"
"\n"/* call-seq: */
"\n"/*   to_sym -> self */
"\n"/*  */
"\n"/* Returns +self+. */
"\n"/*  */
"\n"/* Related: String#to_sym. */
"  def to_sym\n"
"    self\n"
"  end\n"
"\n"
"  alias intern to_sym\n"
"end\n"
#line 6057 "miniprelude.c"
};

static const char prelude_name15[] = "<internal:timev>";
static const struct {
    char L0[477]; /* 1..394 */
    char L394[507]; /* 395..412 */
    char L412[78]; /* 413..416 */
} prelude_code15 = {
#line 1 "timev.rb"
""/* A +Time+ object represents a date and time: */
""/*  */
""/*   Time.new(2000, 1, 1, 0, 0, 0) # => 2000-01-01 00:00:00 -0600 */
""/*  */
""/* Although its value can be expressed as a single numeric */
""/* (see {Epoch Seconds}[rdoc-ref:Time@Epoch+Seconds] below), */
""/* it can be convenient to deal with the value by parts: */
""/*  */
""/*   t = Time.new(-2000, 1, 1, 0, 0, 0.0) */
""/*   # => -2000-01-01 00:00:00 -0600 */
""/*   t.year # => -2000 */
""/*   t.month # => 1 */
""/*   t.mday # => 1 */
""/*   t.hour # => 0 */
""/*   t.min # => 0 */
""/*   t.sec # => 0 */
""/*   t.subsec # => 0 */
""/*  */
""/*   t = Time.new(2000, 12, 31, 23, 59, 59.5) */
""/*   # => 2000-12-31 23:59:59.5 -0600 */
""/*   t.year # => 2000 */
""/*   t.month # => 12 */
""/*   t.mday # => 31 */
""/*   t.hour # => 23 */
""/*   t.min # => 59 */
""/*   t.sec # => 59 */
""/*   t.subsec # => (1/2) */
""/*  */
""/* == Epoch Seconds */
""/*  */
""/* <i>Epoch seconds</i> is the exact number of seconds */
""/* (including fractional subseconds) since the Unix Epoch, January 1, 1970. */
""/*  */
""/* You can retrieve that value exactly using method Time.to_r: */
""/*  */
""/*   Time.at(0).to_r        # => (0/1) */
""/*   Time.at(0.999999).to_r # => (9007190247541737/9007199254740992) */
""/*  */
""/* Other retrieval methods such as Time#to_i and Time#to_f */
""/* may return a value that rounds or truncates subseconds. */
""/*  */
""/* == \\Time Resolution */
""/*  */
""/* A +Time+ object derived from the system clock */
""/* (for example, by method Time.now) */
""/* has the resolution supported by the system. */
""/*  */
""/* == Examples */
""/*  */
""/* All of these examples were done using the EST timezone which is GMT-5. */
""/*  */
""/* === Creating a New +Time+ Instance */
""/*  */
""/* You can create a new instance of Time with Time.new. This will use the */
""/* current system time. Time.now is an alias for this. You can also */
""/* pass parts of the time to Time.new such as year, month, minute, etc. When */
""/* you want to construct a time this way you must pass at least a year. If you */
""/* pass the year with nothing else time will default to January 1 of that year */
""/* at 00:00:00 with the current system timezone. Here are some examples: */
""/*  */
""/*   Time.new(2002)         #=> 2002-01-01 00:00:00 -0500 */
""/*   Time.new(2002, 10)     #=> 2002-10-01 00:00:00 -0500 */
""/*   Time.new(2002, 10, 31) #=> 2002-10-31 00:00:00 -0500 */
""/*  */
""/* You can pass a UTC offset: */
""/*  */
""/*   Time.new(2002, 10, 31, 2, 2, 2, \"+02:00\") #=> 2002-10-31 02:02:02 +0200 */
""/*  */
""/* Or {a timezone object}[rdoc-ref:Time@Timezone+Objects]: */
""/*  */
""/*   zone = timezone(\"Europe/Athens\")      # Eastern European Time, UTC+2 */
""/*   Time.new(2002, 10, 31, 2, 2, 2, zone) #=> 2002-10-31 02:02:02 +0200 */
""/*  */
""/* You can also use Time.local and Time.utc to infer */
""/* local and UTC timezones instead of using the current system */
""/* setting. */
""/*  */
""/* You can also create a new time using Time.at which takes the number of */
""/* seconds (with subsecond) since the {Unix */
""/* Epoch}[https://en.wikipedia.org/wiki/Unix_time]. */
""/*  */
""/*   Time.at(628232400) #=> 1989-11-28 00:00:00 -0500 */
""/*  */
""/* === Working with an Instance of +Time+ */
""/*  */
""/* Once you have an instance of Time there is a multitude of things you can */
""/* do with it. Below are some examples. For all of the following examples, we */
""/* will work on the assumption that you have done the following: */
""/*  */
""/*   t = Time.new(1993, 02, 24, 12, 0, 0, \"+09:00\") */
""/*  */
""/* Was that a monday? */
""/*  */
""/*   t.monday? #=> false */
""/*  */
""/* What year was that again? */
""/*  */
""/*   t.year #=> 1993 */
""/*  */
""/* Was it daylight savings at the time? */
""/*  */
""/*   t.dst? #=> false */
""/*  */
""/* What's the day a year later? */
""/*  */
""/*   t + (60*60*24*365) #=> 1994-02-24 12:00:00 +0900 */
""/*  */
""/* How many seconds was that since the Unix Epoch? */
""/*  */
""/*   t.to_i #=> 730522800 */
""/*  */
""/* You can also do standard functions like compare two times. */
""/*  */
""/*   t1 = Time.new(2010) */
""/*   t2 = Time.new(2011) */
""/*  */
""/*   t1 == t2 #=> false */
""/*   t1 == t1 #=> true */
""/*   t1 <  t2 #=> true */
""/*   t1 >  t2 #=> false */
""/*  */
""/*   Time.new(2010,10,31).between?(t1, t2) #=> true */
""/*  */
""/* == What's Here */
""/*  */
""/* First, what's elsewhere. \\Class +Time+: */
""/*  */
""/* - Inherits from {class Object}[rdoc-ref:Object@What-27s+Here]. */
""/* - Includes {module Comparable}[rdoc-ref:Comparable@What-27s+Here]. */
""/*  */
""/* Here, class +Time+ provides methods that are useful for: */
""/*  */
""/* - {Creating +Time+ objects}[rdoc-ref:Time@Methods+for+Creating]. */
""/* - {Fetching +Time+ values}[rdoc-ref:Time@Methods+for+Fetching]. */
""/* - {Querying a +Time+ object}[rdoc-ref:Time@Methods+for+Querying]. */
""/* - {Comparing +Time+ objects}[rdoc-ref:Time@Methods+for+Comparing]. */
""/* - {Converting a +Time+ object}[rdoc-ref:Time@Methods+for+Converting]. */
""/* - {Rounding a +Time+}[rdoc-ref:Time@Methods+for+Rounding]. */
""/*  */
""/* === Methods for Creating */
""/*  */
""/* - ::new: Returns a new time from specified arguments (year, month, etc.), */
""/*   including an optional timezone value. */
""/* - ::local (aliased as ::mktime): Same as ::new, except the */
""/*   timezone is the local timezone. */
""/* - ::utc (aliased as ::gm): Same as ::new, except the timezone is UTC. */
""/* - ::at: Returns a new time based on seconds since epoch. */
""/* - ::now: Returns a new time based on the current system time. */
""/* - #+ (plus): Returns a new time increased by the given number of seconds. */
""/* - #- (minus): Returns a new time decreased by the given number of seconds. */
""/*  */
""/* === Methods for Fetching */
""/*  */
""/* - #year: Returns the year of the time. */
""/* - #month (aliased as #mon): Returns the month of the time. */
""/* - #mday (aliased as #day): Returns the day of the month. */
""/* - #hour: Returns the hours value for the time. */
""/* - #min: Returns the minutes value for the time. */
""/* - #sec: Returns the seconds value for the time. */
""/* - #usec (aliased as #tv_usec): Returns the number of microseconds */
""/*   in the subseconds value of the time. */
""/* - #nsec (aliased as #tv_nsec: Returns the number of nanoseconds */
""/*   in the subsecond part of the time. */
""/* - #subsec: Returns the subseconds value for the time. */
""/* - #wday: Returns the integer weekday value of the time (0 == Sunday). */
""/* - #yday: Returns the integer yearday value of the time (1 == January 1). */
""/* - #hash: Returns the integer hash value for the time. */
""/* - #utc_offset (aliased as #gmt_offset and #gmtoff): Returns the offset */
""/*   in seconds between time and UTC. */
""/* - #to_f: Returns the float number of seconds since epoch for the time. */
""/* - #to_i (aliased as #tv_sec): Returns the integer number of seconds since epoch */
""/*   for the time. */
""/* - #to_r: Returns the Rational number of seconds since epoch for the time. */
""/* - #zone: Returns a string representation of the timezone of the time. */
""/*  */
""/* === Methods for Querying */
""/*  */
""/* - #utc? (aliased as #gmt?): Returns whether the time is UTC. */
""/* - #dst? (aliased as #isdst): Returns whether the time is DST (daylight saving time). */
""/* - #sunday?: Returns whether the time is a Sunday. */
""/* - #monday?: Returns whether the time is a Monday. */
""/* - #tuesday?: Returns whether the time is a Tuesday. */
""/* - #wednesday?: Returns whether the time is a Wednesday. */
""/* - #thursday?: Returns whether the time is a Thursday. */
""/* - #friday?: Returns whether time is a Friday. */
""/* - #saturday?: Returns whether the time is a Saturday. */
""/*  */
""/* === Methods for Comparing */
""/*  */
""/* - #<=>: Compares +self+ to another time. */
""/* - #eql?: Returns whether the time is equal to another time. */
""/*  */
""/* === Methods for Converting */
""/*  */
""/* - #asctime (aliased as #ctime): Returns the time as a string. */
""/* - #inspect: Returns the time in detail as a string. */
""/* - #strftime: Returns the time as a string, according to a given format. */
""/* - #to_a: Returns a 10-element array of values from the time. */
""/* - #to_s: Returns a string representation of the time. */
""/* - #getutc (aliased as #getgm): Returns a new time converted to UTC. */
""/* - #getlocal: Returns a new time converted to local time. */
""/* - #utc (aliased as #gmtime): Converts time to UTC in place. */
""/* - #localtime: Converts time to local time in place. */
""/* - #deconstruct_keys: Returns a hash of time components used in pattern-matching. */
""/*  */
""/* === Methods for Rounding */
""/*  */
""/* - #round:Returns a new time with subseconds rounded. */
""/* - #ceil: Returns a new time with subseconds raised to a ceiling. */
""/* - #floor: Returns a new time with subseconds lowered to a floor. */
""/*  */
""/* For the forms of argument +zone+, see */
""/* {Timezone Specifiers}[rdoc-ref:Time@Timezone+Specifiers]. */
""/*  */
""/* :include: doc/_timezones.rdoc */
"class Time\n"
"\n"/* Creates a new +Time+ object from the current system time. */
"\n"/* This is the same as Time.new without arguments. */
"\n"/*  */
"\n"/*    Time.now               # => 2009-06-24 12:39:54 +0900 */
"\n"/*    Time.now(in: '+04:00') # => 2009-06-24 07:39:54 +0400 */
"\n"/*  */
"\n"/* For forms of argument +zone+, see */
"\n"/* {Timezone Specifiers}[rdoc-ref:Time@Timezone+Specifiers]. */
"  def self.now(in: nil)\n"
"    Primitive.time_s_now(Primitive.arg!(:in))\n"
"  end\n"
"\n"
"\n"/* Returns a new +Time+ object based on the given arguments. */
"\n"/*  */
"\n"/* Required argument +time+ may be either of: */
"\n"/*  */
"\n"/* - A +Time+ object, whose value is the basis for the returned time; */
"\n"/*   also influenced by optional keyword argument +in:+ (see below). */
"\n"/* - A numeric number of */
"\n"/*   {Epoch seconds}[rdoc-ref:Time@Epoch+Seconds] */
"\n"/*   for the returned time. */
"\n"/*  */
"\n"/* Examples: */
"\n"/*  */
"\n"/*   t = Time.new(2000, 12, 31, 23, 59, 59) # => 2000-12-31 23:59:59 -0600 */
"\n"/*   secs = t.to_i                          # => 978328799 */
"\n"/*   Time.at(secs)                          # => 2000-12-31 23:59:59 -0600 */
"\n"/*   Time.at(secs + 0.5)                    # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*   Time.at(1000000000)                    # => 2001-09-08 20:46:40 -0500 */
"\n"/*   Time.at(0)                             # => 1969-12-31 18:00:00 -0600 */
"\n"/*   Time.at(-1000000000)                   # => 1938-04-24 17:13:20 -0500 */
"\n"/*  */
"\n"/* Optional numeric argument +subsec+ and optional symbol argument +units+ */
"\n"/* work together to specify subseconds for the returned time; */
"\n"/* argument +units+ specifies the units for +subsec+: */
"\n"/*  */
"\n"/* - +:millisecond+: +subsec+ in milliseconds: */
"\n"/*  */
"\n"/*     Time.at(secs, 0, :millisecond)     # => 2000-12-31 23:59:59 -0600 */
"\n"/*     Time.at(secs, 500, :millisecond)   # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*     Time.at(secs, 1000, :millisecond)  # => 2001-01-01 00:00:00 -0600 */
"\n"/*     Time.at(secs, -1000, :millisecond) # => 2000-12-31 23:59:58 -0600 */
"\n"/*  */
"\n"/* - +:microsecond+ or +:usec+: +subsec+ in microseconds: */
"\n"/*  */
"\n"/*     Time.at(secs, 0, :microsecond)        # => 2000-12-31 23:59:59 -0600 */
"\n"/*     Time.at(secs, 500000, :microsecond)   # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*     Time.at(secs, 1000000, :microsecond)  # => 2001-01-01 00:00:00 -0600 */
"\n"/*     Time.at(secs, -1000000, :microsecond) # => 2000-12-31 23:59:58 -0600 */
"\n"/*  */
"\n"/* - +:nanosecond+ or +:nsec+: +subsec+ in nanoseconds: */
"\n"/*  */
"\n"/*     Time.at(secs, 0, :nanosecond)           # => 2000-12-31 23:59:59 -0600 */
"\n"/*     Time.at(secs, 500000000, :nanosecond)   # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*     Time.at(secs, 1000000000, :nanosecond)  # => 2001-01-01 00:00:00 -0600 */
"\n"/*     Time.at(secs, -1000000000, :nanosecond) # => 2000-12-31 23:59:58 -0600 */
"\n"/*  */
"\n"/*  */
"\n"/* Optional keyword argument <tt>in: zone</tt> specifies the timezone */
"\n"/* for the returned time: */
"\n"/*  */
"\n"/*   Time.at(secs, in: '+12:00') # => 2001-01-01 17:59:59 +1200 */
"\n"/*   Time.at(secs, in: '-12:00') # => 2000-12-31 17:59:59 -1200 */
"\n"/*  */
"\n"/* For the forms of argument +zone+, see */
"\n"/* {Timezone Specifiers}[rdoc-ref:Time@Timezone+Specifiers]. */
"\n"/*  */
"  def self.at(time, subsec = false, unit = :microsecond, in: nil)\n"
"    if Primitive.mandatory_only?\n"
"      Primitive.time_s_at1(time)\n"
"    else\n"
"      Primitive.time_s_at(time, subsec, unit, Primitive.arg!(:in))\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Time.new(year = nil, mon = nil, mday = nil, hour = nil, min = nil, sec = nil, zone = nil, in: nil, precision: 9) */
"\n"/*  */
"\n"/* Returns a new +Time+ object based on the given arguments, */
"\n"/* by default in the local timezone. */
"\n"/*  */
"\n"/* With no positional arguments, returns the value of Time.now: */
"\n"/*  */
"\n"/*   Time.new # => 2021-04-24 17:27:46.0512465 -0500 */
"\n"/*  */
"\n"/* With one string argument that represents a time, returns a new */
"\n"/* +Time+ object based on the given argument, in the local timezone. */
"\n"/*  */
"\n"/*   Time.new('2000-12-31 23:59:59.5')              # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*   Time.new('2000-12-31 23:59:59.5 +0900')        # => 2000-12-31 23:59:59.5 +0900 */
"\n"/*   Time.new('2000-12-31 23:59:59.5', in: '+0900') # => 2000-12-31 23:59:59.5 +0900 */
"\n"/*   Time.new('2000-12-31 23:59:59.5')              # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*   Time.new('2000-12-31 23:59:59.56789', precision: 3) # => 2000-12-31 23:59:59.567 -0600 */
"\n"/*  */
"\n"/* With one to six arguments, returns a new +Time+ object */
"\n"/* based on the given arguments, in the local timezone. */
"\n"/*  */
"\n"/*   Time.new(2000, 1, 2, 3, 4, 5) # => 2000-01-02 03:04:05 -0600 */
"\n"/*  */
"\n"/* For the positional arguments (other than +zone+): */
"\n"/*  */
"\n"/* - +year+: Year, with no range limits: */
"\n"/*  */
"\n"/*     Time.new(999999999)  # => 999999999-01-01 00:00:00 -0600 */
"\n"/*     Time.new(-999999999) # => -999999999-01-01 00:00:00 -0600 */
"\n"/*  */
"\n"/* - +month+: Month in range (1..12), or case-insensitive */
"\n"/*   3-letter month name: */
"\n"/*  */
"\n"/*     Time.new(2000, 1)     # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 12)    # => 2000-12-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 'jan') # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 'JAN') # => 2000-01-01 00:00:00 -0600 */
"\n"/*  */
"\n"/* - +mday+: Month day in range(1..31): */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1)  # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 31) # => 2000-01-31 00:00:00 -0600 */
"\n"/*  */
"\n"/* - +hour+: Hour in range (0..23), or 24 if +min+, +sec+, and +usec+ */
"\n"/*   are zero: */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1, 0)  # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 1, 23) # => 2000-01-01 23:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 1, 24) # => 2000-01-02 00:00:00 -0600 */
"\n"/*  */
"\n"/* - +min+: Minute in range (0..59): */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1, 0, 0)  # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 1, 0, 59) # => 2000-01-01 00:59:00 -0600 */
"\n"/*  */
"\n"/* - +sec+: Second in range (0...61): */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 0)  # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 59) # => 2000-01-01 00:00:59 -0600 */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 60) # => 2000-01-01 00:01:00 -0600 */
"\n"/*  */
"\n"/*   +sec+ may be Float or Rational. */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 59.5)  # => 2000-12-31 23:59:59.5 +0900 */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 59.7r) # => 2000-12-31 23:59:59.7 +0900 */
"\n"/*  */
"\n"/* These values may be: */
"\n"/*  */
"\n"/* - Integers, as above. */
"\n"/* - Numerics convertible to integers: */
"\n"/*  */
"\n"/*     Time.new(Float(0.0), Rational(1, 1), 1.0, 0.0, 0.0, 0.0) */
"\n"/*     # => 0000-01-01 00:00:00 -0600 */
"\n"/*  */
"\n"/* - String integers: */
"\n"/*  */
"\n"/*     a = %w[0 1 1 0 0 0] */
"\n"/*     # => [\"0\", \"1\", \"1\", \"0\", \"0\", \"0\"] */
"\n"/*     Time.new(*a) # => 0000-01-01 00:00:00 -0600 */
"\n"/*  */
"\n"/* When positional argument +zone+ or keyword argument +in:+ is given, */
"\n"/* the new +Time+ object is in the specified timezone. */
"\n"/* For the forms of argument +zone+, see */
"\n"/* {Timezone Specifiers}[rdoc-ref:Time@Timezone+Specifiers]: */
"\n"/*  */
"\n"/*   Time.new(2000, 1, 1, 0, 0, 0, '+12:00') */
"\n"/*   # => 2000-01-01 00:00:00 +1200 */
"\n"/*   Time.new(2000, 1, 1, 0, 0, 0, in: '-12:00') */
"\n"/*   # => 2000-01-01 00:00:00 -1200 */
"\n"/*   Time.new(in: '-12:00') */
"\n"/*   # => 2022-08-23 08:49:26.1941467 -1200 */
"\n"/*  */
"\n"/* Since +in:+ keyword argument just provides the default, so if the */
"\n"/* first argument in single string form contains time zone information, */
"\n"/* this keyword argument will be silently ignored. */
"\n"/*  */
"\n"/*   Time.new('2000-01-01 00:00:00 +0100', in: '-0500').utc_offset  # => 3600 */
"\n"/*  */
"\n"/* - +precision+: maximum effective digits in sub-second part, default is 9. */
"\n"/*   More digits will be truncated, as other operations of +Time+. */
"\n"/*   Ignored unless the first argument is a string. */
"\n"/*  */
,
#line 395 "timev.rb"
"  def initialize(year = (now = true), mon = (str = year; nil), mday = nil, hour = nil, min = nil, sec = nil, zone = nil,\n"
"                 in: nil, precision: 9)\n"
"    if zone\n"
"      if Primitive.arg!(:in)\n"
"        raise ArgumentError, \"timezone argument given as positional and keyword arguments\"\n"
"      end\n"
"    else\n"
"      zone = Primitive.arg!(:in)\n"
"    end\n"
"\n"
"    if now\n"
"      return Primitive.time_init_now(zone)\n"
"    end\n"
"\n"
"    if str and Primitive.time_init_parse(str, zone, precision)\n"
"      return self\n"
"    end\n"
"\n"
,
#line 413 "timev.rb"
"    Primitive.time_init_args(year, mon, mday, hour, min, sec, zone)\n"
"  end\n"
"end\n"
#line 6486 "miniprelude.c"
};

static const char prelude_name16[] = "<internal:thread_sync>";
static const struct {
    char L0[500]; /* 1..38 */
    char L38[446]; /* 39..69 */
} prelude_code16 = {
#line 1 "thread_sync.rb"
"class Thread\n"
"  class Queue\n"
"\n"/* call-seq: */
"\n"/*   pop(non_block=false, timeout: nil) */
"\n"/*  */
"\n"/* Retrieves data from the queue. */
"\n"/*  */
"\n"/* If the queue is empty, the calling thread is suspended until data is pushed */
"\n"/* onto the queue. If +non_block+ is true, the thread isn't suspended, and */
"\n"/* +ThreadError+ is raised. */
"\n"/*  */
"\n"/* If +timeout+ seconds have passed and no data is available +nil+ is */
"\n"/* returned. If +timeout+ is +0+ it returns immediately. */
"    def pop(non_block = false, timeout: nil)\n"
"      if non_block && timeout\n"
"        raise ArgumentError, \"can't set a timeout if non_block is enabled\"\n"
"      end\n"
"      Primitive.rb_queue_pop(non_block, timeout)\n"
"    end\n"
"    alias_method :deq, :pop\n"
"    alias_method :shift, :pop\n"
"  end\n"
"\n"
"  class SizedQueue\n"
"\n"/* call-seq: */
"\n"/*   pop(non_block=false, timeout: nil) */
"\n"/*  */
"\n"/* Retrieves data from the queue. */
"\n"/*  */
"\n"/* If the queue is empty, the calling thread is suspended until data is */
"\n"/* pushed onto the queue. If +non_block+ is true, the thread isn't */
"\n"/* suspended, and +ThreadError+ is raised. */
"\n"/*  */
"\n"/* If +timeout+ seconds have passed and no data is available +nil+ is */
"\n"/* returned. If +timeout+ is +0+ it returns immediately. */
"    def pop(non_block = false, timeout: nil)\n"
"      if non_block && timeout\n"
"        raise ArgumentError, \"can't set a timeout if non_block is enabled\"\n"
,
#line 39 "thread_sync.rb"
"      end\n"
"      Primitive.rb_szqueue_pop(non_block, timeout)\n"
"    end\n"
"    alias_method :deq, :pop\n"
"    alias_method :shift, :pop\n"
"\n"
"\n"/* call-seq: */
"\n"/*   push(object, non_block=false, timeout: nil) */
"\n"/*   enq(object, non_block=false, timeout: nil) */
"\n"/*   <<(object) */
"\n"/*  */
"\n"/* Pushes +object+ to the queue. */
"\n"/*  */
"\n"/* If there is no space left in the queue, waits until space becomes */
"\n"/* available, unless +non_block+ is true.  If +non_block+ is true, the */
"\n"/* thread isn't suspended, and +ThreadError+ is raised. */
"\n"/*  */
"\n"/* If +timeout+ seconds have passed and no space is available +nil+ is */
"\n"/* returned. If +timeout+ is +0+ it returns immediately. */
"\n"/* Otherwise it returns +self+. */
"    def push(object, non_block = false, timeout: nil)\n"
"      if non_block && timeout\n"
"        raise ArgumentError, \"can't set a timeout if non_block is enabled\"\n"
"      end\n"
"      Primitive.rb_szqueue_push(object, non_block, timeout)\n"
"    end\n"
"    alias_method :enq, :push\n"
"    alias_method :<<, :push\n"
"  end\n"
"end\n"
#line 6565 "miniprelude.c"
};

static const char prelude_name17[] = "<internal:nilclass>";
static const struct {
    char L0[98]; /* 1..26 */
} prelude_code17 = {
#line 1 "nilclass.rb"
"class NilClass\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     nil.to_i -> 0 */
"\n"/*  */
"\n"/*  Always returns zero. */
"\n"/*  */
"\n"/*     nil.to_i   #=> 0 */
"\n"/*  */
"  def to_i\n"
"    return 0\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     nil.to_f    -> 0.0 */
"\n"/*  */
"\n"/*  Always returns zero. */
"\n"/*  */
"\n"/*     nil.to_f   #=> 0.0 */
"\n"/*  */
"  def to_f\n"
"    return 0.0\n"
"  end\n"
"end\n"
#line 6598 "miniprelude.c"
};

static const char prelude_name18[] = "<internal:prelude>";
static const struct {
    char L0[352]; /* 1..32 */
} prelude_code18 = {
#line 1 "prelude.rb"
"class Binding\n"
"\n"/* :nodoc: */
"  def irb\n"
"    require 'irb'\n"
"    irb\n"
"  end\n"
"\n"
"\n"/* suppress redefinition warning */
"  alias irb irb\n"/* :nodoc: */
"end\n"
"\n"
"module Kernel\n"
"  def pp(*objs)\n"
"    require 'pp'\n"
"    pp(*objs)\n"
"  end\n"
"\n"
"\n"/* suppress redefinition warning */
"  alias pp pp\n"/* :nodoc: */
"\n"
"  private :pp\n"
"end\n"
"\n"
"autoload :Set, 'set'\n"
"\n"
"module Enumerable\n"
"\n"/* Makes a set from the enumerable object with given arguments. */
"  def to_set(klass = Set, *args, &block)\n"
"    klass.new(self, *args, &block)\n"
"  end unless instance_methods.include?(:to_set)\n"/* RJIT could already load this from builtin prelude */
"end\n"
#line 6637 "miniprelude.c"
};

static const char prelude_name19[] = "<internal:gem_prelude>";
static const struct {
    char L0[478]; /* 1..25 */
    char L25[74]; /* 26..29 */
} prelude_code19 = {
#line 1 "gem_prelude.rb"
"begin\n"
"  require 'rubygems'\n"
"rescue LoadError => e\n"
"  raise unless e.path == 'rubygems'\n"
"\n"
"  warn \"`RubyGems' were not loaded.\"\n"
"else\n"
"  require 'bundled_gems'\n"
"end if defined?(Gem)\n"
"\n"
"begin\n"
"  require 'error_highlight'\n"
"rescue LoadError\n"
"  warn \"`error_highlight' was not loaded.\"\n"
"end if defined?(ErrorHighlight)\n"
"\n"
"begin\n"
"  require 'did_you_mean'\n"
"rescue LoadError\n"
"  warn \"`did_you_mean' was not loaded.\"\n"
"end if defined?(DidYouMean)\n"
"\n"
"begin\n"
"  require 'syntax_suggest/core_ext'\n"
"rescue LoadError\n"
,
#line 26 "gem_prelude.rb"
"  warn \"`syntax_suggest' was not loaded.\"\n"
"end if defined?(SyntaxSuggest)\n"
"\n"
#line 6676 "miniprelude.c"
};

static const char prelude_name20[] = "<internal:yjit>";
static const struct {
    char L0[508]; /* 1..36 */
    char L36[500]; /* 37..56 */
    char L56[496]; /* 57..86 */
    char L86[500]; /* 87..103 */
    char L103[459]; /* 104..148 */
    char L148[488]; /* 149..168 */
    char L168[488]; /* 169..188 */
    char L188[494]; /* 189..220 */
    char L220[474]; /* 221..247 */
    char L247[460]; /* 248..257 */
    char L257[411]; /* 258..261 */
    char L261[504]; /* 262..279 */
    char L279[493]; /* 280..293 */
    char L293[409]; /* 294..305 */
    char L305[444]; /* 306..309 */
    char L309[449]; /* 310..313 */
    char L313[457]; /* 314..319 */
    char L319[500]; /* 320..325 */
    char L325[505]; /* 326..331 */
    char L331[431]; /* 332..335 */
    char L335[471]; /* 336..341 */
    char L341[452]; /* 342..347 */
    char L347[476]; /* 348..353 */
    char L353[463]; /* 354..359 */
    char L359[468]; /* 360..364 */
    char L364[432]; /* 365..369 */
    char L369[491]; /* 370..377 */
    char L377[505]; /* 378..397 */
    char L397[440]; /* 398..409 */
    char L409[476]; /* 410..423 */
    char L423[505]; /* 424..433 */
    char L433[477]; /* 434..450 */
    char L450[461]; /* 451..465 */
    char L465[472]; /* 466..483 */
    char L483[244]; /* 484..492 */
} prelude_code20 = {
#line 1 "yjit.rb"
""/* frozen_string_literal: true */
""/* :markup: markdown */
""
""/* This module allows for introspection of \\YJIT, CRuby's just-in-time compiler. */
""/* Everything in the module is highly implementation specific and the API might */
""/* be less stable compared to the standard library. */
""/*  */
""/* This module may not exist if \\YJIT does not support the particular platform */
""/* for which CRuby is built. */
"module RubyVM::YJIT\n"
"\n"/* Check if \\YJIT is enabled. */
"  def self.enabled?\n"
"    Primitive.cexpr! 'RBOOL(rb_yjit_enabled_p)'\n"
"  end\n"
"\n"
"\n"/* Check if `--yjit-stats` is used. */
"  def self.stats_enabled?\n"
"    Primitive.rb_yjit_stats_enabled_p\n"
"  end\n"
"\n"
"\n"/* Check if rb_yjit_trace_exit_locations_enabled_p is enabled. */
"  def self.trace_exit_locations_enabled?\n"/* :nodoc: */
"    Primitive.rb_yjit_trace_exit_locations_enabled_p\n"
"  end\n"
"\n"
"\n"/* Discard statistics collected for `--yjit-stats`. */
"  def self.reset_stats!\n"
"    Primitive.rb_yjit_reset_stats_bang\n"
"  end\n"
"\n"
"\n"/* Enable \\YJIT compilation. */
"  def self.enable(stats: false)\n"
"    return false if enabled?\n"
"    at_exit { print_and_dump_stats } if stats\n"
"    Primitive.rb_yjit_enable(stats, stats != :quiet)\n"
"  end\n"
,
#line 37 "yjit.rb"
"\n"
"\n"/* If --yjit-trace-exits is enabled parse the hashes from */
"\n"/* Primitive.rb_yjit_get_exit_locations into a format readable */
"\n"/* by Stackprof. This will allow us to find the exact location of a */
"\n"/* side exit in YJIT based on the instruction that is exiting. */
"  def self.exit_locations\n"/* :nodoc: */
"    return unless trace_exit_locations_enabled?\n"
"\n"
"    results = Primitive.rb_yjit_get_exit_locations\n"
"    raw_samples = results[:raw].dup\n"
"    line_samples = results[:lines].dup\n"
"    frames = results[:frames].dup\n"
"    samples_count = 0\n"
"\n"
"\n"/* Loop through the instructions and set the frame hash with the data. */
"\n"/* We use nonexistent.def for the file name, otherwise insns.def will be displayed */
"\n"/* and that information isn't useful in this context. */
"    RubyVM::INSTRUCTION_NAMES.each_with_index do |name, frame_id|\n"
"      frame_hash = { samples: 0, total_samples: 0, edges: {}, name: name, file: \"nonexistent.def\", line: nil, lines: {} }\n"
"      results[:frames][frame_id] = frame_hash\n"
,
#line 57 "yjit.rb"
"      frames[frame_id] = frame_hash\n"
"    end\n"
"\n"
"\n"/* Loop through the raw_samples and build the hashes for StackProf. */
"\n"/* The loop is based off an example in the StackProf documentation and therefore */
"\n"/* this functionality can only work with that library. */
"\n"/*  */
"\n"/* Raw Samples: */
"\n"/* [ length, frame1, frame2, frameN, ..., instruction, count */
"\n"/*  */
"\n"/* Line Samples */
"\n"/* [ length, line_1, line_2, line_n, ..., dummy value, count */
"    i = 0\n"
"    while i < raw_samples.length\n"
"      stack_length = raw_samples[i]\n"
"      i += 1\n"/* consume the stack length */
"\n"
"      sample_count = raw_samples[i + stack_length]\n"
"\n"
"      prev_frame_id = nil\n"
"      stack_length.times do |idx|\n"
"        idx += i\n"
"        frame_id = raw_samples[idx]\n"
"\n"
"        if prev_frame_id\n"
"          prev_frame = frames[prev_frame_id]\n"
"          prev_frame[:edges][frame_id] ||= 0\n"
"          prev_frame[:edges][frame_id] += sample_count\n"
"        end\n"
"\n"
,
#line 87 "yjit.rb"
"        frame_info = frames[frame_id]\n"
"        frame_info[:total_samples] += sample_count\n"
"\n"
"        frame_info[:lines][line_samples[idx]] ||= [0, 0]\n"
"        frame_info[:lines][line_samples[idx]][0] += sample_count\n"
"\n"
"        prev_frame_id = frame_id\n"
"      end\n"
"\n"
"      i += stack_length\n"/* consume the stack */
"\n"
"      top_frame_id = prev_frame_id\n"
"      top_frame_line = 1\n"
"\n"
"      frames[top_frame_id][:samples] += sample_count\n"
"      frames[top_frame_id][:lines] ||= {}\n"
"      frames[top_frame_id][:lines][top_frame_line] ||= [0, 0]\n"
,
#line 104 "yjit.rb"
"      frames[top_frame_id][:lines][top_frame_line][1] += sample_count\n"
"\n"
"      samples_count += sample_count\n"
"      i += 1\n"
"    end\n"
"\n"
"    results[:samples] = samples_count\n"
"\n"/* Set missed_samples and gc_samples to 0 as their values */
"\n"/* don't matter to us in this context. */
"    results[:missed_samples] = 0\n"
"    results[:gc_samples] = 0\n"
"    results\n"
"  end\n"
"\n"
"\n"/* Marshal dumps exit locations to the given filename. */
"\n"/*  */
"\n"/* Usage: */
"\n"/*  */
"\n"/* If `--yjit-exit-locations` is passed, a file named */
"\n"/* \"yjit_exit_locations.dump\" will automatically be generated. */
"\n"/*  */
"\n"/* If you want to collect traces manually, call `dump_exit_locations` */
"\n"/* directly. */
"\n"/*  */
"\n"/* Note that calling this in a script will generate stats after the */
"\n"/* dump is created, so the stats data may include exits from the */
"\n"/* dump itself. */
"\n"/*  */
"\n"/* In a script call: */
"\n"/*  */
"\n"/*     at_exit do */
"\n"/*       RubyVM::YJIT.dump_exit_locations(\"my_file.dump\") */
"\n"/*     end */
"\n"/*  */
"\n"/* Then run the file with the following options: */
"\n"/*  */
"\n"/*     ruby --yjit --yjit-trace-exits test.rb */
"\n"/*  */
"\n"/* Once the code is done running, use Stackprof to read the dump file. */
"\n"/* See Stackprof documentation for options. */
"  def self.dump_exit_locations(filename)\n"
"    unless trace_exit_locations_enabled?\n"
"      raise ArgumentError, \"--yjit-trace-exits must be enabled to use dump_exit_locations.\"\n"
"    end\n"
"\n"
,
#line 149 "yjit.rb"
"    File.binwrite(filename, Marshal.dump(RubyVM::YJIT.exit_locations))\n"
"  end\n"
"\n"
"\n"/* Return a hash for statistics generated for the `--yjit-stats` command line option. */
"\n"/* Return `nil` when option is not passed or unavailable. */
"  def self.runtime_stats(context: false)\n"
"    stats = Primitive.rb_yjit_get_stats(context)\n"
"    return stats if stats.nil?\n"
"\n"
"    stats[:object_shape_count] = Primitive.object_shape_count\n"
"    return stats unless Primitive.rb_yjit_stats_enabled_p\n"
"\n"
"    side_exits = total_exit_count(stats)\n"
"    total_exits = side_exits + stats[:leave_interp_return]\n"
"\n"
"\n"/* Number of instructions that finish executing in YJIT. */
"\n"/* See :count-placement: about the subtraction. */
"    retired_in_yjit = stats[:yjit_insns_count] - side_exits\n"
"\n"
"\n"/* Average length of instruction sequences executed by YJIT */
,
#line 169 "yjit.rb"
"    avg_len_in_yjit = total_exits > 0 ? retired_in_yjit.to_f / total_exits : 0\n"
"\n"
"\n"/* Proportion of instructions that retire in YJIT */
"    total_insns_count = retired_in_yjit + stats[:vm_insns_count]\n"
"    yjit_ratio_pct = 100.0 * retired_in_yjit.to_f / total_insns_count\n"
"    stats[:total_insns_count] = total_insns_count\n"
"    stats[:ratio_in_yjit] = yjit_ratio_pct\n"
"\n"
"\n"/* Make those stats available in RubyVM::YJIT.runtime_stats as well */
"    stats[:side_exit_count]  = side_exits\n"
"    stats[:total_exit_count] = total_exits\n"
"    stats[:avg_len_in_yjit]  = avg_len_in_yjit\n"
"\n"
"    stats\n"
"  end\n"
"\n"
"\n"/* Format and print out counters as a String. This returns a non-empty */
"\n"/* content only when `--yjit-stats` is enabled. */
"  def self.stats_string\n"
"\n"/* Lazily require StringIO to avoid breaking miniruby */
,
#line 189 "yjit.rb"
"    require 'stringio'\n"
"    strio = StringIO.new\n"
"    _print_stats(out: strio)\n"
"    strio.string\n"
"  end\n"
"\n"
"\n"/* Produce disassembly for an iseq. This requires a `--enable-yjit=dev` build. */
"  def self.disasm(iseq)\n"/* :nodoc: */
"\n"/* If a method or proc is passed in, get its iseq */
"    iseq = RubyVM::InstructionSequence.of(iseq)\n"
"\n"
"    if self.enabled?\n"
"\n"/* Produce the disassembly string */
"\n"/* Include the YARV iseq disasm in the string for additional context */
"      iseq.disasm + \"\\n\" + Primitive.rb_yjit_disasm_iseq(iseq)\n"
"    else\n"
"      iseq.disasm\n"
"    end\n"
"  end\n"
"\n"
"\n"/* Produce a list of instructions compiled by YJIT for an iseq */
"  def self.insns_compiled(iseq)\n"/* :nodoc: */
"    return nil unless self.enabled?\n"
"\n"
"\n"/* If a method or proc is passed in, get its iseq */
"    iseq = RubyVM::InstructionSequence.of(iseq)\n"
"    Primitive.rb_yjit_insns_compiled(iseq)\n"
"  end\n"
"\n"
"\n"/* Discard existing compiled code to reclaim memory */
"\n"/* and allow for recompilations in the future. */
"  def self.code_gc\n"
,
#line 221 "yjit.rb"
"    Primitive.rb_yjit_code_gc\n"
"  end\n"
"\n"
"  def self.simulate_oom!\n"/* :nodoc: */
"    Primitive.rb_yjit_simulate_oom_bang\n"
"  end\n"
"\n"
"\n"/* Avoid calling a Ruby method here to not interfere with compilation tests */
"  if Primitive.rb_yjit_stats_enabled_p\n"
"    at_exit { print_and_dump_stats }\n"
"  end\n"
"\n"
"  class << self\n"/* :stopdoc: */
"    private\n"
"\n"
"\n"/* Print stats and dump exit locations */
"    def print_and_dump_stats\n"
"      if Primitive.rb_yjit_print_stats_p\n"
"        _print_stats\n"
"      end\n"
"      _dump_locations\n"
"    end\n"
"\n"
"    def _dump_locations\n"/* :nodoc: */
"      return unless trace_exit_locations_enabled?\n"
"\n"
"      filename = \"yjit_exit_locations.dump\"\n"
,
#line 248 "yjit.rb"
"      dump_exit_locations(filename)\n"
"\n"
"      $stderr.puts(\"YJIT exit locations dumped to `#{filename}`.\")\n"
"    end\n"
"\n"
"\n"/* Print a summary of reasons for adverse performance events (e.g. exits) */
"    def _print_stats_reasons(stats, out)\n"/* :nodoc: */
"      print_counters(stats, out: out, prefix: 'send_', prompt: 'method call fallback reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'invokeblock_', prompt: 'invokeblock fallback reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'invokesuper_', prompt: 'invokesuper fallback reasons: ')\n"
,
#line 258 "yjit.rb"
"      print_counters(stats, out: out, prefix: 'guard_send_', prompt: 'method call exit reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'guard_invokeblock_', prompt: 'invokeblock exit reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'guard_invokesuper_', prompt: 'invokesuper exit reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'gbpp_', prompt: 'getblockparamproxy exit reasons: ')\n"
,
#line 262 "yjit.rb"
"      print_counters(stats, out: out, prefix: 'getivar_', prompt: 'getinstancevariable exit reasons:')\n"
"      print_counters(stats, out: out, prefix: 'setivar_', prompt: 'setinstancevariable exit reasons:')\n"
"      %w[\n"
"        branchif\n"
"        branchnil\n"
"        branchunless\n"
"        definedivar\n"
"        expandarray\n"
"        jump\n"
"        leave\n"
"        objtostring\n"
"        opt_aref\n"
"        opt_aref_with\n"
"        opt_aset\n"
"        opt_case_dispatch\n"
"        opt_div\n"
"        opt_getconstant_path\n"
"        opt_minus\n"
,
#line 280 "yjit.rb"
"        opt_mod\n"
"        opt_mult\n"
"        opt_plus\n"
"        setlocal\n"
"      ].each do |insn|\n"
"        print_counters(stats, out: out, prefix: \"#{insn}_\", prompt: \"#{insn} exit reasons:\", optional: true)\n"
"      end\n"
"      print_counters(stats, out: out, prefix: 'lshift_', prompt: 'left shift (ltlt) exit reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'invalidate_', prompt: 'invalidation reasons: ')\n"
"    end\n"
"\n"
"\n"/* Format and print out counters */
"    def _print_stats(out: $stderr)\n"/* :nodoc: */
"      stats = runtime_stats(context: true)\n"
,
#line 294 "yjit.rb"
"      return unless Primitive.rb_yjit_stats_enabled_p\n"
"\n"
"      out.puts(\"***YJIT: Printing YJIT statistics on exit***\")\n"
"\n"
"      _print_stats_reasons(stats, out)\n"
"\n"
"\n"/* Number of failed compiler invocations */
"      compilation_failure = stats[:compilation_failure]\n"
"\n"
"      code_region_overhead = stats[:code_region_size] - (stats[:inline_code_size] + stats[:outlined_code_size])\n"
"\n"
"      out.puts \"num_send:              \" + format_number(13, stats[:num_send])\n"
,
#line 306 "yjit.rb"
"      out.puts \"num_send_known_class:  \" + format_number_pct(13, stats[:num_send_known_class], stats[:num_send])\n"
"      out.puts \"num_send_polymorphic:  \" + format_number_pct(13, stats[:num_send_polymorphic], stats[:num_send])\n"
"      out.puts \"num_send_megamorphic:  \" + format_number_pct(13, stats[:send_megamorphic], stats[:num_send])\n"
"      out.puts \"num_send_dynamic:      \" + format_number_pct(13, stats[:num_send_dynamic], stats[:num_send])\n"
,
#line 310 "yjit.rb"
"      out.puts \"num_send_inline:       \" + format_number_pct(13, stats[:num_send_inline], stats[:num_send])\n"
"      out.puts \"num_send_leaf_builtin: \" + format_number_pct(13, stats[:num_send_leaf_builtin], stats[:num_send])\n"
"      out.puts \"num_send_cfunc:        \" + format_number_pct(13, stats[:num_send_cfunc], stats[:num_send])\n"
"      out.puts \"num_send_cfunc_inline: \" + format_number_pct(13, stats[:num_send_cfunc_inline], stats[:num_send_cfunc])\n"
,
#line 314 "yjit.rb"
"      if stats[:num_send_x86_rel32] != 0 || stats[:num_send_x86_reg] != 0\n"
"        out.puts \"num_send_x86_rel32:    \" + format_number(13,  stats[:num_send_x86_rel32])\n"
"        out.puts \"num_send_x86_reg:      \" + format_number(13, stats[:num_send_x86_reg])\n"
"      end\n"
"      out.puts \"num_getivar_megamorphic: \" + format_number(13, stats[:num_getivar_megamorphic])\n"
"      out.puts \"num_setivar_megamorphic: \" + format_number(13, stats[:num_setivar_megamorphic])\n"
,
#line 320 "yjit.rb"
"      out.puts \"num_throw:             \" + format_number(13, stats[:num_throw])\n"
"      out.puts \"num_throw_break:       \" + format_number_pct(13, stats[:num_throw_break], stats[:num_throw])\n"
"      out.puts \"num_throw_retry:       \" + format_number_pct(13, stats[:num_throw_retry], stats[:num_throw])\n"
"      out.puts \"num_throw_return:      \" + format_number_pct(13, stats[:num_throw_return], stats[:num_throw])\n"
"\n"
"      out.puts \"iseq_stack_too_large:  \" + format_number(13, stats[:iseq_stack_too_large])\n"
,
#line 326 "yjit.rb"
"      out.puts \"iseq_too_long:         \" + format_number(13, stats[:iseq_too_long])\n"
"      out.puts \"temp_reg_opnd:         \" + format_number(13, stats[:temp_reg_opnd])\n"
"      out.puts \"temp_mem_opnd:         \" + format_number(13, stats[:temp_mem_opnd])\n"
"      out.puts \"temp_spill:            \" + format_number(13, stats[:temp_spill])\n"
"      out.puts \"bindings_allocations:  \" + format_number(13, stats[:binding_allocations])\n"
"      out.puts \"bindings_set:          \" + format_number(13, stats[:binding_set])\n"
,
#line 332 "yjit.rb"
"      out.puts \"compilation_failure:   \" + format_number(13, compilation_failure) if compilation_failure != 0\n"
"      out.puts \"live_iseq_count:       \" + format_number(13, stats[:live_iseq_count])\n"
"      out.puts \"compiled_iseq_entry:   \" + format_number(13, stats[:compiled_iseq_entry])\n"
"      out.puts \"cold_iseq_entry:       \" + format_number_pct(13, stats[:cold_iseq_entry], stats[:compiled_iseq_entry] + stats[:cold_iseq_entry])\n"
,
#line 336 "yjit.rb"
"      out.puts \"compiled_iseq_count:   \" + format_number(13, stats[:compiled_iseq_count])\n"
"      out.puts \"compiled_blockid_count:\" + format_number(13, stats[:compiled_blockid_count])\n"
"      out.puts \"compiled_block_count:  \" + format_number(13, stats[:compiled_block_count])\n"
"      if stats[:compiled_blockid_count] != 0\n"
"        out.puts \"versions_per_block:    \" + format_number(13, \"%4.3f\" % (stats[:compiled_block_count].fdiv(stats[:compiled_blockid_count])))\n"
"      end\n"
,
#line 342 "yjit.rb"
"      out.puts \"compiled_branch_count: \" + format_number(13, stats[:compiled_branch_count])\n"
"      out.puts \"compile_time_ms:       \" + format_number(13, stats[:compile_time_ns] / (1000 * 1000))\n"
"      out.puts \"block_next_count:      \" + format_number(13, stats[:block_next_count])\n"
"      out.puts \"defer_count:           \" + format_number(13, stats[:defer_count])\n"
"      out.puts \"defer_empty_count:     \" + format_number(13, stats[:defer_empty_count])\n"
"\n"
,
#line 348 "yjit.rb"
"      out.puts \"branch_insn_count:     \" + format_number(13, stats[:branch_insn_count])\n"
"      out.puts \"branch_known_count:    \" + format_number_pct(13, stats[:branch_known_count], stats[:branch_insn_count])\n"
"\n"
"      out.puts \"freed_iseq_count:      \" + format_number(13, stats[:freed_iseq_count])\n"
"      out.puts \"invalidation_count:    \" + format_number(13, stats[:invalidation_count])\n"
"      out.puts \"constant_state_bumps:  \" + format_number(13, stats[:constant_state_bumps])\n"
,
#line 354 "yjit.rb"
"      out.puts \"inline_code_size:      \" + format_number(13, stats[:inline_code_size])\n"
"      out.puts \"outlined_code_size:    \" + format_number(13, stats[:outlined_code_size])\n"
"      out.puts \"code_region_size:      \" + format_number(13, stats[:code_region_size])\n"
"      out.puts \"code_region_overhead:  \" + format_number_pct(13, code_region_overhead, stats[:code_region_size])\n"
"\n"
"      out.puts \"freed_code_size:       \" + format_number(13, stats[:freed_code_size])\n"
,
#line 360 "yjit.rb"
"      out.puts \"yjit_alloc_size:       \" + format_number(13, stats[:yjit_alloc_size]) if stats.key?(:yjit_alloc_size)\n"
"      out.puts \"live_context_size:     \" + format_number(13, stats[:live_context_size])\n"
"      out.puts \"live_context_count:    \" + format_number(13, stats[:live_context_count])\n"
"      out.puts \"live_page_count:       \" + format_number(13, stats[:live_page_count])\n"
"      out.puts \"freed_page_count:      \" + format_number(13, stats[:freed_page_count])\n"
,
#line 365 "yjit.rb"
"      out.puts \"code_gc_count:         \" + format_number(13, stats[:code_gc_count])\n"
"      out.puts \"num_gc_obj_refs:       \" + format_number(13, stats[:num_gc_obj_refs])\n"
"      out.puts \"object_shape_count:    \" + format_number(13, stats[:object_shape_count])\n"
"      out.puts \"side_exit_count:       \" + format_number(13, stats[:side_exit_count])\n"
"      out.puts \"total_exit_count:      \" + format_number(13, stats[:total_exit_count])\n"
,
#line 370 "yjit.rb"
"      out.puts \"total_insns_count:     \" + format_number(13, stats[:total_insns_count])\n"
"      out.puts \"vm_insns_count:        \" + format_number(13, stats[:vm_insns_count])\n"
"      out.puts \"yjit_insns_count:      \" + format_number(13, stats[:yjit_insns_count])\n"
"      out.puts \"ratio_in_yjit:         \" + (\"%12.1f\" % stats[:ratio_in_yjit]) + \"%\"\n"
"      out.puts \"avg_len_in_yjit:       \" + (\"%13.1f\" % stats[:avg_len_in_yjit])\n"
"\n"
"      print_sorted_exit_counts(stats, out: out, prefix: \"exit_\")\n"
"\n"
,
#line 378 "yjit.rb"
"      print_sorted_cfunc_calls(stats, out:out)\n"
"    end\n"
"\n"
"    def print_sorted_cfunc_calls(stats, out:, how_many: 20, left_pad: 4)\n"/* :nodoc: */
"      calls = stats[:cfunc_calls]\n"
"      if calls.empty?\n"
"        return\n"
"      end\n"
"\n"
"\n"/* Total number of cfunc calls */
"      num_send_cfunc = stats[:num_send_cfunc]\n"
"\n"
"\n"/* Sort calls by decreasing frequency and keep the top N */
"      pairs = calls.map { |k,v| [k, v] }\n"
"      pairs.sort_by! {|pair| pair[1] }\n"
"      pairs.reverse!\n"
"      pairs = pairs[0...how_many]\n"
"\n"
"      top_n_total = pairs.sum { |name, count| count }\n"
"      top_n_pct = 100.0 * top_n_total / num_send_cfunc\n"
,
#line 398 "yjit.rb"
"      longest_name_len = pairs.max_by { |name, count| name.length }.first.length\n"
"\n"
"      out.puts \"Top-#{pairs.size} most frequent C calls (#{\"%.1f\" % top_n_pct}% of C calls):\"\n"
"\n"
"      pairs.each do |name, count|\n"
"        padding = longest_name_len + left_pad\n"
"        padded_name = \"%#{padding}s\" % name\n"
"        padded_count = format_number_pct(10, count, num_send_cfunc)\n"
"        out.puts(\"#{padded_name}: #{padded_count}\")\n"
"      end\n"
"    end\n"
"\n"
,
#line 410 "yjit.rb"
"    def print_sorted_exit_counts(stats, out:, prefix:, how_many: 20, left_pad: 4)\n"/* :nodoc: */
"      total_exits = total_exit_count(stats)\n"
"\n"
"      if total_exits > 0\n"
"        exits = []\n"
"        stats.each do |k, v|\n"
"          if k.start_with?(prefix)\n"
"            exits.push [k.to_s.delete_prefix(prefix), v]\n"
"          end\n"
"        end\n"
"\n"
"        exits = exits.select { |_name, count| count > 0 }.max_by(how_many) { |_name, count| count }\n"
"\n"
"        top_n_total = exits.sum { |name, count| count }\n"
,
#line 424 "yjit.rb"
"        top_n_exit_pct = 100.0 * top_n_total / total_exits\n"
"\n"
"        out.puts \"Top-#{exits.size} most frequent exit ops (#{\"%.1f\" % top_n_exit_pct}% of exits):\"\n"
"\n"
"        longest_insn_name_len = exits.max_by { |name, count| name.length }.first.length\n"
"        exits.each do |name, count|\n"
"          padding = longest_insn_name_len + left_pad\n"
"          padded_name = \"%#{padding}s\" % name\n"
"          padded_count = format_number_pct(10, count, total_exits)\n"
"          out.puts(\"#{padded_name}: #{padded_count}\")\n"
,
#line 434 "yjit.rb"
"        end\n"
"      else\n"
"        out.puts \"total_exits:           \" + format_number(10, total_exits)\n"
"      end\n"
"    end\n"
"\n"
"    def total_exit_count(stats, prefix: \"exit_\")\n"/* :nodoc: */
"      total = 0\n"
"      stats.each do |k,v|\n"
"        total += v if k.start_with?(prefix)\n"
"      end\n"
"      total\n"
"    end\n"
"\n"
"    def print_counters(counters, out:, prefix:, prompt:, optional: false)\n"/* :nodoc: */
"      counters = counters.filter { |key, _| key.start_with?(prefix) }\n"
"      counters.filter! { |_, value| value != 0 }\n"
,
#line 451 "yjit.rb"
"      counters.transform_keys! { |key| key.to_s.delete_prefix(prefix) }\n"
"\n"
"      if counters.empty?\n"
"        unless optional\n"
"          out.puts(prompt)\n"
"          out.puts(\"    (all relevant counters are zero)\")\n"
"        end\n"
"        return\n"
"      else\n"
"        out.puts(prompt)\n"
"      end\n"
"\n"
"      counters = counters.to_a\n"
"      counters.sort_by! { |(_, counter_value)| counter_value }\n"
"      longest_name_length = counters.max_by { |(name, _)| name.length }.first.length\n"
,
#line 466 "yjit.rb"
"      total = counters.sum { |(_, counter_value)| counter_value }\n"
"\n"
"      counters.reverse_each do |(name, value)|\n"
"        padded_name = name.rjust(longest_name_length, ' ')\n"
"        padded_count = format_number_pct(10, value, total)\n"
"        out.puts(\"    #{padded_name}: #{padded_count}\")\n"
"      end\n"
"    end\n"
"\n"
"\n"/* Format large numbers with comma separators for readability */
"    def format_number(pad, number)\n"
"      s = number.to_s\n"
"      i = s.index('.') || s.size\n"
"      s.insert(i -= 3, ',') while i > 3\n"
"      s.rjust(pad, ' ')\n"
"    end\n"
"\n"
"\n"/* Format a number along with a percentage over a total value */
,
#line 484 "yjit.rb"
"    def format_number_pct(pad, number, total)\n"
"      padded_count = format_number(pad, number)\n"
"      percentage = number.fdiv(total) * 100\n"
"      formatted_pct = \"%4.1f%%\" % percentage\n"
"      \"#{padded_count} (#{formatted_pct})\"\n"
"    end\n"
"  end\n"
"end\n"
#line 7277 "miniprelude.c"
};

COMPILER_WARNING_POP

#define PRELUDE_NAME(n) rb_usascii_str_new_static(prelude_name##n, sizeof(prelude_name##n)-1)
#define PRELUDE_CODE(n) rb_utf8_str_new_static(prelude_code##n.L0, sizeof(prelude_code##n))

static rb_ast_t *
prelude_ast(VALUE name, VALUE code, int line)
{
    rb_ast_t *ast = rb_parser_compile_string_path(rb_parser_new(), name, code, line);
    if (!ast || !ast->body.root) {
        if (ast) rb_ast_dispose(ast);
        rb_exc_raise(rb_errinfo());
    }
    return ast;
}

#define PRELUDE_AST(n, name_str, start_line) \
    (((sizeof(prelude_name##n) - prefix_len - 2) == namelen) && \
     (strncmp(prelude_name##n + prefix_len, feature_name, namelen) == 0) ? \
     prelude_ast((name_str) = PRELUDE_NAME(n), PRELUDE_CODE(n), start_line) : 0)

rb_ast_t *
rb_builtin_ast(const char *feature_name, VALUE *name_str)
{
    const size_t prefix_len = rb_strlen_lit("<internal:");
    size_t namelen = strlen(feature_name);
    rb_ast_t *ast = 0;

    if ((ast = PRELUDE_AST(0, *name_str, 20)) != 0) return ast;
    if ((ast = PRELUDE_AST(1, *name_str, 158)) != 0) return ast;
    if ((ast = PRELUDE_AST(2, *name_str, 11)) != 0) return ast;
    if ((ast = PRELUDE_AST(3, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(4, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(5, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(6, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(7, *name_str, 4)) != 0) return ast;
    if ((ast = PRELUDE_AST(8, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(9, *name_str, 50)) != 0) return ast;
    if ((ast = PRELUDE_AST(10, *name_str, 4)) != 0) return ast;
    if ((ast = PRELUDE_AST(11, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(12, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(13, *name_str, 239)) != 0) return ast;
    if ((ast = PRELUDE_AST(14, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(15, *name_str, 216)) != 0) return ast;
    if ((ast = PRELUDE_AST(16, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(17, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(18, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(19, *name_str, 1)) != 0) return ast;
    if ((ast = PRELUDE_AST(20, *name_str, 10)) != 0) return ast;
    return ast;
}

void
Init_prelude(void)
{
}
