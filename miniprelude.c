/* -*-c-*-
 THIS FILE WAS AUTOGENERATED BY template/prelude.c.tmpl. DO NOT EDIT.

 sources: ./ast, ./dir, ./gc, ./numeric, ./io, ./marshal, ./pack, ./trace_point, ./warning, ./array, ./hash, ./kernel, ./pathname_builtin, ./ractor, ./symbol, ./timev, ./thread_sync, ./nilclass, ./prelude, ./gem_prelude, ./jit_hook, ./jit_undef, ./yjit, ./zjit
*/
#include "internal.h"
#include "internal/ruby_parser.h"
#include "internal/warnings.h"
#include "iseq.h"
#include "ruby/internal/attr/nonstring.h"
#include "ruby/ruby.h"
#include "vm_core.h"

COMPILER_WARNING_PUSH
#if __has_warning("-Wstring-concatenation")
COMPILER_WARNING_IGNORED(-Wstring-concatenation)
#endif

static const char prelude_name0[] = "<internal:ast>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[508]; /* 1..87 */
    RBIMPL_ATTR_NONSTRING() char L87[498]; /* 88..147 */
    RBIMPL_ATTR_NONSTRING() char L147[491]; /* 148..190 */
    RBIMPL_ATTR_NONSTRING() char L190[465]; /* 191..265 */
    RBIMPL_ATTR_NONSTRING() char L265[505]; /* 266..312 */
    RBIMPL_ATTR_NONSTRING() char L312[199]; /* 313..333 */
} prelude_code0 = {
#line 1 "ast.rb"
""/* for ast.c */
""
""/* AbstractSyntaxTree provides methods to parse Ruby code into */
""/* abstract syntax trees. The nodes in the tree */
""/* are instances of RubyVM::AbstractSyntaxTree::Node. */
""/*  */
""/* This module is MRI specific as it exposes implementation details */
""/* of the MRI abstract syntax tree. */
""/*  */
""/* This module is experimental and its API is not stable, therefore it might */
""/* change without notice. As examples, the order of children nodes is not */
""/* guaranteed, the number of children nodes might change, there is no way to */
""/* access children nodes by name, etc. */
""/*  */
""/* If you are looking for a stable API or an API working under multiple Ruby */
""/* implementations, consider using the _prism_ gem, which is the official */
""/* Ruby API to parse Ruby code. */
""/*  */
"module RubyVM::AbstractSyntaxTree\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.parse(string, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false) -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*  */
"\n"/*  Parses the given _string_ into an abstract syntax tree, */
"\n"/*  returning the root node of that tree. */
"\n"/*  */
"\n"/*    RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\") */
"\n"/*    # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-1:9> */
"\n"/*  */
"\n"/*  If <tt>keep_script_lines: true</tt> option is provided, the text of the parsed */
"\n"/*  source is associated with nodes and is available via Node#script_lines. */
"\n"/*  */
"\n"/*  If <tt>keep_tokens: true</tt> option is provided, Node#tokens are populated. */
"\n"/*  */
"\n"/*  SyntaxError is raised if the given _string_ is invalid syntax. To overwrite this */
"\n"/*  behavior, <tt>error_tolerant: true</tt> can be provided. In this case, the parser */
"\n"/*  will produce a tree where expressions with syntax errors would be represented by */
"\n"/*  Node with <tt>type=:ERROR</tt>. */
"\n"/*  */
"\n"/*     root = RubyVM::AbstractSyntaxTree.parse(\"x = 1; p(x; y=2\") */
"\n"/*     # <internal:ast>:33:in `parse': syntax error, unexpected ';', expecting ')' (SyntaxError) */
"\n"/*     # x = 1; p(x; y=2 */
"\n"/*     #           ^ */
"\n"/*  */
"\n"/*     root = RubyVM::AbstractSyntaxTree.parse(\"x = 1; p(x; y=2\", error_tolerant: true) */
"\n"/*     # (SCOPE@1:0-1:15 */
"\n"/*     #  tbl: [:x, :y] */
"\n"/*     #  args: nil */
"\n"/*     #  body: (BLOCK@1:0-1:15 (LASGN@1:0-1:5 :x (LIT@1:4-1:5 1)) (ERROR@1:7-1:11) (LASGN@1:12-1:15 :y (LIT@1:14-1:15 2)))) */
"\n"/*     root.children.last.children */
"\n"/*     # [(LASGN@1:0-1:5 :x (LIT@1:4-1:5 1)), */
"\n"/*     #  (ERROR@1:7-1:11), */
"\n"/*     #  (LASGN@1:12-1:15 :y (LIT@1:14-1:15 2))] */
"\n"/*  */
"\n"/*  Note that parsing continues even after the errored expression. */
"\n"/*  */
"  def self.parse string, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false\n"
"    Primitive.ast_s_parse string, keep_script_lines, error_tolerant, keep_tokens\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.parse_file(pathname, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false) -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*  */
"\n"/*   Reads the file from _pathname_, then parses it like ::parse, */
"\n"/*   returning the root node of the abstract syntax tree. */
"\n"/*  */
"\n"/*   SyntaxError is raised if _pathname_'s contents are not */
"\n"/*   valid Ruby syntax. */
"\n"/*  */
"\n"/*     RubyVM::AbstractSyntaxTree.parse_file(\"my-app/app.rb\") */
"\n"/*     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-31:3> */
"\n"/*  */
"\n"/*   See ::parse for explanation of keyword argument meaning and usage. */
"  def self.parse_file pathname, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false\n"
"    Primitive.ast_s_parse_file pathname, keep_script_lines, error_tolerant, keep_tokens\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.of(proc, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false)   -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*     RubyVM::AbstractSyntaxTree.of(method, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false) -> RubyVM::AbstractSyntaxTree::Node */
"\n"/*  */
"\n"/*   Returns AST nodes of the given _proc_ or _method_. */
"\n"/*  */
"\n"/*     RubyVM::AbstractSyntaxTree.of(proc {1 + 2}) */
"\n"/*     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:35-1:42> */
"\n"/*  */
"\n"/*     def hello */
,
#line 88 "ast.rb"
"\n"/*       puts \"hello, world\" */
"\n"/*     end */
"\n"/*  */
"\n"/*     RubyVM::AbstractSyntaxTree.of(method(:hello)) */
"\n"/*     # => #<RubyVM::AbstractSyntaxTree::Node:SCOPE@1:0-3:3> */
"\n"/*  */
"\n"/*   See ::parse for explanation of keyword argument meaning and usage. */
"  def self.of body, keep_script_lines: RubyVM.keep_script_lines, error_tolerant: false, keep_tokens: false\n"
"    Primitive.ast_s_of body, keep_script_lines, error_tolerant, keep_tokens\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     RubyVM::AbstractSyntaxTree.node_id_for_backtrace_location(backtrace_location)   -> integer */
"\n"/*  */
"\n"/*   Returns the node id for the given backtrace location. */
"\n"/*  */
"\n"/*     begin */
"\n"/*       raise */
"\n"/*     rescue =>  e */
"\n"/*       loc = e.backtrace_locations.first */
"\n"/*       RubyVM::AbstractSyntaxTree.node_id_for_backtrace_location(loc) */
"\n"/*     end # => 0 */
"  def self.node_id_for_backtrace_location backtrace_location\n"
"    Primitive.node_id_for_backtrace_location backtrace_location\n"
"  end\n"
"\n"
"\n"/* RubyVM::AbstractSyntaxTree::Node instances are created by parse methods in */
"\n"/* RubyVM::AbstractSyntaxTree. */
"\n"/*  */
"\n"/* This class is MRI specific. */
"\n"/*  */
"  class Node\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.type -> symbol */
"\n"/*  */
"\n"/*  Returns the type of this node as a symbol. */
"\n"/*  */
"\n"/*    root = RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\") */
"\n"/*    root.type # => :SCOPE */
"\n"/*    lasgn = root.children[2] */
"\n"/*    lasgn.type # => :LASGN */
"\n"/*    call = lasgn.children[1] */
"\n"/*    call.type # => :OPCALL */
"    def type\n"
"      Primitive.ast_node_type\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.first_lineno -> integer */
"\n"/*  */
"\n"/*  The line number in the source code where this AST's text began. */
"    def first_lineno\n"
"      Primitive.ast_node_first_lineno\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.first_column -> integer */
"\n"/*  */
"\n"/*  The column number in the source code where this AST's text began. */
,
#line 148 "ast.rb"
"    def first_column\n"
"      Primitive.ast_node_first_column\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.last_lineno -> integer */
"\n"/*  */
"\n"/*  The line number in the source code where this AST's text ended. */
"    def last_lineno\n"
"      Primitive.ast_node_last_lineno\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.last_column -> integer */
"\n"/*  */
"\n"/*  The column number in the source code where this AST's text ended. */
"    def last_column\n"
"      Primitive.ast_node_last_column\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.tokens -> array */
"\n"/*  */
"\n"/*  Returns tokens corresponding to the location of the node. */
"\n"/*  Returns +nil+ if +keep_tokens+ is not enabled when #parse method is called. */
"\n"/*  */
"\n"/*    root = RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\", keep_tokens: true) */
"\n"/*    root.tokens # => [[0, :tIDENTIFIER, \"x\", [1, 0, 1, 1]], [1, :tSP, \" \", [1, 1, 1, 2]], ...] */
"\n"/*    root.tokens.map{_1[2]}.join # => \"x = 1 + 2\" */
"\n"/*  */
"\n"/*  Token is an array of: */
"\n"/*  */
"\n"/*  - id */
"\n"/*  - token type */
"\n"/*  - source code text */
"\n"/*  - location [ first_lineno, first_column, last_lineno, last_column ] */
"    def tokens\n"
"      return nil unless all_tokens\n"
"\n"
"      all_tokens.each_with_object([]) do |token, a|\n"
"        loc = token.last\n"
"        if ([first_lineno, first_column] <=> [loc[0], loc[1]]) <= 0 &&\n"
"           ([last_lineno, last_column]   <=> [loc[2], loc[3]]) >= 0\n"
,
#line 191 "ast.rb"
"           a << token\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.all_tokens -> array */
"\n"/*  */
"\n"/*  Returns all tokens for the input script regardless the receiver node. */
"\n"/*  Returns +nil+ if +keep_tokens+ is not enabled when #parse method is called. */
"\n"/*  */
"\n"/*    root = RubyVM::AbstractSyntaxTree.parse(\"x = 1 + 2\", keep_tokens: true) */
"\n"/*    root.all_tokens # => [[0, :tIDENTIFIER, \"x\", [1, 0, 1, 1]], [1, :tSP, \" \", [1, 1, 1, 2]], ...] */
"\n"/*    root.children[-1].all_tokens # => [[0, :tIDENTIFIER, \"x\", [1, 0, 1, 1]], [1, :tSP, \" \", [1, 1, 1, 2]], ...] */
"    def all_tokens\n"
"      Primitive.ast_node_all_tokens\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.children -> array */
"\n"/*  */
"\n"/*  Returns AST nodes under this one.  Each kind of node */
"\n"/*  has different children, depending on what kind of node it is. */
"\n"/*  */
"\n"/*  The returned array may contain other nodes or <code>nil</code>. */
"    def children\n"
"      Primitive.ast_node_children\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.inspect -> string */
"\n"/*  */
"\n"/*  Returns debugging information about this node as a string. */
"    def inspect\n"
"      Primitive.ast_node_inspect\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.node_id -> integer */
"\n"/*  */
"\n"/*  Returns an internal node_id number. */
"\n"/*  Note that this is an API for ruby internal use, debugging, */
"\n"/*  and research. Do not use this for any other purpose. */
"\n"/*  The compatibility is not guaranteed. */
"    def node_id\n"
"      Primitive.ast_node_node_id\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.script_lines -> array */
"\n"/*  */
"\n"/*  Returns the original source code as an array of lines. */
"\n"/*  */
"\n"/*  Note that this is an API for ruby internal use, debugging, */
"\n"/*  and research. Do not use this for any other purpose. */
"\n"/*  The compatibility is not guaranteed. */
"    def script_lines\n"
"      Primitive.ast_node_script_lines\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.source -> string */
"\n"/*  */
"\n"/*  Returns the code fragment that corresponds to this AST. */
"\n"/*  */
"\n"/*  Note that this is an API for ruby internal use, debugging, */
"\n"/*  and research. Do not use this for any other purpose. */
"\n"/*  The compatibility is not guaranteed. */
"\n"/*  */
"\n"/*  Also note that this API may return an incomplete code fragment */
"\n"/*  that does not parse; for example, a here document following */
"\n"/*  an expression may be dropped. */
"    def source\n"
"      lines = script_lines\n"
"      if lines\n"
,
#line 266 "ast.rb"
"        lines = lines[first_lineno - 1 .. last_lineno - 1]\n"
"        lines[-1] = lines[-1].byteslice(0...last_column)\n"
"        lines[0] = lines[0].byteslice(first_column..-1)\n"
"        lines.join\n"
"      else\n"
"        nil\n"
"      end\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     node.locations -> array */
"\n"/*  */
"\n"/*  Returns location objects associated with the AST node. */
"\n"/*  The returned array contains RubyVM::AbstractSyntaxTree::Location. */
"    def locations\n"
"      Primitive.ast_node_locations\n"
"    end\n"
"  end\n"
"\n"
"\n"/* RubyVM::AbstractSyntaxTree::Location instances are created by */
"\n"/* RubyVM::AbstractSyntaxTree::Node#locations. */
"\n"/*  */
"\n"/* This class is MRI specific. */
"\n"/*  */
"  class Location\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     location.first_lineno -> integer */
"\n"/*  */
"\n"/*  The line number in the source code where this AST's text began. */
"    def first_lineno\n"
"      Primitive.ast_location_first_lineno\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     location.first_column -> integer */
"\n"/*  */
"\n"/*  The column number in the source code where this AST's text began. */
"    def first_column\n"
"      Primitive.ast_location_first_column\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     location.last_lineno -> integer */
"\n"/*  */
"\n"/*  The line number in the source code where this AST's text ended. */
"    def last_lineno\n"
,
#line 313 "ast.rb"
"      Primitive.ast_location_last_lineno\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     location.last_column -> integer */
"\n"/*  */
"\n"/*  The column number in the source code where this AST's text ended. */
"    def last_column\n"
"      Primitive.ast_location_last_column\n"
"    end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*     location.inspect -> string */
"\n"/*  */
"\n"/*  Returns debugging information about this location as a string. */
"    def inspect\n"
"      Primitive.ast_location_inspect\n"
"    end\n"
"  end\n"
"end\n"
#line 372 "miniprelude.c"
};

static const char prelude_name1[] = "<internal:dir>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[508]; /* 1..266 */
    RBIMPL_ATTR_NONSTRING() char L266[497]; /* 267..507 */
} prelude_code1 = {
#line 1 "dir.rb"
""/* An object of class \\Dir represents a directory in the underlying file system. */
""/*  */
""/* It consists mainly of: */
""/*  */
""/* - A string _path_, given when the object is created, */
""/*   that specifies a directory in the underlying file system; */
""/*   method #path returns the path. */
""/* - A collection of string <i>entry names</i>, */
""/*   each of which is the name of a directory or file in the underlying file system; */
""/*   the entry names may be retrieved */
""/*   in an {array-like fashion}[rdoc-ref:Dir@Dir+As+Array-Like] */
""/*   or in a {stream-like fashion}[rdoc-ref:Dir@Dir+As+Stream-Like]. */
""/*  */
""/* == About the Examples */
""/*  */
""/* Some examples on this page use this simple file tree: */
""/*  */
""/*   example/ */
""/*   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 config.h */
""/*   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 lib/ */
""/*   \xE2\x94\x82   \xE2\x94\x9C\xE2\x94\x80\xE2\x94\x80 song/ */
""/*   \xE2\x94\x82   \xE2\x94\x82   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 karaoke.rb */
""/*   \xE2\x94\x82   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 song.rb */
""/*   \xE2\x94\x94\xE2\x94\x80\xE2\x94\x80 main.rb */
""/*  */
""/* Others use the file tree for the */
""/* {Ruby project itself}[https://github.com/ruby/ruby]. */
""/*  */
""/* == \\Dir As \\Array-Like */
""/*  */
""/* A \\Dir object is in some ways array-like: */
""/*  */
""/* - It has instance methods #children, #each, and #each_child. */
""/* - It includes {module Enumerable}[rdoc-ref:Enumerable@What-27s+Here]. */
""/*  */
""/* == \\Dir As Stream-Like */
""/*  */
""/* A \\Dir object is in some ways stream-like. */
""/*  */
""/* The stream is initially open for reading, */
""/* but may be closed manually (using method #close), */
""/* and will be closed on block exit if created by Dir.open called with a block. */
""/* The closed stream may not be further manipulated, */
""/* and may not be reopened. */
""/*  */
""/* The stream has a _position_, which is the index of an entry in the directory: */
""/*  */
""/* - The initial position is zero (before the first entry). */
""/* - Method #tell (aliased as #pos) returns the position. */
""/* - Method #pos= sets the position (but ignores a value outside the stream), */
""/*   and returns the position. */
""/* - Method #seek is like #pos=, but returns +self+ (convenient for chaining). */
""/* - Method #read, if not at end-of-stream, reads the next entry and increments */
""/*   the position; */
""/*   if at end-of-stream, does not increment the position. */
""/* - Method #rewind sets the position to zero. */
""/*  */
""/* Examples (using the {simple file tree}[rdoc-ref:Dir@About+the+Examples]): */
""/*  */
""/*   dir = Dir.new('example') # => #<Dir:example> */
""/*   dir.pos                  # => 0 */
""/*  */
""/*   dir.read # => \".\" */
""/*   dir.read # => \"..\" */
""/*   dir.read # => \"config.h\" */
""/*   dir.read # => \"lib\" */
""/*   dir.read # => \"main.rb\" */
""/*   dir.pos  # => 5 */
""/*   dir.read # => nil */
""/*   dir.pos  # => 5 */
""/*  */
""/*   dir.rewind # => #<Dir:example> */
""/*   dir.pos    # => 0 */
""/*  */
""/*   dir.pos = 3 # => 3 */
""/*   dir.pos     # => 3 */
""/*  */
""/*   dir.seek(4) # => #<Dir:example> */
""/*   dir.pos     # => 4 */
""/*  */
""/*   dir.close # => nil */
""/*   dir.read  # Raises IOError. */
""/*  */
""/* == What's Here */
""/*  */
""/* First, what's elsewhere. Class \\Dir: */
""/*  */
""/* - Inherits from {class Object}[rdoc-ref:Object@What-27s+Here]. */
""/* - Includes {module Enumerable}[rdoc-ref:Enumerable@What-27s+Here], */
""/*   which provides dozens of additional methods. */
""/*  */
""/* Here, class \\Dir provides methods that are useful for: */
""/*  */
""/* - {Reading}[rdoc-ref:Dir@Reading] */
""/* - {Setting}[rdoc-ref:Dir@Setting] */
""/* - {Querying}[rdoc-ref:Dir@Querying] */
""/* - {Iterating}[rdoc-ref:Dir@Iterating] */
""/* - {Other}[rdoc-ref:Dir@Other] */
""/*  */
""/* === Reading */
""/*  */
""/* - #close: Closes the directory stream for +self+. */
""/* - #pos=: Sets the position in the directory stream for +self+. */
""/* - #read: Reads and returns the next entry in the directory stream for +self+. */
""/* - #rewind: Sets the position in the directory stream for +self+ to the first entry. */
""/* - #seek: Sets the position in the directory stream for +self+ */
""/*   the entry at the given offset. */
""/*  */
""/* === Setting */
""/*  */
""/* - ::chdir: Changes the working directory of the current process */
""/*   to the given directory. */
""/* - ::chroot: Changes the file-system root for the current process */
""/*   to the given directory. */
""/*  */
""/* === Querying */
""/*  */
""/* - ::[]: Same as ::glob without the ability to pass flags. */
""/* - ::children: Returns an array of names of the children */
""/*   (both files and directories) of the given directory, */
""/*   but not including <tt>.</tt> or <tt>..</tt>. */
""/* - ::empty?: Returns whether the given path is an empty directory. */
""/* - ::entries: Returns an array of names of the children */
""/*   (both files and directories) of the given directory, */
""/*   including <tt>.</tt> and <tt>..</tt>. */
""/* - ::exist?: Returns whether the given path is a directory. */
""/* - ::getwd (aliased as #pwd): Returns the path to the current working directory. */
""/* - ::glob: Returns an array of file paths matching the given pattern and flags. */
""/* - ::home: Returns the home directory path for a given user or the current user. */
""/* - #children: Returns an array of names of the children */
""/*   (both files and directories) of +self+, */
""/*   but not including <tt>.</tt> or <tt>..</tt>. */
""/* - #fileno: Returns the integer file descriptor for +self+. */
""/* - #path (aliased as #to_path): Returns the path used to create +self+. */
""/* - #tell (aliased as #pos): Returns the integer position */
""/*   in the directory stream for +self+. */
""/*  */
""/* === Iterating */
""/*  */
""/* - ::each_child: Calls the given block with each entry in the given directory, */
""/*   but not including <tt>.</tt> or <tt>..</tt>. */
""/* - ::foreach: Calls the given block with each entry in the given directory, */
""/*   including <tt>.</tt> and <tt>..</tt>. */
""/* - #each: Calls the given block with each entry in +self+, */
""/*   including <tt>.</tt> and <tt>..</tt>. */
""/* - #each_child: Calls the given block with each entry in +self+, */
""/*   but not including <tt>.</tt> or <tt>..</tt>. */
""/*  */
""/* === Other */
""/*  */
""/* - ::mkdir: Creates a directory at the given path, with optional permissions. */
""/* - ::new: Returns a new \\Dir for the given path, with optional encoding. */
""/* - ::open: Same as ::new, but if a block is given, yields the \\Dir to the block, */
""/*   closing it upon block exit. */
""/* - ::unlink (aliased as ::delete and ::rmdir): Removes the given directory. */
""/* - #inspect: Returns a string description of +self+. */
""/*  */
"class Dir\n"
"\n"/* call-seq: */
"\n"/*   Dir.open(dirpath) -> dir */
"\n"/*   Dir.open(dirpath, encoding: nil) -> dir */
"\n"/*   Dir.open(dirpath) {|dir| ... } -> object */
"\n"/*   Dir.open(dirpath, encoding: nil) {|dir| ... } -> object */
"\n"/*  */
"\n"/* Creates a new \\Dir object _dir_ for the directory at +dirpath+. */
"\n"/*  */
"\n"/* With no block, the method equivalent to Dir.new(dirpath, encoding): */
"\n"/*  */
"\n"/*   Dir.open('.') # => #<Dir:.> */
"\n"/*  */
"\n"/* With a block given, the block is called with the created _dir_; */
"\n"/* on block exit _dir_ is closed and the block's value is returned: */
"\n"/*  */
"\n"/*   Dir.open('.') {|dir| dir.inspect } # => \"#<Dir:.>\" */
"\n"/*  */
"\n"/* The value given with optional keyword argument +encoding+ */
"\n"/* specifies the encoding for the directory entry names; */
"\n"/* if +nil+ (the default), the file system's encoding is used: */
"\n"/*  */
"\n"/*   Dir.open('.').read.encoding                       # => #<Encoding:UTF-8> */
"\n"/*   Dir.open('.', encoding: Encoding::US_ASCII).read.encoding # => #<Encoding:US-ASCII> */
"\n"/*  */
"  def self.open(name, encoding: nil, &block)\n"
"    dir = Primitive.dir_s_open(name, encoding)\n"
"    if block\n"
"      begin\n"
"        yield dir\n"
"      ensure\n"
"        Primitive.dir_s_close(dir)\n"
"      end\n"
"    else\n"
"      dir\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Dir.new(dirpath) -> dir */
"\n"/*   Dir.new(dirpath, encoding: nil) -> dir */
"\n"/*  */
"\n"/* Returns a new \\Dir object for the directory at +dirpath+: */
"\n"/*  */
"\n"/*   Dir.new('.') # => #<Dir:.> */
"\n"/*  */
"\n"/* The value given with optional keyword argument +encoding+ */
"\n"/* specifies the encoding for the directory entry names; */
"\n"/* if +nil+ (the default), the file system's encoding is used: */
"\n"/*  */
"\n"/*   Dir.new('.').read.encoding                       # => #<Encoding:UTF-8> */
"\n"/*   Dir.new('.', encoding: Encoding::US_ASCI).read.encoding # => #<Encoding:US-ASCII> */
"\n"/*  */
"  def initialize(name, encoding: nil)\n"
"    Primitive.dir_initialize(name, encoding)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Dir[*patterns, base: nil, sort: true] -> array */
"\n"/*  */
"\n"/* Calls Dir.glob with argument +patterns+ */
"\n"/* and the values of keyword arguments +base+ and +sort+; */
"\n"/* returns the array of selected entry names. */
"\n"/*  */
"  def self.[](*args, base: nil, sort: true)\n"
"    Primitive.dir_s_aref(args, base, sort)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Dir.glob(patterns, flags: 0, base: nil, sort: true) -> array */
"\n"/*   Dir.glob(patterns, flags: 0, base: nil, sort: true) {|entry_name| ... } -> nil */
"\n"/*  */
"\n"/* Forms an array _entry_names_ of the entry names selected by the arguments. */
"\n"/*  */
"\n"/* Argument +patterns+ is a string pattern or an array of string patterns; */
"\n"/* note that these are not regexps; see below. */
"\n"/*  */
"\n"/* Notes for the following examples: */
"\n"/*  */
"\n"/* - <tt>'*'</tt> is the pattern that matches any entry name */
"\n"/*   except those that begin with <tt>'.'</tt>. */
"\n"/* - We use method Array#take to shorten returned arrays */
"\n"/*   that otherwise would be very large. */
"\n"/*  */
"\n"/* With no block, returns array _entry_names_; */
"\n"/* example (using the {simple file tree}[rdoc-ref:Dir@About+the+Examples]): */
"\n"/*  */
"\n"/*   Dir.glob('*') # => [\"config.h\", \"lib\", \"main.rb\"] */
"\n"/*  */
"\n"/* With a block, calls the block with each of the _entry_names_ */
"\n"/* and returns +nil+: */
"\n"/*  */
"\n"/*   Dir.glob('*') {|entry_name| puts entry_name } # => nil */
"\n"/*  */
"\n"/* Output: */
"\n"/*  */
"\n"/*   config.h */
"\n"/*   lib */
"\n"/*   main.rb */
"\n"/*  */
"\n"/* If optional keyword argument +flags+ is given, */
"\n"/* the value modifies the matching; see below. */
"\n"/*  */
"\n"/* If optional keyword argument +base+ is given, */
"\n"/* its value specifies the base directory. */
"\n"/* Each pattern string specifies entries relative to the base directory; */
"\n"/* the default is <tt>'.'</tt>. */
"\n"/* The base directory is not prepended to the entry names in the result: */
"\n"/*  */
,
#line 267 "dir.rb"
"\n"/*   Dir.glob(pattern, base: 'lib').take(5) */
"\n"/*   # => [\"abbrev.gemspec\", \"abbrev.rb\", \"base64.gemspec\", \"base64.rb\", \"benchmark.gemspec\"] */
"\n"/*   Dir.glob(pattern, base: 'lib/irb').take(5) */
"\n"/*   # => [\"cmd\", \"color.rb\", \"color_printer.rb\", \"completion.rb\", \"context.rb\"] */
"\n"/*  */
"\n"/* If optional keyword +sort+ is given, its value specifies whether */
"\n"/* the array is to be sorted; the default is +true+. */
"\n"/* Passing value +false+ with that keyword disables sorting */
"\n"/* (though the underlying file system may already have sorted the array). */
"\n"/*  */
"\n"/* <b>Patterns</b> */
"\n"/*  */
"\n"/* Each pattern string is expanded */
"\n"/* according to certain metacharacters; */
"\n"/* examples below use the {Ruby file tree}[rdoc-ref:Dir@About+the+Examples]: */
"\n"/*  */
"\n"/* - <tt>'*'</tt>: Matches any substring in an entry name, */
"\n"/*   similar in meaning to regexp <tt>/.*\/mx</tt>; */
"\n"/*   may be restricted by other values in the pattern strings: */
"\n"/*  */
"\n"/*   - <tt>'*'</tt> matches all entry names: */
"\n"/*  */
"\n"/*       Dir.glob('*').take(3)  # => [\"BSDL\", \"CONTRIBUTING.md\", \"COPYING\"] */
"\n"/*  */
"\n"/*   - <tt>'c*'</tt> matches entry names beginning with <tt>'c'</tt>: */
"\n"/*  */
"\n"/*       Dir.glob('c*').take(3) # => [\"CONTRIBUTING.md\", \"COPYING\", \"COPYING.ja\"] */
"\n"/*  */
"\n"/*   - <tt>'*c'</tt> matches entry names ending with <tt>'c'</tt>: */
"\n"/*  */
"\n"/*       Dir.glob('*c').take(3) # => [\"addr2line.c\", \"array.c\", \"ast.c\"] */
"\n"/*  */
"\n"/*   - <tt>'\\*c\\*'</tt> matches entry names that contain <tt>'c'</tt>, */
"\n"/*     even at the beginning or end: */
"\n"/*  */
"\n"/*       Dir.glob('*c*').take(3) # => [\"CONTRIBUTING.md\", \"COPYING\", \"COPYING.ja\"] */
"\n"/*  */
"\n"/*   Does not match Unix-like hidden entry names (\"dot files\"). */
"\n"/*   To include those in the matched entry names, */
"\n"/*   use flag IO::FNM_DOTMATCH or something like <tt>'{*,.*}'</tt>. */
"\n"/*  */
"\n"/*  - <tt>'**'</tt>: Matches entry names recursively */
"\n"/*    if followed by  the slash character <tt>'/'</tt>: */
"\n"/*  */
"\n"/*      Dir.glob('**\/').take(3) # => [\"basictest/\", \"benchmark/\", \"benchmark/gc/\"] */
"\n"/*  */
"\n"/*    If the string pattern contains other characters */
"\n"/*    or is not followed by a slash character, */
"\n"/*    it is equivalent to <tt>'*'</tt>. */
"\n"/*  */
"\n"/* - <tt>'?'</tt> Matches any single character; */
"\n"/*   similar in meaning to regexp <tt>/./</tt>: */
"\n"/*  */
"\n"/*     Dir.glob('io.?') # => [\"io.c\"] */
"\n"/*  */
"\n"/* - <tt>'[_set_]'</tt>: Matches any one character in the string _set_; */
"\n"/*   behaves like a {Regexp character class}[rdoc-ref:Regexp@Character+Classes], */
"\n"/*   including set negation (<tt>'[^a-z]'</tt>): */
"\n"/*  */
"\n"/*     Dir.glob('*.[a-z][a-z]').take(3) */
"\n"/*     # => [\"CONTRIBUTING.md\", \"COPYING.ja\", \"KNOWNBUGS.rb\"] */
"\n"/*  */
"\n"/* - <tt>'{_abc_,_xyz_}'</tt>: */
"\n"/*   Matches either string _abc_ or string _xyz_; */
"\n"/*   behaves like {Regexp alternation}[rdoc-ref:Regexp@Alternation]: */
"\n"/*  */
"\n"/*     Dir.glob('{LEGAL,BSDL}') # => [\"LEGAL\", \"BSDL\"] */
"\n"/*  */
"\n"/*   More than two alternatives may be given. */
"\n"/*  */
"\n"/* - <tt>\\\\</tt>: Escapes the following metacharacter. */
"\n"/*  */
"\n"/*   Note that on Windows, the backslash character may not be used */
"\n"/*   in a string pattern: */
"\n"/*   <tt>Dir['c:\\\\foo*']</tt> will not work, use <tt>Dir['c:/foo*']</tt> instead. */
"\n"/*  */
"\n"/* More examples (using the {simple file tree}[rdoc-ref:Dir@About+the+Examples]): */
"\n"/*  */
"\n"/*   # We're in the example directory. */
"\n"/*   File.basename(Dir.pwd) # => \"example\" */
"\n"/*   Dir.glob('config.?')              # => [\"config.h\"] */
"\n"/*   Dir.glob('*.[a-z][a-z]')          # => [\"main.rb\"] */
"\n"/*   Dir.glob('*.[^r]*')               # => [\"config.h\"] */
"\n"/*   Dir.glob('*.{rb,h}')              # => [\"main.rb\", \"config.h\"] */
"\n"/*   Dir.glob('*')                     # => [\"config.h\", \"lib\", \"main.rb\"] */
"\n"/*   Dir.glob('*', File::FNM_DOTMATCH) # => [\".\", \"config.h\", \"lib\", \"main.rb\"] */
"\n"/*   Dir.glob([\"*.rb\", \"*.h\"])         # => [\"main.rb\", \"config.h\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/\*.rb') */
"\n"/*   => [\"lib/song/karaoke.rb\", \"lib/song.rb\", \"main.rb\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/\*.rb', base: 'lib')  #   => [\"song/karaoke.rb\", \"song.rb\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/lib')                # => [\"lib\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/lib/\**\/\*.rb')        # => [\"lib/song/karaoke.rb\", \"lib/song.rb\"] */
"\n"/*  */
"\n"/*   Dir.glob('**\/lib/\*.rb')           # => [\"lib/song.rb\"] */
"\n"/*  */
"\n"/* <b>Flags</b> */
"\n"/*  */
"\n"/* If optional keyword argument +flags+ is given (the default is zero -- no flags), */
"\n"/* its value should be the bitwise OR of one or more of the constants */
"\n"/* defined in module File::Constants. */
"\n"/*  */
"\n"/* Example: */
"\n"/*  */
"\n"/*   flags = File::FNM_EXTGLOB | File::FNM_DOTMATCH */
"\n"/*  */
"\n"/* Specifying flags can extend, restrict, or otherwise modify the matching. */
"\n"/*  */
"\n"/* The flags for this method (other constants in File::Constants do not apply): */
"\n"/*  */
"\n"/* - File::FNM_DOTMATCH: */
"\n"/*   specifies that entry names beginning with <tt>'.'</tt> */
"\n"/*   should be considered for matching: */
"\n"/*  */
"\n"/*     Dir.glob('*').take(5) */
"\n"/*     # => [\"BSDL\", \"CONTRIBUTING.md\", \"COPYING\", \"COPYING.ja\", \"GPL\"] */
"\n"/*     Dir.glob('*', flags: File::FNM_DOTMATCH).take(5) */
"\n"/*     # => [\".\", \".appveyor.yml\", \".cirrus.yml\", \".dir-locals.el\", \".document\"] */
"\n"/*  */
"\n"/* - File::FNM_EXTGLOB: */
"\n"/*   enables the pattern extension */
"\n"/*   <tt>'{_a_,_b_}'</tt>, which matches pattern _a_ and pattern _b_; */
"\n"/*   behaves like a */
"\n"/*   {regexp union}[rdoc-ref:Regexp.union] */
"\n"/*   (e.g., <tt>'(?:_a_|_b_)'</tt>): */
"\n"/*  */
"\n"/*     pattern = '{LEGAL,BSDL}' */
"\n"/*     Dir.glob(pattern)      # => [\"LEGAL\", \"BSDL\"] */
"\n"/*  */
"\n"/* - File::FNM_NOESCAPE: */
"\n"/*   specifies that escaping with the backslash character <tt>'\\'</tt> */
"\n"/*   is disabled; the character is not an escape character. */
"\n"/*  */
"\n"/* - File::FNM_PATHNAME: */
"\n"/*   specifies that metacharacters <tt>'*'</tt> and <tt>'?'</tt> */
"\n"/*   do not match directory separators. */
"\n"/*  */
"\n"/* - File::FNM_SHORTNAME: */
"\n"/*   specifies that patterns may match short names if they exist; Windows only. */
"\n"/*  */
"  def self.glob(pattern, _flags = 0, flags: _flags, base: nil, sort: true)\n"
"    Primitive.attr! :use_block\n"
"    Primitive.dir_s_glob(pattern, flags, base, sort)\n"
"  end\n"
"end\n"
"\n"
"class << File\n"
"\n"/* call-seq: */
"\n"/*    File.fnmatch( pattern, path, [flags] ) -> (true or false) */
"\n"/*    File.fnmatch?( pattern, path, [flags] ) -> (true or false) */
"\n"/*  */
"\n"/* Returns true if +path+ matches against +pattern+.  The pattern is not a */
"\n"/* regular expression; instead it follows rules similar to shell filename */
"\n"/* globbing.  It may contain the following metacharacters: */
"\n"/*  */
"\n"/* <code>*</code>:: */
"\n"/*   Matches any file. Can be restricted by other values in the glob. */
"\n"/*   Equivalent to <code>/.*\/x</code> in regexp. */
"\n"/*  */
"\n"/*   <code>*</code>::    Matches all regular files */
"\n"/*   <code>c*</code>::   Matches all files beginning with <code>c</code> */
"\n"/*   <code>*c</code>::   Matches all files ending with <code>c</code> */
"\n"/*   <code>\\*c*</code>:: Matches all files that have <code>c</code> in them */
"\n"/*                       (including at the beginning or end). */
"\n"/*  */
"\n"/*   To match hidden files (that start with a <code>.</code>) set the */
"\n"/*   File::FNM_DOTMATCH flag. */
"\n"/*  */
"\n"/* <code>**</code>:: */
"\n"/*   Matches directories recursively or files expansively. */
"\n"/*  */
"\n"/* <code>?</code>:: */
"\n"/*   Matches any one character. Equivalent to <code>/.{1}/</code> in regexp. */
"\n"/*  */
"\n"/* <code>[set]</code>:: */
"\n"/*   Matches any one character in +set+.  Behaves exactly like character sets */
"\n"/*   in Regexp, including set negation (<code>[^a-z]</code>). */
"\n"/*  */
"\n"/* <code>\\\\</code>:: */
"\n"/*   Escapes the next metacharacter. */
"\n"/*  */
"\n"/* <code>{a,b}</code>:: */
"\n"/*   Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled. */
"\n"/*   Behaves like a Regexp union (<code>(?:a|b)</code>). */
"\n"/*  */
"\n"/* +flags+ is a bitwise OR of the <code>FNM_XXX</code> constants. The same */
"\n"/* glob pattern and flags are used by Dir::glob. */
"\n"/*  */
"\n"/* Examples: */
"\n"/*  */
"\n"/*    File.fnmatch('cat',       'cat')        #=> true  # match entire string */
"\n"/*    File.fnmatch('cat',       'category')   #=> false # only match partial string */
"\n"/*  */
"\n"/*    File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default */
"\n"/*    File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB */
"\n"/*  */
"\n"/*    File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character */
"\n"/*    File.fnmatch('c??t',    'cat')          #=> false # ditto */
"\n"/*    File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters */
"\n"/*    File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto */
"\n"/*    File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression */
"\n"/*    File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!') */
"\n"/*  */
"\n"/*    File.fnmatch('cat', 'CAT')                     #=> false # case sensitive */
"\n"/*    File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive */
"\n"/*    File.fnmatch('cat', 'CAT', File::FNM_SYSCASE)  #=> true or false # depends on the system default */
"\n"/*  */
"\n"/*    File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME */
"\n"/*    File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto */
"\n"/*    File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto */
"\n"/*  */
"\n"/*    File.fnmatch('\\?',   '?')                       #=> true  # escaped wildcard becomes ordinary */
"\n"/*    File.fnmatch('\\a',   'a')                       #=> true  # escaped ordinary remains ordinary */
"\n"/*    File.fnmatch('\\a',   '\\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\\' ordinary */
"\n"/*    File.fnmatch('[\\?]', '?')                       #=> true  # can escape inside bracket expression */
"\n"/*  */
"\n"/*    File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading */
"\n"/*    File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default. */
"\n"/*    File.fnmatch('.*',  '.profile')                      #=> true */
"\n"/*  */
"\n"/*    File.fnmatch('**\/\*.rb', 'main.rb')                  #=> false */
"\n"/*    File.fnmatch('**\/\*.rb', './main.rb')                #=> false */
"\n"/*    File.fnmatch('**\/\*.rb', 'lib/song.rb')              #=> true */
"\n"/*    File.fnmatch('**.rb', 'main.rb')                    #=> true */
"\n"/*    File.fnmatch('**.rb', './main.rb')                  #=> false */
"\n"/*    File.fnmatch('**.rb', 'lib/song.rb')                #=> true */
"\n"/*    File.fnmatch('*',     'dave/.profile')              #=> true */
"\n"/*  */
"\n"/*    File.fnmatch('**\/foo', 'a/b/c/foo', File::FNM_PATHNAME)     #=> true */
"\n"/*    File.fnmatch('**\/foo', '/a/b/c/foo', File::FNM_PATHNAME)    #=> true */
"\n"/*    File.fnmatch('**\/foo', 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true */
"\n"/*    File.fnmatch('**\/foo', 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false */
"\n"/*    File.fnmatch('**\/foo', 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true */
"  def fnmatch(pattern, path, flags = 0)\n"
"  end\n"
"  alias fnmatch? fnmatch\n"
"end if false\n"
#line 889 "miniprelude.c"
};

static const char prelude_name2[] = "<internal:gc>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[508]; /* 1..83 */
    RBIMPL_ATTR_NONSTRING() char L83[508]; /* 84..365 */
    RBIMPL_ATTR_NONSTRING() char L365[497]; /* 366..454 */
    RBIMPL_ATTR_NONSTRING() char L454[494]; /* 455..537 */
    RBIMPL_ATTR_NONSTRING() char L537[502]; /* 538..594 */
    RBIMPL_ATTR_NONSTRING() char L594[128]; /* 595..600 */
} prelude_code2 = {
#line 1 "gc.rb"
""/* for gc.c */
""
""/*  The \\GC module provides an interface to Ruby's mark-and-sweep garbage collection mechanism. */
""/*  */
""/*  Some of the underlying methods are also available via the ObjectSpace module. */
""/*  */
""/*  You may obtain information about the operation of the \\GC through GC::Profiler. */
"module GC\n"
"\n"
"\n"/* Initiates garbage collection, even if explicitly disabled by GC.disable. */
"\n"/*  */
"\n"/* Keyword arguments: */
"\n"/*  */
"\n"/* - +full_mark+: */
"\n"/*   its boolean value determines whether to perform a major garbage collection cycle: */
"\n"/*  */
"\n"/*   - +true+: initiates a major garbage collection cycle, */
"\n"/*     meaning all objects (old and new) are marked. */
"\n"/*   - +false+: initiates a minor garbage collection cycle, */
"\n"/*     meaning only young objects are marked. */
"\n"/*  */
"\n"/* - +immediate_mark+: */
"\n"/*   its boolean value determines whether to perform incremental marking: */
"\n"/*  */
"\n"/*   - +true+: marking is completed before the method returns. */
"\n"/*   - +false+: marking is performed by parts, */
"\n"/*     interleaved with program execution both before the method returns and afterward; */
"\n"/*     therefore marking may not be completed before the return. */
"\n"/*     Note that if +full_mark+ is +false+, marking will always be immediate, */
"\n"/*     regardless of the value of +immediate_mark+. */
"\n"/*  */
"\n"/* - +immediate_sweep+: */
"\n"/*   its boolean value determines whether to defer sweeping (using lazy sweep): */
"\n"/*  */
"\n"/*   - +true+: sweeping is completed before the method returns. */
"\n"/*   - +false+: sweeping is performed by parts, */
"\n"/*     interleaved with program execution both before the method returns and afterward; */
"\n"/*     therefore sweeping may not be completed before the return. */
"\n"/*  */
"\n"/* Note that these keyword arguments are implementation- and version-dependent, */
"\n"/* are not guaranteed to be future-compatible, */
"\n"/* and may be ignored in some implementations. */
"  def self.start full_mark: true, immediate_mark: true, immediate_sweep: true\n"
"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
"  end\n"
"\n"
"\n"/* Alias of GC.start */
"  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   GC.enable -> true or false */
"\n"/*  */
"\n"/* Enables garbage collection; */
"\n"/* returns whether garbage collection was disabled: */
"\n"/*  */
"\n"/*   GC.disable */
"\n"/*   GC.enable # => true */
"\n"/*   GC.enable # => false */
"\n"/*  */
"  def self.enable\n"
"    Primitive.gc_enable\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    GC.disable -> true or false */
"\n"/*  */
"\n"/* Disables garbage collection (but GC.start remains potent): */
"\n"/* returns whether garbage collection was already disabled. */
"\n"/*  */
"\n"/*   GC.enable */
"\n"/*   GC.disable # => false */
"\n"/*   GC.disable # => true */
"\n"/*  */
"  def self.disable\n"
"    Primitive.gc_disable\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   GC.stress -> setting */
"\n"/*  */
"\n"/* Returns the current \\GC stress-mode setting, */
,
#line 84 "gc.rb"
"\n"/* which initially is +false+. */
"\n"/*  */
"\n"/* The stress mode may be set by method GC.stress=. */
"  def self.stress\n"
"    Primitive.gc_stress_get\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   GC.stress = value -> value */
"\n"/*  */
"\n"/* Enables or disables stress mode; */
"\n"/* enabling stress mode will degrade performance; it is only for debugging. */
"\n"/*  */
"\n"/* Sets the current \\GC stress mode to the given value: */
"\n"/*  */
"\n"/* - If the value is +nil+ or +false+, disables stress mode. */
"\n"/* - If the value is an integer, */
"\n"/*   enables stress mode with certain flags; see below. */
"\n"/* - Otherwise, enables stress mode; */
"\n"/*   \\GC is invoked at every \\GC opportunity: all memory and object allocations. */
"\n"/*  */
"\n"/* The flags are bits in the given integer: */
"\n"/*  */
"\n"/* - +0x01+: No major \\GC. */
"\n"/* - +0x02+: No immediate sweep. */
"\n"/* - +0x04+: Full mark after malloc/calloc/realloc. */
"\n"/*  */
"  def self.stress=(flag)\n"
"    Primitive.gc_stress_set_m flag\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   self.count -> integer */
"\n"/*  */
"\n"/* Returns the total number of times garbage collection has occurred: */
"\n"/*  */
"\n"/*   GC.count # => 385 */
"\n"/*   GC.start */
"\n"/*   GC.count # => 386 */
"\n"/*  */
"  def self.count\n"
"    Primitive.gc_count\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   GC.stat -> new_hash */
"\n"/*   GC.stat(key) -> value */
"\n"/*   GC.stat(hash) -> hash */
"\n"/*  */
"\n"/* This method is implementation-specific to CRuby. */
"\n"/*  */
"\n"/* Returns \\GC statistics. */
"\n"/* The particular statistics are implementation-specific */
"\n"/* and may change in the future without notice. */
"\n"/*  */
"\n"/* With no argument given, */
"\n"/* returns information about the most recent garbage collection: */
"\n"/*  */
"\n"/*   GC.stat */
"\n"/*   # => */
"\n"/*   {count: 28, */
"\n"/*    time: 1, */
"\n"/*    marking_time: 1, */
"\n"/*    sweeping_time: 0, */
"\n"/*    heap_allocated_pages: 521, */
"\n"/*    heap_empty_pages: 0, */
"\n"/*    heap_allocatable_slots: 0, */
"\n"/*    heap_available_slots: 539590, */
"\n"/*    heap_live_slots: 422243, */
"\n"/*    heap_free_slots: 117347, */
"\n"/*    heap_final_slots: 0, */
"\n"/*    heap_marked_slots: 264877, */
"\n"/*    heap_eden_pages: 521, */
"\n"/*    total_allocated_pages: 521, */
"\n"/*    total_freed_pages: 0, */
"\n"/*    total_allocated_objects: 2246376, */
"\n"/*    total_freed_objects: 1824133, */
"\n"/*    malloc_increase_bytes: 50982, */
"\n"/*    malloc_increase_bytes_limit: 18535172, */
"\n"/*    minor_gc_count: 18, */
"\n"/*    major_gc_count: 10, */
"\n"/*    compact_count: 0, */
"\n"/*    read_barrier_faults: 0, */
"\n"/*    total_moved_objects: 0, */
"\n"/*    remembered_wb_unprotected_objects: 0, */
"\n"/*    remembered_wb_unprotected_objects_limit: 2162, */
"\n"/*    old_objects: 216365, */
"\n"/*    old_objects_limit: 432540, */
"\n"/*    oldmalloc_increase_bytes: 1654232, */
"\n"/*    oldmalloc_increase_bytes_limit: 16846103} */
"\n"/*  */
"\n"/* With symbol argument +key+ given, */
"\n"/* returns the value for that key: */
"\n"/*  */
"\n"/*   GC.stat(:count) # => 30 */
"\n"/*  */
"\n"/* With hash argument +hash+ given, */
"\n"/* returns that hash with GC statistics merged into its content; */
"\n"/* this form may be useful in minimizing {probe effects}[https://en.wikipedia.org/wiki/Probe_effect]: */
"\n"/*  */
"\n"/*   h = {foo: 0, bar: 1} */
"\n"/*   GC.stat(h) */
"\n"/*   h.keys.take(5) # => [:foo, :bar, :count, :time, :marking_time] */
"\n"/*  */
"\n"/* The hash includes entries such as: */
"\n"/*  */
"\n"/* - +:count+: */
"\n"/*   The total number of garbage collections run since application start */
"\n"/*   (count includes both minor and major garbage collections). */
"\n"/* - +:time+: */
"\n"/*   The total time spent in garbage collections (in milliseconds). */
"\n"/* - +:heap_allocated_pages+: */
"\n"/*   The total number of allocated pages. */
"\n"/* - +:heap_empty_pages+: */
"\n"/*   The number of pages with no live objects, and that could be released to the system. */
"\n"/* - +:heap_sorted_length+: */
"\n"/*   The number of pages that can fit into the buffer that holds references to  all pages. */
"\n"/* - +:heap_allocatable_pages+: */
"\n"/*   The total number of pages the application could allocate without additional \\GC. */
"\n"/* - +:heap_available_slots+: */
"\n"/*   The total number of slots in all +:heap_allocated_pages+. */
"\n"/* - +:heap_live_slots+: */
"\n"/*   The total number of slots which contain live objects. */
"\n"/* - +:heap_free_slots+: */
"\n"/*   The total number of slots which do not contain live objects. */
"\n"/* - +:heap_final_slots+: */
"\n"/*   The total number of slots with pending finalizers to be run. */
"\n"/* - +:heap_marked_slots+: */
"\n"/*   The total number of objects marked in the last \\GC. */
"\n"/* - +:heap_eden_pages+: */
"\n"/*   The total number of pages which contain at least one live slot. */
"\n"/* - +:total_allocated_pages+: */
"\n"/*   The cumulative number of pages allocated since application start. */
"\n"/* - +:total_freed_pages+: */
"\n"/*   The cumulative number of pages freed since application start. */
"\n"/* - +:total_allocated_objects+: */
"\n"/*   The cumulative number of objects allocated since application start. */
"\n"/* - +:total_freed_objects+: */
"\n"/*   The cumulative number of objects freed since application start. */
"\n"/* - +:malloc_increase_bytes+: */
"\n"/*   Amount of memory allocated on the heap for objects. Decreased by any \\GC. */
"\n"/* - +:malloc_increase_bytes_limit+: */
"\n"/*   When +:malloc_increase_bytes+ crosses this limit, \\GC is triggered. */
"\n"/* - +:minor_gc_count+: */
"\n"/*   The total number of minor garbage collections run since process start. */
"\n"/* - +:major_gc_count+: */
"\n"/*   The total number of major garbage collections run since process start. */
"\n"/* - +:compact_count+: */
"\n"/*   The total number of compactions run since process start. */
"\n"/* - +:read_barrier_faults+: */
"\n"/*   The total number of times the read barrier was triggered during compaction. */
"\n"/* - +:total_moved_objects+: */
"\n"/*   The total number of objects compaction has moved. */
"\n"/* - +:remembered_wb_unprotected_objects+: */
"\n"/*   The total number of objects without write barriers. */
"\n"/* - +:remembered_wb_unprotected_objects_limit+: */
"\n"/*   When +:remembered_wb_unprotected_objects+ crosses this limit, major \\GC is triggered. */
"\n"/* - +:old_objects+: */
"\n"/*   Number of live, old objects which have survived at least 3 garbage collections. */
"\n"/* - +:old_objects_limit+: */
"\n"/*   When +:old_objects+ crosses this limit, major \\GC is triggered. */
"\n"/* - +:oldmalloc_increase_bytes+: */
"\n"/*   Amount of memory allocated on the heap for objects. Decreased by major \\GC. */
"\n"/* - +:oldmalloc_increase_bytes_limit+: */
"\n"/*   When +:oldmalloc_increase_bytes+ crosses this limit, major \\GC is triggered. */
"\n"/*  */
"  def self.stat hash_or_key = nil\n"
"    Primitive.gc_stat hash_or_key\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    GC.stat_heap -> new_hash */
"\n"/*    GC.stat_heap(heap_id) -> new_hash */
"\n"/*    GC.stat_heap(heap_id, key) -> value */
"\n"/*    GC.stat_heap(nil, hash) -> hash */
"\n"/*    GC.stat_heap(heap_id, hash) -> hash */
"\n"/*  */
"\n"/* This method is implementation-specific to CRuby. */
"\n"/*  */
"\n"/* Returns statistics for \\GC heaps. */
"\n"/* The particular statistics are implementation-specific */
"\n"/* and may change in the future without notice. */
"\n"/*  */
"\n"/* With no argument given, returns statistics for all heaps: */
"\n"/*  */
"\n"/*   GC.stat_heap */
"\n"/*   # => */
"\n"/*   {0 => */
"\n"/*     {slot_size: 40, */
"\n"/*      heap_eden_pages: 246, */
"\n"/*      heap_eden_slots: 402802, */
"\n"/*      total_allocated_pages: 246, */
"\n"/*      force_major_gc_count: 2, */
"\n"/*      force_incremental_marking_finish_count: 1, */
"\n"/*      total_allocated_objects: 33867152, */
"\n"/*      total_freed_objects: 33520523}, */
"\n"/*    1 => */
"\n"/*     {slot_size: 80, */
"\n"/*      heap_eden_pages: 84, */
"\n"/*      heap_eden_slots: 68746, */
"\n"/*      total_allocated_pages: 84, */
"\n"/*      force_major_gc_count: 1, */
"\n"/*      force_incremental_marking_finish_count: 4, */
"\n"/*      total_allocated_objects: 147491, */
"\n"/*      total_freed_objects: 90699}, */
"\n"/*    2 => */
"\n"/*     {slot_size: 160, */
"\n"/*      heap_eden_pages: 157, */
"\n"/*      heap_eden_slots: 64182, */
"\n"/*      total_allocated_pages: 157, */
"\n"/*      force_major_gc_count: 0, */
"\n"/*      force_incremental_marking_finish_count: 0, */
"\n"/*      total_allocated_objects: 211460, */
"\n"/*      total_freed_objects: 190075}, */
"\n"/*    3 => */
"\n"/*     {slot_size: 320, */
"\n"/*      heap_eden_pages: 8, */
"\n"/*      heap_eden_slots: 1631, */
"\n"/*      total_allocated_pages: 8, */
"\n"/*      force_major_gc_count: 0, */
"\n"/*      force_incremental_marking_finish_count: 0, */
"\n"/*      total_allocated_objects: 1422, */
"\n"/*      total_freed_objects: 700}, */
"\n"/*    4 => */
"\n"/*     {slot_size: 640, */
"\n"/*      heap_eden_pages: 16, */
"\n"/*      heap_eden_slots: 1628, */
"\n"/*      total_allocated_pages: 16, */
"\n"/*      force_major_gc_count: 0, */
"\n"/*      force_incremental_marking_finish_count: 0, */
"\n"/*      total_allocated_objects: 1230, */
"\n"/*      total_freed_objects: 309}} */
"\n"/*  */
"\n"/* In the example above, the keys in the outer hash are the heap identifiers: */
"\n"/*  */
"\n"/*   GC.stat_heap.keys # => [0, 1, 2, 3, 4] */
"\n"/*  */
"\n"/* On CRuby, each heap identifier is an integer; */
"\n"/* on other implementations, a heap identifier may be a string. */
"\n"/*  */
"\n"/* With only argument +heap_id+ given, */
"\n"/* returns statistics for the given heap identifier: */
"\n"/*  */
"\n"/*   GC.stat_heap(2) */
"\n"/*   # => */
"\n"/*   {slot_size: 160, */
"\n"/*    heap_eden_pages: 157, */
"\n"/*    heap_eden_slots: 64182, */
"\n"/*    total_allocated_pages: 157, */
"\n"/*    force_major_gc_count: 0, */
"\n"/*    force_incremental_marking_finish_count: 0, */
"\n"/*    total_allocated_objects: 225018, */
"\n"/*    total_freed_objects: 206647} */
"\n"/*  */
"\n"/* With arguments +heap_id+ and +key+ given, */
"\n"/* returns the value for the given key in the given heap: */
"\n"/*  */
"\n"/*   GC.stat_heap(2, :slot_size) # => 160 */
"\n"/*  */
"\n"/* With arguments +nil+ and +hash+ given, */
"\n"/* merges the statistics for all heaps into the given hash: */
"\n"/*  */
"\n"/*   h = {foo: 0, bar: 1} */
"\n"/*   GC.stat_heap(nil, h).keys # => [:foo, :bar, 0, 1, 2, 3, 4] */
"\n"/*  */
"\n"/* With arguments +heap_id+ and +hash+ given, */
"\n"/* merges the statistics for the given heap into the given hash: */
"\n"/*  */
"\n"/*   h = {foo: 0, bar: 1} */
"\n"/*   GC.stat_heap(2, h).keys */
"\n"/*   # => */
"\n"/*   [:foo, */
"\n"/*    :bar, */
"\n"/*    :slot_size, */
"\n"/*    :heap_eden_pages, */
"\n"/*    :heap_eden_slots, */
"\n"/*    :total_allocated_pages, */
"\n"/*    :force_major_gc_count, */
"\n"/*    :force_incremental_marking_finish_count, */
"\n"/*    :total_allocated_objects, */
"\n"/*    :total_freed_objects] */
"\n"/*  */
,
#line 366 "gc.rb"
"\n"/* The statistics for a heap may include: */
"\n"/*  */
"\n"/* - +:slot_size+: */
"\n"/*   The slot size of the heap in bytes. */
"\n"/* - +:heap_allocatable_pages+: */
"\n"/*   The number of pages that can be allocated without triggering a new */
"\n"/*   garbage collection cycle. */
"\n"/* - +:heap_eden_pages+: */
"\n"/*   The number of pages in the eden heap. */
"\n"/* - +:heap_eden_slots+: */
"\n"/*   The total number of slots in all of the pages in the eden heap. */
"\n"/* - +:total_allocated_pages+: */
"\n"/*   The total number of pages that have been allocated in the heap. */
"\n"/* - +:total_freed_pages+: */
"\n"/*   The total number of pages that have been freed and released back to the */
"\n"/*   system in the heap. */
"\n"/* - +:force_major_gc_count+: */
"\n"/*   The number of times this heap has forced major garbage collection cycles */
"\n"/*   to start due to running out of free slots. */
"\n"/* - +:force_incremental_marking_finish_count+: */
"\n"/*   The number of times this heap has forced incremental marking to complete */
"\n"/*   due to running out of pooled slots. */
"\n"/*  */
"  def self.stat_heap heap_name = nil, hash_or_key = nil\n"
"    Primitive.gc_stat_heap heap_name, hash_or_key\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*     GC.config -> hash */
"\n"/*     GC.config(hash_to_merge) -> hash */
"\n"/*  */
"\n"/* This method is implementation-specific to CRuby. */
"\n"/*  */
"\n"/* Sets or gets information about the current \\GC configuration. */
"\n"/*  */
"\n"/* Configuration parameters are \\GC implementation-specific and may change without notice. */
"\n"/*  */
"\n"/* With no argument given, returns a hash containing the configuration: */
"\n"/*  */
"\n"/*   GC.config */
"\n"/*   # => {rgengc_allow_full_mark: true, implementation: \"default\"} */
"\n"/*  */
"\n"/* With argument +hash_to_merge+ given, */
"\n"/* merges that hash into the stored configuration hash; */
"\n"/* ignores unknown hash keys; */
"\n"/* returns the configuration hash: */
"\n"/*  */
"\n"/*   GC.config(rgengc_allow_full_mark: false) */
"\n"/*   # => {rgengc_allow_full_mark: false, implementation: \"default\"} */
"\n"/*   GC.config(foo: 'bar') */
"\n"/*   # => {rgengc_allow_full_mark: false, implementation: \"default\"} */
"\n"/*  */
"\n"/* <b>All-Implementations Configuration</b> */
"\n"/*  */
"\n"/* The single read-only entry for all implementations is: */
"\n"/*  */
"\n"/* - +:implementation+: */
"\n"/*   the string name of the implementation; */
"\n"/*   for the Ruby default implementation, <tt>'default'</tt>. */
"\n"/*  */
"\n"/* <b>Implementation-Specific Configuration</b> */
"\n"/*  */
"\n"/* A \\GC implementation maintains its own implementation-specific configuration. */
"\n"/*  */
"\n"/* For Ruby's default implementation the single entry is: */
"\n"/*  */
"\n"/* - +:rgengc_allow_full_mark+: */
"\n"/*   Controls whether the \\GC is allowed to run a full mark (young & old objects): */
"\n"/*  */
"\n"/*   - +true+ (default): \\GC interleaves major and minor collections. */
"\n"/*     A flag is set to notify GC that a full mark has been requested. */
"\n"/*     This flag is accessible via GC.latest_gc_info(:need_major_by). */
"\n"/*   - +false+: \\GC does not initiate a full marking cycle unless explicitly directed by user code; */
"\n"/*     see GC.start. */
"\n"/*     Setting this parameter to +false+ disables young-to-old promotion. */
"\n"/*     For performance reasons, we recommended warming up the application using Process.warmup */
"\n"/*     before setting this parameter to +false+. */
"\n"/*  */
"  def self.config hash = nil\n"
"    if Primitive.cexpr!(\"RBOOL(RB_TYPE_P(hash, T_HASH))\")\n"
"      if hash.include?(:implementation)\n"
"        raise ArgumentError, 'Attempting to set read-only key \"Implementation\"'\n"
"      end\n"
"\n"
"      Primitive.gc_config_set hash\n"
"    elsif hash != nil\n"
"      raise ArgumentError\n"
"    end\n"
"\n"
,
#line 455 "gc.rb"
"    Primitive.gc_config_get\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   GC.latest_gc_info -> new_hash */
"\n"/*   GC.latest_gc_info(key) -> value */
"\n"/*   GC.latest_gc_info(hash) -> hash */
"\n"/*  */
"\n"/* With no argument given, */
"\n"/* returns information about the most recent garbage collection: */
"\n"/*  */
"\n"/*   GC.latest_gc_info */
"\n"/*   # => */
"\n"/*   {major_by: :force, */
"\n"/*    need_major_by: nil, */
"\n"/*    gc_by: :method, */
"\n"/*    have_finalizer: false, */
"\n"/*    immediate_sweep: true, */
"\n"/*    state: :none, */
"\n"/*    weak_references_count: 0, */
"\n"/*    retained_weak_references_count: 0} */
"\n"/*  */
"\n"/* With symbol argument +key+ given, */
"\n"/* returns the value for that key: */
"\n"/*  */
"\n"/*   GC.latest_gc_info(:gc_by) # => :newobj */
"\n"/*  */
"\n"/* With hash argument +hash+ given, */
"\n"/* returns that hash with GC information merged into its content; */
"\n"/* this form may be useful in minimizing {probe effects}[https://en.wikipedia.org/wiki/Probe_effect]: */
"\n"/*  */
"\n"/*   h = {foo: 0, bar: 1} */
"\n"/*   GC.latest_gc_info(h) */
"\n"/*   # => */
"\n"/*   {foo: 0, */
"\n"/*    bar: 1, */
"\n"/*    major_by: nil, */
"\n"/*    need_major_by: nil, */
"\n"/*    gc_by: :newobj, */
"\n"/*    have_finalizer: false, */
"\n"/*    immediate_sweep: false, */
"\n"/*    state: :sweeping, */
"\n"/*    weak_references_count: 0, */
"\n"/*    retained_weak_references_count: 0} */
"\n"/*  */
"  def self.latest_gc_info hash_or_key = nil\n"
"    if hash_or_key == nil\n"
"      hash_or_key = {}\n"
"    elsif Primitive.cexpr!(\"RBOOL(!SYMBOL_P(hash_or_key) && !RB_TYPE_P(hash_or_key, T_HASH))\")\n"
"      raise TypeError, \"non-hash or symbol given\"\n"
"    end\n"
"\n"
"    Primitive.cstmt! %{\n"
"      return rb_gc_latest_gc_info(hash_or_key);\n"
"    }\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   GC.measure_total_time = setting -> setting */
"\n"/*  */
"\n"/* Enables or disables \\GC total time measurement; */
"\n"/* returns +setting+. */
"\n"/* See GC.total_time. */
"\n"/*  */
"\n"/* When argument +object+ is +nil+ or +false+, disables total time measurement; */
"\n"/* GC.measure_total_time then returns +false+: */
"\n"/*  */
"\n"/*   GC.measure_total_time = nil   # => nil */
"\n"/*   GC.measure_total_time         # => false */
"\n"/*   GC.measure_total_time = false # => false */
"\n"/*   GC.measure_total_time         # => false */
"\n"/*  */
"\n"/* Otherwise, enables total time measurement; */
"\n"/* GC.measure_total_time then returns +true+: */
"\n"/*  */
"\n"/*   GC.measure_total_time = true # => true */
"\n"/*   GC.measure_total_time        # => true */
"\n"/*   GC.measure_total_time = :foo # => :foo */
"\n"/*   GC.measure_total_time        # => true */
"\n"/*  */
"\n"/* Note that when enabled, total time measurement affects performance. */
"  def self.measure_total_time=(flag)\n"
"    Primitive.cstmt! %{\n"
,
#line 538 "gc.rb"
"      rb_gc_impl_set_measure_total_time(rb_gc_get_objspace(), flag);\n"
"      return flag;\n"
"    }\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   GC.measure_total_time -> true or false */
"\n"/*  */
"\n"/* Returns the setting for \\GC total time measurement; */
"\n"/* the initial setting is +true+. */
"\n"/* See GC.total_time. */
"  def self.measure_total_time\n"
"    Primitive.cexpr! %{\n"
"      RBOOL(rb_gc_impl_get_measure_total_time(rb_gc_get_objspace()))\n"
"    }\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    GC.total_time -> integer */
"\n"/*  */
"\n"/* Returns the \\GC total time in nanoseconds: */
"\n"/*  */
"\n"/*   GC.total_time # => 156250 */
"\n"/*  */
"\n"/* Note that total time accumulates */
"\n"/* only when total time measurement is enabled */
"\n"/* (that is, when GC.measure_total_time is +true+): */
"\n"/*  */
"\n"/*   GC.measure_total_time # => true */
"\n"/*   GC.total_time # => 625000 */
"\n"/*   GC.start */
"\n"/*   GC.total_time # => 937500 */
"\n"/*   GC.start */
"\n"/*   GC.total_time # => 1093750 */
"\n"/*  */
"\n"/*   GC.measure_total_time = false */
"\n"/*   GC.total_time # => 1250000 */
"\n"/*   GC.start */
"\n"/*   GC.total_time # => 1250000 */
"\n"/*   GC.start */
"\n"/*   GC.total_time # => 1250000 */
"\n"/*  */
"\n"/*   GC.measure_total_time = true */
"\n"/*   GC.total_time # => 1250000 */
"\n"/*   GC.start */
"\n"/*   GC.total_time # => 1406250 */
"\n"/*  */
"  def self.total_time\n"
"    Primitive.cexpr! %{\n"
"      ULL2NUM(rb_gc_impl_get_total_time(rb_gc_get_objspace()))\n"
"    }\n"
"  end\n"
"end\n"
"\n"
"module ObjectSpace\n"
"\n"/* Alias of GC.start */
"  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
,
#line 595 "gc.rb"
"    Primitive.gc_start_internal full_mark, immediate_mark, immediate_sweep, false\n"
"  end\n"
"\n"
"  module_function :garbage_collect\n"
"end\n"
#line 1511 "miniprelude.c"
};

static const char prelude_name3[] = "<internal:numeric>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[507]; /* 1..123 */
    RBIMPL_ATTR_NONSTRING() char L123[496]; /* 124..213 */
    RBIMPL_ATTR_NONSTRING() char L213[501]; /* 214..287 */
    RBIMPL_ATTR_NONSTRING() char L287[502]; /* 288..340 */
    RBIMPL_ATTR_NONSTRING() char L340[508]; /* 341..400 */
    RBIMPL_ATTR_NONSTRING() char L400[227]; /* 401..422 */
} prelude_code3 = {
#line 1 "numeric.rb"
"class Numeric\n"
"\n"/*  call-seq: */
"\n"/*    dup -> self */
"\n"/*  */
"\n"/*  Returns +self+. */
"\n"/*  */
"\n"/*  Related: Numeric#clone. */
"\n"/*  */
"  def dup\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    real? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is a real number (i.e. not Complex). */
"\n"/*  */
"  def real?\n"
"    true\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   real -> self */
"\n"/*  */
"\n"/* Returns +self+. */
"\n"/*  */
"  def real\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    integer? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is an Integer. */
"\n"/*  */
"\n"/*    1.0.integer? # => false */
"\n"/*    1.integer?   # => true */
"\n"/*  */
"  def integer?\n"
"    false\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    finite? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is a finite number, +false+ otherwise. */
"\n"/*  */
"  def finite?\n"
"    true\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    infinite? -> -1, 1, or nil */
"\n"/*  */
"\n"/*  Returns +nil+, -1, or 1 depending on whether +self+ is */
"\n"/*  finite, <tt>-Infinity</tt>, or <tt>+Infinity</tt>. */
"\n"/*  */
"  def infinite?\n"
"    nil\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   imag -> 0 */
"\n"/*  */
"\n"/* Returns zero. */
"\n"/*  */
"  def imaginary\n"
"    0\n"
"  end\n"
"\n"
"  alias imag imaginary\n"
"\n"
"\n"/* call-seq: */
"\n"/*   conj -> self */
"\n"/*  */
"\n"/* Returns +self+. */
"\n"/*  */
"  def conjugate\n"
"    self\n"
"  end\n"
"\n"
"  alias conj conjugate\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    +self -> self */
"\n"/*  */
"\n"/*  Returns +self+. */
"\n"/*  */
"  def +@\n"
"    self\n"
"  end\n"
"end\n"
"\n"
"class Integer\n"
"\n"/* call-seq: */
"\n"/*   -self -> integer */
"\n"/*  */
"\n"/* Returns +self+, negated: */
"\n"/*  */
"\n"/*   -1    # => -1 */
"\n"/*   -(-1) # => 1 */
"\n"/*   -0    # => 0 */
"\n"/*  */
"  def -@\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_uminus(self)'\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   ~int -> integer */
"\n"/*  */
"\n"/* One's complement: */
"\n"/* returns the value of +self+ with each bit inverted. */
"\n"/*  */
"\n"/* Because an integer value is conceptually of infinite length, */
"\n"/* the result acts as if it had an infinite number of */
"\n"/* one bits to the left. */
"\n"/* In hex representations, this is displayed */
"\n"/* as two periods to the left of the digits: */
"\n"/*  */
"\n"/*   sprintf(\"%X\", ~0x1122334455)    # => \"..FEEDDCCBBAA\" */
"\n"/*  */
"  def ~\n"
,
#line 124 "numeric.rb"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_comp(self)'\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   abs -> integer */
"\n"/*  */
"\n"/* Returns the absolute value of +self+. */
"\n"/*  */
"\n"/*   (-12345).abs # => 12345 */
"\n"/*   -12345.abs   # => 12345 */
"\n"/*   12345.abs    # => 12345 */
"\n"/*  */
"  def abs\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_abs(self)'\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   bit_length -> integer */
"\n"/*  */
"\n"/* Returns the number of bits of the value of +self+, */
"\n"/* which is the bit position of the highest-order bit */
"\n"/* that is different from the sign bit */
"\n"/* (where the least significant bit has bit position 1). */
"\n"/* If there is no such bit (zero or minus one), returns zero. */
"\n"/*  */
"\n"/* This method returns <tt>ceil(log2(self < 0 ? -self : self + 1))</tt>>. */
"\n"/*  */
"\n"/*   (-2**1000-1).bit_length   # => 1001 */
"\n"/*   (-2**1000).bit_length     # => 1000 */
"\n"/*   (-2**1000+1).bit_length   # => 1000 */
"\n"/*   (-2**12-1).bit_length     # => 13 */
"\n"/*   (-2**12).bit_length       # => 12 */
"\n"/*   (-2**12+1).bit_length     # => 12 */
"\n"/*   -0x101.bit_length         # => 9 */
"\n"/*   -0x100.bit_length         # => 8 */
"\n"/*   -0xff.bit_length          # => 8 */
"\n"/*   -2.bit_length             # => 1 */
"\n"/*   -1.bit_length             # => 0 */
"\n"/*   0.bit_length              # => 0 */
"\n"/*   1.bit_length              # => 1 */
"\n"/*   0xff.bit_length           # => 8 */
"\n"/*   0x100.bit_length          # => 9 */
"\n"/*   (2**12-1).bit_length      # => 12 */
"\n"/*   (2**12).bit_length        # => 13 */
"\n"/*   (2**12+1).bit_length      # => 13 */
"\n"/*   (2**1000-1).bit_length    # => 1000 */
"\n"/*   (2**1000).bit_length      # => 1001 */
"\n"/*   (2**1000+1).bit_length    # => 1001 */
"\n"/*  */
"\n"/* For \\Integer _n_, */
"\n"/* this method can be used to detect overflow in Array#pack: */
"\n"/*  */
"\n"/*   if n.bit_length < 32 */
"\n"/*     [n].pack('l') # No overflow. */
"\n"/*   else */
"\n"/*     raise 'Overflow' */
"\n"/*   end */
"\n"/*  */
"  def bit_length\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_bit_length(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    even? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is an even number, +false+ otherwise. */
"  def even?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_even_p(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    integer? -> true */
"\n"/*  */
"\n"/*  Since +self+ is already an \\Integer, always returns +true+. */
"  def integer?\n"
"    true\n"
"  end\n"
"\n"
"  alias magnitude abs\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    odd? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is an odd number, +false+ otherwise. */
"  def odd?\n"
"    Primitive.attr! :leaf\n"
,
#line 214 "numeric.rb"
"    Primitive.cexpr! 'rb_int_odd_p(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    ord -> self */
"\n"/*  */
"\n"/*  Returns +self+; */
"\n"/*  intended for compatibility to character literals in Ruby 1.9. */
"  def ord\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    size -> integer */
"\n"/*  */
"\n"/*  Returns the number of bytes in the machine representation of +self+; */
"\n"/*  the value is system-dependent: */
"\n"/*  */
"\n"/*    1.size             # => 8 */
"\n"/*    -1.size            # => 8 */
"\n"/*    2147483647.size    # => 8 */
"\n"/*    (256**10 - 1).size # => 10 */
"\n"/*    (256**20 - 1).size # => 20 */
"\n"/*    (256**40 - 1).size # => 40 */
"\n"/*  */
"  def size\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_size(self)'\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   times {|i| ... } -> self */
"\n"/*   times            -> enumerator */
"\n"/*  */
"\n"/* Calls the given block +self+ times with each integer in <tt>(0..self-1)</tt>: */
"\n"/*  */
"\n"/*   a = [] */
"\n"/*   5.times {|i| a.push(i) } # => 5 */
"\n"/*   a                        # => [0, 1, 2, 3, 4] */
"\n"/*  */
"\n"/* With no block given, returns an Enumerator. */
"  def times\n"
"    Primitive.attr! :inline_block\n"
"    unless defined?(yield)\n"
"      return Primitive.cexpr! 'SIZED_ENUMERATOR(self, 0, 0, int_dotimes_size)'\n"
"    end\n"
"    i = 0\n"
"    while i < self\n"
"      yield i\n"
"      i = i.succ\n"
"    end\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    to_i -> self */
"\n"/*  */
"\n"/*  Returns +self+ (which is already an \\Integer). */
"  def to_i\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    to_int -> self */
"\n"/*  */
"\n"/*  Returns +self+ (which is already an \\Integer). */
"  def to_int\n"
"    self\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   zero? -> true or false */
"\n"/*  */
"\n"/* Returns +true+ if +self+ has a zero value, +false+ otherwise. */
,
#line 288 "numeric.rb"
"  def zero?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_int_zero_p(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    ceildiv(numeric) -> integer */
"\n"/*  */
"\n"/*  Returns the result of division +self+ by +numeric+. */
"\n"/*  rounded up to the nearest integer. */
"\n"/*  */
"\n"/*    3.ceildiv(3)   # => 1 */
"\n"/*    4.ceildiv(3)   # => 2 */
"\n"/*  */
"\n"/*    4.ceildiv(-3)  # => -1 */
"\n"/*    -4.ceildiv(3)  # => -1 */
"\n"/*    -4.ceildiv(-3) # => 2 */
"\n"/*  */
"\n"/*    3.ceildiv(1.2) # => 3 */
"\n"/*  */
"  def ceildiv(other)\n"
"    -div(0 - other)\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*   numerator -> self */
"\n"/*  */
"\n"/* Returns +self+. */
"\n"/*  */
"  def numerator\n"
"    self\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   denominator -> 1 */
"\n"/*  */
"\n"/* Returns +1+. */
"  def denominator\n"
"    1\n"
"  end\n"
"\n"
"  with_jit do\n"
"    if Primitive.rb_builtin_basic_definition_p(:downto)\n"
"      undef :downto\n"
"\n"
"      def downto(to)\n"/* :nodoc: */
"        Primitive.attr! :inline_block, :c_trace\n"
"\n"
"\n"/* When no block is given, return an Enumerator that enumerates from `self` to `to`. */
"\n"/* Not using `block_given?` and `to_enum` to keep them unaffected by redefinitions. */
"        unless defined?(yield)\n"
"          return Primitive.cexpr! 'SIZED_ENUMERATOR(self, 1, &to, int_downto_size)'\n"
,
#line 341 "numeric.rb"
"        end\n"
"\n"
"        from = self\n"
"        while from >= to\n"
"          yield from\n"
"          from = from.pred\n"
"        end\n"
"        self\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"\n"
"class Float\n"
"\n"
"\n"/* call-seq: */
"\n"/*   to_f -> self */
"\n"/*  */
"\n"/*  Returns +self+ (which is already a \\Float). */
"  def to_f\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    float.abs ->  float */
"\n"/*  */
"\n"/*  Returns the absolute value of +self+: */
"\n"/*  */
"\n"/*    (-34.56).abs # => 34.56 */
"\n"/*    -34.56.abs   # => 34.56 */
"\n"/*    34.56.abs    # => 34.56 */
"\n"/*  */
"  def abs\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_float_abs(self)'\n"
"  end\n"
"\n"
"  alias magnitude abs\n"
"\n"
"\n"/* call-seq: */
"\n"/*   -self -> float */
"\n"/*  */
"\n"/* Returns +self+, negated: */
"\n"/*  */
"\n"/*   -3.14    # => -3.14 */
"\n"/*   -(-3.14) # => 3.14 */
"\n"/*   -0.0     # => -0.0 */
"\n"/*  */
"  def -@\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_float_uminus(self)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    zero? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is 0.0, +false+ otherwise. */
"  def zero?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'RBOOL(FLOAT_ZERO_P(self))'\n"
,
#line 401 "numeric.rb"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    positive? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is greater than 0, +false+ otherwise. */
"  def positive?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'RBOOL(RFLOAT_VALUE(self) > 0.0)'\n"
"  end\n"
"\n"
"\n"/*  call-seq: */
"\n"/*    negative? -> true or false */
"\n"/*  */
"\n"/*  Returns +true+ if +self+ is less than 0, +false+ otherwise. */
"  def negative?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'RBOOL(RFLOAT_VALUE(self) < 0.0)'\n"
"  end\n"
"\n"
"end\n"
#line 1955 "miniprelude.c"
};

static const char prelude_name4[] = "<internal:io>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[449]; /* 1..137 */
} prelude_code4 = {
#line 1 "io.rb"
"class IO\n"
"\n"/* other IO methods are defined in io.c */
"\n"
"\n"/* call-seq: */
"\n"/*    ios.read_nonblock(maxlen [, options])              -> string */
"\n"/*    ios.read_nonblock(maxlen, outbuf [, options])      -> outbuf */
"\n"/*  */
"\n"/* Reads at most <i>maxlen</i> bytes from <em>ios</em> using */
"\n"/* the read(2) system call after O_NONBLOCK is set for */
"\n"/* the underlying file descriptor. */
"\n"/*  */
"\n"/* If the optional <i>outbuf</i> argument is present, */
"\n"/* it must reference a String, which will receive the data. */
"\n"/* The <i>outbuf</i> will contain only the received data after the method call */
"\n"/* even if it is not empty at the beginning. */
"\n"/*  */
"\n"/* read_nonblock just calls the read(2) system call. */
"\n"/* It causes all errors the read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. */
"\n"/* The caller should care such errors. */
"\n"/*  */
"\n"/* If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, */
"\n"/* it is extended by IO::WaitReadable. */
"\n"/* So IO::WaitReadable can be used to rescue the exceptions for retrying */
"\n"/* read_nonblock. */
"\n"/*  */
"\n"/* read_nonblock causes EOFError on EOF. */
"\n"/*  */
"\n"/* On some platforms, such as Windows, non-blocking mode is not supported */
"\n"/* on IO objects other than sockets. In such cases, Errno::EBADF will */
"\n"/* be raised. */
"\n"/*  */
"\n"/* If the read byte buffer is not empty, */
"\n"/* read_nonblock reads from the buffer like readpartial. */
"\n"/* In this case, the read(2) system call is not called. */
"\n"/*  */
"\n"/* When read_nonblock raises an exception kind of IO::WaitReadable, */
"\n"/* read_nonblock should not be called */
"\n"/* until io is readable for avoiding busy loop. */
"\n"/* This can be done as follows. */
"\n"/*  */
"\n"/*   # emulates blocking read (readpartial). */
"\n"/*   begin */
"\n"/*     result = io.read_nonblock(maxlen) */
"\n"/*   rescue IO::WaitReadable */
"\n"/*     IO.select([io]) */
"\n"/*     retry */
"\n"/*   end */
"\n"/*  */
"\n"/* Although IO#read_nonblock doesn't raise IO::WaitWritable. */
"\n"/* OpenSSL::Buffering#read_nonblock can raise IO::WaitWritable. */
"\n"/* If IO and SSL should be used polymorphically, */
"\n"/* IO::WaitWritable should be rescued too. */
"\n"/* See the document of OpenSSL::Buffering#read_nonblock for sample code. */
"\n"/*  */
"\n"/* Note that this method is identical to readpartial */
"\n"/* except the non-blocking flag is set. */
"\n"/*  */
"\n"/* By specifying a keyword argument _exception_ to +false+, you can indicate */
"\n"/* that read_nonblock should not raise an IO::WaitReadable exception, but */
"\n"/* return the symbol +:wait_readable+ instead. At EOF, it will return nil */
"\n"/* instead of raising EOFError. */
"  def read_nonblock(len, buf = nil, exception: true)\n"
"    Primitive.io_read_nonblock(len, buf, exception)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    ios.write_nonblock(string)   -> integer */
"\n"/*    ios.write_nonblock(string [, options])   -> integer */
"\n"/*  */
"\n"/* Writes the given string to <em>ios</em> using */
"\n"/* the write(2) system call after O_NONBLOCK is set for */
"\n"/* the underlying file descriptor. */
"\n"/*  */
"\n"/* It returns the number of bytes written. */
"\n"/*  */
"\n"/* write_nonblock just calls the write(2) system call. */
"\n"/* It causes all errors the write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. */
"\n"/* The result may also be smaller than string.length (partial write). */
"\n"/* The caller should care such errors and partial write. */
"\n"/*  */
"\n"/* If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, */
"\n"/* it is extended by IO::WaitWritable. */
"\n"/* So IO::WaitWritable can be used to rescue the exceptions for retrying write_nonblock. */
"\n"/*  */
"\n"/*   # Creates a pipe. */
"\n"/*   r, w = IO.pipe */
"\n"/*  */
"\n"/*   # write_nonblock writes only 65536 bytes and return 65536. */
"\n"/*   # (The pipe size is 65536 bytes on this environment.) */
"\n"/*   s = \"a\" * 100000 */
"\n"/*   p w.write_nonblock(s)     #=> 65536 */
"\n"/*  */
"\n"/*   # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN). */
"\n"/*   p w.write_nonblock(\"b\")   # Resource temporarily unavailable (Errno::EAGAIN) */
"\n"/*  */
"\n"/* If the write buffer is not empty, it is flushed at first. */
"\n"/*  */
"\n"/* When write_nonblock raises an exception kind of IO::WaitWritable, */
"\n"/* write_nonblock should not be called */
"\n"/* until io is writable for avoiding busy loop. */
"\n"/* This can be done as follows. */
"\n"/*  */
"\n"/*   begin */
"\n"/*     result = io.write_nonblock(string) */
"\n"/*   rescue IO::WaitWritable, Errno::EINTR */
"\n"/*     IO.select(nil, [io]) */
"\n"/*     retry */
"\n"/*   end */
"\n"/*  */
"\n"/* Note that this doesn't guarantee to write all data in string. */
"\n"/* The length written is reported as result and it should be checked later. */
"\n"/*  */
"\n"/* On some platforms such as Windows, write_nonblock is not supported */
"\n"/* according to the kind of the IO object. */
"\n"/* In such cases, write_nonblock raises <code>Errno::EBADF</code>. */
"\n"/*  */
"\n"/* By specifying a keyword argument _exception_ to +false+, you can indicate */
"\n"/* that write_nonblock should not raise an IO::WaitWritable exception, but */
"\n"/* return the symbol +:wait_writable+ instead. */
"  def write_nonblock(buf, exception: true)\n"
"    Primitive.io_write_nonblock(buf, exception)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   readline(sep = $/, chomp: false)   -> string */
"\n"/*   readline(limit, chomp: false)      -> string */
"\n"/*   readline(sep, limit, chomp: false) -> string */
"\n"/*  */
"\n"/* Reads a line as with IO#gets, but raises EOFError if already at end-of-stream. */
"\n"/*  */
"\n"/* Optional keyword argument +chomp+ specifies whether line separators */
"\n"/* are to be omitted. */
"  def readline(sep = $/, limit = nil, chomp: false)\n"
"    Primitive.io_readline(sep, limit, chomp)\n"
"  end\n"
"end\n"
#line 2099 "miniprelude.c"
};

static const char prelude_name5[] = "<internal:marshal>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[202]; /* 1..41 */
} prelude_code5 = {
#line 1 "marshal.rb"
"module Marshal\n"
"\n"/* call-seq: */
"\n"/*    load(source, proc = nil, freeze: false) -> obj */
"\n"/*    restore(source, proc = nil, freeze: false) -> obj */
"\n"/*  */
"\n"/* Returns the result of converting the serialized data in source into a */
"\n"/* Ruby object (possibly with associated subordinate objects). source */
"\n"/* may be either an instance of IO or an object that responds to */
"\n"/* to_str. If proc is specified, each object will be passed to the proc, as the object */
"\n"/* is being deserialized. */
"\n"/*  */
"\n"/* Never pass untrusted data (including user supplied input) to this method. */
"\n"/* Please see the overview for further details. */
"\n"/*  */
"\n"/* If the <tt>freeze: true</tt> argument is passed, deserialized object would */
"\n"/* be deeply frozen. Note that it may lead to more efficient memory usage due to */
"\n"/* frozen strings deduplication: */
"\n"/*  */
"\n"/*    serialized = Marshal.dump(['value1', 'value2', 'value1', 'value2']) */
"\n"/*  */
"\n"/*    deserialized = Marshal.load(serialized) */
"\n"/*    deserialized.map(&:frozen?) */
"\n"/*    # => [false, false, false, false] */
"\n"/*    deserialized.map(&:object_id) */
"\n"/*    # => [1023900, 1023920, 1023940, 1023960] -- 4 different objects */
"\n"/*  */
"\n"/*    deserialized = Marshal.load(serialized, freeze: true) */
"\n"/*    deserialized.map(&:frozen?) */
"\n"/*    # => [true, true, true, true] */
"\n"/*    deserialized.map(&:object_id) */
"\n"/*    # => [1039360, 1039380, 1039360, 1039380] -- only 2 different objects, object_ids repeating */
"\n"/*  */
"  def self.load(source, proc = nil, freeze: false)\n"
"    Primitive.marshal_load(source, proc, freeze)\n"
"  end\n"
"\n"
"  class << self\n"
"    alias restore load\n"
"  end\n"
"end\n"
#line 2147 "miniprelude.c"
};

static const char prelude_name6[] = "<internal:pack>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[312]; /* 1..41 */
} prelude_code6 = {
#line 1 "pack.rb"
"class Array\n"
"\n"/*  call-seq: */
"\n"/*    pack(template, buffer: nil) -> string */
"\n"/*  */
"\n"/*  Formats each element in +self+ into a binary string; returns that string. */
"\n"/*  See {Packed Data}[rdoc-ref:language/packed_data.rdoc]. */
"  def pack(fmt, buffer: nil)\n"
"    Primitive.pack_pack(fmt, buffer)\n"
"  end\n"
"end\n"
"\n"
"class String\n"
"\n"/*  call-seq: */
"\n"/*    unpack(template, offset: 0) {|o| .... } -> object */
"\n"/*    unpack(template, offset: 0) -> array */
"\n"/*  */
"\n"/*  Extracts data from +self+ to form new objects; */
"\n"/*  see {Packed Data}[rdoc-ref:language/packed_data.rdoc]. */
"\n"/*  */
"\n"/*  With a block given, calls the block with each unpacked object. */
"\n"/*  */
"\n"/*  With no block given, returns an array containing the unpacked objects. */
"\n"/*  */
"\n"/*  Related: see {Converting to Non-String}[rdoc-ref:String@Converting+to+Non--5CString]. */
"  def unpack(fmt, offset: 0)\n"
"    Primitive.attr! :use_block\n"
"    Primitive.pack_unpack(fmt, offset)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   unpack1(template, offset: 0) -> object */
"\n"/*  */
"\n"/*  Like String#unpack with no block, but unpacks and returns only the first extracted object. */
"\n"/*  See {Packed Data}[rdoc-ref:language/packed_data.rdoc]. */
"\n"/*  */
"\n"/*  Related: see {Converting to Non-String}[rdoc-ref:String@Converting+to+Non--5CString]. */
"  def unpack1(fmt, offset: 0)\n"
"    Primitive.pack_unpack1(fmt, offset)\n"
"  end\n"
"end\n"
#line 2195 "miniprelude.c"
};

static const char prelude_name7[] = "<internal:trace_point>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[489]; /* 1..200 */
    RBIMPL_ATTR_NONSTRING() char L200[504]; /* 201..313 */
    RBIMPL_ATTR_NONSTRING() char L313[471]; /* 314..383 */
    RBIMPL_ATTR_NONSTRING() char L383[413]; /* 384..421 */
} prelude_code7 = {
#line 1 "trace_point.rb"
""/* loaded from vm_trace.c */
""
""/* A class that provides the functionality of Kernel#set_trace_func in a */
""/* well-structured Object-Oriented API. */
""/*  */
""/* == Example */
""/*  */
""/* Use TracePoint to gather information specifically for exceptions: */
""/*  */
""/*     trace = TracePoint.new(:raise) do |tp| */
""/*       p [tp.lineno, tp.event, tp.raised_exception] */
""/*     end */
""/*     #=> #<TracePoint:disabled> */
""/*  */
""/*     trace.enable  #=> false */
""/*  */
""/*     0 / 0 */
""/*     #=> [5, :raise, #<ZeroDivisionError: divided by 0>] */
""/*  */
""/* == Events */
""/*  */
""/* If you don't specify the types of events you want to listen for, */
""/* TracePoint will include all available events. */
""/*  */
""/* *Note:* Do not depend on the current event set, as this list is subject to */
""/* change. Instead, it is recommended to specify the types of events you */
""/* want to use. */
""/*  */
""/* To filter what is traced, you can pass any number of the following as +events+: */
""/*  */
""/* +:line+:: Execute an expression or statement on a new line. */
""/* +:class+:: Start a class or module definition. */
""/* +:end+:: Finish a class or module definition. */
""/* +:call+:: Call a Ruby method. */
""/* +:return+:: Return from a Ruby method. */
""/* +:c_call+:: Call a C-language routine. */
""/* +:c_return+:: Return from a C-language routine. */
""/* +:raise+:: Raise an exception. */
""/* +:rescue+:: Rescue an exception. */
""/* +:b_call+:: Event hook at block entry. */
""/* +:b_return+:: Event hook at block ending. */
""/* +:a_call+:: Event hook at all calls (+call+, +b_call+, and +c_call+). */
""/* +:a_return+:: Event hook at all returns (+return+, +b_return+, and +c_return+). */
""/* +:thread_begin+:: Event hook at thread beginning. */
""/* +:thread_end+:: Event hook at thread ending. */
""/* +:fiber_switch+:: Event hook at fiber switch. */
""/* +:script_compiled+:: New Ruby code compiled (with +eval+, +load+, or +require+). */
""/*  */
"class TracePoint\n"
"\n"/* call-seq: */
"\n"/*   TracePoint.new(*events) { |tp| block } -> tp */
"\n"/*  */
"\n"/* Returns a new TracePoint object, not enabled by default. */
"\n"/*  */
"\n"/* To activate the TracePoint object, use TracePoint#enable: */
"\n"/*  */
"\n"/*     trace = TracePoint.new(:call) do |tp| */
"\n"/*       p [tp.lineno, tp.defined_class, tp.method_id, tp.event] */
"\n"/*     end */
"\n"/*     #=> #<TracePoint:disabled> */
"\n"/*  */
"\n"/*     trace.enable  #=> false */
"\n"/*  */
"\n"/*     puts \"Hello, TracePoint!\" */
"\n"/*     # ... */
"\n"/*     # [48, IRB::Notifier::AbstractNotifier, :printf, :call] */
"\n"/*     # ... */
"\n"/*  */
"\n"/* To deactivate the trace, use TracePoint#disable. */
"\n"/*  */
"\n"/*     trace.disable */
"\n"/*  */
"\n"/* See TracePoint@Events for possible events and more information. */
"\n"/*  */
"\n"/* A block must be given; otherwise, an ArgumentError is raised. */
"\n"/*  */
"\n"/* If the trace method isn't supported for the given event(s) filter, a */
"\n"/* RuntimeError is raised. */
"\n"/*  */
"\n"/*     TracePoint.trace(:line) do |tp| */
"\n"/*       p tp.raised_exception */
"\n"/*     end */
"\n"/*     #=> RuntimeError: 'raised_exception' not supported by this event */
"\n"/*  */
"\n"/* If the trace method is called outside a block, a RuntimeError is raised. */
"\n"/*  */
"\n"/*     TracePoint.trace(:line) do |tp| */
"\n"/*       $tp = tp */
"\n"/*     end */
"\n"/*     $tp.lineno #=> access from outside (RuntimeError) */
"\n"/*  */
"\n"/* Access from other ractors, threads or fibers is forbidden. TracePoints are active */
"\n"/* per-ractor so if you enable a TracePoint in one ractor, other ractors will not be */
"\n"/* affected. */
"\n"/*  */
"  def self.new(*events)\n"
"    Primitive.attr! :use_block\n"
"    Primitive.tracepoint_new_s(events)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   trace.inspect -> string */
"\n"/*  */
"\n"/* Returns a string containing a human-readable TracePoint */
"\n"/* status. */
"  def inspect\n"
"    Primitive.tracepoint_inspect\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   TracePoint.stat -> obj */
"\n"/*  */
"\n"/* Returns internal information of TracePoint. */
"\n"/*  */
"\n"/* The contents of the returned value are implementation-specific */
"\n"/* and may change in the future. */
"\n"/*  */
"\n"/* This method is only for debugging TracePoint itself. */
"  def self.stat\n"
"    Primitive.tracepoint_stat_s\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   TracePoint.trace(*events) { |tp| block } -> obj */
"\n"/*  */
"\n"/* A convenience method for TracePoint.new that activates the trace */
"\n"/* automatically. */
"\n"/*  */
"\n"/*     trace = TracePoint.trace(:call) { |tp| [tp.lineno, tp.event] } */
"\n"/*     #=> #<TracePoint:enabled> */
"\n"/*  */
"\n"/*     trace.enabled?  #=> true */
"\n"/*  */
"  def self.trace(*events)\n"
"    Primitive.attr! :use_block\n"
"    Primitive.tracepoint_trace_s(events)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   TracePoint.allow_reentry { block } */
"\n"/*  */
"\n"/* Generally, while a TracePoint callback is running, */
"\n"/* other registered callbacks are not called to avoid */
"\n"/* confusion from reentrance. */
"\n"/* This method allows reentrance within a given block. */
"\n"/* Use this method carefully to avoid infinite callback invocation. */
"\n"/*  */
"\n"/* If called when reentrance is already allowed, */
"\n"/* it raises a RuntimeError. */
"\n"/*  */
"\n"/* <b>Example:</b> */
"\n"/*  */
"\n"/*   # Without reentry */
"\n"/*   # --------------- */
"\n"/*  */
"\n"/*   line_handler = TracePoint.new(:line) do |tp| */
"\n"/*     next if tp.path != __FILE__ # Only works in this file */
"\n"/*     puts \"Line handler\" */
"\n"/*     binding.eval(\"class C; end\") */
"\n"/*   end.enable */
"\n"/*  */
"\n"/*   class_handler = TracePoint.new(:class) do |tp| */
"\n"/*     puts \"Class handler\" */
"\n"/*   end.enable */
"\n"/*  */
"\n"/*   class B */
"\n"/*   end */
"\n"/*  */
"\n"/*   # This script will print \"Class handler\" only once: when inside the :line */
"\n"/*   # handler, all other handlers are ignored. */
"\n"/*  */
"\n"/*  */
"\n"/*   # With reentry */
"\n"/*   # ------------ */
"\n"/*  */
"\n"/*   line_handler = TracePoint.new(:line) do |tp| */
"\n"/*     next if tp.path != __FILE__ # Only works in this file */
"\n"/*     next if (__LINE__..__LINE__+3).cover?(tp.lineno) # Prevent infinite calls */
"\n"/*     puts \"Line handler\" */
"\n"/*     TracePoint.allow_reentry { binding.eval(\"class C; end\") } */
"\n"/*   end.enable */
"\n"/*  */
"\n"/*   class_handler = TracePoint.new(:class) do |tp| */
"\n"/*     puts \"Class handler\" */
"\n"/*   end.enable */
"\n"/*  */
"\n"/*   class B */
"\n"/*   end */
"\n"/*  */
"\n"/*   # This will print \"Class handler\" twice: inside the allow_reentry block in the :line */
"\n"/*   # handler, other handlers are enabled. */
"\n"/*  */
"\n"/* Note that the example shows the principal effect of the method, but its */
"\n"/* practical usage is for debugging libraries that sometimes require other libraries' */
"\n"/* hooks to not be affected by the debugger being inside trace point handling. */
"\n"/* Precautions should be taken against infinite recursion in this case */
"\n"/* (note that we needed to filter out calls by itself from the :line handler, */
"\n"/* otherwise it would call itself infinitely). */
"\n"/*  */
"  def self.allow_reentry\n"
,
#line 201 "trace_point.rb"
"    Primitive.attr! :use_block\n"
"    Primitive.tracepoint_allow_reentry\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   trace.enable(target: nil, target_line: nil, target_thread: nil) -> true or false */
"\n"/*   trace.enable(target: nil, target_line: nil, target_thread: :default) { block } -> obj */
"\n"/*  */
"\n"/* Activates the trace. */
"\n"/*  */
"\n"/* Returns +true+ if the trace was enabled. */
"\n"/* Returns +false+ if the trace was disabled. */
"\n"/*  */
"\n"/*   trace.enabled?  #=> false */
"\n"/*   trace.enable    #=> false (previous state) */
"\n"/*                   #   trace is enabled */
"\n"/*   trace.enabled?  #=> true */
"\n"/*   trace.enable    #=> true (previous state) */
"\n"/*                   #   trace is still enabled */
"\n"/*  */
"\n"/* If a block is given, the trace will only be enabled during the block execution. */
"\n"/* If target and target_line are both nil, then target_thread will default */
"\n"/* to the current thread if a block is given. */
"\n"/*  */
"\n"/*     trace.enabled?  #=> false */
"\n"/*  */
"\n"/*     trace.enable do */
"\n"/*       trace.enabled? */
"\n"/*       # Only enabled for this block and thread */
"\n"/*     end */
"\n"/*  */
"\n"/*     trace.enabled?  #=> false */
"\n"/*  */
"\n"/* The +target+, +target_line+, and +target_thread+ parameters are used to */
"\n"/* limit tracing to specified code objects. +target+ should be a */
"\n"/* code object for which RubyVM::InstructionSequence.of will return */
"\n"/* an instruction sequence. */
"\n"/*  */
"\n"/*     t = TracePoint.new(:line) { |tp| p tp } */
"\n"/*  */
"\n"/*     def m1 */
"\n"/*       p 1 */
"\n"/*     end */
"\n"/*  */
"\n"/*     def m2 */
"\n"/*       p 2 */
"\n"/*     end */
"\n"/*  */
"\n"/*     t.enable(target: method(:m1)) */
"\n"/*  */
"\n"/*     m1 */
"\n"/*     # Prints #<TracePoint:line test.rb:4 in `m1'> */
"\n"/*     m2 */
"\n"/*     # Prints nothing */
"\n"/*  */
"\n"/* Note: You cannot access event hooks within the +enable+ block. */
"\n"/*  */
"\n"/*     trace.enable { p tp.lineno } */
"\n"/*     #=> RuntimeError: access from outside */
"\n"/*  */
"  def enable(target: nil, target_line: nil, target_thread: :default)\n"
"    Primitive.attr! :use_block\n"
"    Primitive.tracepoint_enable_m(target, target_line, target_thread)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   trace.disable -> true or false */
"\n"/*   trace.disable { block } -> obj */
"\n"/*  */
"\n"/* Deactivates the trace. */
"\n"/*  */
"\n"/* Returns +true+ if the trace was enabled. */
"\n"/* Returns +false+ if the trace was disabled. */
"\n"/*  */
"\n"/*     trace.enabled?  #=> true */
"\n"/*     trace.disable   #=> true (previous status) */
"\n"/*     trace.enabled?  #=> false */
"\n"/*     trace.disable   #=> false */
"\n"/*  */
"\n"/* If a block is given, the trace will only be disabled within the scope of the */
"\n"/* block. */
"\n"/*  */
"\n"/*     trace.enabled?  #=> true */
"\n"/*  */
"\n"/*     trace.disable do */
"\n"/*       trace.enabled? */
"\n"/*       # Only disabled for this block */
"\n"/*     end */
"\n"/*  */
"\n"/*     trace.enabled?  #=> true */
"\n"/*  */
"\n"/* Note: You cannot access event hooks within the block. */
"\n"/*  */
"\n"/*     trace.disable { p tp.lineno } */
"\n"/*     #=> RuntimeError: access from outside */
"\n"/*  */
"  def disable\n"
"    Primitive.attr! :use_block\n"
"    Primitive.tracepoint_disable_m\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   trace.enabled? -> true or false */
"\n"/*  */
"\n"/* Returns the current status of the trace. */
"  def enabled?\n"
"    Primitive.tracepoint_enabled_p\n"
"  end\n"
"\n"
"\n"/* Returns the type of event. */
"\n"/*  */
"\n"/* See TracePoint@Events for more information. */
"  def event\n"
,
#line 314 "trace_point.rb"
"    Primitive.tracepoint_attr_event\n"
"  end\n"
"\n"
"\n"/* Returns the line number of the event. */
"  def lineno\n"
"    Primitive.tracepoint_attr_lineno\n"
"  end\n"
"\n"
"\n"/* Returns the path of the file being executed. */
"  def path\n"
"    Primitive.tracepoint_attr_path\n"
"  end\n"
"\n"
"\n"/* Returns the parameter definitions of the method or block that the */
"\n"/* current hook belongs to. The format is the same as for Method#parameters. */
"  def parameters\n"
"    Primitive.tracepoint_attr_parameters\n"
"  end\n"
"\n"
"\n"/* Returns the name at the definition of the method being called. */
"  def method_id\n"
"    Primitive.tracepoint_attr_method_id\n"
"  end\n"
"\n"
"\n"/* Returns the called name of the method being called. */
"  def callee_id\n"
"    Primitive.tracepoint_attr_callee_id\n"
"  end\n"
"\n"
"\n"/* Returns the class or module of the method being called. */
"\n"/*  */
"\n"/*     class C; def foo; end; end */
"\n"/*     trace = TracePoint.new(:call) do |tp| */
"\n"/*       p tp.defined_class #=> C */
"\n"/*     end.enable do */
"\n"/*       C.new.foo */
"\n"/*     end */
"\n"/*  */
"\n"/* If the method is defined by a module, then that module is returned. */
"\n"/*  */
"\n"/*     module M; def foo; end; end */
"\n"/*     class C; include M; end */
"\n"/*     trace = TracePoint.new(:call) do |tp| */
"\n"/*       p tp.defined_class #=> M */
"\n"/*     end.enable do */
"\n"/*       C.new.foo */
"\n"/*     end */
"\n"/*  */
"\n"/* <b>Note:</b> #defined_class returns the singleton class. */
"\n"/*  */
"\n"/* The 6th block parameter of Kernel#set_trace_func passes the original class */
"\n"/* attached by the singleton class. */
"\n"/*  */
"\n"/* <b>This is a difference between Kernel#set_trace_func and TracePoint.</b> */
"\n"/*  */
"\n"/*     class C; def self.foo; end; end */
"\n"/*     trace = TracePoint.new(:call) do |tp| */
"\n"/*       p tp.defined_class #=> #<Class:C> */
"\n"/*     end.enable do */
"\n"/*       C.foo */
"\n"/*     end */
"  def defined_class\n"
"    Primitive.tracepoint_attr_defined_class\n"
"  end\n"
"\n"
"\n"/* Returns the generated binding object from the event. */
"\n"/*  */
"\n"/* Note that for +:c_call+ and +:c_return+ events, the method returns */
"\n"/* +nil+, since C methods themselves do not have bindings. */
"  def binding\n"
,
#line 384 "trace_point.rb"
"    Primitive.tracepoint_attr_binding\n"
"  end\n"
"\n"
"\n"/* Returns the trace object during the event. */
"\n"/*  */
"\n"/* Similar to the following, but it returns the correct object (the method */
"\n"/* receiver) for +:c_call+ and +:c_return+ events: */
"\n"/*  */
"\n"/*   trace.binding.eval('self') */
"  def self\n"
"    Primitive.tracepoint_attr_self\n"
"  end\n"
"\n"
"\n"/* Returns the return value from +:return+, +:c_return+, and +:b_return+ events. */
"  def return_value\n"
"    Primitive.tracepoint_attr_return_value\n"
"  end\n"
"\n"
"\n"/* Returns the exception raised on the +:raise+ event or rescued on the +:rescue+ event. */
"  def raised_exception\n"
"    Primitive.tracepoint_attr_raised_exception\n"
"  end\n"
"\n"
"\n"/* Returns the compiled source code (String) from eval methods on the +:script_compiled+ event. */
"\n"/* If loaded from a file, it returns +nil+. */
"  def eval_script\n"
"    Primitive.tracepoint_attr_eval_script\n"
"  end\n"
"\n"
"\n"/* Returns the compiled instruction sequence represented by a RubyVM::InstructionSequence instance */
"\n"/* on the +:script_compiled+ event. */
"\n"/*  */
"\n"/* Note that this method is CRuby-specific. */
"  def instruction_sequence\n"
"    Primitive.tracepoint_attr_instruction_sequence\n"
"  end\n"
"end\n"
#line 2632 "miniprelude.c"
};

static const char prelude_name8[] = "<internal:warning>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[361]; /* 1..60 */
} prelude_code8 = {
#line 1 "warning.rb"
""/* encoding: utf-8 */
""/* frozen-string-literal: true */
""
"module Kernel\n"
"  module_function\n"
"\n"
"\n"/* call-seq: */
"\n"/*    warn(*msgs, uplevel: nil, category: nil)   -> nil */
"\n"/*  */
"\n"/* If warnings have been disabled (for example with the */
"\n"/* <code>-W0</code> flag), does nothing.  Otherwise, */
"\n"/* converts each of the messages to strings, appends a newline */
"\n"/* character to the string if the string does not end in a newline, */
"\n"/* and calls Warning.warn with the string. */
"\n"/*  */
"\n"/*    warn(\"warning 1\", \"warning 2\") */
"\n"/*  */
"\n"/* <em>produces:</em> */
"\n"/*  */
"\n"/*    warning 1 */
"\n"/*    warning 2 */
"\n"/*  */
"\n"/* If the <code>uplevel</code> keyword argument is given, the string will */
"\n"/* be prepended with information for the given caller frame in */
"\n"/* the same format used by the <code>rb_warn</code> C function. */
"\n"/*  */
"\n"/*    # In baz.rb */
"\n"/*    def foo */
"\n"/*      warn(\"invalid call to foo\", uplevel: 1) */
"\n"/*    end */
"\n"/*  */
"\n"/*    def bar */
"\n"/*      foo */
"\n"/*    end */
"\n"/*  */
"\n"/*    bar */
"\n"/*  */
"\n"/* <em>produces:</em> */
"\n"/*  */
"\n"/*    baz.rb:6: warning: invalid call to foo */
"\n"/*  */
"\n"/* If <code>category</code> keyword argument is given, passes the category */
"\n"/* to <code>Warning.warn</code>.  The category given must be one of the */
"\n"/* following categories: */
"\n"/*  */
"\n"/* :deprecated :: Used for warning for deprecated functionality that may */
"\n"/*                be removed in the future. */
"\n"/* :experimental :: Used for experimental features that may change in */
"\n"/*                  future releases. */
"\n"/* :performance  :: Used for warning about APIs or pattern that have */
"\n"/*                  negative performance impact */
"  def warn(*msgs, uplevel: nil, category: nil)\n"
"    if Primitive.cexpr!(\"NIL_P(category)\")\n"
"      Primitive.rb_warn_m(msgs, uplevel, nil)\n"
"    elsif Warning[category = Primitive.cexpr!(\"rb_to_symbol_type(category)\")]\n"
"      Primitive.rb_warn_m(msgs, uplevel, category)\n"
"    end\n"
"  end\n"
"end\n"
#line 2699 "miniprelude.c"
};

static const char prelude_name9[] = "<internal:array>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[488]; /* 1..129 */
    RBIMPL_ATTR_NONSTRING() char L129[504]; /* 130..171 */
    RBIMPL_ATTR_NONSTRING() char L171[483]; /* 172..222 */
    RBIMPL_ATTR_NONSTRING() char L222[452]; /* 223..240 */
    RBIMPL_ATTR_NONSTRING() char L240[463]; /* 241..258 */
    RBIMPL_ATTR_NONSTRING() char L258[507]; /* 259..275 */
    RBIMPL_ATTR_NONSTRING() char L275[147]; /* 276..285 */
} prelude_code9 = {
#line 1 "array.rb"
"class Array\n"
"\n"/* call-seq: */
"\n"/*   shuffle!(random: Random) -> self */
"\n"/*  */
"\n"/* Shuffles all elements in +self+ into a random order, */
"\n"/* as selected by the object given by the keyword argument +random+. */
"\n"/* Returns +self+: */
"\n"/*  */
"\n"/*   a =             [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] */
"\n"/*   a.shuffle! # => [5, 3, 8, 7, 6, 1, 9, 4, 2, 0] */
"\n"/*   a.shuffle! # => [9, 4, 0, 6, 2, 8, 1, 5, 3, 7] */
"\n"/*  */
"\n"/* Duplicate elements are included: */
"\n"/*  */
"\n"/*   a =             [0, 1, 0, 1, 0, 1, 0, 1, 0, 1] */
"\n"/*   a.shuffle! # => [1, 0, 0, 1, 1, 0, 1, 0, 0, 1] */
"\n"/*   a.shuffle! # => [0, 1, 0, 1, 1, 0, 1, 0, 1, 0] */
"\n"/*  */
"\n"/* The object given with the keyword argument +random+ is used as the random number generator. */
"\n"/*  */
"\n"/* Related: see {Methods for Assigning}[rdoc-ref:Array@Methods+for+Assigning]. */
"  def shuffle!(random: Random)\n"
"    Primitive.rb_ary_shuffle_bang(random)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   shuffle(random: Random) -> new_array */
"\n"/*  */
"\n"/* Returns a new array containing all elements from +self+ in a random order, */
"\n"/* as selected by the object given by the keyword argument +random+: */
"\n"/*  */
"\n"/*   a =            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] */
"\n"/*   a.shuffle # => [0, 8, 1, 9, 6, 3, 4, 7, 2, 5] */
"\n"/*   a.shuffle # => [8, 9, 0, 5, 1, 2, 6, 4, 7, 3] */
"\n"/*  */
"\n"/* Duplicate elements are included: */
"\n"/*  */
"\n"/*   a =            [0, 1, 0, 1, 0, 1, 0, 1, 0, 1] */
"\n"/*   a.shuffle # => [1, 0, 1, 1, 0, 0, 1, 0, 0, 1] */
"\n"/*   a.shuffle # => [1, 1, 0, 0, 0, 1, 1, 0, 0, 1] */
"\n"/*  */
"\n"/* The object given with the keyword argument +random+ is used as the random number generator. */
"\n"/*  */
"\n"/* Related: see {Methods for Fetching}[rdoc-ref:Array@Methods+for+Fetching]. */
"  def shuffle(random: Random)\n"
"    Primitive.rb_ary_shuffle(random)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   sample(random: Random) -> object */
"\n"/*   sample(count, random: Random) -> new_ary */
"\n"/*  */
"\n"/* Returns random elements from +self+, */
"\n"/* as selected by the object given by the keyword argument +random+. */
"\n"/*  */
"\n"/* With no argument +count+ given, returns one random element from +self+: */
"\n"/*  */
"\n"/*   a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] */
"\n"/*   a.sample # => 3 */
"\n"/*   a.sample # => 8 */
"\n"/*  */
"\n"/* Returns +nil+ if +self+ is empty: */
"\n"/*  */
"\n"/*   [].sample # => nil */
"\n"/*  */
"\n"/* With a non-negative numeric argument +count+ given, */
"\n"/* returns a new array containing +count+ random elements from +self+: */
"\n"/*  */
"\n"/*   a.sample(3) # => [8, 9, 2] */
"\n"/*   a.sample(6) # => [9, 6, 0, 3, 1, 4] */
"\n"/*  */
"\n"/* The order of the result array is unrelated to the order of +self+. */
"\n"/*  */
"\n"/* Returns a new empty array if +self+ is empty: */
"\n"/*  */
"\n"/*   [].sample(4) # => [] */
"\n"/*  */
"\n"/* May return duplicates in +self+: */
"\n"/*  */
"\n"/*   a = [1, 1, 1, 2, 2, 3] */
"\n"/*   a.sample(a.size) # => [1, 1, 3, 2, 1, 2] */
"\n"/*  */
"\n"/* Returns no more than <tt>a.size</tt> elements */
"\n"/* (because no new duplicates are introduced): */
"\n"/*  */
"\n"/*   a.sample(50) # => [6, 4, 1, 8, 5, 9, 0, 2, 3, 7] */
"\n"/*  */
"\n"/* The object given with the keyword argument +random+ is used as the random number generator: */
"\n"/*  */
"\n"/*   a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] */
"\n"/*   a.sample(random: Random.new(1))     # => 6 */
"\n"/*   a.sample(4, random: Random.new(1))  # => [6, 10, 9, 2] */
"\n"/*  */
"\n"/* Related: see {Methods for Fetching}[rdoc-ref:Array@Methods+for+Fetching]. */
"  def sample(n = (ary = false), random: Random)\n"
"    if Primitive.mandatory_only?\n"
"\n"/* Primitive.cexpr! %{ rb_ary_sample(self, rb_cRandom, Qfalse, Qfalse) } */
"      Primitive.ary_sample0\n"
"    else\n"
"\n"/* Primitive.cexpr! %{ rb_ary_sample(self, random, n, ary) } */
"      Primitive.ary_sample(random, n, ary)\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   first -> object or nil */
"\n"/*   first(count) -> new_array */
"\n"/*  */
"\n"/* Returns elements from +self+, or +nil+; does not modify +self+. */
"\n"/*  */
"\n"/* With no argument given, returns the first element (if available): */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.first # => :foo */
"\n"/*   a # => [:foo, \"bar\", 2] */
"\n"/*  */
"\n"/* If +self+ is empty, returns +nil+. */
"\n"/*  */
"\n"/*   [].first # => nil */
"\n"/*  */
"\n"/* With a non-negative integer argument +count+ given, */
"\n"/* returns the first +count+ elements (as available) in a new array: */
"\n"/*  */
"\n"/*   a.first(0)  # => [] */
"\n"/*   a.first(2)  # => [:foo, \"bar\"] */
"\n"/*   a.first(50) # => [:foo, \"bar\", 2] */
"\n"/*  */
"\n"/* Related: see {Methods for Querying}[rdoc-ref:Array@Methods+for+Querying]. */
"  def first n = unspecified = true\n"
,
#line 130 "array.rb"
"    if Primitive.mandatory_only?\n"
"      Primitive.attr! :leaf\n"
"      Primitive.cexpr! %q{ ary_first(self) }\n"
"    else\n"
"      if unspecified\n"
"        Primitive.cexpr! %q{ ary_first(self) }\n"
"      else\n"
"        Primitive.cexpr! %q{  ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_FIRST) }\n"
"      end\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*  last  -> last_object or nil */
"\n"/*  last(count) -> new_array */
"\n"/*  */
"\n"/* Returns elements from +self+, or +nil+; +self+ is not modified. */
"\n"/*  */
"\n"/* With no argument given, returns the last element, or +nil+ if +self+ is empty: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.last # => 2 */
"\n"/*   a # => [:foo, \"bar\", 2] */
"\n"/*   [].last # => nil */
"\n"/*  */
"\n"/*  */
"\n"/* With non-negative integer argument +count+ given, */
"\n"/* returns a new array containing the trailing +count+ elements of +self+, as available: */
"\n"/*  */
"\n"/*   a = [:foo, 'bar', 2] */
"\n"/*   a.last(2)  # => [\"bar\", 2] */
"\n"/*   a.last(50) # => [:foo, \"bar\", 2] */
"\n"/*   a.last(0)  # => [] */
"\n"/*   [].last(3) # => [] */
"\n"/*  */
"\n"/* Related: see {Methods for Fetching}[rdoc-ref:Array@Methods+for+Fetching]. */
"  def last n = unspecified = true\n"
"    if Primitive.mandatory_only?\n"
"      Primitive.attr! :leaf\n"
"      Primitive.cexpr! %q{ ary_last(self) }\n"
"    else\n"
"      if unspecified\n"
,
#line 172 "array.rb"
"        Primitive.cexpr! %q{ ary_last(self) }\n"
"      else\n"
"        Primitive.cexpr! %q{ ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_LAST) }\n"
"      end\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   fetch_values(*indexes) -> new_array */
"\n"/*   fetch_values(*indexes) { |index| ... } -> new_array */
"\n"/*  */
"\n"/* With no block given, returns a new array containing the elements of +self+ */
"\n"/* at the offsets specified by +indexes+. Each of the +indexes+ must be an */
"\n"/* {integer-convertible object}[rdoc-ref:implicit_conversion.rdoc@Integer-Convertible+Objects]: */
"\n"/*  */
"\n"/*    a = [:foo, :bar, :baz] */
"\n"/*    a.fetch_values(2, 0)   # => [:baz, :foo] */
"\n"/*    a.fetch_values(2.1, 0) # => [:baz, :foo] */
"\n"/*    a.fetch_values         # => [] */
"\n"/*  */
"\n"/* For a negative index, counts backwards from the end of the array: */
"\n"/*  */
"\n"/*    a.fetch_values(-2, -1) # [:bar, :baz] */
"\n"/*  */
"\n"/* When no block is given, raises an exception if any index is out of range. */
"\n"/*  */
"\n"/* With a block given, for each index: */
"\n"/*  */
"\n"/* - If the index is in range, uses an element of +self+ (as above). */
"\n"/* - Otherwise, calls the block with the index and uses the block's return value. */
"\n"/*  */
"\n"/* Example: */
"\n"/*  */
"\n"/*   a = [:foo, :bar, :baz] */
"\n"/*   a.fetch_values(1, 0, 42, 777) { |index| index.to_s } */
"\n"/*   # => [:bar, :foo, \"42\", \"777\"] */
"\n"/*  */
"\n"/* Related: see {Methods for Fetching}[rdoc-ref:Array@Methods+for+Fetching]. */
"  def fetch_values(*indexes, &block)\n"
"    indexes.map! { |i| fetch(i, &block) }\n"
"    indexes\n"
"  end\n"
"\n"
"  with_jit do\n"
"    if Primitive.rb_builtin_basic_definition_p(:each)\n"
"      undef :each\n"
"\n"
"      def each\n"/* :nodoc: */
"        Primitive.attr! :inline_block, :c_trace\n"
"\n"
"        unless defined?(yield)\n"
,
#line 223 "array.rb"
"          return Primitive.cexpr! 'SIZED_ENUMERATOR(self, 0, 0, ary_enum_length)'\n"
"        end\n"
"        _i = 0\n"
"        value = nil\n"
"        while Primitive.cexpr!(%q{ ary_fetch_next(self, LOCAL_PTR(_i), LOCAL_PTR(value)) })\n"
"          yield value\n"
"        end\n"
"        self\n"
"      end\n"
"    end\n"
"\n"
"    if Primitive.rb_builtin_basic_definition_p(:map)\n"
"      undef :map\n"
"\n"
"      def map\n"/* :nodoc: */
"        Primitive.attr! :inline_block, :c_trace\n"
"\n"
"        unless defined?(yield)\n"
,
#line 241 "array.rb"
"          return Primitive.cexpr! 'SIZED_ENUMERATOR(self, 0, 0, ary_enum_length)'\n"
"        end\n"
"\n"
"        _i = 0\n"
"        value = nil\n"
"        result = Primitive.ary_sized_alloc\n"
"        while Primitive.cexpr!(%q{ ary_fetch_next(self, LOCAL_PTR(_i), LOCAL_PTR(value)) })\n"
"          result << yield(value)\n"
"        end\n"
"        result\n"
"      end\n"
"\n"
"      if Primitive.rb_builtin_basic_definition_p(:collect)\n"
"        undef :collect\n"
"        alias collect map\n"
"      end\n"
"    end\n"
"\n"
,
#line 259 "array.rb"
"    if Primitive.rb_builtin_basic_definition_p(:select)\n"
"      undef :select\n"
"\n"
"      def select\n"/* :nodoc: */
"        Primitive.attr! :inline_block, :c_trace\n"
"\n"
"        unless defined?(yield)\n"
"          return Primitive.cexpr! 'SIZED_ENUMERATOR(self, 0, 0, ary_enum_length)'\n"
"        end\n"
"\n"
"        _i = 0\n"
"        value = nil\n"
"        result = Primitive.ary_sized_alloc\n"
"        while Primitive.cexpr!(%q{ ary_fetch_next(self, LOCAL_PTR(_i), LOCAL_PTR(value)) })\n"
"          result << value if yield value\n"
"        end\n"
"        result\n"
,
#line 276 "array.rb"
"      end\n"
"\n"
"      if Primitive.rb_builtin_basic_definition_p(:filter)\n"
"        undef :filter\n"
"        alias filter select\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
#line 3009 "miniprelude.c"
};

static const char prelude_name10[] = "<internal:hash>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[192]; /* 1..41 */
} prelude_code10 = {
#line 1 "hash.rb"
"class Hash\n"
"\n"/* call-seq: */
"\n"/*   Hash.new(default_value = nil, capacity: 0) -> new_hash */
"\n"/*   Hash.new(capacity: 0) {|self, key| ... } -> new_hash */
"\n"/*  */
"\n"/* Returns a new empty \\Hash object. */
"\n"/*  */
"\n"/* Initializes the values of Hash#default and Hash#default_proc, */
"\n"/* which determine the behavior when a given key is not found; */
"\n"/* see {Key Not Found?}[rdoc-ref:Hash@Key+Not+Found-3F]. */
"\n"/*  */
"\n"/* By default, a hash has +nil+ values for both +default+ and +default_proc+: */
"\n"/*  */
"\n"/*   h = Hash.new        # => {} */
"\n"/*   h.default           # => nil */
"\n"/*   h.default_proc      # => nil */
"\n"/*  */
"\n"/* With argument +default_value+ given, sets the +default+ value for the hash: */
"\n"/*  */
"\n"/*   h = Hash.new(false) # => {} */
"\n"/*   h.default           # => false */
"\n"/*   h.default_proc      # => nil */
"\n"/*  */
"\n"/* With a block given, sets the +default_proc+ value: */
"\n"/*  */
"\n"/*   h = Hash.new {|hash, key| \"Hash \#{hash}: Default value for \#{key}\" } */
"\n"/*   h.default      # => nil */
"\n"/*   h.default_proc # => #<Proc:0x00000289b6fa7048 (irb):185> */
"\n"/*   h[:nosuch]     # => \"Hash {}: Default value for nosuch\" */
"\n"/*  */
"\n"/* Raises ArgumentError if both +default_value+ and a block are given. */
"\n"/*  */
"\n"/* If optional keyword argument +capacity+ is given with a positive integer value +n+, */
"\n"/* initializes the hash with enough capacity to accommodate +n+ entries without resizing. */
"\n"/*  */
"\n"/* See also {Methods for Creating a Hash}[rdoc-ref:Hash@Methods+for+Creating+a+Hash]. */
"  def initialize(ifnone = (ifnone_unset = true), capacity: 0, &block)\n"
"    Primitive.rb_hash_init(capacity, ifnone_unset, ifnone, block)\n"
"  end\n"
"end\n"
#line 3057 "miniprelude.c"
};

static const char prelude_name11[] = "<internal:kernel>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[486]; /* 1..122 */
    RBIMPL_ATTR_NONSTRING() char L122[491]; /* 123..193 */
    RBIMPL_ATTR_NONSTRING() char L193[444]; /* 194..295 */
} prelude_code11 = {
#line 1 "kernel.rb"
"module Kernel\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.class    -> class */
"\n"/*  */
"\n"/*  Returns the class of <i>obj</i>. This method must always be called */
"\n"/*  with an explicit receiver, as #class is also a reserved word in */
"\n"/*  Ruby. */
"\n"/*  */
"\n"/*     1.class      #=> Integer */
"\n"/*     self.class   #=> Object */
"\n"/* -- */
"\n"/* Equivalent to \\c Object\\#class in Ruby. */
"\n"/*  */
"\n"/* Returns the class of \\c obj, skipping singleton classes or module inclusions. */
"\n"/* ++ */
"\n"/*  */
"  def class\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_obj_class_must(self)'\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.clone(freeze: nil) -> an_object */
"\n"/*  */
"\n"/*  Produces a shallow copy of <i>obj</i>---the instance variables of */
"\n"/*  <i>obj</i> are copied, but not the objects they reference. */
"\n"/*  #clone copies the frozen value state of <i>obj</i>, unless the */
"\n"/*  +:freeze+ keyword argument is given with a false or true value. */
"\n"/*  See also the discussion under Object#dup. */
"\n"/*  */
"\n"/*     class Klass */
"\n"/*        attr_accessor :str */
"\n"/*     end */
"\n"/*     s1 = Klass.new      #=> #<Klass:0x401b3a38> */
"\n"/*     s1.str = \"Hello\"    #=> \"Hello\" */
"\n"/*     s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\"> */
"\n"/*     s2.str[1,4] = \"i\"   #=> \"i\" */
"\n"/*     s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\" */
"\n"/*     s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\" */
"\n"/*  */
"\n"/*  This method may have class-specific behavior. If so, that */
"\n"/*  behavior will be documented under the #+initialize_copy+ method of */
"\n"/*  the class. */
"\n"/*  */
"  def clone(freeze: nil)\n"
"    Primitive.rb_obj_clone2(freeze)\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.frozen?    -> true or false */
"\n"/*  */
"\n"/*  Returns the freeze status of <i>obj</i>. */
"\n"/*  */
"\n"/*     a = [ \"a\", \"b\", \"c\" ] */
"\n"/*     a.freeze    #=> [\"a\", \"b\", \"c\"] */
"\n"/*     a.frozen?   #=> true */
"\n"/* -- */
"\n"/* Determines if the object is frozen. Equivalent to `Object#frozen?` in Ruby. */
"\n"/* @param[in] obj  the object to be determines */
"\n"/* @retval Qtrue if frozen */
"\n"/* @retval Qfalse if not frozen */
"\n"/* ++ */
"\n"/*  */
"  def frozen?\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_obj_frozen_p(self)'\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.tap {|x| block }    -> obj */
"\n"/*  */
"\n"/*  Yields self to the block and then returns self. */
"\n"/*  The primary purpose of this method is to \"tap into\" a method chain, */
"\n"/*  in order to perform operations on intermediate results within the chain. */
"\n"/*  */
"\n"/*     (1..10)                  .tap {|x| puts \"original: \#{x}\" } */
"\n"/*       .to_a                  .tap {|x| puts \"array:    \#{x}\" } */
"\n"/*       .select {|x| x.even? } .tap {|x| puts \"evens:    \#{x}\" } */
"\n"/*       .map {|x| x*x }        .tap {|x| puts \"squares:  \#{x}\" } */
"\n"/*  */
"\n"/* -- */
"\n"/* \\private */
"\n"/* ++ */
"\n"/*  */
"  def tap\n"
"    Primitive.attr! :inline_block\n"
"    yield(self)\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     obj.then {|x| block }          -> an_object */
"\n"/*  */
"\n"/*  Yields self to the block and returns the result of the block. */
"\n"/*  */
"\n"/*     3.next.then {|x| x**x }.to_s             #=> \"256\" */
"\n"/*  */
"\n"/*  A good use of +then+ is value piping in method chains: */
"\n"/*  */
"\n"/*     require 'open-uri' */
"\n"/*     require 'json' */
"\n"/*  */
"\n"/*     construct_url(arguments) */
"\n"/*       .then {|url| URI(url).read } */
"\n"/*       .then {|response| JSON.parse(response) } */
"\n"/*  */
"\n"/*  When called without a block, the method returns an +Enumerator+, */
"\n"/*  which can be used, for example, for conditional */
"\n"/*  circuit-breaking: */
"\n"/*  */
"\n"/*     # Meets condition, no-op */
"\n"/*     1.then.detect(&:odd?)            # => 1 */
"\n"/*     # Does not meet condition, drop value */
"\n"/*     2.then.detect(&:odd?)            # => nil */
"\n"/*  */
"  def then\n"
"    Primitive.attr! :inline_block\n"
,
#line 123 "kernel.rb"
"    unless defined?(yield)\n"
"      return Primitive.cexpr! 'SIZED_ENUMERATOR(self, 0, 0, rb_obj_size)'\n"
"    end\n"
"    yield(self)\n"
"  end\n"
"\n"
"  alias yield_self then\n"
"\n"
"  module_function\n"
"\n"
"\n"/* call-seq: */
"\n"/*    loop { block } */
"\n"/*    loop            -> an_enumerator */
"\n"/*  */
"\n"/* Repeatedly executes the block. */
"\n"/*  */
"\n"/* If no block is given, an enumerator is returned instead. */
"\n"/*  */
"\n"/*    loop do */
"\n"/*      print \"Input: \" */
"\n"/*      line = gets */
"\n"/*      # break if q, Q is entered or EOF signal (Ctrl-D on Unix, Ctrl-Z on windows) is sent */
"\n"/*      break if !line or line =~ /^q/i */
"\n"/*      # ... */
"\n"/*    end */
"\n"/*  */
"\n"/* A StopIteration raised in the block breaks the loop. In this case, */
"\n"/* loop returns the \"result\" value stored in the exception. */
"\n"/*  */
"\n"/*    enum = Enumerator.new { |y| */
"\n"/*      y << \"one\" */
"\n"/*      y << \"two\" */
"\n"/*      :ok */
"\n"/*    } */
"\n"/*  */
"\n"/*    result = loop { */
"\n"/*      puts enum.next */
"\n"/*    } #=> :ok */
"  def loop\n"
"    Primitive.attr! :inline_block\n"
"    unless defined?(yield)\n"
"      return Primitive.cexpr! 'SIZED_ENUMERATOR(self, 0, 0, rb_f_loop_size)'\n"
"    end\n"
"\n"
"    begin\n"
"      while true\n"
"        yield\n"
"      end\n"
"    rescue StopIteration => e\n"
"      e.result\n"
"    end\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     Float(arg, exception: true)    -> float or nil */
"\n"/*  */
"\n"/*  Returns <i>arg</i> converted to a float. Numeric types are */
"\n"/*  converted directly, and with exception to String and */
"\n"/*  <code>nil</code>, the rest are converted using */
"\n"/*  <i>arg</i><code>.to_f</code>. Converting a String with invalid */
"\n"/*  characters will result in an ArgumentError. Converting */
"\n"/*  <code>nil</code> generates a TypeError. Exceptions can be */
"\n"/*  suppressed by passing <code>exception: false</code>. */
"\n"/*  */
"\n"/*     Float(1)                 #=> 1.0 */
"\n"/*     Float(\"123.456\")         #=> 123.456 */
"\n"/*     Float(\"123.0_badstring\") #=> ArgumentError: invalid value for Float(): \"123.0_badstring\" */
"\n"/*     Float(nil)               #=> TypeError: can't convert nil into Float */
"\n"/*     Float(\"123.0_badstring\", exception: false)  #=> nil */
"\n"/*  */
,
#line 194 "kernel.rb"
"  def Float(arg, exception: true)\n"
"    if Primitive.mandatory_only?\n"
"      Primitive.rb_f_float1(arg)\n"
"    else\n"
"      Primitive.rb_f_float(arg, exception)\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Integer(object, base = 0, exception: true) -> integer or nil */
"\n"/*  */
"\n"/* Returns an integer converted from +object+. */
"\n"/*  */
"\n"/* Tries to convert +object+ to an integer */
"\n"/* using +to_int+ first and +to_i+ second; */
"\n"/* see below for exceptions. */
"\n"/*  */
"\n"/* With a non-zero +base+, +object+ must be a string or convertible */
"\n"/* to a string. */
"\n"/*  */
"\n"/* ==== \\Numeric objects */
"\n"/*  */
"\n"/* With an integer argument +object+ given, returns +object+: */
"\n"/*  */
"\n"/*   Integer(1)                # => 1 */
"\n"/*   Integer(-1)               # => -1 */
"\n"/*  */
"\n"/* With a floating-point argument +object+ given, */
"\n"/* returns +object+ truncated to an integer: */
"\n"/*  */
"\n"/*   Integer(1.9)              # => 1  # Rounds toward zero. */
"\n"/*   Integer(-1.9)             # => -1 # Rounds toward zero. */
"\n"/*  */
"\n"/* ==== \\String objects */
"\n"/*  */
"\n"/* With a string argument +object+ and zero +base+ given, */
"\n"/* returns +object+ converted to an integer in base 10: */
"\n"/*  */
"\n"/*   Integer('100')    # => 100 */
"\n"/*   Integer('-100')   # => -100 */
"\n"/*  */
"\n"/* With +base+ zero, string +object+ may contain leading characters */
"\n"/* to specify the actual base (radix indicator): */
"\n"/*  */
"\n"/*   Integer('0100')  # => 64  # Leading '0' specifies base 8. */
"\n"/*   Integer('0b100') # => 4   # Leading '0b' specifies base 2. */
"\n"/*   Integer('0x100') # => 256 # Leading '0x' specifies base 16. */
"\n"/*  */
"\n"/* With a positive +base+ (in range 2..36) given, returns +object+ */
"\n"/* converted to an integer in the given base: */
"\n"/*  */
"\n"/*   Integer('100', 2)   # => 4 */
"\n"/*   Integer('100', 8)   # => 64 */
"\n"/*   Integer('-100', 16) # => -256 */
"\n"/*  */
"\n"/* With a negative +base+ (in range -36..-2) given, returns +object+ */
"\n"/* converted to the radix indicator if it exists or */
"\n"/* +base+: */
"\n"/*  */
"\n"/*   Integer('0x100', -2)   # => 256 */
"\n"/*   Integer('100', -2)     # => 4 */
"\n"/*   Integer('0b100', -8)   # => 4 */
"\n"/*   Integer('100', -8)     # => 64 */
"\n"/*   Integer('0o100', -10)  # => 64 */
"\n"/*   Integer('100', -10)    # => 100 */
"\n"/*  */
"\n"/* +base+ -1 is equivalent to the -10 case. */
"\n"/*  */
"\n"/* When converting strings, surrounding whitespace and embedded underscores */
"\n"/* are allowed and ignored: */
"\n"/*  */
"\n"/*   Integer(' 100 ')      # => 100 */
"\n"/*   Integer('-1_0_0', 16) # => -256 */
"\n"/*  */
"\n"/* ==== Other classes */
"\n"/*  */
"\n"/* Examples with +object+ of various other classes: */
"\n"/*  */
"\n"/*   Integer(Rational(9, 10)) # => 0  # Rounds toward zero. */
"\n"/*   Integer(Complex(2, 0))   # => 2  # Imaginary part must be zero. */
"\n"/*   Integer(Time.now)        # => 1650974042 */
"\n"/*  */
"\n"/* ==== Keywords */
"\n"/*  */
"\n"/* With the optional keyword argument +exception+ given as +true+ (the default): */
"\n"/*  */
"\n"/* - Raises TypeError if +object+ does not respond to +to_int+ or +to_i+. */
"\n"/* - Raises TypeError if +object+ is +nil+. */
"\n"/* - Raises ArgumentError if +object+ is an invalid string. */
"\n"/*  */
"\n"/* With +exception+ given as +false+, an exception of any kind is suppressed */
"\n"/* and +nil+ is returned. */
"\n"/*  */
"  def Integer(arg, base = 0, exception: true)\n"
"    if Primitive.mandatory_only?\n"
"      Primitive.rb_f_integer1(arg)\n"
"    else\n"
"      Primitive.rb_f_integer(arg, base, exception)\n"
"    end\n"
"  end\n"
"end\n"
#line 3365 "miniprelude.c"
};

static const char prelude_name12[] = "<internal:pathname_builtin>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[484]; /* 1..234 */
    RBIMPL_ATTR_NONSTRING() char L234[503]; /* 235..267 */
    RBIMPL_ATTR_NONSTRING() char L267[488]; /* 268..281 */
    RBIMPL_ATTR_NONSTRING() char L281[507]; /* 282..315 */
    RBIMPL_ATTR_NONSTRING() char L315[499]; /* 316..342 */
    RBIMPL_ATTR_NONSTRING() char L342[500]; /* 343..369 */
    RBIMPL_ATTR_NONSTRING() char L369[494]; /* 370..390 */
    RBIMPL_ATTR_NONSTRING() char L390[501]; /* 391..430 */
    RBIMPL_ATTR_NONSTRING() char L430[499]; /* 431..452 */
    RBIMPL_ATTR_NONSTRING() char L452[506]; /* 453..476 */
    RBIMPL_ATTR_NONSTRING() char L476[498]; /* 477..492 */
    RBIMPL_ATTR_NONSTRING() char L492[481]; /* 493..527 */
    RBIMPL_ATTR_NONSTRING() char L527[489]; /* 528..609 */
    RBIMPL_ATTR_NONSTRING() char L609[494]; /* 610..671 */
    RBIMPL_ATTR_NONSTRING() char L671[498]; /* 672..688 */
    RBIMPL_ATTR_NONSTRING() char L688[504]; /* 689..704 */
    RBIMPL_ATTR_NONSTRING() char L704[480]; /* 705..732 */
    RBIMPL_ATTR_NONSTRING() char L732[487]; /* 733..808 */
    RBIMPL_ATTR_NONSTRING() char L808[499]; /* 809..836 */
    RBIMPL_ATTR_NONSTRING() char L836[487]; /* 837..850 */
    RBIMPL_ATTR_NONSTRING() char L850[489]; /* 851..883 */
    RBIMPL_ATTR_NONSTRING() char L883[465]; /* 884..918 */
    RBIMPL_ATTR_NONSTRING() char L918[467]; /* 919..946 */
    RBIMPL_ATTR_NONSTRING() char L946[493]; /* 947..977 */
    RBIMPL_ATTR_NONSTRING() char L977[466]; /* 978..1009 */
    RBIMPL_ATTR_NONSTRING() char L1009[485]; /* 1010..1041 */
    RBIMPL_ATTR_NONSTRING() char L1041[474]; /* 1042..1071 */
    RBIMPL_ATTR_NONSTRING() char L1071[489]; /* 1072..1099 */
    RBIMPL_ATTR_NONSTRING() char L1099[472]; /* 1100..1133 */
    RBIMPL_ATTR_NONSTRING() char L1133[486]; /* 1134..1167 */
    RBIMPL_ATTR_NONSTRING() char L1167[98]; /* 1168..1173 */
} prelude_code12 = {
#line 1 "pathname_builtin.rb"
""/* frozen_string_literal: true */
""/*  */
""/* = pathname.rb */
""/*  */
""/* Object-Oriented Pathname Class */
""/*  */
""/* Author:: Tanaka Akira <akr@m17n.org> */
""/* Documentation:: Author and Gavin Sinclair */
""/*  */
""/* For documentation, see class Pathname. */
""/*  */
""
""/*  */
""/* Pathname represents the name of a file or directory on the filesystem, */
""/* but not the file itself. */
""/*  */
""/* The pathname depends on the Operating System: Unix, Windows, etc. */
""/* This library works with pathnames of local OS, however non-Unix pathnames */
""/* are supported experimentally. */
""/*  */
""/* A Pathname can be relative or absolute.  It's not until you try to */
""/* reference the file that it even matters whether the file exists or not. */
""/*  */
""/* Pathname is immutable.  It has no method for destructive update. */
""/*  */
""/* The goal of this class is to manipulate file path information in a neater */
""/* way than standard Ruby provides.  The examples below demonstrate the */
""/* difference. */
""/*  */
""/* *All* functionality from File, FileTest, and some from Dir and FileUtils is */
""/* included, in an unsurprising way.  It is essentially a facade for all of */
""/* these, and more. */
""/*  */
""/* == Examples */
""/*  */
""/* === Example 1: Using Pathname */
""/*  */
""/*   require 'pathname' */
""/*   pn = Pathname.new(\"/usr/bin/ruby\") */
""/*   size = pn.size              # 27662 */
""/*   isdir = pn.directory?       # false */
""/*   dir  = pn.dirname           # Pathname:/usr/bin */
""/*   base = pn.basename          # Pathname:ruby */
""/*   dir, base = pn.split        # [Pathname:/usr/bin, Pathname:ruby] */
""/*   data = pn.read */
""/*   pn.open { |f| _ } */
""/*   pn.each_line { |line| _ } */
""/*  */
""/* === Example 2: Using standard Ruby */
""/*  */
""/*   pn = \"/usr/bin/ruby\" */
""/*   size = File.size(pn)        # 27662 */
""/*   isdir = File.directory?(pn) # false */
""/*   dir  = File.dirname(pn)     # \"/usr/bin\" */
""/*   base = File.basename(pn)    # \"ruby\" */
""/*   dir, base = File.split(pn)  # [\"/usr/bin\", \"ruby\"] */
""/*   data = File.read(pn) */
""/*   File.open(pn) { |f| _ } */
""/*   File.foreach(pn) { |line| _ } */
""/*  */
""/* === Example 3: Special features */
""/*  */
""/*   p1 = Pathname.new(\"/usr/lib\")   # Pathname:/usr/lib */
""/*   p2 = p1 + \"ruby/1.8\"            # Pathname:/usr/lib/ruby/1.8 */
""/*   p3 = p1.parent                  # Pathname:/usr */
""/*   p4 = p2.relative_path_from(p3)  # Pathname:lib/ruby/1.8 */
""/*   pwd = Pathname.pwd              # Pathname:/home/gavin */
""/*   pwd.absolute?                   # true */
""/*   p5 = Pathname.new \".\"           # Pathname:. */
""/*   p5 = p5 + \"music/../articles\"   # Pathname:music/../articles */
""/*   p5.cleanpath                    # Pathname:articles */
""/*   p5.realpath                     # Pathname:/home/gavin/articles */
""/*   p5.children                     # [Pathname:/home/gavin/articles/linux, ...] */
""/*  */
""/* == Breakdown of functionality */
""/*  */
""/* === Core methods */
""/*  */
""/* These methods are effectively manipulating a String, because that's */
""/* all a path is.  None of these access the file system except for */
""/* #mountpoint?, #children, #each_child, #realdirpath and #realpath. */
""/*  */
""/* - + */
""/* - #join */
""/* - #parent */
""/* - #root? */
""/* - #absolute? */
""/* - #relative? */
""/* - #relative_path_from */
""/* - #each_filename */
""/* - #cleanpath */
""/* - #realpath */
""/* - #realdirpath */
""/* - #children */
""/* - #each_child */
""/* - #mountpoint? */
""/*  */
""/* === File status predicate methods */
""/*  */
""/* These methods are a facade for FileTest: */
""/* - #blockdev? */
""/* - #chardev? */
""/* - #directory? */
""/* - #executable? */
""/* - #executable_real? */
""/* - #exist? */
""/* - #file? */
""/* - #grpowned? */
""/* - #owned? */
""/* - #pipe? */
""/* - #readable? */
""/* - #world_readable? */
""/* - #readable_real? */
""/* - #setgid? */
""/* - #setuid? */
""/* - #size */
""/* - #size? */
""/* - #socket? */
""/* - #sticky? */
""/* - #symlink? */
""/* - #writable? */
""/* - #world_writable? */
""/* - #writable_real? */
""/* - #zero? */
""/*  */
""/* === File property and manipulation methods */
""/*  */
""/* These methods are a facade for File: */
""/* - #each_line(*args, &block) */
""/* - #read(*args) */
""/* - #binread(*args) */
""/* - #readlines(*args) */
""/* - #sysopen(*args) */
""/* - #write(*args) */
""/* - #binwrite(*args) */
""/* - #atime */
""/* - #birthtime */
""/* - #ctime */
""/* - #mtime */
""/* - #chmod(mode) */
""/* - #lchmod(mode) */
""/* - #chown(owner, group) */
""/* - #lchown(owner, group) */
""/* - #fnmatch(pattern, *args) */
""/* - #fnmatch?(pattern, *args) */
""/* - #ftype */
""/* - #make_link(old) */
""/* - #open(*args, &block) */
""/* - #readlink */
""/* - #rename(to) */
""/* - #stat */
""/* - #lstat */
""/* - #make_symlink(old) */
""/* - #truncate(length) */
""/* - #utime(atime, mtime) */
""/* - #lutime(atime, mtime) */
""/* - #basename(*args) */
""/* - #dirname */
""/* - #extname */
""/* - #expand_path(*args) */
""/* - #split */
""/*  */
""/* === Directory methods */
""/*  */
""/* These methods are a facade for Dir: */
""/* - Pathname.glob(*args) */
""/* - Pathname.getwd / Pathname.pwd */
""/* - #rmdir */
""/* - #entries */
""/* - #each_entry(&block) */
""/* - #mkdir(*args) */
""/* - #opendir(*args) */
""/*  */
""/* === Utilities */
""/*  */
""/* These methods are a mixture of Find, FileUtils, and others: */
""/* - #find(&block) */
""/* - #mkpath */
""/* - #rmtree */
""/* - #unlink / #delete */
""/*  */
""/*  */
""/* == Method documentation */
""/*  */
""/* As the above section shows, most of the methods in Pathname are facades.  The */
""/* documentation for these methods generally just says, for instance, \"See */
""/* FileTest.writable?\", as you should be familiar with the original method */
""/* anyway, and its documentation (e.g. through +ri+) will contain more */
""/* information.  In some cases, a brief description will follow. */
""/*  */
"class Pathname\n"
"\n"
"\n"/* The version string. */
"  VERSION = \"0.4.0\"\n"
"\n"
"\n"/* :stopdoc: */
"\n"
"  if File::FNM_SYSCASE.nonzero?\n"
"\n"/* Avoid #zero? here because #casecmp can return nil. */
"    private def same_paths?(a, b) a.casecmp(b) == 0 end\n"
"  else\n"
"    private def same_paths?(a, b) a == b end\n"
"  end\n"
"\n"
"  attr_reader :path\n"
"  protected :path\n"
"\n"
"\n"/* :startdoc: */
"\n"
"\n"/*  */
"\n"/* Create a Pathname object from the given String (or String-like object). */
"\n"/* If +path+ contains a NUL character (<tt>\\0</tt>), an ArgumentError is raised. */
"\n"/*  */
"  def initialize(path)\n"
"    @path = File.path(path).dup\n"
"  rescue TypeError => e\n"
"    raise e.class, \"Pathname.new requires a String, #to_path or #to_str\", cause: nil\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* Freze self. */
"\n"/*  */
"  def freeze\n"
"    super\n"
"    @path.freeze\n"
"    self\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* Compare this pathname with +other+.  The comparison is string-based. */
"\n"/* Be aware that two different paths (<tt>foo.txt</tt> and <tt>./foo.txt</tt>) */
"\n"/* can refer to the same file. */
"\n"/*  */
"  def ==(other)\n"
,
#line 235 "pathname_builtin.rb"
"    return false unless Pathname === other\n"
"    other.path == @path\n"
"  end\n"
"  alias === ==\n"
"  alias eql? ==\n"
"\n"
"  unless method_defined?(:<=>, false)\n"
"\n"/* Provides for comparing pathnames, case-sensitively. */
"    def <=>(other)\n"
"      return nil unless Pathname === other\n"
"      @path.tr('/', \"\\0\") <=> other.path.tr('/', \"\\0\")\n"
"    end\n"
"  end\n"
"\n"
"  def hash\n"/* :nodoc: */
"    @path.hash\n"
"  end\n"
"\n"
"\n"/* Return the path as a String. */
"  def to_s\n"
"    @path.dup\n"
"  end\n"
"\n"
"\n"/* to_path is implemented so Pathname objects are usable with File.open, etc. */
"  alias to_path to_s\n"
"\n"
"  def inspect\n"/* :nodoc: */
"    \"#<#{self.class}:#{@path}>\"\n"
"  end\n"
"\n"
"  unless method_defined?(:sub, false)\n"
"\n"/* Return a pathname which is substituted by String#sub. */
"    def sub(pattern, *args, **kwargs, &block)\n"
,
#line 268 "pathname_builtin.rb"
"      if block\n"
"        path = @path.sub(pattern, *args, **kwargs) {|*sub_args|\n"
"          begin\n"
"            old = Thread.current[:pathname_sub_matchdata]\n"
"            Thread.current[:pathname_sub_matchdata] = $~\n"
"            eval(\"$~ = Thread.current[:pathname_sub_matchdata]\", block.binding)\n"
"          ensure\n"
"            Thread.current[:pathname_sub_matchdata] = old\n"
"          end\n"
"          yield(*sub_args)\n"
"        }\n"
"      else\n"
"        path = @path.sub(pattern, *args, **kwargs)\n"
"      end\n"
,
#line 282 "pathname_builtin.rb"
"      self.class.new(path)\n"
"    end\n"
"  end\n"
"\n"
"\n"/* Return a pathname with +repl+ added as a suffix to the basename. */
"\n"/*  */
"\n"/* If self has no extension part, +repl+ is appended. */
"\n"/*  */
"\n"/* Pathname.new('/usr/bin/shutdown').sub_ext('.rb') */
"\n"/*     #=> #<Pathname:/usr/bin/shutdown.rb> */
"  def sub_ext(repl)\n"
"    ext = File.extname(@path)\n"
"\n"
"\n"/* File.extname(\"foo.bar:stream\") returns \".bar\" on NTFS and not \".bar:stream\" */
"\n"/* (see ruby_enc_find_extname()). */
"\n"/* The behavior of Pathname#sub_ext is to replace everything */
"\n"/* from the start of the extname until the end of the path with repl. */
"    unless @path.end_with?(ext)\n"
"      ext = @path[@path.rindex(ext)..]\n"
"    end\n"
"\n"
"    self.class.new(@path.chomp(ext) + repl)\n"
"  end\n"
"\n"
"  if File::ALT_SEPARATOR\n"
"\n"/* Separator list string. */
"    SEPARATOR_LIST = Regexp.quote \"#{File::ALT_SEPARATOR}#{File::SEPARATOR}\"\n"
"\n"/* Regexp that matches a separator. */
"    SEPARATOR_PAT = /[#{SEPARATOR_LIST}]/\n"
"  else\n"
"    SEPARATOR_LIST = Regexp.quote File::SEPARATOR\n"
"    SEPARATOR_PAT = /#{SEPARATOR_LIST}/\n"
"  end\n"
"  SEPARATOR_LIST.freeze\n"
,
#line 316 "pathname_builtin.rb"
"  SEPARATOR_PAT.freeze\n"
"  private_constant :SEPARATOR_LIST, :SEPARATOR_LIST\n"
"\n"
"  if File.dirname('A:') == 'A:.'\n"/* DOSish drive letter */
"\n"/* Regexp that matches an absolute path. */
"    ABSOLUTE_PATH = /\\A(?:[A-Za-z]:|#{SEPARATOR_PAT})/\n"
"  else\n"
"    ABSOLUTE_PATH = /\\A#{SEPARATOR_PAT}/\n"
"  end\n"
"  ABSOLUTE_PATH.freeze\n"
"  private_constant :ABSOLUTE_PATH\n"
"\n"
"\n"/* :startdoc: */
"\n"
"\n"/* Creates a full path, including any intermediate directories that don't yet */
"\n"/* exist. */
"\n"/*  */
"\n"/* See FileUtils.mkpath and FileUtils.mkdir_p */
"  def mkpath(mode: nil)\n"
"    path = @path == '/' ? @path : @path.chomp('/')\n"
"\n"
"    stack = []\n"
"    until File.directory?(path) || File.dirname(path) == path\n"
"      stack.push path\n"
"      path = File.dirname(path)\n"
"    end\n"
"\n"
,
#line 343 "pathname_builtin.rb"
"    stack.reverse_each do |dir|\n"
"      dir = dir == '/' ? dir : dir.chomp('/')\n"
"      if mode\n"
"        Dir.mkdir dir, mode\n"
"        File.chmod mode, dir\n"
"      else\n"
"        Dir.mkdir dir\n"
"      end\n"
"    rescue SystemCallError\n"
"      raise unless File.directory?(dir)\n"
"    end\n"
"\n"
"    self\n"
"  end\n"
"\n"
"\n"/* chop_basename(path) -> [pre-basename, basename] or nil */
"  def chop_basename(path)\n"/* :nodoc: */
"    base = File.basename(path)\n"
"    if /\\A#{SEPARATOR_PAT}?\\z/o.match?(base)\n"
"      return nil\n"
"    else\n"
"      return path[0, path.rindex(base)], base\n"
"    end\n"
"  end\n"
"  private :chop_basename\n"
"\n"
"\n"/* split_names(path) -> prefix, [name, ...] */
,
#line 370 "pathname_builtin.rb"
"  def split_names(path)\n"/* :nodoc: */
"    names = []\n"
"    while r = chop_basename(path)\n"
"      path, basename = r\n"
"      names.unshift basename\n"
"    end\n"
"    return path, names\n"
"  end\n"
"  private :split_names\n"
"\n"
"  def prepend_prefix(prefix, relpath)\n"/* :nodoc: */
"    if relpath.empty?\n"
"      File.dirname(prefix)\n"
"    elsif SEPARATOR_PAT.match?(prefix)\n"
"      prefix = File.dirname(prefix)\n"
"      prefix = File.join(prefix, \"\") if File.basename(prefix + 'a') != 'a'\n"
"      prefix + relpath\n"
"    else\n"
"      prefix + relpath\n"
"    end\n"
"  end\n"
,
#line 391 "pathname_builtin.rb"
"  private :prepend_prefix\n"
"\n"
"\n"/* Returns clean pathname of +self+ with consecutive slashes and useless dots */
"\n"/* removed.  The filesystem is not accessed. */
"\n"/*  */
"\n"/* If +consider_symlink+ is +true+, then a more conservative algorithm is used */
"\n"/* to avoid breaking symbolic linkages.  This may retain more +..+ */
"\n"/* entries than absolutely necessary, but without accessing the filesystem, */
"\n"/* this can't be avoided. */
"\n"/*  */
"\n"/* See Pathname#realpath. */
"\n"/*  */
"  def cleanpath(consider_symlink=false)\n"
"    if consider_symlink\n"
"      cleanpath_conservative\n"
"    else\n"
"      cleanpath_aggressive\n"
"    end\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* Clean the path simply by resolving and removing excess +.+ and +..+ entries. */
"\n"/* Nothing more, nothing less. */
"\n"/*  */
"  def cleanpath_aggressive\n"/* :nodoc: */
"    path = @path\n"
"    names = []\n"
"    pre = path\n"
"    while r = chop_basename(pre)\n"
"      pre, base = r\n"
"      case base\n"
"      when '.'\n"
"      when '..'\n"
"        names.unshift base\n"
"      else\n"
"        if names[0] == '..'\n"
"          names.shift\n"
"        else\n"
"          names.unshift base\n"
"        end\n"
,
#line 431 "pathname_builtin.rb"
"      end\n"
"    end\n"
"    pre.tr!(File::ALT_SEPARATOR, File::SEPARATOR) if File::ALT_SEPARATOR\n"
"    if SEPARATOR_PAT.match?(File.basename(pre))\n"
"      names.shift while names[0] == '..'\n"
"    end\n"
"    self.class.new(prepend_prefix(pre, File.join(*names)))\n"
"  end\n"
"  private :cleanpath_aggressive\n"
"\n"
"\n"/* has_trailing_separator?(path) -> bool */
"  def has_trailing_separator?(path)\n"/* :nodoc: */
"    if r = chop_basename(path)\n"
"      pre, basename = r\n"
"      pre.length + basename.length < path.length\n"
"    else\n"
"      false\n"
"    end\n"
"  end\n"
"  private :has_trailing_separator?\n"
"\n"
"\n"/* add_trailing_separator(path) -> path */
,
#line 453 "pathname_builtin.rb"
"  def add_trailing_separator(path)\n"/* :nodoc: */
"    if File.basename(path + 'a') == 'a'\n"
"      path\n"
"    else\n"
"      File.join(path, \"\")\n"/* xxx: Is File.join is appropriate to add separator? */
"    end\n"
"  end\n"
"  private :add_trailing_separator\n"
"\n"
"  def del_trailing_separator(path)\n"/* :nodoc: */
"    if r = chop_basename(path)\n"
"      pre, basename = r\n"
"      pre + basename\n"
"    elsif /#{SEPARATOR_PAT}+\\z/o =~ path\n"
"      $` + File.dirname(path)[/#{SEPARATOR_PAT}*\\z/o]\n"
"    else\n"
"      path\n"
"    end\n"
"  end\n"
"  private :del_trailing_separator\n"
"\n"
"  def cleanpath_conservative\n"/* :nodoc: */
"    path = @path\n"
"    names = []\n"
,
#line 477 "pathname_builtin.rb"
"    pre = path\n"
"    while r = chop_basename(pre)\n"
"      pre, base = r\n"
"      names.unshift base if base != '.'\n"
"    end\n"
"    pre.tr!(File::ALT_SEPARATOR, File::SEPARATOR) if File::ALT_SEPARATOR\n"
"    if SEPARATOR_PAT.match?(File.basename(pre))\n"
"      names.shift while names[0] == '..'\n"
"    end\n"
"    if names.empty?\n"
"      self.class.new(File.dirname(pre))\n"
"    else\n"
"      if names.last != '..' && File.basename(path) == '.'\n"
"        names << '.'\n"
"      end\n"
"      result = prepend_prefix(pre, File.join(*names))\n"
,
#line 493 "pathname_builtin.rb"
"      if /\\A(?:\\.|\\.\\.)\\z/ !~ names.last && has_trailing_separator?(path)\n"
"        self.class.new(add_trailing_separator(result))\n"
"      else\n"
"        self.class.new(result)\n"
"      end\n"
"    end\n"
"  end\n"
"  private :cleanpath_conservative\n"
"\n"
"\n"/* Returns the parent directory. */
"\n"/*  */
"\n"/* This is same as <code>self + '..'</code>. */
"  def parent\n"
"    self + '..'\n"
"  end\n"
"\n"
"\n"/* Returns +true+ if +self+ points to a mountpoint. */
"  def mountpoint?\n"
"    begin\n"
"      stat1 = self.lstat\n"
"      stat2 = self.parent.lstat\n"
"      stat1.dev != stat2.dev || stat1.ino == stat2.ino\n"
"    rescue Errno::ENOENT\n"
"      false\n"
"    end\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* Predicate method for root directories.  Returns +true+ if the */
"\n"/* pathname consists of consecutive slashes. */
"\n"/*  */
"\n"/* It doesn't access the filesystem.  So it may return +false+ for some */
"\n"/* pathnames which points to roots such as <tt>/usr/..</tt>. */
"\n"/*  */
"  def root?\n"
,
#line 528 "pathname_builtin.rb"
"    chop_basename(@path) == nil && SEPARATOR_PAT.match?(@path)\n"
"  end\n"
"\n"
"\n"/* Predicate method for testing whether a path is absolute. */
"\n"/*  */
"\n"/* It returns +true+ if the pathname begins with a slash. */
"\n"/*  */
"\n"/*   p = Pathname.new('/im/sure') */
"\n"/*   p.absolute? */
"\n"/*       #=> true */
"\n"/*  */
"\n"/*   p = Pathname.new('not/so/sure') */
"\n"/*   p.absolute? */
"\n"/*       #=> false */
"  def absolute?\n"
"    ABSOLUTE_PATH.match? @path\n"
"  end\n"
"\n"
"\n"/* The opposite of Pathname#absolute? */
"\n"/*  */
"\n"/* It returns +false+ if the pathname begins with a slash. */
"\n"/*  */
"\n"/*   p = Pathname.new('/im/sure') */
"\n"/*   p.relative? */
"\n"/*       #=> false */
"\n"/*  */
"\n"/*   p = Pathname.new('not/so/sure') */
"\n"/*   p.relative? */
"\n"/*       #=> true */
"  def relative?\n"
"    !absolute?\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* Iterates over each component of the path. */
"\n"/*  */
"\n"/*   Pathname.new(\"/usr/bin/ruby\").each_filename {|filename| ... } */
"\n"/*     # yields \"usr\", \"bin\", and \"ruby\". */
"\n"/*  */
"\n"/* Returns an Enumerator if no block was given. */
"\n"/*  */
"\n"/*   enum = Pathname.new(\"/usr/bin/ruby\").each_filename */
"\n"/*     # ... do stuff ... */
"\n"/*   enum.each { |e| ... } */
"\n"/*     # yields \"usr\", \"bin\", and \"ruby\". */
"\n"/*  */
"  def each_filename\n"/* :yield: filename */
"    return to_enum(__method__) unless block_given?\n"
"    _, names = split_names(@path)\n"
"    names.each {|filename| yield filename }\n"
"    nil\n"
"  end\n"
"\n"
"\n"/* Iterates over and yields a new Pathname object */
"\n"/* for each element in the given path in descending order. */
"\n"/*  */
"\n"/*  Pathname.new('/path/to/some/file.rb').descend {|v| p v} */
"\n"/*     #<Pathname:/> */
"\n"/*     #<Pathname:/path> */
"\n"/*     #<Pathname:/path/to> */
"\n"/*     #<Pathname:/path/to/some> */
"\n"/*     #<Pathname:/path/to/some/file.rb> */
"\n"/*  */
"\n"/*  Pathname.new('path/to/some/file.rb').descend {|v| p v} */
"\n"/*     #<Pathname:path> */
"\n"/*     #<Pathname:path/to> */
"\n"/*     #<Pathname:path/to/some> */
"\n"/*     #<Pathname:path/to/some/file.rb> */
"\n"/*  */
"\n"/* Returns an Enumerator if no block was given. */
"\n"/*  */
"\n"/*   enum = Pathname.new(\"/usr/bin/ruby\").descend */
"\n"/*     # ... do stuff ... */
"\n"/*   enum.each { |e| ... } */
"\n"/*     # yields Pathnames /, /usr, /usr/bin, and /usr/bin/ruby. */
"\n"/*  */
"\n"/* It doesn't access the filesystem. */
"\n"/*  */
"  def descend\n"
"    return to_enum(__method__) unless block_given?\n"
"    vs = []\n"
"    ascend {|v| vs << v }\n"
,
#line 610 "pathname_builtin.rb"
"    vs.reverse_each {|v| yield v }\n"
"    nil\n"
"  end\n"
"\n"
"\n"/* Iterates over and yields a new Pathname object */
"\n"/* for each element in the given path in ascending order. */
"\n"/*  */
"\n"/*  Pathname.new('/path/to/some/file.rb').ascend {|v| p v} */
"\n"/*     #<Pathname:/path/to/some/file.rb> */
"\n"/*     #<Pathname:/path/to/some> */
"\n"/*     #<Pathname:/path/to> */
"\n"/*     #<Pathname:/path> */
"\n"/*     #<Pathname:/> */
"\n"/*  */
"\n"/*  Pathname.new('path/to/some/file.rb').ascend {|v| p v} */
"\n"/*     #<Pathname:path/to/some/file.rb> */
"\n"/*     #<Pathname:path/to/some> */
"\n"/*     #<Pathname:path/to> */
"\n"/*     #<Pathname:path> */
"\n"/*  */
"\n"/* Returns an Enumerator if no block was given. */
"\n"/*  */
"\n"/*   enum = Pathname.new(\"/usr/bin/ruby\").ascend */
"\n"/*     # ... do stuff ... */
"\n"/*   enum.each { |e| ... } */
"\n"/*     # yields Pathnames /usr/bin/ruby, /usr/bin, /usr, and /. */
"\n"/*  */
"\n"/* It doesn't access the filesystem. */
"\n"/*  */
"  def ascend\n"
"    return to_enum(__method__) unless block_given?\n"
"    path = @path\n"
"    yield self\n"
"    while r = chop_basename(path)\n"
"      path, = r\n"
"      break if path.empty?\n"
"      yield self.class.new(del_trailing_separator(path))\n"
"    end\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* Appends a pathname fragment to +self+ to produce a new Pathname object. */
"\n"/* Since +other+ is considered as a path relative to +self+, if +other+ is */
"\n"/* an absolute path, the new Pathname object is created from just +other+. */
"\n"/*  */
"\n"/*   p1 = Pathname.new(\"/usr\")      # Pathname:/usr */
"\n"/*   p2 = p1 + \"bin/ruby\"           # Pathname:/usr/bin/ruby */
"\n"/*   p3 = p1 + \"/etc/passwd\"        # Pathname:/etc/passwd */
"\n"/*  */
"\n"/*   # / is aliased to +. */
"\n"/*   p4 = p1 / \"bin/ruby\"           # Pathname:/usr/bin/ruby */
"\n"/*   p5 = p1 / \"/etc/passwd\"        # Pathname:/etc/passwd */
"\n"/*  */
"\n"/* This method doesn't access the file system; it is pure string manipulation. */
"\n"/*  */
"  def +(other)\n"
"    other = Pathname.new(other) unless Pathname === other\n"
"    Pathname.new(plus(@path, other.path))\n"
"  end\n"
"  alias / +\n"
"\n"
"  def plus(path1, path2)\n"/* -> path # :nodoc: */
,
#line 672 "pathname_builtin.rb"
"    prefix2 = path2\n"
"    index_list2 = []\n"
"    basename_list2 = []\n"
"    while r2 = chop_basename(prefix2)\n"
"      prefix2, basename2 = r2\n"
"      index_list2.unshift prefix2.length\n"
"      basename_list2.unshift basename2\n"
"    end\n"
"    return path2 if prefix2 != ''\n"
"    prefix1 = path1\n"
"    while true\n"
"      while !basename_list2.empty? && basename_list2.first == '.'\n"
"        index_list2.shift\n"
"        basename_list2.shift\n"
"      end\n"
"      break unless r1 = chop_basename(prefix1)\n"
"      prefix1, basename1 = r1\n"
,
#line 689 "pathname_builtin.rb"
"      next if basename1 == '.'\n"
"      if basename1 == '..' || basename_list2.empty? || basename_list2.first != '..'\n"
"        prefix1 = prefix1 + basename1\n"
"        break\n"
"      end\n"
"      index_list2.shift\n"
"      basename_list2.shift\n"
"    end\n"
"    r1 = chop_basename(prefix1)\n"
"    if !r1 && (r1 = SEPARATOR_PAT.match?(File.basename(prefix1)))\n"
"      while !basename_list2.empty? && basename_list2.first == '..'\n"
"        index_list2.shift\n"
"        basename_list2.shift\n"
"      end\n"
"    end\n"
"    if !basename_list2.empty?\n"
,
#line 705 "pathname_builtin.rb"
"      suffix2 = path2[index_list2.first..-1]\n"
"      r1 ? File.join(prefix1, suffix2) : prefix1 + suffix2\n"
"    else\n"
"      r1 ? prefix1 : File.dirname(prefix1)\n"
"    end\n"
"  end\n"
"  private :plus\n"
"\n"
"\n"/*  */
"\n"/* Joins the given pathnames onto +self+ to create a new Pathname object. */
"\n"/* This is effectively the same as using Pathname#+ to append +self+ and */
"\n"/* all arguments sequentially. */
"\n"/*  */
"\n"/*   path0 = Pathname.new(\"/usr\")                # Pathname:/usr */
"\n"/*   path0 = path0.join(\"bin/ruby\")              # Pathname:/usr/bin/ruby */
"\n"/*       # is the same as */
"\n"/*   path1 = Pathname.new(\"/usr\") + \"bin/ruby\"   # Pathname:/usr/bin/ruby */
"\n"/*   path0 == path1 */
"\n"/*       #=> true */
"\n"/*  */
"  def join(*args)\n"
"    return self if args.empty?\n"
"    result = args.pop\n"
"    result = Pathname.new(result) unless Pathname === result\n"
"    return result if result.absolute?\n"
"    args.reverse_each {|arg|\n"
"      arg = Pathname.new(arg) unless Pathname === arg\n"
"      result = arg + result\n"
,
#line 733 "pathname_builtin.rb"
"      return result if result.absolute?\n"
"    }\n"
"    self + result\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* Returns the children of the directory (files and subdirectories, not */
"\n"/* recursive) as an array of Pathname objects. */
"\n"/*  */
"\n"/* By default, the returned pathnames will have enough information to access */
"\n"/* the files. If you set +with_directory+ to +false+, then the returned */
"\n"/* pathnames will contain the filename only. */
"\n"/*  */
"\n"/* For example: */
"\n"/*   pn = Pathname(\"/usr/lib/ruby/1.8\") */
"\n"/*   pn.children */
"\n"/*       # -> [ Pathname:/usr/lib/ruby/1.8/English.rb, */
"\n"/*              Pathname:/usr/lib/ruby/1.8/Env.rb, */
"\n"/*              Pathname:/usr/lib/ruby/1.8/abbrev.rb, ... ] */
"\n"/*   pn.children(false) */
"\n"/*       # -> [ Pathname:English.rb, Pathname:Env.rb, Pathname:abbrev.rb, ... ] */
"\n"/*  */
"\n"/* Note that the results never contain the entries +.+ and +..+ in */
"\n"/* the directory because they are not children. */
"\n"/*  */
"  def children(with_directory=true)\n"
"    with_directory = false if @path == '.'\n"
"    result = []\n"
"    Dir.foreach(@path) {|e|\n"
"      next if e == '.' || e == '..'\n"
"      if with_directory\n"
"        result << self.class.new(File.join(@path, e))\n"
"      else\n"
"        result << self.class.new(e)\n"
"      end\n"
"    }\n"
"    result\n"
"  end\n"
"\n"
"\n"/* Iterates over the children of the directory */
"\n"/* (files and subdirectories, not recursive). */
"\n"/*  */
"\n"/* It yields Pathname object for each child. */
"\n"/*  */
"\n"/* By default, the yielded pathnames will have enough information to access */
"\n"/* the files. */
"\n"/*  */
"\n"/* If you set +with_directory+ to +false+, then the returned pathnames will */
"\n"/* contain the filename only. */
"\n"/*  */
"\n"/*   Pathname(\"/usr/local\").each_child {|f| p f } */
"\n"/*   #=> #<Pathname:/usr/local/share> */
"\n"/*   #   #<Pathname:/usr/local/bin> */
"\n"/*   #   #<Pathname:/usr/local/games> */
"\n"/*   #   #<Pathname:/usr/local/lib> */
"\n"/*   #   #<Pathname:/usr/local/include> */
"\n"/*   #   #<Pathname:/usr/local/sbin> */
"\n"/*   #   #<Pathname:/usr/local/src> */
"\n"/*   #   #<Pathname:/usr/local/man> */
"\n"/*  */
"\n"/*   Pathname(\"/usr/local\").each_child(false) {|f| p f } */
"\n"/*   #=> #<Pathname:share> */
"\n"/*   #   #<Pathname:bin> */
"\n"/*   #   #<Pathname:games> */
"\n"/*   #   #<Pathname:lib> */
"\n"/*   #   #<Pathname:include> */
"\n"/*   #   #<Pathname:sbin> */
"\n"/*   #   #<Pathname:src> */
"\n"/*   #   #<Pathname:man> */
"\n"/*  */
"\n"/* Note that the results never contain the entries +.+ and +..+ in */
"\n"/* the directory because they are not children. */
"\n"/*  */
"\n"/* See Pathname#children */
"\n"/*  */
"  def each_child(with_directory=true, &b)\n"
,
#line 809 "pathname_builtin.rb"
"    children(with_directory).each(&b)\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* Returns a relative path from the given +base_directory+ to the receiver. */
"\n"/*  */
"\n"/* If +self+ is absolute, then +base_directory+ must be absolute too. */
"\n"/*  */
"\n"/* If +self+ is relative, then +base_directory+ must be relative too. */
"\n"/*  */
"\n"/* This method doesn't access the filesystem.  It assumes no symlinks. */
"\n"/*  */
"\n"/* ArgumentError is raised when it cannot find a relative path. */
"\n"/*  */
"\n"/* Note that this method does not handle situations where the case sensitivity */
"\n"/* of the filesystem in use differs from the operating system default. */
"\n"/*  */
"  def relative_path_from(base_directory)\n"
"    base_directory = Pathname.new(base_directory) unless base_directory.is_a? Pathname\n"
"    dest_directory = self.cleanpath.path\n"
"    base_directory = base_directory.cleanpath.path\n"
"    dest_prefix = dest_directory\n"
"    dest_names = []\n"
"    while r = chop_basename(dest_prefix)\n"
"      dest_prefix, basename = r\n"
"      dest_names.unshift basename if basename != '.'\n"
"    end\n"
"    base_prefix = base_directory\n"
,
#line 837 "pathname_builtin.rb"
"    base_names = []\n"
"    while r = chop_basename(base_prefix)\n"
"      base_prefix, basename = r\n"
"      base_names.unshift basename if basename != '.'\n"
"    end\n"
"    unless same_paths?(dest_prefix, base_prefix)\n"
"      raise ArgumentError, \"different prefix: #{dest_prefix.inspect} and #{base_directory.inspect}\"\n"
"    end\n"
"    while !dest_names.empty? &&\n"
"          !base_names.empty? &&\n"
"          same_paths?(dest_names.first, base_names.first)\n"
"      dest_names.shift\n"
"      base_names.shift\n"
"    end\n"
,
#line 851 "pathname_builtin.rb"
"    if base_names.include? '..'\n"
"      raise ArgumentError, \"base_directory has ..: #{base_directory.inspect}\"\n"
"    end\n"
"    base_names.fill('..')\n"
"    relpath_names = base_names + dest_names\n"
"    if relpath_names.empty?\n"
"      Pathname.new('.')\n"
"    else\n"
"      Pathname.new(File.join(*relpath_names))\n"
"    end\n"
"  end\n"
"end\n"
"\n"
"class Pathname\n"/* * File * */
"\n"/*  */
"\n"/* #each_line iterates over the line in the file.  It yields a String object */
"\n"/* for each line. */
"\n"/*  */
"\n"/* This method has existed since 1.8.1. */
"\n"/*  */
"  def each_line(...)\n"/* :yield: line */
"    File.foreach(@path, ...)\n"
"  end\n"
"\n"
"\n"/* See <tt>File.read</tt>.  Returns all data from the file, or the first +N+ bytes */
"\n"/* if specified. */
"  def read(...) File.read(@path, ...) end\n"
"\n"
"\n"/* See <tt>File.binread</tt>.  Returns all the bytes from the file, or the first +N+ */
"\n"/* if specified. */
"  def binread(...) File.binread(@path, ...) end\n"
"\n"
"\n"/* See <tt>File.readlines</tt>.  Returns all the lines from the file. */
,
#line 884 "pathname_builtin.rb"
"  def readlines(...) File.readlines(@path, ...) end\n"
"\n"
"\n"/* See <tt>File.sysopen</tt>. */
"  def sysopen(...) File.sysopen(@path, ...) end\n"
"\n"
"\n"/* Writes +contents+ to the file. See <tt>File.write</tt>. */
"  def write(...) File.write(@path, ...) end\n"
"\n"
"\n"/* Writes +contents+ to the file, opening it in binary mode. */
"\n"/*  */
"\n"/* See File.binwrite. */
"  def binwrite(...) File.binwrite(@path, ...) end\n"
"\n"
"\n"/* See <tt>File.atime</tt>.  Returns last access time. */
"  def atime() File.atime(@path) end\n"
"\n"
"\n"/* Returns the birth time for the file. */
"\n"/* If the platform doesn't have birthtime, raises NotImplementedError. */
"\n"/*  */
"\n"/* See File.birthtime. */
"  def birthtime() File.birthtime(@path) end\n"
"\n"
"\n"/* See <tt>File.ctime</tt>.  Returns last (directory entry, not file) change time. */
"  def ctime() File.ctime(@path) end\n"
"\n"
"\n"/* See <tt>File.mtime</tt>.  Returns last modification time. */
"  def mtime() File.mtime(@path) end\n"
"\n"
"\n"/* See <tt>File.chmod</tt>.  Changes permissions. */
"  def chmod(mode) File.chmod(mode, @path) end\n"
"\n"
"\n"/* See <tt>File.lchmod</tt>. */
"  def lchmod(mode) File.lchmod(mode, @path) end\n"
"\n"
"\n"/* See <tt>File.chown</tt>.  Change owner and group of file. */
,
#line 919 "pathname_builtin.rb"
"  def chown(owner, group) File.chown(owner, group, @path) end\n"
"\n"
"\n"/* See <tt>File.lchown</tt>. */
"  def lchown(owner, group) File.lchown(owner, group, @path) end\n"
"\n"
"\n"/* See <tt>File.fnmatch</tt>.  Return +true+ if the receiver matches the given */
"\n"/* pattern. */
"  def fnmatch(pattern, ...) File.fnmatch(pattern, @path, ...) end\n"
"\n"
"\n"/* See <tt>File.fnmatch?</tt> (same as #fnmatch). */
"  def fnmatch?(pattern, ...) File.fnmatch?(pattern, @path, ...) end\n"
"\n"
"\n"/* See <tt>File.ftype</tt>.  Returns \"type\" of file (\"file\", \"directory\", */
"\n"/* etc). */
"  def ftype() File.ftype(@path) end\n"
"\n"
"\n"/* See <tt>File.link</tt>.  Creates a hard link. */
"  def make_link(old) File.link(old, @path) end\n"
"\n"
"\n"/* See <tt>File.open</tt>.  Opens the file for reading or writing. */
"  def open(...)\n"/* :yield: file */
"    File.open(@path, ...)\n"
"  end\n"
"\n"
"\n"/* See <tt>File.readlink</tt>.  Read symbolic link. */
"  def readlink() self.class.new(File.readlink(@path)) end\n"
"\n"
"\n"/* See <tt>File.rename</tt>.  Rename the file. */
,
#line 947 "pathname_builtin.rb"
"  def rename(to) File.rename(@path, to) end\n"
"\n"
"\n"/* See <tt>File.stat</tt>.  Returns a <tt>File::Stat</tt> object. */
"  def stat() File.stat(@path) end\n"
"\n"
"\n"/* See <tt>File.lstat</tt>. */
"  def lstat() File.lstat(@path) end\n"
"\n"
"\n"/* See <tt>File.symlink</tt>.  Creates a symbolic link. */
"  def make_symlink(old) File.symlink(old, @path) end\n"
"\n"
"\n"/* See <tt>File.truncate</tt>.  Truncate the file to +length+ bytes. */
"  def truncate(length) File.truncate(@path, length) end\n"
"\n"
"\n"/* See <tt>File.utime</tt>.  Update the access and modification times. */
"  def utime(atime, mtime) File.utime(atime, mtime, @path) end\n"
"\n"
"\n"/* Update the access and modification times of the file. */
"\n"/*  */
"\n"/* Same as Pathname#utime, but does not follow symbolic links. */
"\n"/*  */
"\n"/* See File.lutime. */
"  def lutime(atime, mtime) File.lutime(atime, mtime, @path) end\n"
"\n"
"\n"/* See <tt>File.basename</tt>.  Returns the last component of the path. */
"  def basename(...) self.class.new(File.basename(@path, ...)) end\n"
"\n"
"\n"/* See <tt>File.dirname</tt>.  Returns all but the last component of the path. */
"  def dirname() self.class.new(File.dirname(@path)) end\n"
"\n"
"\n"/* See <tt>File.extname</tt>.  Returns the file's extension. */
,
#line 978 "pathname_builtin.rb"
"  def extname() File.extname(@path) end\n"
"\n"
"\n"/* See <tt>File.expand_path</tt>. */
"  def expand_path(...) self.class.new(File.expand_path(@path, ...)) end\n"
"\n"
"\n"/* See <tt>File.split</tt>.  Returns the #dirname and the #basename in an */
"\n"/* Array. */
"  def split()\n"
"    array = File.split(@path)\n"
"    raise TypeError, 'wrong argument type nil (expected Array)' unless Array === array\n"
"    array.map {|f| self.class.new(f) }\n"
"  end\n"
"\n"
"\n"/* Returns the real (absolute) pathname for +self+ in the actual filesystem. */
"\n"/*  */
"\n"/* Does not contain symlinks or useless dots, +..+ and +.+. */
"\n"/*  */
"\n"/* All components of the pathname must exist when this method is called. */
"  def realpath(...) self.class.new(File.realpath(@path, ...)) end\n"
"\n"
"\n"/* Returns the real (absolute) pathname of +self+ in the actual filesystem. */
"\n"/*  */
"\n"/* Does not contain symlinks or useless dots, +..+ and +.+. */
"\n"/*  */
"\n"/* The last component of the real pathname can be nonexistent. */
"  def realdirpath(...) self.class.new(File.realdirpath(@path, ...)) end\n"
"end\n"
"\n"
"\n"
"class Pathname\n"/* * FileTest * */
"\n"
"\n"/* See <tt>FileTest.blockdev?</tt>. */
,
#line 1010 "pathname_builtin.rb"
"  def blockdev?() FileTest.blockdev?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.chardev?</tt>. */
"  def chardev?() FileTest.chardev?(@path) end\n"
"\n"
"\n"/* Tests the file is empty. */
"\n"/*  */
"\n"/* See Dir#empty? and FileTest.empty?. */
"  def empty?\n"
"    if FileTest.directory?(@path)\n"
"      Dir.empty?(@path)\n"
"    else\n"
"      File.empty?(@path)\n"
"    end\n"
"  end\n"
"\n"
"\n"/* See <tt>FileTest.executable?</tt>. */
"  def executable?() FileTest.executable?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.executable_real?</tt>. */
"  def executable_real?() FileTest.executable_real?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.exist?</tt>. */
"  def exist?() FileTest.exist?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.grpowned?</tt>. */
"  def grpowned?() FileTest.grpowned?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.directory?</tt>. */
"  def directory?() FileTest.directory?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.file?</tt>. */
,
#line 1042 "pathname_builtin.rb"
"  def file?() FileTest.file?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.pipe?</tt>. */
"  def pipe?() FileTest.pipe?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.socket?</tt>. */
"  def socket?() FileTest.socket?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.owned?</tt>. */
"  def owned?() FileTest.owned?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.readable?</tt>. */
"  def readable?() FileTest.readable?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.world_readable?</tt>. */
"  def world_readable?() File.world_readable?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.readable_real?</tt>. */
"  def readable_real?() FileTest.readable_real?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.setuid?</tt>. */
"  def setuid?() FileTest.setuid?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.setgid?</tt>. */
"  def setgid?() FileTest.setgid?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.size</tt>. */
"  def size() FileTest.size(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.size?</tt>. */
,
#line 1072 "pathname_builtin.rb"
"  def size?() FileTest.size?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.sticky?</tt>. */
"  def sticky?() FileTest.sticky?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.symlink?</tt>. */
"  def symlink?() FileTest.symlink?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.writable?</tt>. */
"  def writable?() FileTest.writable?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.world_writable?</tt>. */
"  def world_writable?() File.world_writable?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.writable_real?</tt>. */
"  def writable_real?() FileTest.writable_real?(@path) end\n"
"\n"
"\n"/* See <tt>FileTest.zero?</tt>. */
"  def zero?() FileTest.zero?(@path) end\n"
"end\n"
"\n"
"\n"
"class Pathname\n"/* * Dir * */
"\n"/* See <tt>Dir.glob</tt>.  Returns or yields Pathname objects. */
"  def Pathname.glob(*args, **kwargs)\n"/* :yield: pathname */
"    if block_given?\n"
"      Dir.glob(*args, **kwargs) {|f| yield self.new(f) }\n"
"    else\n"
,
#line 1100 "pathname_builtin.rb"
"      Dir.glob(*args, **kwargs).map {|f| self.new(f) }\n"
"    end\n"
"  end\n"
"\n"
"\n"/* Returns or yields Pathname objects. */
"\n"/*  */
"\n"/*  Pathname(\"ruby-2.4.2\").glob(\"R*.md\") */
"\n"/*  #=> [#<Pathname:ruby-2.4.2/README.md>, #<Pathname:ruby-2.4.2/README.ja.md>] */
"\n"/*  */
"\n"/* See Dir.glob. */
"\n"/* This method uses the +base+ keyword argument of Dir.glob. */
"  def glob(*args, **kwargs)\n"/* :yield: pathname */
"    if block_given?\n"
"      Dir.glob(*args, **kwargs, base: @path) {|f| yield self + f }\n"
"    else\n"
"      Dir.glob(*args, **kwargs, base: @path).map {|f| self + f }\n"
"    end\n"
"  end\n"
"\n"
"\n"/* See <tt>Dir.getwd</tt>.  Returns the current working directory as a Pathname. */
"  def Pathname.getwd() self.new(Dir.getwd) end\n"
"  class << self\n"
"    alias pwd getwd\n"
"  end\n"
"\n"
"\n"/* Return the entries (files and subdirectories) in the directory, each as a */
"\n"/* Pathname object. */
"  def entries() Dir.entries(@path).map {|f| self.class.new(f) } end\n"
"\n"
"\n"/* Iterates over the entries (files and subdirectories) in the directory.  It */
"\n"/* yields a Pathname object for each entry. */
"\n"/*  */
"\n"/* This method has existed since 1.8.1. */
"  def each_entry(&block)\n"/* :yield: pathname */
,
#line 1134 "pathname_builtin.rb"
"    return to_enum(__method__) unless block_given?\n"
"    Dir.foreach(@path) {|f| yield self.class.new(f) }\n"
"  end\n"
"\n"
"\n"/* See <tt>Dir.mkdir</tt>.  Create the referenced directory. */
"  def mkdir(...) Dir.mkdir(@path, ...) end\n"
"\n"
"\n"/* See <tt>Dir.rmdir</tt>.  Remove the referenced directory. */
"  def rmdir() Dir.rmdir(@path) end\n"
"\n"
"\n"/* See <tt>Dir.open</tt>. */
"  def opendir(&block)\n"/* :yield: dir */
"    Dir.open(@path, &block)\n"
"  end\n"
"end\n"
"\n"
"class Pathname\n"/* * mixed * */
"\n"/* Removes a file or directory, using <tt>File.unlink</tt> or */
"\n"/* <tt>Dir.unlink</tt> as necessary. */
"  def unlink()\n"
"    Dir.unlink @path\n"
"  rescue Errno::ENOTDIR\n"
"    File.unlink @path\n"
"  end\n"
"  alias delete unlink\n"
"end\n"
"\n"
"class Pathname\n"
"  undef =~ if Kernel.method_defined?(:=~)\n"
"end\n"
"\n"
"module Kernel\n"
"\n"/* Creates a Pathname object. */
"  def Pathname(path)\n"/* :doc: */
,
#line 1168 "pathname_builtin.rb"
"    return path if Pathname === path\n"
"    Pathname.new(path)\n"
"  end\n"
"  module_function :Pathname\n"
"end\n"
#line 4635 "miniprelude.c"
};

static const char prelude_name13[] = "<internal:ractor>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[506]; /* 1..238 */
    RBIMPL_ATTR_NONSTRING() char L238[486]; /* 239..316 */
    RBIMPL_ATTR_NONSTRING() char L316[496]; /* 317..348 */
    RBIMPL_ATTR_NONSTRING() char L348[504]; /* 349..378 */
    RBIMPL_ATTR_NONSTRING() char L378[497]; /* 379..458 */
    RBIMPL_ATTR_NONSTRING() char L458[470]; /* 459..483 */
    RBIMPL_ATTR_NONSTRING() char L483[470]; /* 484..520 */
    RBIMPL_ATTR_NONSTRING() char L520[499]; /* 521..550 */
    RBIMPL_ATTR_NONSTRING() char L550[499]; /* 551..633 */
    RBIMPL_ATTR_NONSTRING() char L633[508]; /* 634..698 */
    RBIMPL_ATTR_NONSTRING() char L698[472]; /* 699..818 */
    RBIMPL_ATTR_NONSTRING() char L818[303]; /* 819..835 */
} prelude_code13 = {
#line 1 "ractor.rb"
""/* Ractor.new creates a new \\Ractor, which can run in parallel with other ractors. */
""/*  */
""/*     # The simplest ractor */
""/*     r = Ractor.new {puts \"I am in Ractor!\"} */
""/*     r.join # wait for it to finish */
""/*     # Here, \"I am in Ractor!\" is printed */
""/*  */
""/* Ractors do not share all objects with each other. There are two main benefits to this: across ractors, thread-safety */
""/* concerns such as data-races and race-conditions are not possible. The other benefit is parallelism. */
""/*  */
""/* To achieve this, object sharing is limited across ractors. */
""/* Unlike in threads, ractors can't access all the objects available in other ractors. For example, objects normally */
""/* available through variables in the outer scope are prohibited from being used across ractors. */
""/*  */
""/*     a = 1 */
""/*     r = Ractor.new {puts \"I am in Ractor! a=\#{a}\"} */
""/*     # fails immediately with */
""/*     # ArgumentError (can not isolate a Proc because it accesses outer variables (a).) */
""/*  */
""/* The object must be explicitly shared: */
""/*     a = 1 */
""/*     r = Ractor.new(a) { |a1| puts \"I am in Ractor! a=\#{a1}\"} */
""/*  */
""/* On CRuby (the default implementation), the Global Virtual Machine Lock (GVL) is held per ractor, so */
""/* ractors can run in parallel. This is unlike the situation with threads on CRuby. */
""/*  */
""/* Instead of accessing shared state, objects should be passed to and from ractors by */
""/* sending and receiving them as messages. */
""/*  */
""/*     a = 1 */
""/*     r = Ractor.new do */
""/*       a_in_ractor = receive # receive blocks the Thread until our default port gets sent a message */
""/*       puts \"I am in Ractor! a=\#{a_in_ractor}\" */
""/*     end */
""/*     r.send(a)  # pass it */
""/*     r.join */
""/*     # Here, \"I am in Ractor! a=1\" is printed */
""/*  */
""/* In addition to that, any arguments passed to Ractor.new are passed to the block and available there */
""/* as if received by Ractor.receive, and the last block value can be received with Ractor#value. */
""/*  */
""/* == Shareable and unshareable objects */
""/*  */
""/* When an object is sent to a ractor, it's important to understand whether the */
""/* object is shareable or unshareable. Most Ruby objects are unshareable objects. Even */
""/* frozen objects can be unshareable if they contain (through their instance variables) unfrozen */
""/* objects. */
""/*  */
""/* Shareable objects are those which can be used by several ractors at once without compromising */
""/* thread-safety, for example numbers, +true+ and +false+. Ractor.shareable? allows you to check this, */
""/* and Ractor.make_shareable tries to make the object shareable if it's not already and gives an error */
""/* if it can't do it. */
""/*  */
""/*     Ractor.shareable?(1)            #=> true -- numbers and other immutable basic values are shareable */
""/*     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # frozen_string_literal: true */
""/*     Ractor.shareable?('foo'.freeze) #=> true */
""/*     Ractor.shareable?([Object.new].freeze) #=> false, inner object is unfrozen */
""/*  */
""/*     ary = ['hello', 'world'] */
""/*     ary.frozen?                 #=> false */
""/*     ary[0].frozen?              #=> false */
""/*     Ractor.make_shareable(ary) */
""/*     ary.frozen?                 #=> true */
""/*     ary[0].frozen?              #=> true */
""/*     ary[1].frozen?              #=> true */
""/*  */
""/* When a shareable object is sent via #send, no additional processing occurs */
""/* on it and it becomes usable by both ractors. When an unshareable object is sent, it can be */
""/* either _copied_ or _moved_. Copying is the default, and it copies the object fully by */
""/* deep cloning (Object#clone) the non-shareable parts of its structure. */
""/*  */
""/*     data = ['foo'.dup, 'bar'.freeze] */
""/*     r = Ractor.new do */
""/*       data2 = Ractor.receive */
""/*       puts \"In ractor: \#{data2.object_id}, \#{data2[0].object_id}, \#{data2[1].object_id}\" */
""/*     end */
""/*     r.send(data) */
""/*     r.join */
""/*     puts \"Outside  : \#{data.object_id}, \#{data[0].object_id}, \#{data[1].object_id}\" */
""/*  */
""/* This will output something like: */
""/*  */
""/*     In ractor: 8, 16, 24 */
""/*     Outside  : 32, 40, 24 */
""/*  */
""/* Note that the object ids of the array and the non-frozen string inside the array have changed in */
""/* the ractor because they are different objects. The second array's element, which is a */
""/* shareable frozen string, is the same object. */
""/*  */
""/* Deep cloning of objects may be slow, and sometimes impossible. Alternatively, <tt>move: true</tt> may */
""/* be used during sending. This will <em>move</em> the unshareable object to the receiving ractor, making it */
""/* inaccessible to the sending ractor. */
""/*  */
""/*     data = ['foo', 'bar'] */
""/*     r = Ractor.new do */
""/*       data_in_ractor = Ractor.receive */
""/*       puts \"In ractor: \#{data_in_ractor.object_id}, \#{data_in_ractor[0].object_id}\" */
""/*     end */
""/*     r.send(data, move: true) */
""/*     r.join */
""/*     puts \"Outside: moved? \#{Ractor::MovedObject === data}\" */
""/*     puts \"Outside: \#{data.inspect}\" */
""/*  */
""/* This will output: */
""/*  */
""/*     In ractor: 100, 120 */
""/*     Outside: moved? true */
""/*     test.rb:9:in `method_missing': can not send any methods to a moved object (Ractor::MovedError) */
""/*  */
""/* Notice that even +inspect+ and more basic methods like <tt>__id__</tt> are inaccessible */
""/* on a moved object. */
""/*  */
""/* +Class+ and +Module+ objects are shareable and their class/module definitions are shared between ractors. */
""/* \\Ractor objects are also shareable. All operations on shareable objects are thread-safe across ractors. */
""/* Defining mutable, shareable objects in Ruby is not possible, but C extensions can introduce them. */
""/*  */
""/* It is prohibited to access (get) instance variables of shareable objects in other ractors if the values of the */
""/* variables aren't shareable. This can occur because modules/classes are shareable, but they can have */
""/* instance variables whose values are not. In non-main ractors, it's also prohibited to set instance */
""/* variables on classes/modules (even if the value is shareable). */
""/*  */
""/*     class C */
""/*       class << self */
""/*         attr_accessor :tricky */
""/*       end */
""/*     end */
""/*  */
""/*     C.tricky = \"unshareable\".dup */
""/*  */
""/*     r = Ractor.new(C) do |cls| */
""/*       puts \"I see \#{cls}\" */
""/*       puts \"I can't see \#{cls.tricky}\" */
""/*       cls.tricky = true # doesn't get here, but this would also raise an error */
""/*     end */
""/*     r.join */
""/*     # I see C */
""/*     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError) */
""/*  */
""/* Ractors can access constants if they are shareable. The main \\Ractor is the only one that can */
""/* access non-shareable constants. */
""/*  */
""/*     GOOD = 'good'.freeze */
""/*     BAD = 'bad'.dup */
""/*  */
""/*     r = Ractor.new do */
""/*       puts \"GOOD=\#{GOOD}\" */
""/*       puts \"BAD=\#{BAD}\" */
""/*     end */
""/*     r.join */
""/*     # GOOD=good */
""/*     # can not access non-shareable objects in constant Object::BAD by non-main Ractor. (NameError) */
""/*  */
""/*     # Consider the same C class from above */
""/*  */
""/*     r = Ractor.new do */
""/*       puts \"I see \#{C}\" */
""/*       puts \"I can't see \#{C.tricky}\" */
""/*     end */
""/*     r.join */
""/*     # I see C */
""/*     # can not access instance variables of classes/modules from non-main Ractors (RuntimeError) */
""/*  */
""/* See also the description of <tt># shareable_constant_value</tt> pragma in */
""/* {Comments syntax}[rdoc-ref:syntax/comments.rdoc] explanation. */
""/*  */
""/* == Ractors vs threads */
""/*  */
""/* Each ractor has its own main Thread. New threads can be created from inside ractors */
""/* (and, on CRuby, they share the GVL with other threads of this ractor). */
""/*  */
""/*     r = Ractor.new do */
""/*       a = 1 */
""/*       Thread.new {puts \"Thread in ractor: a=\#{a}\"}.join */
""/*     end */
""/*     r.join */
""/*     # Here \"Thread in ractor: a=1\" will be printed */
""/*  */
""/* == Note on code examples */
""/*  */
""/* In the examples below, sometimes we use the following method to wait for ractors */
""/* to make progress or finish. */
""/*  */
""/*     def wait */
""/*       sleep(0.1) */
""/*     end */
""/*  */
""/* This is **only for demonstration purposes** and shouldn't be used in a real code. */
""/* Most of the time, #join is used to wait for ractors to finish and Ractor.receive is used */
""/* to wait for messages. */
""/*  */
""/* == Reference */
""/*  */
""/* See {Ractor design doc}[rdoc-ref:ractor.md] for more details. */
""/*  */
"class Ractor\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     Ractor.new(*args, name: nil) {|*args| block } -> ractor */
"\n"/*  */
"\n"/* Creates a new \\Ractor with args and a block. */
"\n"/*  */
"\n"/* The given block (Proc) is isolated (can't access any outer variables). +self+ */
"\n"/* inside the block will refer to the current \\Ractor. */
"\n"/*  */
"\n"/*    r = Ractor.new { puts \"Hi, I am \#{self.inspect}\" } */
"\n"/*    r.join */
"\n"/*    # Prints \"Hi, I am #<Ractor:#2 test.rb:1 running>\" */
"\n"/*  */
"\n"/* Any +args+ passed are propagated to the block arguments by the same rules as */
"\n"/* objects sent via #send/Ractor.receive. If an argument in +args+ is not shareable, it */
"\n"/* will be copied (via deep cloning, which might be inefficient). */
"\n"/*  */
"\n"/*    arg = [1, 2, 3] */
"\n"/*    puts \"Passing: \#{arg} (#\#{arg.object_id})\" */
"\n"/*    r = Ractor.new(arg) {|received_arg| */
"\n"/*      puts \"Received: \#{received_arg} (#\#{received_arg.object_id})\" */
"\n"/*    } */
"\n"/*    r.join */
"\n"/*    # Prints: */
"\n"/*    #   Passing: [1, 2, 3] (#280) */
"\n"/*    #   Received: [1, 2, 3] (#300) */
"\n"/*  */
"\n"/* Ractor's +name+ can be set for debugging purposes: */
"\n"/*  */
"\n"/*    r = Ractor.new(name: 'my ractor') {}; r.join */
"\n"/*    p r */
"\n"/*    #=> #<Ractor:#3 my ractor test.rb:1 terminated> */
"\n"/*  */
"  def self.new(*args, name: nil, &block)\n"
"    b = block\n"/* TODO: builtin bug */
"    raise ArgumentError, \"must be called with a block\" unless block\n"
"    if __builtin_cexpr!(\"RBOOL(ruby_single_main_ractor)\")\n"
"      Kernel.warn(\"Ractor API is experimental and may change in future versions of Ruby.\",\n"
"                  uplevel: 0, category: :experimental)\n"
"    end\n"
"    loc = caller_locations(1, 1).first\n"
"    loc = \"#{loc.path}:#{loc.lineno}\"\n"
"    __builtin_ractor_create(loc, name, args, b)\n"
,
#line 239 "ractor.rb"
"  end\n"
"\n"
"\n"/* Returns the currently executing Ractor. */
"\n"/*  */
"\n"/*   Ractor.current #=> #<Ractor:#1 running> */
"  def self.current\n"
"    __builtin_cexpr! %q{\n"
"      rb_ractor_self(rb_ec_ractor_ptr(ec));\n"
"    }\n"
"  end\n"
"\n"
"\n"/* Returns the number of ractors currently running or blocking (waiting). */
"\n"/*  */
"\n"/*    Ractor.count                   #=> 1 */
"\n"/*    r = Ractor.new(name: 'example') { Ractor.receive } */
"\n"/*    Ractor.count                   #=> 2 (main + example ractor) */
"\n"/*    r << 42                        # r's Ractor.receive will resume */
"\n"/*    r.join                         # wait for r's termination */
"\n"/*    Ractor.count                   #=> 1 */
"  def self.count\n"
"    __builtin_cexpr! %q{\n"
"      ULONG2NUM(GET_VM()->ractor.cnt);\n"
"    }\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    Ractor.select(*ractors_or_ports) -> [ractor or port, obj] */
"\n"/*  */
"\n"/* Blocks the current Thread until one of the given ports has received a message. Returns an */
"\n"/* array of two elements where the first element is the Port and the second is the received object. */
"\n"/* This method can also accept Ractor objects themselves, and in that case will wait until one */
"\n"/* has terminated and return a two-element array where the first element is the ractor and the */
"\n"/* second is its termination value. */
"\n"/*  */
"\n"/*    p1, p2 = Ractor::Port.new, Ractor::Port.new */
"\n"/*    ps = [p1, p2] */
"\n"/*    rs = 2.times.map do |i| */
"\n"/*      Ractor.new(ps.shift, i) do |p, i| */
"\n"/*        sleep rand(0.99) */
"\n"/*        p.send(\"r\#{i}\") */
"\n"/*        sleep rand(0.99) */
"\n"/*        \"r\#{i} done\" */
"\n"/*      end */
"\n"/*    end */
"\n"/*  */
"\n"/*    waiting_on = [p1, p2, *rs] */
"\n"/*    until waiting_on.empty? */
"\n"/*      received_on, obj = Ractor.select(*waiting_on) */
"\n"/*      waiting_on.delete(received_on) */
"\n"/*      puts obj */
"\n"/*    end */
"\n"/*  */
"\n"/*    # r0 */
"\n"/*    # r1 */
"\n"/*    # r1 done */
"\n"/*    # r0 done */
"\n"/*  */
"\n"/* The following example is almost equivalent to <code>ractors.map(&:value)</code> except the thread */
"\n"/* is unblocked when any of the ractors has terminated as opposed to waiting for their termination in */
"\n"/* the array element order. */
"\n"/*  */
"\n"/*    values = [] */
"\n"/*    until ractors.empty? */
"\n"/*      r, val = Ractor.select(*ractors) */
"\n"/*      ractors.delete(r) */
"\n"/*      values << val */
"\n"/*    end */
"\n"/*  */
"  def self.select(*ports)\n"
"    raise ArgumentError, 'specify at least one Ractor::Port or Ractor' if ports.empty?\n"
"\n"
"    monitors = {}\n"/* Ractor::Port => Ractor */
"\n"
"    ports = ports.map do |arg|\n"
"      case arg\n"
"      when Ractor\n"
"        port = Ractor::Port.new\n"
,
#line 317 "ractor.rb"
"        monitors[port] = arg\n"
"        arg.monitor port\n"
"        port\n"
"      when Ractor::Port\n"
"        arg\n"
"      else\n"
"        raise ArgumentError, \"should be Ractor::Port or Ractor\"\n"
"      end\n"
"    end\n"
"\n"
"    begin\n"
"      result_port, obj = __builtin_ractor_select_internal(ports)\n"
"\n"
"      if r = monitors[result_port]\n"
"        [r, r.value]\n"
"      else\n"
"        [result_port, obj]\n"
"      end\n"
"    ensure\n"
"\n"/* close all ports for join */
"      monitors.each do |port, r|\n"
"        r.unmonitor port\n"
"        port.close\n"
"      end\n"
"    end\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    Ractor.receive -> obj */
"\n"/*  */
"\n"/* Receives a message from the current ractor's default port. */
,
#line 349 "ractor.rb"
"  def self.receive\n"
"    Ractor.current.default_port.receive\n"
"  end\n"
"\n"
"  class << self\n"
"    alias recv receive\n"
"  end\n"
"\n"
"\n"/* same as Ractor.receive */
"  private def receive\n"
"    default_port.receive\n"
"  end\n"
"  alias recv receive\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*   ractor.send(msg, move: false) -> self */
"\n"/*  */
"\n"/* This is equivalent to Port#send to the ractor's #default_port. */
"  def send(...)\n"
"    default_port.send(...)\n"
"    self\n"
"  end\n"
"  alias << send\n"
"\n"
"  def inspect\n"
"    loc  = __builtin_cexpr! %q{ RACTOR_PTR(self)->loc }\n"
"    name = __builtin_cexpr! %q{ RACTOR_PTR(self)->name }\n"
"    id   = __builtin_cexpr! %q{ UINT2NUM(rb_ractor_id(RACTOR_PTR(self))) }\n"
"    status = __builtin_cexpr! %q{\n"
,
#line 379 "ractor.rb"
"      rb_str_new2(ractor_status_str(RACTOR_PTR(self)->status_))\n"
"    }\n"
"    \"#<Ractor:##{id}#{name ? ' '+name : ''}#{loc ? \" \" + loc : ''} #{status}>\"\n"
"  end\n"
"\n"
"  alias to_s inspect\n"
"\n"
"\n"/* Returns the name set in Ractor.new, or +nil+. */
"  def name\n"
"    __builtin_cexpr! %q{RACTOR_PTR(self)->name}\n"
"  end\n"
"\n"
"  class RemoteError\n"
"\n"/* The Ractor in which the uncaught exception was raised. */
"    attr_reader :ractor\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     ractor.close -> true | false */
"\n"/*  */
"\n"/* Closes the default port. Closing a port is allowed only by the ractor which created the port. */
"\n"/* Therefore, the receiver must be the current ractor. */
"\n"/*  */
"  def close\n"
"    default_port.close\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    Ractor.shareable?(obj) -> true | false */
"\n"/*  */
"\n"/* Checks if the object is shareable by ractors. */
"\n"/*  */
"\n"/*     Ractor.shareable?(1)            #=> true -- numbers are shareable */
"\n"/*     Ractor.shareable?('foo')        #=> false, unless the string is frozen due to # frozen_string_literal: true */
"\n"/*     Ractor.shareable?('foo'.freeze) #=> true */
"\n"/*  */
"\n"/* See also the \"Shareable and unshareable objects\" section in the \\Ractor class docs. */
"  def self.shareable? obj\n"
"    __builtin_cexpr! %q{\n"
"      RBOOL(rb_ractor_shareable_p(obj));\n"
"    }\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    Ractor.make_shareable(obj, copy: false) -> shareable_obj */
"\n"/*  */
"\n"/* Makes +obj+ shareable between ractors. */
"\n"/*  */
"\n"/* +obj+ and all the objects it refers to will be frozen, unless they are */
"\n"/* already shareable. */
"\n"/*  */
"\n"/* If +copy+ keyword is +true+, it will copy objects before freezing them, and will not */
"\n"/* modify +obj+ or its internal objects. */
"\n"/*  */
"\n"/* Note that the specification and implementation of this method are not */
"\n"/* mature and may be changed in the future. */
"\n"/*  */
"\n"/*   obj = ['test'] */
"\n"/*   Ractor.shareable?(obj)     #=> false */
"\n"/*   Ractor.make_shareable(obj) #=> [\"test\"] */
"\n"/*   Ractor.shareable?(obj)     #=> true */
"\n"/*   obj.frozen?                #=> true */
"\n"/*   obj[0].frozen?             #=> true */
"\n"/*  */
"\n"/*   # Copy vs non-copy versions: */
"\n"/*   obj1 = ['test'] */
"\n"/*   obj1s = Ractor.make_shareable(obj1) */
"\n"/*   obj1.frozen?                        #=> true */
"\n"/*   obj1s.object_id == obj1.object_id   #=> true */
"\n"/*   obj2 = ['test'] */
"\n"/*   obj2s = Ractor.make_shareable(obj2, copy: true) */
"\n"/*   obj2.frozen?                        #=> false */
"\n"/*   obj2s.frozen?                       #=> true */
"\n"/*   obj2s.object_id == obj2.object_id   #=> false */
"\n"/*   obj2s[0].object_id == obj2[0].object_id #=> false */
"\n"/*  */
"\n"/* See also the \"Shareable and unshareable objects\" section in the Ractor class docs. */
,
#line 459 "ractor.rb"
"  def self.make_shareable obj, copy: false\n"
"    if copy\n"
"      __builtin_cexpr! %q{\n"
"        rb_ractor_make_shareable_copy(obj);\n"
"      }\n"
"    else\n"
"      __builtin_cexpr! %q{\n"
"        rb_ractor_make_shareable(obj);\n"
"      }\n"
"    end\n"
"  end\n"
"\n"
"\n"/* Gets a value from ractor-local storage for the current Ractor. */
"\n"/* Obsolete, use Ractor.[] instead. */
"  def [](sym)\n"
"    if (self != Ractor.current)\n"
"      raise RuntimeError, \"Cannot get ractor local storage for non-current ractor\"\n"
"    end\n"
"    Primitive.ractor_local_value(sym)\n"
"  end\n"
"\n"
"\n"/* Sets a value in ractor-local storage for the current Ractor. */
"\n"/* Obsolete, use Ractor.[]= instead. */
"  def []=(sym, val)\n"
"    if (self != Ractor.current)\n"
,
#line 484 "ractor.rb"
"      raise RuntimeError, \"Cannot set ractor local storage for non-current ractor\"\n"
"    end\n"
"    Primitive.ractor_local_value_set(sym, val)\n"
"  end\n"
"\n"
"\n"/* Gets a value from ractor-local storage for the current Ractor. */
"  def self.[](sym)\n"
"    Primitive.ractor_local_value(sym)\n"
"  end\n"
"\n"
"\n"/* Sets a value in ractor-local storage for the current Ractor. */
"  def self.[]=(sym, val)\n"
"    Primitive.ractor_local_value_set(sym, val)\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Ractor.store_if_absent(key){ init_block } */
"\n"/*  */
"\n"/* If the corresponding ractor-local value is not set, yields a value with */
"\n"/* init_block and stores the value in a thread-safe manner. */
"\n"/* This method returns the stored value. */
"\n"/*  */
"\n"/*   (1..10).map{ */
"\n"/*     Thread.new(it){|i| */
"\n"/*       Ractor.store_if_absent(:s){ f(); i } */
"\n"/*       #=> return stored value of key :s */
"\n"/*     } */
"\n"/*   }.map(&:value).uniq.size #=> 1 and f() is called only once */
"\n"/*  */
"  def self.store_if_absent(sym)\n"
"    Primitive.attr! :use_block\n"
"    Primitive.ractor_local_value_store_if_absent(sym)\n"
"  end\n"
"\n"
"\n"/* Returns the main ractor. */
"  def self.main\n"
"    __builtin_cexpr! %q{\n"
,
#line 521 "ractor.rb"
"      rb_ractor_self(GET_VM()->ractor.main_ractor);\n"
"    }\n"
"  end\n"
"\n"
"\n"/* Returns true if the current ractor is the main ractor. */
"  def self.main?\n"
"    __builtin_cexpr! %q{\n"
"      RBOOL(GET_VM()->ractor.main_ractor == rb_ec_ractor_ptr(ec))\n"
"    }\n"
"  end\n"
"\n"
"\n"/* internal method */
"  def self._require feature\n"/* :nodoc: */
"    if main?\n"
"      super feature\n"
"    else\n"
"      Primitive.ractor_require feature\n"
"    end\n"
"  end\n"
"\n"
"  class << self\n"
"    private\n"
"\n"
"\n"/* internal method that is called when the first \"Ractor.new\" is called */
"    def _activated\n"/* :nodoc: */
"      Kernel.prepend Module.new{|m|\n"
"        m.set_temporary_name '<RactorRequire>'\n"
"\n"
"        def require feature\n"/* :nodoc: -- otherwise RDoc outputs it as a class method */
"          if Ractor.main?\n"
,
#line 551 "ractor.rb"
"            super\n"
"          else\n"
"            Ractor._require feature\n"
"          end\n"
"        end\n"
"      }\n"
"    end\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*   ractor.default_port -> port object */
"\n"/*  */
"\n"/* Returns the default port of the Ractor. */
"\n"/*  */
"  def default_port\n"
"    __builtin_cexpr! %q{\n"
"      ractor_default_port_value(RACTOR_PTR(self))\n"
"    }\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    ractor.join -> self */
"\n"/*  */
"\n"/* Waits for the termination of the Ractor. */
"\n"/* If the Ractor was aborted (terminated by an unhandled exception), */
"\n"/* the exception is raised in the current ractor. */
"\n"/*  */
"\n"/*     Ractor.new{}.join #=> ractor */
"\n"/*  */
"\n"/*     Ractor.new{ raise \"foo\" }.join */
"\n"/*     #=> raises the exception \"foo (RuntimeError)\" */
"\n"/*  */
"  def join\n"
"    port = Port.new\n"
"\n"
"    self.monitor port\n"
"    if port.receive == :aborted\n"
"      __builtin_ractor_value\n"
"    end\n"
"\n"
"    self\n"
"  ensure\n"
"    port.close\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    ractor.value -> obj */
"\n"/*  */
"\n"/* Waits for +ractor+ to complete and returns its value or raises the exception */
"\n"/* which terminated the Ractor. The termination value will be moved to the calling */
"\n"/* Ractor. Therefore, at most 1 Ractor can receive another ractor's termination value. */
"\n"/*  */
"\n"/*   r = Ractor.new{ [1, 2] } */
"\n"/*   r.value #=> [1, 2] (unshareable object) */
"\n"/*  */
"\n"/*   Ractor.new(r){|r| r.value} #=> Ractor::Error */
"\n"/*  */
"  def value\n"
"    self.join\n"
"    __builtin_ractor_value\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    ractor.monitor(port) -> self */
"\n"/*  */
"\n"/* Registers the port as a monitoring port for this ractor. When the ractor terminates, */
"\n"/* the port receives a Symbol object. */
"\n"/*  */
"\n"/* * +:exited+ is sent if the ractor terminates without an unhandled exception. */
"\n"/* * +:aborted+ is sent if the ractor terminates by an unhandled exception. */
"\n"/*  */
"\n"/*     r = Ractor.new{ some_task() } */
"\n"/*     r.monitor(port = Ractor::Port.new) */
"\n"/*     port.receive #=> :exited and r is terminated */
"\n"/*  */
"\n"/*     r = Ractor.new{ raise \"foo\" } */
"\n"/*     r.monitor(port = Ractor::Port.new) */
"\n"/*     port.receive #=> :aborted and r is terminated by the RuntimeError \"foo\" */
"\n"/*  */
,
#line 634 "ractor.rb"
"  def monitor port\n"
"    __builtin_ractor_monitor(port)\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    ractor.unmonitor(port) -> self */
"\n"/*  */
"\n"/* Unregisters the port from the monitoring ports for this ractor. */
"\n"/*  */
"  def unmonitor port\n"
"    __builtin_ractor_unmonitor(port)\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*   Ractor.shareable_proc(self: nil){} -> shareable proc */
"\n"/*  */
"\n"/* Returns a shareable copy of the given block's Proc. The value of +self+ */
"\n"/* in the Proc will be replaced with the value passed via the `self:` keyword, */
"\n"/* or +nil+ if not given. */
"\n"/*  */
"\n"/* In a shareable Proc, access to any outer variables if prohibited. */
"\n"/*  */
"\n"/*     a = 42 */
"\n"/*     Ractor.shareable_proc{ p a } */
"\n"/*     #=> can not isolate a Proc because it accesses outer variables (a). (ArgumentError) */
"\n"/*  */
"\n"/* The value of `self` in the Proc must be a shareable object. */
"\n"/*  */
"\n"/*     Ractor.shareable_proc(self: self){} */
"\n"/*     #=> self should be shareable: main (Ractor::IsolationError) */
"\n"/*  */
"  def self.shareable_proc self: nil\n"
"    Primitive.attr! :use_block\n"
"\n"
"    __builtin_cexpr!(%Q{\n"
"      ractor_shareable_proc(ec, *LOCAL_PTR(self), false)\n"
"    })\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*   Ractor.shareable_lambda(self: nil){} -> shareable lambda */
"\n"/*  */
"\n"/* Same as Ractor.shareable_proc, but returns a lambda Proc. */
"\n"/*  */
"  def self.shareable_lambda self: nil\n"
"    Primitive.attr! :use_block\n"
"\n"
"    __builtin_cexpr!(%Q{\n"
"      ractor_shareable_proc(ec, *LOCAL_PTR(self), true)\n"
"    })\n"
"  end\n"
"\n"
"\n"/* \\Port objects transmit messages between Ractors. */
"  class Port\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    port.receive -> msg */
"\n"/*  */
"\n"/* Receives a message from the port (which was sent there by Port#send). Only the ractor */
"\n"/* that created the port can receive messages this way. */
"\n"/*  */
"\n"/*     port = Ractor::Port.new */
,
#line 699 "ractor.rb"
"\n"/*     r = Ractor.new port do |port| */
"\n"/*       port.send('message1') */
"\n"/*     end */
"\n"/*  */
"\n"/*     v1 = port.receive */
"\n"/*     puts \"Received: \#{v1}\" */
"\n"/*     r.join */
"\n"/*     # This will print: \"Received: message1\" */
"\n"/*  */
"\n"/* The method blocks the current Thread if the message queue is empty. */
"\n"/*  */
"\n"/*     port = Ractor::Port.new */
"\n"/*     r = Ractor.new port do |port| */
"\n"/*       wait */
"\n"/*       puts \"Still not received\" */
"\n"/*       port.send('message1') */
"\n"/*       wait */
"\n"/*       puts \"Still received only one\" */
"\n"/*       port.send('message2') */
"\n"/*     end */
"\n"/*     puts \"Before first receive\" */
"\n"/*     v1 = port.receive */
"\n"/*     puts \"Received: \#{v1}\" */
"\n"/*     v2 = port.receive */
"\n"/*     puts \"Received: \#{v2}\" */
"\n"/*     r.join */
"\n"/*  */
"\n"/* Output: */
"\n"/*  */
"\n"/*     Before first receive */
"\n"/*     Still not received */
"\n"/*     Received: message1 */
"\n"/*     Still received only one */
"\n"/*     Received: message2 */
"\n"/*  */
"\n"/* If the port is closed and there are no more messages in the message queue, */
"\n"/* the method raises Ractor::ClosedError. */
"\n"/*  */
"\n"/*     port = Ractor::Port.new */
"\n"/*     port.close */
"\n"/*     port.receive #=> raise Ractor::ClosedError */
"\n"/*  */
"    def receive\n"
"      __builtin_cexpr! %q{\n"
"        ractor_port_receive(ec, self)\n"
"      }\n"
"    end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    port.send(msg, move: false) -> self */
"\n"/*  */
"\n"/* Sends a message to the port to be accepted by port.receive. */
"\n"/*  */
"\n"/*     port = Ractor::Port.new */
"\n"/*     r = Ractor.new(port) do |port| */
"\n"/*       port.send 'message' */
"\n"/*     end */
"\n"/*     value = port.receive */
"\n"/*     puts \"Received \#{value}\" */
"\n"/*     # Prints: \"Received: message\" */
"\n"/*  */
"\n"/* The method is non-blocking (it will return immediately even if the ractor that created the port is not ready */
"\n"/* to receive anything): */
"\n"/*  */
"\n"/*     port = Ractor::Port.new */
"\n"/*     r = Ractor.new(port) do |port| */
"\n"/*       port.send 'test' */
"\n"/*       puts \"Sent successfully\" */
"\n"/*       # Prints: \"Sent successfully\" immediately */
"\n"/*     end */
"\n"/*  */
"\n"/* An attempt to send to a closed port will raise Ractor::ClosedError. */
"\n"/*  */
"\n"/*   r = Ractor.new {Ractor::Port.new} */
"\n"/*   r.join */
"\n"/*   p r */
"\n"/*   # \"#<Ractor:#6 (irb):23 terminated>\" */
"\n"/*   port = r.value */
"\n"/*   port.send('test') # raise Ractor::ClosedError */
"\n"/*  */
"\n"/* If the +obj+ is unshareable, by default it will be copied into the receiving ractor by deep cloning. */
"\n"/*  */
"\n"/* If the object is shareable, a reference to the object will be sent to the receiving ractor. */
"\n"/*  */
"    def send obj, move: false\n"
"      __builtin_cexpr! %q{\n"
"        ractor_port_send(ec, self, obj, move)\n"
"      }\n"
"    end\n"
"\n"
"    alias << send\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    port.close */
"\n"/*  */
"\n"/* Closes the port. Sending to a closed port is prohibited. */
"\n"/* Receiving is also prohibited if there are no messages in its message queue. */
"\n"/*  */
"\n"/* Only the Ractor which created the port is allowed to close it. */
"\n"/*  */
"\n"/*     port = Ractor::Port.new */
"\n"/*     Ractor.new port do |port| */
"\n"/*       port.close #=> closing port by other ractors is not allowed (Ractor::Error) */
"\n"/*     end.join */
"\n"/*  */
"    def close\n"
"      __builtin_cexpr! %q{\n"
"        ractor_port_close(ec, self)\n"
"      }\n"
"    end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    port.closed? -> true/false */
"\n"/*  */
"\n"/* Returns whether or not the port is closed. */
"    def closed?\n"
"      __builtin_cexpr! %q{\n"
,
#line 819 "ractor.rb"
"        ractor_port_closed_p(ec, self);\n"
"      }\n"
"    end\n"
"\n"
"\n"/*  */
"\n"/* call-seq: */
"\n"/*    port.inspect -> string */
"    def inspect\n"
"      \"#<Ractor::Port to:\\##{\n"
"        __builtin_cexpr! \"SIZET2NUM(rb_ractor_id((RACTOR_PORT_PTR(self)->r)))\"\n"
"      } id:#{\n"
"        __builtin_cexpr! \"SIZET2NUM(ractor_port_id(RACTOR_PORT_PTR(self)))\"\n"
"      }>\"\n"
"    end\n"
"  end\n"
"end\n"
#line 5510 "miniprelude.c"
};

static const char prelude_name14[] = "<internal:symbol>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[282]; /* 1..43 */
} prelude_code14 = {
#line 1 "symbol.rb"
"class Symbol\n"
"\n"/* call-seq: */
"\n"/*   to_s -> string */
"\n"/*  */
"\n"/* Returns a string representation of +self+ (not including the leading colon): */
"\n"/*  */
"\n"/*   :foo.to_s # => \"foo\" */
"\n"/*  */
"\n"/* Related: Symbol#inspect, Symbol#name. */
"  def to_s\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_sym_to_s(self)'\n"
"  end\n"
"\n"
"  alias id2name to_s\n"
"\n"
"\n"/* call-seq: */
"\n"/*   name -> string */
"\n"/*  */
"\n"/* Returns a frozen string representation of +self+ (not including the leading colon): */
"\n"/*  */
"\n"/*   :foo.name         # => \"foo\" */
"\n"/*   :foo.name.frozen? # => true */
"\n"/*  */
"\n"/* Related: Symbol#to_s, Symbol#inspect. */
"  def name\n"
"    Primitive.attr! :leaf\n"
"    Primitive.cexpr! 'rb_sym2str(self)'\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   to_sym -> self */
"\n"/*  */
"\n"/* Returns +self+. */
"\n"/*  */
"\n"/* Related: String#to_sym. */
"  def to_sym\n"
"    self\n"
"  end\n"
"\n"
"  alias intern to_sym\n"
"end\n"
#line 5560 "miniprelude.c"
};

static const char prelude_name15[] = "<internal:timev>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[477]; /* 1..439 */
    RBIMPL_ATTR_NONSTRING() char L439[507]; /* 440..457 */
    RBIMPL_ATTR_NONSTRING() char L457[78]; /* 458..461 */
} prelude_code15 = {
#line 1 "timev.rb"
""/* A +Time+ object represents a date and time: */
""/*  */
""/*   Time.new(2000, 1, 1, 0, 0, 0) # => 2000-01-01 00:00:00 -0600 */
""/*  */
""/* Although its value can be expressed as a single numeric */
""/* (see {Epoch Seconds}[rdoc-ref:Time@Epoch+Seconds] below), */
""/* it can be convenient to deal with the value by parts: */
""/*  */
""/*   t = Time.new(-2000, 1, 1, 0, 0, 0.0) */
""/*   # => -2000-01-01 00:00:00 -0600 */
""/*   t.year # => -2000 */
""/*   t.month # => 1 */
""/*   t.mday # => 1 */
""/*   t.hour # => 0 */
""/*   t.min # => 0 */
""/*   t.sec # => 0 */
""/*   t.subsec # => 0 */
""/*  */
""/*   t = Time.new(2000, 12, 31, 23, 59, 59.5) */
""/*   # => 2000-12-31 23:59:59.5 -0600 */
""/*   t.year # => 2000 */
""/*   t.month # => 12 */
""/*   t.mday # => 31 */
""/*   t.hour # => 23 */
""/*   t.min # => 59 */
""/*   t.sec # => 59 */
""/*   t.subsec # => (1/2) */
""/*  */
""/* == Epoch Seconds */
""/*  */
""/* <i>Epoch seconds</i> is the exact number of seconds */
""/* (including fractional subseconds) since the Unix Epoch, January 1, 1970. */
""/*  */
""/* You can retrieve that value exactly using method Time.to_r: */
""/*  */
""/*   Time.at(0).to_r        # => (0/1) */
""/*   Time.at(0.999999).to_r # => (9007190247541737/9007199254740992) */
""/*  */
""/* Other retrieval methods such as Time#to_i and Time#to_f */
""/* may return a value that rounds or truncates subseconds. */
""/*  */
""/* == \\Time Resolution */
""/*  */
""/* A +Time+ object derived from the system clock */
""/* (for example, by method Time.now) */
""/* has the resolution supported by the system. */
""/*  */
""/* == \\Time Internal Representation */
""/*  */
""/* Conceptually, Time class uses a rational value to represent the number of */
""/* seconds from _Epoch_, 1970-01-01 00:00:00 UTC. */
""/* There are no boundary or resolution limitations. */
""/* The value can be obtained using Time#to_r. */
""/*  */
""/* The Time class always uses the Gregorian calendar. */
""/* I.e. the proleptic Gregorian calendar is used. */
""/* Other calendars, such as Julian calendar, are not supported. */
""/*  */
""/* The implementation uses a signed 63 bit integer, Integer (Bignum) object or */
""/* Ratoinal object to represent a rational value. */
""/* (The signed 63 bit integer is used regardless of 32 and 64 bit environments.) */
""/* The value represents the number of nanoseconds from _Epoch_. */
""/* The signed 63 bit integer can represent 1823-11-12 to 2116-02-20. */
""/* When Integer or Rational object is used (before 1823, after 2116, under */
""/* nanosecond), Time works slower than when the signed 63 bit integer is used. */
""/*  */
""/* Ruby uses the C function +localtime+ and +gmtime+ to map between the number */
""/* and 6-tuple (year,month,day,hour,minute,second). */
""/* +localtime+ is used for local time and +gmtime+ is used for UTC. */
""/*  */
""/* Integer and Rational has no range limit, but the localtime and */
""/* gmtime has range limits due to the C types +time_t+ and <tt>struct tm</tt>. */
""/* If that limit is exceeded, Ruby extrapolates the localtime function. */
""/*  */
""/* +time_t+ can represent 1901-12-14 to 2038-01-19 if it is 32 bit signed integer, */
""/* -292277022657-01-27 to 292277026596-12-05 if it is 64 bit signed integer. */
""/* However +localtime+ on some platforms doesn't supports negative +time_t+ (before 1970). */
""/*  */
""/* <tt>struct tm</tt> has _tm_year_ member to represent years. */
""/* (<tt>tm_year = 0</tt> means the year 1900.) */
""/* It is defined as +int+ in the C standard. */
""/* _tm_year_ can represent years between -2147481748 to 2147485547 if +int+ is 32 bit. */
""/*  */
""/* Ruby supports leap seconds as far as if the C function +localtime+ and */
""/* +gmtime+ supports it. */
""/* They use the tz database in most Unix systems. */
""/* The tz database has timezones which supports leap seconds. */
""/* For example, \"Asia/Tokyo\" doesn't support leap seconds but */
""/* \"right/Asia/Tokyo\" supports leap seconds. */
""/* So, Ruby supports leap seconds if the TZ environment variable is */
""/* set to \"right/Asia/Tokyo\" in most Unix systems. */
""/*  */
""/* == Examples */
""/*  */
""/* All of these examples were done using the EST timezone which is GMT-5. */
""/*  */
""/* === Creating a New +Time+ Instance */
""/*  */
""/* You can create a new instance of Time with Time.new. This will use the */
""/* current system time. Time.now is an alias for this. You can also */
""/* pass parts of the time to Time.new such as year, month, minute, etc. When */
""/* you want to construct a time this way you must pass at least a year. If you */
""/* pass the year with nothing else time will default to January 1 of that year */
""/* at 00:00:00 with the current system timezone. Here are some examples: */
""/*  */
""/*   Time.new(2002)         #=> 2002-01-01 00:00:00 -0500 */
""/*   Time.new(2002, 10)     #=> 2002-10-01 00:00:00 -0500 */
""/*   Time.new(2002, 10, 31) #=> 2002-10-31 00:00:00 -0500 */
""/*  */
""/* You can pass a UTC offset: */
""/*  */
""/*   Time.new(2002, 10, 31, 2, 2, 2, \"+02:00\") #=> 2002-10-31 02:02:02 +0200 */
""/*  */
""/* Or {a timezone object}[rdoc-ref:Time@Timezone+Objects]: */
""/*  */
""/*   zone = timezone(\"Europe/Athens\")      # Eastern European Time, UTC+2 */
""/*   Time.new(2002, 10, 31, 2, 2, 2, zone) #=> 2002-10-31 02:02:02 +0200 */
""/*  */
""/* You can also use Time.local and Time.utc to infer */
""/* local and UTC timezones instead of using the current system */
""/* setting. */
""/*  */
""/* You can also create a new time using Time.at which takes the number of */
""/* seconds (with subsecond) since the {Unix */
""/* Epoch}[https://en.wikipedia.org/wiki/Unix_time]. */
""/*  */
""/*   Time.at(628232400) #=> 1989-11-28 00:00:00 -0500 */
""/*  */
""/* === Working with an Instance of +Time+ */
""/*  */
""/* Once you have an instance of Time there is a multitude of things you can */
""/* do with it. Below are some examples. For all of the following examples, we */
""/* will work on the assumption that you have done the following: */
""/*  */
""/*   t = Time.new(1993, 02, 24, 12, 0, 0, \"+09:00\") */
""/*  */
""/* Was that a monday? */
""/*  */
""/*   t.monday? #=> false */
""/*  */
""/* What year was that again? */
""/*  */
""/*   t.year #=> 1993 */
""/*  */
""/* Was it daylight savings at the time? */
""/*  */
""/*   t.dst? #=> false */
""/*  */
""/* What's the day a year later? */
""/*  */
""/*   t + (60*60*24*365) #=> 1994-02-24 12:00:00 +0900 */
""/*  */
""/* How many seconds was that since the Unix Epoch? */
""/*  */
""/*   t.to_i #=> 730522800 */
""/*  */
""/* You can also do standard functions like compare two times. */
""/*  */
""/*   t1 = Time.new(2010) */
""/*   t2 = Time.new(2011) */
""/*  */
""/*   t1 == t2 #=> false */
""/*   t1 == t1 #=> true */
""/*   t1 <  t2 #=> true */
""/*   t1 >  t2 #=> false */
""/*  */
""/*   Time.new(2010,10,31).between?(t1, t2) #=> true */
""/*  */
""/* == What's Here */
""/*  */
""/* First, what's elsewhere. Class +Time+: */
""/*  */
""/* - Inherits from {class Object}[rdoc-ref:Object@What-27s+Here]. */
""/* - Includes {module Comparable}[rdoc-ref:Comparable@What-27s+Here]. */
""/*  */
""/* Here, class +Time+ provides methods that are useful for: */
""/*  */
""/* - {Creating Time objects}[rdoc-ref:Time@Methods+for+Creating]. */
""/* - {Fetching Time values}[rdoc-ref:Time@Methods+for+Fetching]. */
""/* - {Querying a Time object}[rdoc-ref:Time@Methods+for+Querying]. */
""/* - {Comparing Time objects}[rdoc-ref:Time@Methods+for+Comparing]. */
""/* - {Converting a Time object}[rdoc-ref:Time@Methods+for+Converting]. */
""/* - {Rounding a Time}[rdoc-ref:Time@Methods+for+Rounding]. */
""/*  */
""/* === Methods for Creating */
""/*  */
""/* - ::new: Returns a new time from specified arguments (year, month, etc.), */
""/*   including an optional timezone value. */
""/* - ::local (aliased as ::mktime): Same as ::new, except the */
""/*   timezone is the local timezone. */
""/* - ::utc (aliased as ::gm): Same as ::new, except the timezone is UTC. */
""/* - ::at: Returns a new time based on seconds since epoch. */
""/* - ::now: Returns a new time based on the current system time. */
""/* - #+ (plus): Returns a new time increased by the given number of seconds. */
""/* - #- (minus): Returns a new time decreased by the given number of seconds. */
""/*  */
""/* === Methods for Fetching */
""/*  */
""/* - #year: Returns the year of the time. */
""/* - #month (aliased as #mon): Returns the month of the time. */
""/* - #mday (aliased as #day): Returns the day of the month. */
""/* - #hour: Returns the hours value for the time. */
""/* - #min: Returns the minutes value for the time. */
""/* - #sec: Returns the seconds value for the time. */
""/* - #usec (aliased as #tv_usec): Returns the number of microseconds */
""/*   in the subseconds value of the time. */
""/* - #nsec (aliased as #tv_nsec: Returns the number of nanoseconds */
""/*   in the subsecond part of the time. */
""/* - #subsec: Returns the subseconds value for the time. */
""/* - #wday: Returns the integer weekday value of the time (0 == Sunday). */
""/* - #yday: Returns the integer yearday value of the time (1 == January 1). */
""/* - #hash: Returns the integer hash value for the time. */
""/* - #utc_offset (aliased as #gmt_offset and #gmtoff): Returns the offset */
""/*   in seconds between time and UTC. */
""/* - #to_f: Returns the float number of seconds since epoch for the time. */
""/* - #to_i (aliased as #tv_sec): Returns the integer number of seconds since epoch */
""/*   for the time. */
""/* - #to_r: Returns the Rational number of seconds since epoch for the time. */
""/* - #zone: Returns a string representation of the timezone of the time. */
""/*  */
""/* === Methods for Querying */
""/*  */
""/* - #utc? (aliased as #gmt?): Returns whether the time is UTC. */
""/* - #dst? (aliased as #isdst): Returns whether the time is DST (daylight saving time). */
""/* - #sunday?: Returns whether the time is a Sunday. */
""/* - #monday?: Returns whether the time is a Monday. */
""/* - #tuesday?: Returns whether the time is a Tuesday. */
""/* - #wednesday?: Returns whether the time is a Wednesday. */
""/* - #thursday?: Returns whether the time is a Thursday. */
""/* - #friday?: Returns whether time is a Friday. */
""/* - #saturday?: Returns whether the time is a Saturday. */
""/*  */
""/* === Methods for Comparing */
""/*  */
""/* - #<=>: Compares +self+ to another time. */
""/* - #eql?: Returns whether the time is equal to another time. */
""/*  */
""/* === Methods for Converting */
""/*  */
""/* - #asctime (aliased as #ctime): Returns the time as a string. */
""/* - #inspect: Returns the time in detail as a string. */
""/* - #strftime: Returns the time as a string, according to a given format. */
""/* - #to_a: Returns a 10-element array of values from the time. */
""/* - #to_s: Returns a string representation of the time. */
""/* - #getutc (aliased as #getgm): Returns a new time converted to UTC. */
""/* - #getlocal: Returns a new time converted to local time. */
""/* - #utc (aliased as #gmtime): Converts time to UTC in place. */
""/* - #localtime: Converts time to local time in place. */
""/* - #deconstruct_keys: Returns a hash of time components used in pattern-matching. */
""/*  */
""/* === Methods for Rounding */
""/*  */
""/* - #round:Returns a new time with subseconds rounded. */
""/* - #ceil: Returns a new time with subseconds raised to a ceiling. */
""/* - #floor: Returns a new time with subseconds lowered to a floor. */
""/*  */
""/* For the forms of argument +zone+, see */
""/* {Timezone Specifiers}[rdoc-ref:Time@Timezone+Specifiers]. */
""/*  */
""/* :include: doc/_timezones.rdoc */
"class Time\n"
"\n"/* Creates a new +Time+ object from the current system time. */
"\n"/* This is the same as Time.new without arguments. */
"\n"/*  */
"\n"/*    Time.now               # => 2009-06-24 12:39:54 +0900 */
"\n"/*    Time.now(in: '+04:00') # => 2009-06-24 07:39:54 +0400 */
"\n"/*  */
"\n"/* For forms of argument +zone+, see */
"\n"/* {Timezone Specifiers}[rdoc-ref:Time@Timezone+Specifiers]. */
"  def self.now(in: nil)\n"
"    Primitive.time_s_now(Primitive.arg!(:in))\n"
"  end\n"
"\n"
"\n"/* Returns a new +Time+ object based on the given arguments. */
"\n"/*  */
"\n"/* Required argument +time+ may be either of: */
"\n"/*  */
"\n"/* - A +Time+ object, whose value is the basis for the returned time; */
"\n"/*   also influenced by optional keyword argument +in:+ (see below). */
"\n"/* - A numeric number of */
"\n"/*   {Epoch seconds}[rdoc-ref:Time@Epoch+Seconds] */
"\n"/*   for the returned time. */
"\n"/*  */
"\n"/* Examples: */
"\n"/*  */
"\n"/*   t = Time.new(2000, 12, 31, 23, 59, 59) # => 2000-12-31 23:59:59 -0600 */
"\n"/*   secs = t.to_i                          # => 978328799 */
"\n"/*   Time.at(secs)                          # => 2000-12-31 23:59:59 -0600 */
"\n"/*   Time.at(secs + 0.5)                    # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*   Time.at(1000000000)                    # => 2001-09-08 20:46:40 -0500 */
"\n"/*   Time.at(0)                             # => 1969-12-31 18:00:00 -0600 */
"\n"/*   Time.at(-1000000000)                   # => 1938-04-24 17:13:20 -0500 */
"\n"/*  */
"\n"/* Optional numeric argument +subsec+ and optional symbol argument +units+ */
"\n"/* work together to specify subseconds for the returned time; */
"\n"/* argument +units+ specifies the units for +subsec+: */
"\n"/*  */
"\n"/* - +:millisecond+: +subsec+ in milliseconds: */
"\n"/*  */
"\n"/*     Time.at(secs, 0, :millisecond)     # => 2000-12-31 23:59:59 -0600 */
"\n"/*     Time.at(secs, 500, :millisecond)   # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*     Time.at(secs, 1000, :millisecond)  # => 2001-01-01 00:00:00 -0600 */
"\n"/*     Time.at(secs, -1000, :millisecond) # => 2000-12-31 23:59:58 -0600 */
"\n"/*  */
"\n"/* - +:microsecond+ or +:usec+: +subsec+ in microseconds: */
"\n"/*  */
"\n"/*     Time.at(secs, 0, :microsecond)        # => 2000-12-31 23:59:59 -0600 */
"\n"/*     Time.at(secs, 500000, :microsecond)   # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*     Time.at(secs, 1000000, :microsecond)  # => 2001-01-01 00:00:00 -0600 */
"\n"/*     Time.at(secs, -1000000, :microsecond) # => 2000-12-31 23:59:58 -0600 */
"\n"/*  */
"\n"/* - +:nanosecond+ or +:nsec+: +subsec+ in nanoseconds: */
"\n"/*  */
"\n"/*     Time.at(secs, 0, :nanosecond)           # => 2000-12-31 23:59:59 -0600 */
"\n"/*     Time.at(secs, 500000000, :nanosecond)   # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*     Time.at(secs, 1000000000, :nanosecond)  # => 2001-01-01 00:00:00 -0600 */
"\n"/*     Time.at(secs, -1000000000, :nanosecond) # => 2000-12-31 23:59:58 -0600 */
"\n"/*  */
"\n"/*  */
"\n"/* Optional keyword argument <tt>in: zone</tt> specifies the timezone */
"\n"/* for the returned time: */
"\n"/*  */
"\n"/*   Time.at(secs, in: '+12:00') # => 2001-01-01 17:59:59 +1200 */
"\n"/*   Time.at(secs, in: '-12:00') # => 2000-12-31 17:59:59 -1200 */
"\n"/*  */
"\n"/* For the forms of argument +zone+, see */
"\n"/* {Timezone Specifiers}[rdoc-ref:Time@Timezone+Specifiers]. */
"\n"/*  */
"  def self.at(time, subsec = false, unit = :microsecond, in: nil)\n"
"    if Primitive.mandatory_only?\n"
"      Primitive.time_s_at1(time)\n"
"    else\n"
"      Primitive.time_s_at(time, subsec, unit, Primitive.arg!(:in))\n"
"    end\n"
"  end\n"
"\n"
"\n"/* call-seq: */
"\n"/*   Time.new(year = nil, mon = nil, mday = nil, hour = nil, min = nil, sec = nil, zone = nil, in: nil, precision: 9) */
"\n"/*  */
"\n"/* Returns a new +Time+ object based on the given arguments, */
"\n"/* by default in the local timezone. */
"\n"/*  */
"\n"/* With no positional arguments, returns the value of Time.now: */
"\n"/*  */
"\n"/*   Time.new # => 2021-04-24 17:27:46.0512465 -0500 */
"\n"/*  */
"\n"/* With one string argument that represents a time, returns a new */
"\n"/* +Time+ object based on the given argument, in the local timezone. */
"\n"/*  */
"\n"/*   Time.new('2000-12-31 23:59:59.5')              # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*   Time.new('2000-12-31 23:59:59.5 +0900')        # => 2000-12-31 23:59:59.5 +0900 */
"\n"/*   Time.new('2000-12-31 23:59:59.5', in: '+0900') # => 2000-12-31 23:59:59.5 +0900 */
"\n"/*   Time.new('2000-12-31 23:59:59.5')              # => 2000-12-31 23:59:59.5 -0600 */
"\n"/*   Time.new('2000-12-31 23:59:59.56789', precision: 3) # => 2000-12-31 23:59:59.567 -0600 */
"\n"/*  */
"\n"/* With one to six arguments, returns a new +Time+ object */
"\n"/* based on the given arguments, in the local timezone. */
"\n"/*  */
"\n"/*   Time.new(2000, 1, 2, 3, 4, 5) # => 2000-01-02 03:04:05 -0600 */
"\n"/*  */
"\n"/* For the positional arguments (other than +zone+): */
"\n"/*  */
"\n"/* - +year+: Year, with no range limits: */
"\n"/*  */
"\n"/*     Time.new(999999999)  # => 999999999-01-01 00:00:00 -0600 */
"\n"/*     Time.new(-999999999) # => -999999999-01-01 00:00:00 -0600 */
"\n"/*  */
"\n"/* - +month+: Month in range (1..12), or case-insensitive */
"\n"/*   3-letter month name: */
"\n"/*  */
"\n"/*     Time.new(2000, 1)     # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 12)    # => 2000-12-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 'jan') # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 'JAN') # => 2000-01-01 00:00:00 -0600 */
"\n"/*  */
"\n"/* - +mday+: Month day in range(1..31): */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1)  # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 31) # => 2000-01-31 00:00:00 -0600 */
"\n"/*  */
"\n"/* - +hour+: Hour in range (0..23), or 24 if +min+, +sec+, and +usec+ */
"\n"/*   are zero: */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1, 0)  # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 1, 23) # => 2000-01-01 23:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 1, 24) # => 2000-01-02 00:00:00 -0600 */
"\n"/*  */
"\n"/* - +min+: Minute in range (0..59): */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1, 0, 0)  # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 1, 0, 59) # => 2000-01-01 00:59:00 -0600 */
"\n"/*  */
"\n"/* - +sec+: Second in range (0...61): */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 0)  # => 2000-01-01 00:00:00 -0600 */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 59) # => 2000-01-01 00:00:59 -0600 */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 60) # => 2000-01-01 00:01:00 -0600 */
"\n"/*  */
"\n"/*   +sec+ may be Float or Rational. */
"\n"/*  */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 59.5)  # => 2000-12-31 23:59:59.5 +0900 */
"\n"/*     Time.new(2000, 1, 1, 0, 0, 59.7r) # => 2000-12-31 23:59:59.7 +0900 */
"\n"/*  */
"\n"/* These values may be: */
"\n"/*  */
"\n"/* - Integers, as above. */
"\n"/* - Numerics convertible to integers: */
"\n"/*  */
"\n"/*     Time.new(Float(0.0), Rational(1, 1), 1.0, 0.0, 0.0, 0.0) */
"\n"/*     # => 0000-01-01 00:00:00 -0600 */
"\n"/*  */
"\n"/* - String integers: */
"\n"/*  */
"\n"/*     a = %w[0 1 1 0 0 0] */
"\n"/*     # => [\"0\", \"1\", \"1\", \"0\", \"0\", \"0\"] */
"\n"/*     Time.new(*a) # => 0000-01-01 00:00:00 -0600 */
"\n"/*  */
"\n"/* When positional argument +zone+ or keyword argument +in:+ is given, */
"\n"/* the new +Time+ object is in the specified timezone. */
"\n"/* For the forms of argument +zone+, see */
"\n"/* {Timezone Specifiers}[rdoc-ref:Time@Timezone+Specifiers]: */
"\n"/*  */
"\n"/*   Time.new(2000, 1, 1, 0, 0, 0, '+12:00') */
"\n"/*   # => 2000-01-01 00:00:00 +1200 */
"\n"/*   Time.new(2000, 1, 1, 0, 0, 0, in: '-12:00') */
"\n"/*   # => 2000-01-01 00:00:00 -1200 */
"\n"/*   Time.new(in: '-12:00') */
"\n"/*   # => 2022-08-23 08:49:26.1941467 -1200 */
"\n"/*  */
"\n"/* Since +in:+ keyword argument just provides the default, so if the */
"\n"/* first argument in single string form contains time zone information, */
"\n"/* this keyword argument will be silently ignored. */
"\n"/*  */
"\n"/*   Time.new('2000-01-01 00:00:00 +0100', in: '-0500').utc_offset  # => 3600 */
"\n"/*  */
"\n"/* - +precision+: maximum effective digits in sub-second part, default is 9. */
"\n"/*   More digits will be truncated, as other operations of +Time+. */
"\n"/*   Ignored unless the first argument is a string. */
"\n"/*  */
,
#line 440 "timev.rb"
"  def initialize(year = (now = true), mon = (str = year; nil), mday = nil, hour = nil, min = nil, sec = nil, zone = nil,\n"
"                 in: nil, precision: 9)\n"
"    if zone\n"
"      if Primitive.arg!(:in)\n"
"        raise ArgumentError, \"timezone argument given as positional and keyword arguments\"\n"
"      end\n"
"    else\n"
"      zone = Primitive.arg!(:in)\n"
"    end\n"
"\n"
"    if now\n"
"      return Primitive.time_init_now(zone)\n"
"    end\n"
"\n"
"    if str and Primitive.time_init_parse(str, zone, precision)\n"
"      return self\n"
"    end\n"
"\n"
,
#line 458 "timev.rb"
"    Primitive.time_init_args(year, mon, mday, hour, min, sec, zone)\n"
"  end\n"
"end\n"
#line 6034 "miniprelude.c"
};

static const char prelude_name16[] = "<internal:thread_sync>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[500]; /* 1..40 */
    RBIMPL_ATTR_NONSTRING() char L40[493]; /* 41..82 */
    RBIMPL_ATTR_NONSTRING() char L82[490]; /* 83..146 */
    RBIMPL_ATTR_NONSTRING() char L146[493]; /* 147..196 */
} prelude_code16 = {
#line 1 "thread_sync.rb"
""/* frozen_string_literal: true */
""
"class Thread\n"
"  class Queue\n"
"\n"/* call-seq: */
"\n"/*   pop(non_block=false, timeout: nil) */
"\n"/*  */
"\n"/* Retrieves data from the queue. */
"\n"/*  */
"\n"/* If the queue is empty, the calling thread is suspended until data is pushed */
"\n"/* onto the queue. If +non_block+ is true, the thread isn't suspended, and */
"\n"/* +ThreadError+ is raised. */
"\n"/*  */
"\n"/* If +timeout+ seconds have passed and no data is available +nil+ is */
"\n"/* returned. If +timeout+ is +0+ it returns immediately. */
"    def pop(non_block = false, timeout: nil)\n"
"      if non_block && timeout\n"
"        raise ArgumentError, \"can't set a timeout if non_block is enabled\"\n"
"      end\n"
"      Primitive.rb_queue_pop(non_block, timeout)\n"
"    end\n"
"    alias_method :deq, :pop\n"
"    alias_method :shift, :pop\n"
"  end\n"
"\n"
"  class SizedQueue\n"
"\n"/* call-seq: */
"\n"/*   pop(non_block=false, timeout: nil) */
"\n"/*  */
"\n"/* Retrieves data from the queue. */
"\n"/*  */
"\n"/* If the queue is empty, the calling thread is suspended until data is */
"\n"/* pushed onto the queue. If +non_block+ is true, the thread isn't */
"\n"/* suspended, and +ThreadError+ is raised. */
"\n"/*  */
"\n"/* If +timeout+ seconds have passed and no data is available +nil+ is */
"\n"/* returned. If +timeout+ is +0+ it returns immediately. */
"    def pop(non_block = false, timeout: nil)\n"
"      if non_block && timeout\n"
"        raise ArgumentError, \"can't set a timeout if non_block is enabled\"\n"
,
#line 41 "thread_sync.rb"
"      end\n"
"      Primitive.rb_szqueue_pop(non_block, timeout)\n"
"    end\n"
"    alias_method :deq, :pop\n"
"    alias_method :shift, :pop\n"
"\n"
"\n"/* call-seq: */
"\n"/*   push(object, non_block=false, timeout: nil) */
"\n"/*   enq(object, non_block=false, timeout: nil) */
"\n"/*   <<(object) */
"\n"/*  */
"\n"/* Pushes +object+ to the queue. */
"\n"/*  */
"\n"/* If there is no space left in the queue, waits until space becomes */
"\n"/* available, unless +non_block+ is true.  If +non_block+ is true, the */
"\n"/* thread isn't suspended, and +ThreadError+ is raised. */
"\n"/*  */
"\n"/* If +timeout+ seconds have passed and no space is available +nil+ is */
"\n"/* returned. If +timeout+ is +0+ it returns immediately. */
"\n"/* Otherwise it returns +self+. */
"    def push(object, non_block = false, timeout: nil)\n"
"      if non_block && timeout\n"
"        raise ArgumentError, \"can't set a timeout if non_block is enabled\"\n"
"      end\n"
"      Primitive.rb_szqueue_push(object, non_block, timeout)\n"
"    end\n"
"    alias_method :enq, :push\n"
"    alias_method :<<, :push\n"
"  end\n"
"\n"
"  class Mutex\n"
"\n"/* call-seq: */
"\n"/*    Thread::Mutex.new   -> mutex */
"\n"/*  */
"\n"/* Creates a new Mutex */
"    def initialize\n"
"    end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    mutex.locked?  -> true or false */
"\n"/*  */
"\n"/* Returns +true+ if this lock is currently held by some thread. */
,
#line 83 "thread_sync.rb"
"    def locked?\n"
"      Primitive.cexpr! %q{ RBOOL(mutex_locked_p(mutex_ptr(self))) }\n"
"    end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    mutex.owned?  -> true or false */
"\n"/*  */
"\n"/* Returns +true+ if this lock is currently held by current thread. */
"    def owned?\n"
"      Primitive.rb_mut_owned_p\n"
"    end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    mutex.lock  -> self */
"\n"/*  */
"\n"/* Attempts to grab the lock and waits if it isn't available. */
"\n"/* Raises +ThreadError+ if +mutex+ was locked by the current thread. */
"    def lock\n"
"      Primitive.rb_mut_lock\n"
"    end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    mutex.try_lock  -> true or false */
"\n"/*  */
"\n"/* Attempts to obtain the lock and returns immediately. Returns +true+ if the */
"\n"/* lock was granted. */
"    def try_lock\n"
"      Primitive.rb_mut_trylock\n"
"    end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    mutex.lock  -> self */
"\n"/*  */
"\n"/* Attempts to grab the lock and waits if it isn't available. */
"\n"/* Raises +ThreadError+ if +mutex+ was locked by the current thread. */
"    def unlock\n"
"      Primitive.rb_mut_unlock\n"
"    end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    mutex.synchronize { ... }    -> result of the block */
"\n"/*  */
"\n"/* Obtains a lock, runs the block, and releases the lock when the block */
"\n"/* completes.  See the example under Thread::Mutex. */
"    def synchronize\n"
"      raise ThreadError, \"must be called with a block\" unless defined?(yield)\n"
"\n"
"      Primitive.rb_mut_synchronize\n"
"    end\n"
"\n"
"\n"/* call-seq: */
"\n"/*    mutex.sleep(timeout = nil)    -> number or nil */
"\n"/*  */
"\n"/* Releases the lock and sleeps +timeout+ seconds if it is given and */
"\n"/* non-nil or forever.  Raises +ThreadError+ if +mutex+ wasn't locked by */
"\n"/* the current thread. */
"\n"/*  */
"\n"/* When the thread is next woken up, it will attempt to reacquire */
"\n"/* the lock. */
"\n"/*  */
"\n"/* Note that this method can wakeup without explicit Thread#wakeup call. */
"\n"/* For example, receiving signal and so on. */
"\n"/*  */
"\n"/* Returns the slept time in seconds if woken up, or +nil+ if timed out. */
,
#line 147 "thread_sync.rb"
"    def sleep(timeout = nil)\n"
"      Primitive.rb_mut_sleep(timeout)\n"
"    end\n"
"  end\n"
"\n"
"  class ConditionVariable\n"
"\n"/* Document-method: ConditionVariable::new */
"\n"/*  */
"\n"/* Creates a new condition variable instance. */
"    def initialize\n"
"    end\n"
"\n"
"    undef_method :initialize_copy\n"
"\n"
"\n"/* :nodoc: */
"    def marshal_dump\n"
"      raise TypeError, \"can't dump #{self.class}\"\n"
"    end\n"
"\n"
"\n"/* Document-method: Thread::ConditionVariable#signal */
"\n"/*  */
"\n"/* Wakes up the first thread in line waiting for this lock. */
"    def signal\n"
"      Primitive.rb_condvar_signal\n"
"    end\n"
"\n"
"\n"/* Document-method: Thread::ConditionVariable#broadcast */
"\n"/*  */
"\n"/* Wakes up all threads waiting for this lock. */
"    def broadcast\n"
"      Primitive.rb_condvar_broadcast\n"
"    end\n"
"\n"
"\n"/* Document-method: Thread::ConditionVariable#wait */
"\n"/* call-seq: wait(mutex, timeout=nil) */
"\n"/*  */
"\n"/* Releases the lock held in +mutex+ and waits; reacquires the lock on wakeup. */
"\n"/*  */
"\n"/* If +timeout+ is given, this method returns after +timeout+ seconds passed, */
"\n"/* even if no other thread doesn't signal. */
"\n"/*  */
"\n"/* This method may wake up spuriously due to underlying implementation details. */
"\n"/*  */
"\n"/* Returns the slept result on +mutex+. */
"    def wait(mutex, timeout=nil)\n"
"      Primitive.rb_condvar_wait(mutex, timeout)\n"
"    end\n"
"  end\n"
"end\n"
#line 6246 "miniprelude.c"
};

static const char prelude_name17[] = "<internal:nilclass>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[217]; /* 1..64 */
} prelude_code17 = {
#line 1 "nilclass.rb"
"class NilClass\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     rationalize(eps = nil)  ->  (0/1) */
"\n"/*  */
"\n"/*  Returns zero as a Rational: */
"\n"/*  */
"\n"/*     nil.rationalize # => (0/1) */
"\n"/*  */
"\n"/*  Argument +eps+ is ignored. */
"\n"/*  */
"  def rationalize(eps = nil)\n"
"    0r\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     to_c -> (0+0i) */
"\n"/*  */
"\n"/*  Returns zero as a Complex: */
"\n"/*  */
"\n"/*     nil.to_c # => (0+0i) */
"\n"/*  */
"  def to_c\n"
"    0i\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     nil.to_i -> 0 */
"\n"/*  */
"\n"/*  Always returns zero. */
"\n"/*  */
"\n"/*     nil.to_i   #=> 0 */
"\n"/*  */
"  def to_i\n"
"    return 0\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     nil.to_f    -> 0.0 */
"\n"/*  */
"\n"/*  Always returns zero. */
"\n"/*  */
"\n"/*     nil.to_f   #=> 0.0 */
"\n"/*  */
"  def to_f\n"
"    return 0.0\n"
"  end\n"
"\n"
"\n"/*  */
"\n"/*  call-seq: */
"\n"/*     to_r  ->  (0/1) */
"\n"/*  */
"\n"/*  Returns zero as a Rational: */
"\n"/*  */
"\n"/*     nil.to_r # => (0/1) */
"\n"/*  */
"  def to_r\n"
"    0r\n"
"  end\n"
"end\n"
#line 6317 "miniprelude.c"
};

static const char prelude_name18[] = "<internal:prelude>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[506]; /* 1..39 */
    RBIMPL_ATTR_NONSTRING() char L39[53]; /* 40..44 */
} prelude_code18 = {
#line 1 "prelude.rb"
"class Binding\n"
"\n"/* :nodoc: */
"  def irb(...)\n"
"    begin\n"
"      require 'irb'\n"
"    rescue LoadError, Gem::LoadError\n"
"      Gem::BUNDLED_GEMS.force_activate 'irb'\n"
"      require 'irb'\n"
"    end\n"
"    irb(...)\n"
"  end\n"
"\n"
"\n"/* suppress redefinition warning */
"  alias irb irb\n"/* :nodoc: */
"end\n"
"\n"
"module Kernel\n"
"\n"/* :stopdoc: */
"  def pp(*objs)\n"
"    require 'pp'\n"
"    pp(*objs)\n"
"  end\n"
"\n"
"\n"/* suppress redefinition warning */
"  alias pp pp\n"
"\n"
"  private :pp\n"
"\n"/* :startdoc: */
"end\n"
"\n"
"module Enumerable\n"
"\n"/* Makes a set from the enumerable object with given arguments. */
"\n"/* Passing arguments to this method is deprecated. */
"  def to_set(*args, &block)\n"
"    klass = if args.empty?\n"
"      Set\n"
"    else\n"
"      warn \"passing arguments to Enumerable#to_set is deprecated\", uplevel: 1\n"
"      args.shift\n"
,
#line 40 "prelude.rb"
"    end\n"
"    klass.new(self, *args, &block)\n"
"  end\n"
"end\n"
#line 6371 "miniprelude.c"
};

static const char prelude_name19[] = "<internal:gem_prelude>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[478]; /* 1..25 */
    RBIMPL_ATTR_NONSTRING() char L25[73]; /* 26..28 */
} prelude_code19 = {
#line 1 "gem_prelude.rb"
"begin\n"
"  require 'rubygems'\n"
"rescue LoadError => e\n"
"  raise unless e.path == 'rubygems'\n"
"\n"
"  warn \"`RubyGems' were not loaded.\"\n"
"else\n"
"  require 'bundled_gems'\n"
"end if defined?(Gem)\n"
"\n"
"begin\n"
"  require 'error_highlight'\n"
"rescue LoadError\n"
"  warn \"`error_highlight' was not loaded.\"\n"
"end if defined?(ErrorHighlight)\n"
"\n"
"begin\n"
"  require 'did_you_mean'\n"
"rescue LoadError\n"
"  warn \"`did_you_mean' was not loaded.\"\n"
"end if defined?(DidYouMean)\n"
"\n"
"begin\n"
"  require 'syntax_suggest/core_ext'\n"
"rescue LoadError\n"
,
#line 26 "gem_prelude.rb"
"  warn \"`syntax_suggest' was not loaded.\"\n"
"end if defined?(SyntaxSuggest)\n"
#line 6409 "miniprelude.c"
};

static const char prelude_name20[] = "<internal:jit_hook>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[229]; /* 1..13 */
} prelude_code20 = {
#line 1 "jit_hook.rb"
"class Module\n"
"\n"/* Internal helper for built-in initializations to define methods only when JIT is enabled. */
"\n"/* This method is removed in jit_undef.rb. */
"  private def with_jit(&block)\n"/* :nodoc: */
"\n"/* ZJIT currently doesn't compile Array#each properly, so it's disabled for now. */
"    if defined?(RubyVM::ZJIT) && false\n"/* TODO: remove `&& false` (Shopify/ruby#667) */
"      RubyVM::ZJIT.send(:add_jit_hook, block)\n"
"    elsif defined?(RubyVM::YJIT)\n"
"      RubyVM::YJIT.send(:add_jit_hook, block)\n"
"    end\n"
"  end\n"
"end\n"
#line 6429 "miniprelude.c"
};

static const char prelude_name21[] = "<internal:jit_undef>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[35]; /* 1..5 */
} prelude_code21 = {
#line 1 "jit_undef.rb"
""/* Remove the helper defined in jit_hook.rb */
"class Module\n"
"  undef :with_jit\n"
"end\n"
#line 6441 "miniprelude.c"
};

static const char prelude_name22[] = "<internal:yjit>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[501]; /* 1..48 */
    RBIMPL_ATTR_NONSTRING() char L48[506]; /* 49..62 */
    RBIMPL_ATTR_NONSTRING() char L62[503]; /* 63..80 */
    RBIMPL_ATTR_NONSTRING() char L80[485]; /* 81..108 */
    RBIMPL_ATTR_NONSTRING() char L108[484]; /* 109..124 */
    RBIMPL_ATTR_NONSTRING() char L124[489]; /* 125..145 */
    RBIMPL_ATTR_NONSTRING() char L145[496]; /* 146..195 */
    RBIMPL_ATTR_NONSTRING() char L195[461]; /* 196..221 */
    RBIMPL_ATTR_NONSTRING() char L221[488]; /* 222..246 */
    RBIMPL_ATTR_NONSTRING() char L246[492]; /* 247..281 */
    RBIMPL_ATTR_NONSTRING() char L281[469]; /* 282..304 */
    RBIMPL_ATTR_NONSTRING() char L304[404]; /* 305..308 */
    RBIMPL_ATTR_NONSTRING() char L308[415]; /* 309..312 */
    RBIMPL_ATTR_NONSTRING() char L312[501]; /* 313..335 */
    RBIMPL_ATTR_NONSTRING() char L335[487]; /* 336..345 */
    RBIMPL_ATTR_NONSTRING() char L345[439]; /* 346..358 */
    RBIMPL_ATTR_NONSTRING() char L358[444]; /* 359..362 */
    RBIMPL_ATTR_NONSTRING() char L362[449]; /* 363..366 */
    RBIMPL_ATTR_NONSTRING() char L366[479]; /* 367..372 */
    RBIMPL_ATTR_NONSTRING() char L372[501]; /* 373..377 */
    RBIMPL_ATTR_NONSTRING() char L377[502]; /* 378..383 */
    RBIMPL_ATTR_NONSTRING() char L383[424]; /* 384..388 */
    RBIMPL_ATTR_NONSTRING() char L388[455]; /* 389..393 */
    RBIMPL_ATTR_NONSTRING() char L393[418]; /* 394..397 */
    RBIMPL_ATTR_NONSTRING() char L397[392]; /* 398..401 */
    RBIMPL_ATTR_NONSTRING() char L401[428]; /* 402..407 */
    RBIMPL_ATTR_NONSTRING() char L407[477]; /* 408..413 */
    RBIMPL_ATTR_NONSTRING() char L413[473]; /* 414..419 */
    RBIMPL_ATTR_NONSTRING() char L419[494]; /* 420..426 */
    RBIMPL_ATTR_NONSTRING() char L426[468]; /* 427..432 */
    RBIMPL_ATTR_NONSTRING() char L432[432]; /* 433..437 */
    RBIMPL_ATTR_NONSTRING() char L437[488]; /* 438..442 */
    RBIMPL_ATTR_NONSTRING() char L442[462]; /* 443..451 */
    RBIMPL_ATTR_NONSTRING() char L451[508]; /* 452..465 */
    RBIMPL_ATTR_NONSTRING() char L465[491]; /* 466..482 */
    RBIMPL_ATTR_NONSTRING() char L482[489]; /* 483..492 */
    RBIMPL_ATTR_NONSTRING() char L492[482]; /* 493..506 */
    RBIMPL_ATTR_NONSTRING() char L506[453]; /* 507..520 */
    RBIMPL_ATTR_NONSTRING() char L520[473]; /* 521..539 */
    RBIMPL_ATTR_NONSTRING() char L539[205]; /* 540..551 */
} prelude_code22 = {
#line 1 "yjit.rb"
""/* frozen_string_literal: true */
""/* :markup: markdown */
""
""/* This module allows for introspection of YJIT, CRuby's just-in-time compiler. */
""/* Everything in the module is highly implementation specific and the API might */
""/* be less stable compared to the standard library. */
""/*  */
""/* This module may not exist if YJIT does not support the particular platform */
""/* for which CRuby is built. */
"module RubyVM::YJIT\n"
"\n"/* Check if YJIT is enabled. */
"  def self.enabled?\n"
"    Primitive.cexpr! 'RBOOL(rb_yjit_enabled_p)'\n"
"  end\n"
"\n"
"\n"/* Check if `--yjit-stats` is used. */
"  def self.stats_enabled?\n"
"    Primitive.rb_yjit_stats_enabled_p\n"
"  end\n"
"\n"
"\n"/* Check if `--yjit-log` is used. */
"  def self.log_enabled?\n"
"    Primitive.rb_yjit_log_enabled_p\n"
"  end\n"
"\n"
"\n"/* Check if rb_yjit_trace_exit_locations_enabled_p is enabled. */
"  def self.trace_exit_locations_enabled?\n"/* :nodoc: */
"    Primitive.rb_yjit_trace_exit_locations_enabled_p\n"
"  end\n"
"\n"
"\n"/* Discard statistics collected for `--yjit-stats`. */
"  def self.reset_stats!\n"
"    Primitive.rb_yjit_reset_stats_bang\n"
"  end\n"
"\n"
"\n"/* Enable YJIT compilation. `stats` option decides whether to enable YJIT stats or not. `log` decides */
"\n"/* whether to enable YJIT compilation logging or not. Optional `mem_size` and `call_threshold` can be */
"\n"/* provided to override default configuration. */
"\n"/*  */
"\n"/* * `stats`: */
"\n"/*     * `false`: Don't enable stats. */
"\n"/*     * `true`: Enable stats. Print stats at exit. */
"\n"/*     * `:quiet`: Enable stats. Do not print stats at exit. */
"\n"/* * `log`: */
"\n"/*     * `false`: Don't enable the log. */
"\n"/*     * `true`: Enable the log. Print log at exit. */
"\n"/*     * `:quiet`: Enable the log. Do not print log at exit. */
"  def self.enable(stats: false, log: false, mem_size: nil, call_threshold: nil)\n"
,
#line 49 "yjit.rb"
"    return false if enabled?\n"
"\n"
"    if Primitive.cexpr! 'RBOOL(rb_zjit_enabled_p)'\n"
"      warn(\"Only one JIT can be enabled at the same time.\")\n"
"      return false\n"
"    end\n"
"\n"
"    if mem_size\n"
"      raise ArgumentError, \"mem_size must be a Integer\" unless mem_size.is_a?(Integer)\n"
"      raise ArgumentError, \"mem_size must be between 1 and 2048 MB\" unless (1..2048).include?(mem_size)\n"
"    end\n"
"\n"
"    if call_threshold\n"
"      raise ArgumentError, \"call_threshold must be a Integer\" unless call_threshold.is_a?(Integer)\n"
,
#line 63 "yjit.rb"
"      raise ArgumentError, \"call_threshold must be a positive integer\" unless call_threshold.positive?\n"
"    end\n"
"\n"
"    at_exit { print_and_dump_stats } if stats\n"
"    Primitive.rb_yjit_enable(stats, stats != :quiet, log, log != :quiet, mem_size, call_threshold)\n"
"  end\n"
"\n"
"\n"/* If --yjit-trace-exits is enabled parse the hashes from */
"\n"/* Primitive.rb_yjit_get_exit_locations into a format readable */
"\n"/* by Stackprof. This will allow us to find the exact location of a */
"\n"/* side exit in YJIT based on the instruction that is exiting. */
"  def self.exit_locations\n"/* :nodoc: */
"    return unless trace_exit_locations_enabled?\n"
"\n"
"    results = Primitive.rb_yjit_get_exit_locations\n"
"    raw_samples = results[:raw].dup\n"
"    line_samples = results[:lines].dup\n"
"    frames = results[:frames].dup\n"
,
#line 81 "yjit.rb"
"    samples_count = 0\n"
"\n"
"\n"/* Loop through the instructions and set the frame hash with the data. */
"\n"/* We use nonexistent.def for the file name, otherwise insns.def will be displayed */
"\n"/* and that information isn't useful in this context. */
"    RubyVM::INSTRUCTION_NAMES.each_with_index do |name, frame_id|\n"
"      frame_hash = { samples: 0, total_samples: 0, edges: {}, name: name, file: \"nonexistent.def\", line: nil, lines: {} }\n"
"      results[:frames][frame_id] = frame_hash\n"
"      frames[frame_id] = frame_hash\n"
"    end\n"
"\n"
"\n"/* Loop through the raw_samples and build the hashes for StackProf. */
"\n"/* The loop is based off an example in the StackProf documentation and therefore */
"\n"/* this functionality can only work with that library. */
"\n"/*  */
"\n"/* Raw Samples: */
"\n"/* [ length, frame1, frame2, frameN, ..., instruction, count */
"\n"/*  */
"\n"/* Line Samples */
"\n"/* [ length, line_1, line_2, line_n, ..., dummy value, count */
"    i = 0\n"
"    while i < raw_samples.length\n"
"      stack_length = raw_samples[i]\n"
"      i += 1\n"/* consume the stack length */
"\n"
"      sample_count = raw_samples[i + stack_length]\n"
"\n"
"      prev_frame_id = nil\n"
,
#line 109 "yjit.rb"
"      stack_length.times do |idx|\n"
"        idx += i\n"
"        frame_id = raw_samples[idx]\n"
"\n"
"        if prev_frame_id\n"
"          prev_frame = frames[prev_frame_id]\n"
"          prev_frame[:edges][frame_id] ||= 0\n"
"          prev_frame[:edges][frame_id] += sample_count\n"
"        end\n"
"\n"
"        frame_info = frames[frame_id]\n"
"        frame_info[:total_samples] += sample_count\n"
"\n"
"        frame_info[:lines][line_samples[idx]] ||= [0, 0]\n"
"        frame_info[:lines][line_samples[idx]][0] += sample_count\n"
"\n"
,
#line 125 "yjit.rb"
"        prev_frame_id = frame_id\n"
"      end\n"
"\n"
"      i += stack_length\n"/* consume the stack */
"\n"
"      top_frame_id = prev_frame_id\n"
"      top_frame_line = 1\n"
"\n"
"      frames[top_frame_id][:samples] += sample_count\n"
"      frames[top_frame_id][:lines] ||= {}\n"
"      frames[top_frame_id][:lines][top_frame_line] ||= [0, 0]\n"
"      frames[top_frame_id][:lines][top_frame_line][1] += sample_count\n"
"\n"
"      samples_count += sample_count\n"
"      i += 1\n"
"    end\n"
"\n"
"    results[:samples] = samples_count\n"
"\n"/* Set missed_samples and gc_samples to 0 as their values */
"\n"/* don't matter to us in this context. */
"    results[:missed_samples] = 0\n"
,
#line 146 "yjit.rb"
"    results[:gc_samples] = 0\n"
"    results\n"
"  end\n"
"\n"
"\n"/* Marshal dumps exit locations to the given filename. */
"\n"/*  */
"\n"/* Usage: */
"\n"/*  */
"\n"/* If `--yjit-exit-locations` is passed, a file named */
"\n"/* \"yjit_exit_locations.dump\" will automatically be generated. */
"\n"/*  */
"\n"/* If you want to collect traces manually, call `dump_exit_locations` */
"\n"/* directly. */
"\n"/*  */
"\n"/* Note that calling this in a script will generate stats after the */
"\n"/* dump is created, so the stats data may include exits from the */
"\n"/* dump itself. */
"\n"/*  */
"\n"/* In a script call: */
"\n"/*  */
"\n"/*     at_exit do */
"\n"/*       RubyVM::YJIT.dump_exit_locations(\"my_file.dump\") */
"\n"/*     end */
"\n"/*  */
"\n"/* Then run the file with the following options: */
"\n"/*  */
"\n"/*     ruby --yjit --yjit-trace-exits test.rb */
"\n"/*  */
"\n"/* Once the code is done running, use Stackprof to read the dump file. */
"\n"/* See Stackprof documentation for options. */
"  def self.dump_exit_locations(filename)\n"
"    unless trace_exit_locations_enabled?\n"
"      raise ArgumentError, \"--yjit-trace-exits must be enabled to use dump_exit_locations.\"\n"
"    end\n"
"\n"
"    File.binwrite(filename, Marshal.dump(RubyVM::YJIT.exit_locations))\n"
"  end\n"
"\n"
"\n"/* Return a hash for statistics generated for the `--yjit-stats` command line option. */
"\n"/* Return `nil` when option is not passed or unavailable. */
"\n"/* If a symbol argument is provided, return only the value for the named stat. */
"\n"/* If any other type is provided, raises TypeError. */
"  def self.runtime_stats(key = nil)\n"
"    raise TypeError, \"non-symbol given\" unless key.nil? || Symbol === key\n"
"\n"
"    Primitive.rb_yjit_get_stats(key)\n"
"  end\n"
"\n"
"\n"/* Format and print out counters as a String. This returns a non-empty */
"\n"/* content only when `--yjit-stats` is enabled. */
,
#line 196 "yjit.rb"
"  def self.stats_string\n"
"\n"/* Lazily require StringIO to avoid breaking miniruby */
"    require 'stringio'\n"
"    strio = StringIO.new\n"
"    _print_stats(out: strio)\n"
"    strio.string\n"
"  end\n"
"\n"
"\n"/* Return an array of log entries. */
"\n"/* Return `nil` when option is not passed or unavailable. */
"  def self.log\n"
"    return nil unless log_enabled?\n"
"\n"
"    Primitive.rb_yjit_get_log.map do |timestamp, path|\n"
"      [Time.at(timestamp), path]\n"
"    end\n"
"  end\n"
"\n"
"\n"/* Produce disassembly for an iseq. This requires a `--enable-yjit=dev` build. */
"  def self.disasm(iseq)\n"/* :nodoc: */
"\n"/* If a method or proc is passed in, get its iseq */
"    iseq = RubyVM::InstructionSequence.of(iseq)\n"
"\n"
"    if !self.enabled?\n"
"      warn(\n"
"        \"YJIT needs to be enabled to produce disasm output, e.g.\\n\" +\n"
,
#line 222 "yjit.rb"
"        \"ruby --yjit-call-threshold=1 my_script.rb (see doc/jit/yjit.md)\"\n"
"      )\n"
"      return nil\n"
"    end\n"
"\n"
"    disasm_str = Primitive.rb_yjit_disasm_iseq(iseq)\n"
"\n"
"    if !disasm_str\n"
"      warn(\n"
"        \"YJIT disasm is only available when YJIT is built in dev mode, i.e.\\n\" +\n"
"        \"./configure --enable-yjit=dev (see doc/jit/yjit.md)\\n\"\n"
"      )\n"
"      return nil\n"
"    end\n"
"\n"
"\n"/* Produce the disassembly string */
"\n"/* Include the YARV iseq disasm in the string for additional context */
"    iseq.disasm + \"\\n\" + disasm_str\n"
"  end\n"
"\n"
"\n"/* Produce a list of instructions compiled by YJIT for an iseq */
"  def self.insns_compiled(iseq)\n"/* :nodoc: */
"    return nil unless self.enabled?\n"
"\n"
"\n"/* If a method or proc is passed in, get its iseq */
,
#line 247 "yjit.rb"
"    iseq = RubyVM::InstructionSequence.of(iseq)\n"
"    Primitive.rb_yjit_insns_compiled(iseq)\n"
"  end\n"
"\n"
"\n"/* Discard existing compiled code to reclaim memory */
"\n"/* and allow for recompilations in the future. */
"  def self.code_gc\n"
"    Primitive.rb_yjit_code_gc\n"
"  end\n"
"\n"
"  def self.simulate_oom!\n"/* :nodoc: */
"    Primitive.rb_yjit_simulate_oom_bang\n"
"  end\n"
"\n"
"\n"/* Avoid calling a Ruby method here to not interfere with compilation tests */
"  if Primitive.rb_yjit_stats_enabled_p\n"
"    at_exit { print_and_dump_stats }\n"
"  end\n"
"\n"
"\n"/* Blocks that are called when YJIT is enabled */
"  @jit_hooks = []\n"
"\n"
"  class << self\n"
"\n"/* :stopdoc: */
"    private\n"
"\n"
"\n"/* Register a block to be called when YJIT is enabled */
"    def add_jit_hook(hook)\n"
"      @jit_hooks << hook\n"
"    end\n"
"\n"
"\n"/* Run YJIT hooks registered by `#with_jit` */
"    def call_jit_hooks\n"
"\n"/* Skip using builtin methods in Ruby if --yjit-c-builtin is given */
"      return if Primitive.yjit_c_builtin_p\n"
,
#line 282 "yjit.rb"
"      @jit_hooks.each(&:call)\n"
"      @jit_hooks.clear\n"
"    end\n"
"\n"
"\n"/* Print stats and dump exit locations */
"    def print_and_dump_stats\n"/* :nodoc: */
"      if Primitive.rb_yjit_print_stats_p\n"
"        _print_stats\n"
"      end\n"
"      _dump_locations\n"
"    end\n"
"\n"
"    def _dump_locations\n"/* :nodoc: */
"      return unless trace_exit_locations_enabled?\n"
"\n"
"      filename = \"yjit_exit_locations.dump\"\n"
"      dump_exit_locations(filename)\n"
"\n"
"      $stderr.puts(\"YJIT exit locations dumped to `#{filename}`.\")\n"
"    end\n"
"\n"
"\n"/* Print a summary of reasons for adverse performance events (e.g. exits) */
"    def _print_stats_reasons(stats, out)\n"/* :nodoc: */
,
#line 305 "yjit.rb"
"      print_counters(stats, out: out, prefix: 'send_', prompt: 'method call fallback reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'invokeblock_', prompt: 'invokeblock fallback reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'invokesuper_', prompt: 'invokesuper fallback reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'guard_send_', prompt: 'method call exit reasons: ')\n"
,
#line 309 "yjit.rb"
"      print_counters(stats, out: out, prefix: 'guard_invokeblock_', prompt: 'invokeblock exit reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'guard_invokesuper_', prompt: 'invokesuper exit reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'gbpp_', prompt: 'getblockparamproxy exit reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'getivar_', prompt: 'getinstancevariable exit reasons:')\n"
,
#line 313 "yjit.rb"
"      print_counters(stats, out: out, prefix: 'setivar_', prompt: 'setinstancevariable exit reasons:')\n"
"      %w[\n"
"        branchif\n"
"        branchnil\n"
"        branchunless\n"
"        definedivar\n"
"        expandarray\n"
"        invokebuiltin\n"
"        jump\n"
"        leave\n"
"        objtostring\n"
"        opt_aref\n"
"        opt_aset\n"
"        opt_case_dispatch\n"
"        opt_div\n"
"        opt_getconstant_path\n"
"        opt_minus\n"
"        opt_mod\n"
"        opt_mult\n"
"        opt_plus\n"
"        opt_succ\n"
"        setlocal\n"
"        splatkw\n"
,
#line 336 "yjit.rb"
"      ].each do |insn|\n"
"        print_counters(stats, out: out, prefix: \"#{insn}_\", prompt: \"#{insn} exit reasons:\", optional: true)\n"
"      end\n"
"      print_counters(stats, out: out, prefix: 'lshift_', prompt: 'left shift (opt_ltlt) exit reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'rshift_', prompt: 'right shift (>>) exit reasons: ')\n"
"      print_counters(stats, out: out, prefix: 'invalidate_', prompt: 'invalidation reasons: ')\n"
"    end\n"
"\n"
"\n"/* Format and print out counters */
"    def _print_stats(out: $stderr)\n"/* :nodoc: */
,
#line 346 "yjit.rb"
"      stats = runtime_stats()\n"
"      return unless Primitive.rb_yjit_stats_enabled_p\n"
"\n"
"      out.puts(\"***YJIT: Printing YJIT statistics on exit***\")\n"
"\n"
"      _print_stats_reasons(stats, out)\n"
"\n"
"\n"/* Number of failed compiler invocations */
"      compilation_failure = stats[:compilation_failure]\n"
"\n"
"      code_region_overhead = stats[:code_region_size] - (stats[:inline_code_size] + stats[:outlined_code_size])\n"
"\n"
"      out.puts \"num_send:              \" + format_number(13, stats[:num_send])\n"
,
#line 359 "yjit.rb"
"      out.puts \"num_send_known_class:  \" + format_number_pct(13, stats[:num_send_known_class], stats[:num_send])\n"
"      out.puts \"num_send_polymorphic:  \" + format_number_pct(13, stats[:num_send_polymorphic], stats[:num_send])\n"
"      out.puts \"num_send_megamorphic:  \" + format_number_pct(13, stats[:send_megamorphic], stats[:num_send])\n"
"      out.puts \"num_send_dynamic:      \" + format_number_pct(13, stats[:num_send_dynamic], stats[:num_send])\n"
,
#line 363 "yjit.rb"
"      out.puts \"num_send_cfunc:        \" + format_number_pct(13, stats[:num_send_cfunc], stats[:num_send])\n"
"      out.puts \"num_send_cfunc_inline: \" + format_number_pct(13, stats[:num_send_cfunc_inline], stats[:num_send_cfunc])\n"
"      out.puts \"num_send_iseq:         \" + format_number_pct(13, stats[:num_send_iseq], stats[:num_send])\n"
"      out.puts \"num_send_iseq_leaf:    \" + format_number_pct(13, stats[:num_send_iseq_leaf], stats[:num_send_iseq])\n"
,
#line 367 "yjit.rb"
"      out.puts \"num_send_iseq_inline:  \" + format_number_pct(13, stats[:num_send_iseq_inline], stats[:num_send_iseq])\n"
"      if stats[:num_send_x86_rel32] != 0 || stats[:num_send_x86_reg] != 0\n"
"        out.puts \"num_send_x86_rel32:    \" + format_number(13,  stats[:num_send_x86_rel32])\n"
"        out.puts \"num_send_x86_reg:      \" + format_number(13, stats[:num_send_x86_reg])\n"
"      end\n"
"      out.puts \"num_getivar_megamorphic: \" + format_number(11, stats[:num_getivar_megamorphic])\n"
,
#line 373 "yjit.rb"
"      out.puts \"num_setivar_megamorphic: \" + format_number(11, stats[:num_setivar_megamorphic])\n"
"      out.puts \"num_opt_case_megamorphic: \" + format_number(10, stats[:num_opt_case_dispatch_megamorphic])\n"
"      out.puts \"num_throw:             \" + format_number(13, stats[:num_throw])\n"
"      out.puts \"num_throw_break:       \" + format_number_pct(13, stats[:num_throw_break], stats[:num_throw])\n"
"      out.puts \"num_throw_retry:       \" + format_number_pct(13, stats[:num_throw_retry], stats[:num_throw])\n"
,
#line 378 "yjit.rb"
"      out.puts \"num_throw_return:      \" + format_number_pct(13, stats[:num_throw_return], stats[:num_throw])\n"
"      out.puts \"num_lazy_frame_check:  \" + format_number(13, stats[:num_lazy_frame_check])\n"
"      out.puts \"num_lazy_frame_push:   \" + format_number_pct(13, stats[:num_lazy_frame_push], stats[:num_lazy_frame_check])\n"
"      out.puts \"lazy_frame_count:      \" + format_number(13, stats[:lazy_frame_count])\n"
"      out.puts \"lazy_frame_failure:    \" + format_number(13, stats[:lazy_frame_failure])\n"
"\n"
,
#line 384 "yjit.rb"
"      out.puts \"iseq_stack_too_large:  \" + format_number(13, stats[:iseq_stack_too_large])\n"
"      out.puts \"iseq_too_long:         \" + format_number(13, stats[:iseq_too_long])\n"
"      out.puts \"temp_reg_opnd:         \" + format_number(13, stats[:temp_reg_opnd])\n"
"      out.puts \"temp_mem_opnd:         \" + format_number(13, stats[:temp_mem_opnd])\n"
"      out.puts \"temp_spill:            \" + format_number(13, stats[:temp_spill])\n"
,
#line 389 "yjit.rb"
"      out.puts \"bindings_allocations:  \" + format_number(13, stats[:binding_allocations])\n"
"      out.puts \"bindings_set:          \" + format_number(13, stats[:binding_set])\n"
"      out.puts \"compilation_failure:   \" + format_number(13, compilation_failure) if compilation_failure != 0\n"
"      out.puts \"live_iseq_count:       \" + format_number(13, stats[:live_iseq_count])\n"
"      out.puts \"iseq_alloc_count:      \" + format_number(13, stats[:iseq_alloc_count])\n"
,
#line 394 "yjit.rb"
"      out.puts \"compiled_iseq_entry:   \" + format_number(13, stats[:compiled_iseq_entry])\n"
"      out.puts \"cold_iseq_entry:       \" + format_number_pct(13, stats[:cold_iseq_entry], stats[:compiled_iseq_entry] + stats[:cold_iseq_entry])\n"
"      out.puts \"compiled_iseq_count:   \" + format_number(13, stats[:compiled_iseq_count])\n"
"      out.puts \"compiled_blockid_count:\" + format_number(13, stats[:compiled_blockid_count])\n"
,
#line 398 "yjit.rb"
"      out.puts \"compiled_block_count:  \" + format_number(13, stats[:compiled_block_count])\n"
"      out.puts \"inline_block_count:    \" + format_number_pct(13, stats[:inline_block_count], stats[:compiled_block_count])\n"
"      out.puts \"deleted_defer_block_count:\" + format_number_pct(10, stats[:deleted_defer_block_count], stats[:compiled_block_count])\n"
"      if stats[:compiled_blockid_count] != 0\n"
,
#line 402 "yjit.rb"
"        out.puts \"versions_per_block:    \" + format_number(13, \"%4.3f\" % (stats[:compiled_block_count].fdiv(stats[:compiled_blockid_count])))\n"
"      end\n"
"      out.puts \"max_inline_versions:   \" + format_number(13, stats[:max_inline_versions])\n"
"      out.puts \"compiled_branch_count: \" + format_number(13, stats[:compiled_branch_count])\n"
"\n"
"      out.puts \"yjit_active_ms:        \" + format_number(13, stats[:yjit_active_ns] / 10**6)\n"
,
#line 408 "yjit.rb"
"      out.puts \"compile_time_ms:       \" + format_number_pct(13, stats[:compile_time_ns] / 10**6 , stats[:yjit_active_ns] / 10**6)\n"
"      out.puts \"block_next_count:      \" + format_number(13, stats[:block_next_count])\n"
"      out.puts \"defer_count:           \" + format_number(13, stats[:defer_count])\n"
"      out.puts \"defer_empty_count:     \" + format_number(13, stats[:defer_empty_count])\n"
"\n"
"      out.puts \"branch_insn_count:     \" + format_number(13, stats[:branch_insn_count])\n"
,
#line 414 "yjit.rb"
"      out.puts \"branch_known_count:    \" + format_number_pct(13, stats[:branch_known_count], stats[:branch_insn_count])\n"
"\n"
"      out.puts \"freed_iseq_count:      \" + format_number(13, stats[:freed_iseq_count])\n"
"      out.puts \"invalidation_count:    \" + format_number(13, stats[:invalidation_count])\n"
"      out.puts \"inline_code_size:      \" + format_number(13, stats[:inline_code_size])\n"
"      out.puts \"outlined_code_size:    \" + format_number(13, stats[:outlined_code_size])\n"
,
#line 420 "yjit.rb"
"      out.puts \"code_region_size:      \" + format_number(13, stats[:code_region_size])\n"
"      out.puts \"code_region_overhead:  \" + format_number_pct(13, code_region_overhead, stats[:code_region_size])\n"
"\n"
"      out.puts \"freed_code_size:       \" + format_number(13, stats[:freed_code_size])\n"
"      out.puts \"yjit_alloc_size:       \" + format_number(13, stats[:yjit_alloc_size]) if stats.key?(:yjit_alloc_size)\n"
"\n"
"      bytes_per_context = stats[:context_data_bytes].fdiv(stats[:num_contexts_encoded])\n"
,
#line 427 "yjit.rb"
"      out.puts \"context_data_bytes:    \" + format_number(13, stats[:context_data_bytes])\n"
"      out.puts \"context_cache_bytes:   \" + format_number(13, stats[:context_cache_bytes])\n"
"      out.puts \"num_contexts_encoded:  \" + format_number(13, stats[:num_contexts_encoded])\n"
"      out.puts \"bytes_per_context:     \" + (\"%13.2f\" % bytes_per_context)\n"
"      out.puts \"context_cache_hit_rate:\" + format_number_pct(13, stats[:context_cache_hits], stats[:num_contexts_encoded])\n"
"\n"
,
#line 433 "yjit.rb"
"      out.puts \"live_page_count:       \" + format_number(13, stats[:live_page_count])\n"
"      out.puts \"freed_page_count:      \" + format_number(13, stats[:freed_page_count])\n"
"      out.puts \"code_gc_count:         \" + format_number(13, stats[:code_gc_count])\n"
"      out.puts \"num_gc_obj_refs:       \" + format_number(13, stats[:num_gc_obj_refs])\n"
"      out.puts \"object_shape_count:    \" + format_number(13, stats[:object_shape_count])\n"
,
#line 438 "yjit.rb"
"      out.puts \"side_exit_count:       \" + format_number(13, stats[:side_exit_count])\n"
"      out.puts \"total_exit_count:      \" + format_number(13, stats[:total_exit_count])\n"
"      out.puts \"total_insns_count:     \" + format_number(13, stats[:total_insns_count]) if stats[:total_insns_count]\n"
"      out.puts \"vm_insns_count:        \" + format_number(13, stats[:vm_insns_count]) if stats[:vm_insns_count]\n"
"      out.puts \"yjit_insns_count:      \" + format_number(13, stats[:yjit_insns_count])\n"
,
#line 443 "yjit.rb"
"      out.puts \"ratio_in_yjit:         \" + (\"%12.1f\" % stats[:ratio_in_yjit]) + \"%\" if stats[:ratio_in_yjit]\n"
"      out.puts \"avg_len_in_yjit:       \" + (\"%13.1f\" % stats[:avg_len_in_yjit])\n"
"\n"
"      print_sorted_exit_counts(stats, out: out, prefix: \"exit_\")\n"
"\n"
"      print_sorted_method_calls(stats[:cfunc_calls], stats[:num_send_cfunc], out: out, type: 'C')\n"
"      print_sorted_method_calls(stats[:iseq_calls], stats[:num_send_iseq], out: out, type: 'ISEQ')\n"
"    end\n"
"\n"
,
#line 452 "yjit.rb"
"    def print_sorted_method_calls(calls, num_calls, out:, type:, how_many: 20, left_pad: 4)\n"/* :nodoc: */
"      return if calls.empty?\n"
"\n"
"\n"/* Sort calls by decreasing frequency and keep the top N */
"      pairs = calls.map { |k,v| [k, v] }\n"
"      pairs.sort_by! {|pair| -pair[1] }\n"
"      pairs = pairs[0...how_many]\n"
"\n"
"      top_n_total = pairs.sum { |name, count| count }\n"
"      top_n_pct = 100.0 * top_n_total / num_calls\n"
"\n"
"      out.puts \"Top-#{pairs.size} most frequent #{type} calls (#{\"%.1f\" % top_n_pct}% of #{type} calls):\"\n"
"\n"
"      count_width = format_number(0, pairs[0][1]).length\n"
,
#line 466 "yjit.rb"
"      pairs.each do |name, count|\n"
"        padded_count = format_number_pct(count_width, count, num_calls)\n"
"        out.puts(\"  #{padded_count}: #{name}\")\n"
"      end\n"
"    end\n"
"\n"
"    def print_sorted_exit_counts(stats, out:, prefix:, how_many: 20, left_pad: 4)\n"/* :nodoc: */
"      total_exits = stats[:side_exit_count]\n"
"\n"
"      if total_exits > 0\n"
"        exits = []\n"
"        stats.each do |k, v|\n"
"          if k.start_with?(prefix)\n"
"            exits.push [k.to_s.delete_prefix(prefix), v]\n"
"          end\n"
"        end\n"
"\n"
,
#line 483 "yjit.rb"
"        exits = exits.select { |_name, count| count > 0 }.max_by(how_many) { |_name, count| count }\n"
"\n"
"        top_n_total = exits.sum { |name, count| count }\n"
"        top_n_exit_pct = 100.0 * top_n_total / total_exits\n"
"\n"
"        out.puts \"Top-#{exits.size} most frequent exit ops (#{\"%.1f\" % top_n_exit_pct}% of exits):\"\n"
"\n"
"        count_width = format_number(0, exits[0][1]).length\n"
"        exits.each do |name, count|\n"
"          padded_count = format_number_pct(count_width, count, total_exits)\n"
,
#line 493 "yjit.rb"
"          out.puts(\"  #{padded_count}: #{name}\")\n"
"        end\n"
"      else\n"
"        out.puts \"total_exits:           \" + format_number(13, total_exits)\n"
"      end\n"
"    end\n"
"\n"
"    def print_counters(counters, out:, prefix:, prompt:, optional: false)\n"/* :nodoc: */
"      counters = counters.filter { |key, _| key.start_with?(prefix) }\n"
"      counters.filter! { |_, value| value != 0 }\n"
"      counters.transform_keys! { |key| key.to_s.delete_prefix(prefix) }\n"
"\n"
"      if counters.empty?\n"
"        unless optional\n"
,
#line 507 "yjit.rb"
"          out.puts(prompt)\n"
"          out.puts(\"    (all relevant counters are zero)\")\n"
"        end\n"
"        return\n"
"      else\n"
"        out.puts(prompt)\n"
"      end\n"
"\n"
"      counters = counters.to_a\n"
"      counters.sort_by! { |(_, counter_value)| counter_value }\n"
"      longest_name_length = counters.max_by { |(name, _)| name.length }.first.length\n"
"      total = counters.sum { |(_, counter_value)| counter_value }\n"
"\n"
"      counters.reverse_each do |(name, value)|\n"
,
#line 521 "yjit.rb"
"        padded_name = name.rjust(longest_name_length, ' ')\n"
"        padded_count = format_number_pct(10, value, total)\n"
"        out.puts(\"    #{padded_name}: #{padded_count}\")\n"
"      end\n"
"    end\n"
"\n"
"\n"/* Format large numbers with comma separators for readability */
"    def format_number(pad, number)\n"/* :nodoc: */
"      s = number.to_s\n"
"      i = s.index('.') || s.size\n"
"      s.insert(i -= 3, ',') while i > 3\n"
"      s.rjust(pad, ' ')\n"
"    end\n"
"\n"
"\n"/* Format a number along with a percentage over a total value */
"    def format_number_pct(pad, number, total)\n"/* :nodoc: */
"      padded_count = format_number(pad, number)\n"
"\n"
"      if total != 0\n"
,
#line 540 "yjit.rb"
"        percentage = number.fdiv(total) * 100\n"
"        formatted_pct = \"%4.1f%%\" % percentage\n"
"        \"#{padded_count} (#{formatted_pct})\"\n"
"      else\n"
"        \"#{padded_count}\"\n"
"      end\n"
"    end\n"
"\n"
"\n"/* :startdoc: */
"  end\n"
"end\n"
#line 7116 "miniprelude.c"
};

static const char prelude_name23[] = "<internal:zjit>";
static const struct {
    RBIMPL_ATTR_NONSTRING() char L0[479]; /* 1..34 */
    RBIMPL_ATTR_NONSTRING() char L34[467]; /* 35..60 */
    RBIMPL_ATTR_NONSTRING() char L60[504]; /* 61..86 */
    RBIMPL_ATTR_NONSTRING() char L86[502]; /* 87..105 */
    RBIMPL_ATTR_NONSTRING() char L105[482]; /* 106..139 */
    RBIMPL_ATTR_NONSTRING() char L139[507]; /* 140..163 */
    RBIMPL_ATTR_NONSTRING() char L163[431]; /* 164..178 */
    RBIMPL_ATTR_NONSTRING() char L178[387]; /* 179..185 */
    RBIMPL_ATTR_NONSTRING() char L185[446]; /* 186..188 */
    RBIMPL_ATTR_NONSTRING() char L188[491]; /* 189..196 */
    RBIMPL_ATTR_NONSTRING() char L196[391]; /* 197..201 */
    RBIMPL_ATTR_NONSTRING() char L201[488]; /* 202..214 */
    RBIMPL_ATTR_NONSTRING() char L214[476]; /* 215..231 */
    RBIMPL_ATTR_NONSTRING() char L231[502]; /* 232..259 */
    RBIMPL_ATTR_NONSTRING() char L259[504]; /* 260..280 */
    RBIMPL_ATTR_NONSTRING() char L280[501]; /* 281..297 */
    RBIMPL_ATTR_NONSTRING() char L297[462]; /* 298..310 */
    RBIMPL_ATTR_NONSTRING() char L310[475]; /* 311..322 */
    RBIMPL_ATTR_NONSTRING() char L322[495]; /* 323..346 */
    RBIMPL_ATTR_NONSTRING() char L346[293]; /* 347..357 */
} prelude_code23 = {
#line 1 "zjit.rb"
""/* frozen_string_literal: true */
""
""/* This module allows for introspection of ZJIT, CRuby's just-in-time compiler. */
""/* Everything in the module is highly implementation specific and the API might */
""/* be less stable compared to the standard library. */
""/*  */
""/* This module may not exist if ZJIT does not support the particular platform */
""/* for which CRuby is built. */
"module RubyVM::ZJIT\n"
"\n"/* Blocks that are called when YJIT is enabled */
"  @jit_hooks = []\n"
"\n"/* Avoid calling a Ruby method here to avoid interfering with compilation tests */
"  if Primitive.rb_zjit_get_stats_file_path_p\n"
"    at_exit { print_stats_file }\n"
"  end\n"
"  if Primitive.rb_zjit_print_stats_p\n"
"    at_exit { print_stats }\n"
"  end\n"
"  if Primitive.rb_zjit_trace_exit_locations_enabled_p\n"
"    at_exit { dump_locations }\n"
"  end\n"
"end\n"
"\n"
"class << RubyVM::ZJIT\n"
"\n"/* Check if ZJIT is enabled */
"  def enabled?\n"
"    Primitive.cexpr! 'RBOOL(rb_zjit_enabled_p)'\n"
"  end\n"
"\n"
"\n"/* Enable ZJIT compilation. */
"  def enable\n"
"    return false if enabled?\n"
"\n"
"    if Primitive.cexpr! 'RBOOL(rb_yjit_enabled_p)'\n"
,
#line 35 "zjit.rb"
"      warn(\"Only one JIT can be enabled at the same time.\")\n"
"      return false\n"
"    end\n"
"\n"
"    Primitive.rb_zjit_enable\n"
"  end\n"
"\n"
"\n"/* Check if `--zjit-trace-exits` is used */
"  def trace_exit_locations_enabled?\n"
"    Primitive.rb_zjit_trace_exit_locations_enabled_p\n"
"  end\n"
"\n"
"\n"/* If --zjit-trace-exits is enabled parse the hashes from */
"\n"/* Primitive.rb_zjit_get_exit_locations into a format readable */
"\n"/* by Stackprof. This will allow us to find the exact location of a */
"\n"/* side exit in ZJIT based on the instruction that is exiting. */
"  def exit_locations\n"
"    return unless trace_exit_locations_enabled?\n"
"\n"
"    results = Primitive.rb_zjit_get_exit_locations\n"
"    raw_samples = results[:raw]\n"
"    line_samples = results[:lines]\n"
"    frames = results[:frames]\n"
"    samples_count = 0\n"
"\n"
"\n"/* Use nonexistent.def as a dummy file name. */
,
#line 61 "zjit.rb"
"    frame_template = { samples: 0, total_samples: 0, edges: {}, name: name, file: \"nonexistent.def\", line: nil, lines: {} }\n"
"\n"
"\n"/* Loop through all possible instructions and setup the frame hash. */
"    RubyVM::INSTRUCTION_NAMES.each_with_index do |name, frame_id|\n"
"      frames[frame_id] = frame_template.dup.tap { |h| h[:name] = name }\n"
"    end\n"
"\n"
"\n"/* Loop through the raw_samples and build the hashes for StackProf. */
"\n"/* The loop is based off an example in the StackProf documentation and therefore */
"\n"/* this functionality can only work with that library. */
"\n"/*  */
"\n"/* Raw Samples: */
"\n"/* [ length, frame1, frame2, frameN, ..., instruction, count */
"\n"/*  */
"\n"/* Line Samples */
"\n"/* [ length, line_1, line_2, line_n, ..., dummy value, count */
"    i = 0\n"
"    while i < raw_samples.length\n"
"      stack_length = raw_samples[i]\n"
"      i += 1\n"/* consume the stack length */
"\n"
"      sample_count = raw_samples[i + stack_length]\n"
"\n"
"      prev_frame_id = nil\n"
"      stack_length.times do |idx|\n"
"        idx += i\n"
,
#line 87 "zjit.rb"
"        frame_id = raw_samples[idx]\n"
"\n"
"        if prev_frame_id\n"
"          prev_frame = frames[prev_frame_id]\n"
"          prev_frame[:edges][frame_id] ||= 0\n"
"          prev_frame[:edges][frame_id] += sample_count\n"
"        end\n"
"\n"
"        frame_info = frames[frame_id]\n"
"        frame_info[:total_samples] += sample_count\n"
"\n"
"        frame_info[:lines][line_samples[idx]] ||= [0, 0]\n"
"        frame_info[:lines][line_samples[idx]][0] += sample_count\n"
"\n"
"        prev_frame_id = frame_id\n"
"      end\n"
"\n"
"      i += stack_length\n"/* consume the stack */
"\n"
,
#line 106 "zjit.rb"
"      top_frame_id = prev_frame_id\n"
"      top_frame_line = 1\n"
"\n"
"      frames[top_frame_id][:samples] += sample_count\n"
"      frames[top_frame_id][:lines] ||= {}\n"
"      frames[top_frame_id][:lines][top_frame_line] ||= [0, 0]\n"
"      frames[top_frame_id][:lines][top_frame_line][1] += sample_count\n"
"\n"
"      samples_count += sample_count\n"
"      i += 1\n"
"    end\n"
"\n"
"    results[:samples] = samples_count\n"
"\n"
"\n"/* These values are mandatory to include for stackprof, but we don't use them. */
"    results[:missed_samples] = 0\n"
"    results[:gc_samples] = 0\n"
"    results\n"
"  end\n"
"\n"
"\n"/* Marshal dumps exit locations to the given filename. */
"\n"/*  */
"\n"/* Usage: */
"\n"/*  */
"\n"/* In a script call: */
"\n"/*  */
"\n"/*   RubyVM::ZJIT.dump_exit_locations(\"my_file.dump\") */
"\n"/*  */
"\n"/* Then run the file with the following options: */
"\n"/*  */
"\n"/*   ruby --zjit --zjit-stats --zjit-trace-exits test.rb */
"\n"/*  */
"\n"/* Once the code is done running, use Stackprof to read the dump file. */
"\n"/* See Stackprof documentation for options. */
,
#line 140 "zjit.rb"
"  def dump_exit_locations(filename)\n"
"    unless trace_exit_locations_enabled?\n"
"      raise ArgumentError, \"--zjit-trace-exits must be enabled to use dump_exit_locations.\"\n"
"    end\n"
"\n"
"    File.open(filename, \"wb\") do |file|\n"
"      Marshal.dump(RubyVM::ZJIT.exit_locations, file)\n"
"      file.size\n"
"    end\n"
"  end\n"
"\n"
"\n"/* Check if `--zjit-stats` is used */
"  def stats_enabled?\n"
"    Primitive.rb_zjit_stats_enabled_p\n"
"  end\n"
"\n"
"\n"/* Return ZJIT statistics as a Hash */
"  def stats(target_key = nil)\n"
"    Primitive.rb_zjit_stats(target_key)\n"
"  end\n"
"\n"
"\n"/* Discard statistics collected for `--zjit-stats`. */
"  def reset_stats!\n"
"    Primitive.rb_zjit_reset_stats_bang\n"
,
#line 164 "zjit.rb"
"  end\n"
"\n"
"\n"/* Get the summary of ZJIT statistics as a String */
"  def stats_string\n"
"    buf = +\"***ZJIT: Printing ZJIT statistics on exit***\\n\"\n"
"    stats = self.stats\n"
"\n"
"    if stats[:guard_type_count].nonzero?\n"
"      stats[:guard_type_exit_ratio] = stats[:exit_guard_type_failure].to_f / stats[:guard_type_count] * 100\n"
"    end\n"
"    if stats[:guard_shape_count].nonzero?\n"
"      stats[:guard_shape_exit_ratio] = stats[:exit_guard_shape_failure].to_f / stats[:guard_shape_count] * 100\n"
"    end\n"
"\n"
"\n"/* Show counters independent from exit_* or dynamic_send_* */
,
#line 179 "zjit.rb"
"    print_counters_with_prefix(prefix: 'not_inlined_cfuncs_', prompt: 'not inlined C methods', buf:, stats:, limit: 20)\n"
"    print_counters_with_prefix(prefix: 'ccall_', prompt: 'calls to C functions from JIT code', buf:, stats:, limit: 20)\n"
"\n"/* Don't show not_annotated_cfuncs right now because it mostly duplicates not_inlined_cfuncs */
"\n"/* print_counters_with_prefix(prefix: 'not_annotated_cfuncs_', prompt: 'not annotated C methods', buf:, stats:, limit: 20) */
"\n"
"\n"/* Show fallback counters, ordered by the typical amount of fallbacks for the prefix at the time */
"    print_counters_with_prefix(prefix: 'unspecialized_send_def_type_', prompt: 'not optimized method types for send', buf:, stats:, limit: 20)\n"
,
#line 186 "zjit.rb"
"    print_counters_with_prefix(prefix: 'unspecialized_send_without_block_def_type_', prompt: 'not optimized method types for send_without_block', buf:, stats:, limit: 20)\n"
"    print_counters_with_prefix(prefix: 'uncategorized_fallback_yarv_insn_', prompt: 'instructions with uncategorized fallback reason', buf:, stats:, limit: 20)\n"
"    print_counters_with_prefix(prefix: 'send_fallback_', prompt: 'send fallback reasons', buf:, stats:, limit: 20)\n"
,
#line 189 "zjit.rb"
"    print_counters_with_prefix(prefix: 'setivar_fallback_', prompt: 'setivar fallback reasons', buf:, stats:, limit: 5)\n"
"    print_counters_with_prefix(prefix: 'getivar_fallback_', prompt: 'getivar fallback reasons', buf:, stats:, limit: 5)\n"
"    print_counters_with_prefix(prefix: 'definedivar_fallback_', prompt: 'definedivar fallback reasons', buf:, stats:, limit: 5)\n"
"    print_counters_with_prefix(prefix: 'invokeblock_handler_', prompt: 'invokeblock handler', buf:, stats:, limit: 10)\n"
"\n"
"\n"/* Show most popular unsupported call features. Because each call can */
"\n"/* use multiple complex features, a decrease in this number does not */
"\n"/* necessarily mean an increase in number of optimized calls. */
,
#line 197 "zjit.rb"
"    print_counters_with_prefix(prefix: 'complex_arg_pass_', prompt: 'popular complex argument-parameter features not optimized', buf:, stats:, limit: 10)\n"
"\n"
"\n"/* Show exit counters, ordered by the typical amount of exits for the prefix at the time */
"    print_counters_with_prefix(prefix: 'compile_error_', prompt: 'compile error reasons', buf:, stats:, limit: 20)\n"
"    print_counters_with_prefix(prefix: 'unhandled_yarv_insn_', prompt: 'unhandled YARV insns', buf:, stats:, limit: 20)\n"
,
#line 202 "zjit.rb"
"    print_counters_with_prefix(prefix: 'unhandled_hir_insn_', prompt: 'unhandled HIR insns', buf:, stats:, limit: 20)\n"
"    print_counters_with_prefix(prefix: 'exit_', prompt: 'side exit reasons', buf:, stats:, limit: 20)\n"
"\n"
"\n"/* Show no-prefix counters, having the most important stat `ratio_in_zjit` at the end */
"    print_counters([\n"
"      :send_count,\n"
"      :dynamic_send_count,\n"
"      :optimized_send_count,\n"
"      :dynamic_setivar_count,\n"
"      :dynamic_getivar_count,\n"
"      :dynamic_definedivar_count,\n"
"      :iseq_optimized_send_count,\n"
"      :inline_cfunc_optimized_send_count,\n"
,
#line 215 "zjit.rb"
"      :inline_iseq_optimized_send_count,\n"
"      :non_variadic_cfunc_optimized_send_count,\n"
"      :variadic_cfunc_optimized_send_count,\n"
"    ], buf:, stats:, right_align: true, base: :send_count)\n"
"    print_counters([\n"
"      :compiled_iseq_count,\n"
"      :failed_iseq_count,\n"
"\n"
"      :compile_time_ns,\n"
"      :profile_time_ns,\n"
"      :gc_time_ns,\n"
"      :invalidation_time_ns,\n"
"\n"
"      :vm_write_pc_count,\n"
"      :vm_write_sp_count,\n"
"      :vm_write_locals_count,\n"
"      :vm_write_stack_count,\n"
,
#line 232 "zjit.rb"
"      :vm_write_to_parent_iseq_local_count,\n"
"      :vm_read_from_parent_iseq_local_count,\n"
"\n"
"      :guard_type_count,\n"
"      :guard_type_exit_ratio,\n"
"      :guard_shape_count,\n"
"      :guard_shape_exit_ratio,\n"
"\n"
"      :code_region_bytes,\n"
"      :zjit_alloc_bytes,\n"
"      :total_mem_bytes,\n"
"\n"
"      :side_exit_count,\n"
"      :total_insn_count,\n"
"      :vm_insn_count,\n"
"      :zjit_insn_count,\n"
"      :ratio_in_zjit,\n"
"    ], buf:, stats:)\n"
"\n"
"    buf\n"
"  end\n"
"\n"
"\n"/* Assert that any future ZJIT compilation will return a function pointer */
"  def assert_compiles\n"/* :nodoc: */
"    Primitive.rb_zjit_assert_compiles\n"
"  end\n"
"\n"
"\n"/* :stopdoc: */
,
#line 260 "zjit.rb"
"  private\n"
"\n"
"\n"/* Register a block to be called when ZJIT is enabled */
"  def add_jit_hook(hook)\n"
"    @jit_hooks << hook\n"
"  end\n"
"\n"
"\n"/* Run ZJIT hooks registered by `#with_jit` */
"  def call_jit_hooks\n"
"    @jit_hooks.each(&:call)\n"
"    @jit_hooks.clear\n"
"  end\n"
"\n"
"  def print_counters(keys, buf:, stats:, right_align: false, base: nil)\n"
"    key_pad = keys.map { |key| key.to_s.sub(/_time_ns\\z/, '_time').size }.max + 1\n"
"    key_align = '-' unless right_align\n"
"    value_pad = keys.filter_map { |key| stats[key] }.map { |value| number_with_delimiter(value).size }.max\n"
"\n"
"    keys.each do |key|\n"
"\n"/* Some stats like vm_insn_count and ratio_in_zjit are not supported on the release build */
"      next unless stats.key?(key)\n"
,
#line 281 "zjit.rb"
"      value = stats[key]\n"
"      if base && key != base\n"
"        total = stats[base]\n"
"        if total.nonzero?\n"
"          ratio = \" (%4.1f%%)\" % (100.0 * value / total)\n"
"        end\n"
"      end\n"
"\n"
"      case key\n"
"      when :ratio_in_zjit\n"
"        value = '%0.1f%%' % value\n"
"      when :guard_type_exit_ratio, :guard_shape_exit_ratio\n"
"        value = '%0.1f%%' % value\n"
"      when /_time_ns\\z/\n"
"        key = key.to_s.sub(/_time_ns\\z/, '_time')\n"
"        value = \"#{number_with_delimiter(value / 10**6)}ms\"\n"
"      else\n"
,
#line 298 "zjit.rb"
"        value = number_with_delimiter(value)\n"
"      end\n"
"\n"
"      buf << \"%#{key_align}*s %*s%s\\n\" % [key_pad, \"#{key}:\", value_pad, value, ratio]\n"
"    end\n"
"  end\n"
"\n"
"  def print_counters_with_prefix(buf:, stats:, prefix:, prompt:, limit: nil)\n"
"    counters = stats.select { |key, value| key.start_with?(prefix) && value > 0 }\n"
"    return if counters.empty?\n"
"\n"
"    counters.transform_keys! { |key| key.to_s.delete_prefix(prefix) }\n"
"    key_pad = counters.keys.map(&:size).max\n"
,
#line 311 "zjit.rb"
"    value_pad = counters.values.map { |value| number_with_delimiter(value).size }.max\n"
"    total = counters.values.sum\n"
"\n"
"    counters = counters.to_a\n"
"    counters.sort_by! { |_, value| -value }\n"
"    counters = counters.first(limit) if limit\n"
"\n"
"    buf << \"Top-#{counters.size} \" if limit\n"
"    buf << \"#{prompt}\"\n"
"    buf << \" (%.1f%% of total #{number_with_delimiter(total)})\" % (100.0 * counters.map(&:last).sum / total) if limit\n"
"    buf << \":\\n\"\n"
"    counters.each do |key, value|\n"
,
#line 323 "zjit.rb"
"      buf << \"  %*s: %*s (%4.1f%%)\\n\" % [key_pad, key, value_pad, number_with_delimiter(value), (100.0 * value / total)]\n"
"    end\n"
"  end\n"
"\n"
"  def number_with_delimiter(number)\n"
"    s = number.to_s\n"
"    i = s.index('.') || s.size\n"
"    s.insert(i -= 3, ',') while i > 3\n"
"    s\n"
"  end\n"
"\n"
"\n"/* Print ZJIT stats */
"  def print_stats\n"
"    $stderr.write stats_string\n"
"  end\n"
"\n"
"\n"/* Print ZJIT stats to file */
"  def print_stats_file\n"
"    filename = Primitive.rb_zjit_get_stats_file_path_p\n"
"    File.open(filename, \"wb\") do |file|\n"
"      file.write stats_string\n"
"    end\n"
"  end\n"
"\n"
,
#line 347 "zjit.rb"
"  def dump_locations\n"/* :nodoc: */
"    return unless trace_exit_locations_enabled?\n"
"\n"
"    filename = \"zjit_exits_#{Process.pid}.dump\"\n"
"    n_bytes = dump_exit_locations(filename)\n"
"\n"
"    absolute_filename = File.expand_path(filename)\n"
"    $stderr.puts(\"#{n_bytes} bytes written to #{absolute_filename}\")\n"
"  end\n"
"end\n"
#line 7537 "miniprelude.c"
};

COMPILER_WARNING_POP

#define PRELUDE_NAME(n) rb_usascii_str_new_static(prelude_name##n, sizeof(prelude_name##n)-1)
#define PRELUDE_CODE(n) rb_utf8_str_new_static(prelude_code##n.L0, sizeof(prelude_code##n))

#define PRELUDE_MATCH(n) \
    (((sizeof(prelude_name##n) - prefix_len - 2) == namelen) && \
     (strncmp(prelude_name##n + prefix_len, feature_name, namelen) == 0))

VALUE
rb_builtin_find(const char *feature_name, VALUE *name_str, int *start_line)
{
    const size_t prefix_len = rb_strlen_lit("<internal:");
    size_t namelen = strlen(feature_name);

#define PRELUDE_FOUND(n, l) \
    (*name_str = PRELUDE_NAME(n), *start_line = (l), PRELUDE_CODE(n))

    if (PRELUDE_MATCH(0)) return PRELUDE_FOUND(0, 19);
    if (PRELUDE_MATCH(1)) return PRELUDE_FOUND(1, 158);
    if (PRELUDE_MATCH(2)) return PRELUDE_FOUND(2, 8);
    if (PRELUDE_MATCH(3)) return PRELUDE_FOUND(3, 1);
    if (PRELUDE_MATCH(4)) return PRELUDE_FOUND(4, 1);
    if (PRELUDE_MATCH(5)) return PRELUDE_FOUND(5, 1);
    if (PRELUDE_MATCH(6)) return PRELUDE_FOUND(6, 1);
    if (PRELUDE_MATCH(7)) return PRELUDE_FOUND(7, 49);
    if (PRELUDE_MATCH(8)) return PRELUDE_FOUND(8, 4);
    if (PRELUDE_MATCH(9)) return PRELUDE_FOUND(9, 1);
    if (PRELUDE_MATCH(10)) return PRELUDE_FOUND(10, 1);
    if (PRELUDE_MATCH(11)) return PRELUDE_FOUND(11, 1);
    if (PRELUDE_MATCH(12)) return PRELUDE_FOUND(12, 191);
    if (PRELUDE_MATCH(13)) return PRELUDE_FOUND(13, 195);
    if (PRELUDE_MATCH(14)) return PRELUDE_FOUND(14, 1);
    if (PRELUDE_MATCH(15)) return PRELUDE_FOUND(15, 261);
    if (PRELUDE_MATCH(16)) return PRELUDE_FOUND(16, 3);
    if (PRELUDE_MATCH(17)) return PRELUDE_FOUND(17, 1);
    if (PRELUDE_MATCH(18)) return PRELUDE_FOUND(18, 1);
    if (PRELUDE_MATCH(19)) return PRELUDE_FOUND(19, 1);
    if (PRELUDE_MATCH(20)) return PRELUDE_FOUND(20, 1);
    if (PRELUDE_MATCH(21)) return PRELUDE_FOUND(21, 2);
    if (PRELUDE_MATCH(22)) return PRELUDE_FOUND(22, 10);
    if (PRELUDE_MATCH(23)) return PRELUDE_FOUND(23, 9);
#undef PRELUDE_FOUND

    return Qnil;
}

void
Init_prelude(void)
{
}
