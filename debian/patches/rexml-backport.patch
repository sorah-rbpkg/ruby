From: =?utf-8?q?Bastien_Roucari=C3=A8s?= <rouca@debian.org>
Date: Tue, 25 Feb 2025 21:09:16 +0000
Subject: Rexml backport from bullseye

origin: https://sources.debian.org/src/ruby2.7/2.7.4-1%2Bdeb11u1/
---
 lib/rexml/attlistdecl.rb                           |    7 +-
 lib/rexml/attribute.rb                             |   36 +-
 lib/rexml/cdata.rb                                 |    5 +-
 lib/rexml/child.rb                                 |    3 +-
 lib/rexml/comment.rb                               |    6 +-
 lib/rexml/doctype.rb                               |   35 +-
 lib/rexml/document.rb                              |   31 +-
 lib/rexml/dtd/attlistdecl.rb                       |    3 +-
 lib/rexml/dtd/dtd.rb                               |   18 +-
 lib/rexml/dtd/elementdecl.rb                       |    7 +-
 lib/rexml/dtd/entitydecl.rb                        |    3 +-
 lib/rexml/dtd/notationdecl.rb                      |    3 +-
 lib/rexml/element.rb                               |   71 +-
 lib/rexml/encoding.rb                              |    1 +
 lib/rexml/entity.rb                                |   14 +-
 lib/rexml/formatters/default.rb                    |   15 +-
 lib/rexml/formatters/pretty.rb                     |    3 +-
 lib/rexml/formatters/transitive.rb                 |    3 +-
 lib/rexml/functions.rb                             |  143 +-
 lib/rexml/instruction.rb                           |   35 +-
 lib/rexml/light/node.rb                            |    3 +-
 lib/rexml/namespace.rb                             |   26 +-
 lib/rexml/node.rb                                  |    9 +-
 lib/rexml/output.rb                                |    3 +-
 lib/rexml/parent.rb                                |    5 +-
 lib/rexml/parseexception.rb                        |    1 +
 lib/rexml/parsers/baseparser.rb                    |   42 +-
 lib/rexml/parsers/lightparser.rb                   |    7 +-
 lib/rexml/parsers/pullparser.rb                    |    7 +-
 lib/rexml/parsers/sax2parser.rb                    |   10 +-
 lib/rexml/parsers/streamparser.rb                  |   11 +-
 lib/rexml/parsers/treeparser.rb                    |    5 +-
 lib/rexml/parsers/ultralightparser.rb              |    5 +-
 lib/rexml/parsers/xpathparser.rb                   |  122 +-
 lib/rexml/quickpath.rb                             |    9 +-
 lib/rexml/rexml.gemspec                            |   84 +
 lib/rexml/rexml.rb                                 |    7 +-
 lib/rexml/sax2listener.rb                          |    1 +
 lib/rexml/security.rb                              |    1 +
 lib/rexml/source.rb                                |   14 +-
 lib/rexml/streamlistener.rb                        |    3 +-
 lib/rexml/syncenumerator.rb                        |    1 +
 lib/rexml/text.rb                                  |   71 +-
 lib/rexml/undefinednamespaceexception.rb           |    3 +-
 lib/rexml/validation/relaxng.rb                    |   26 +-
 lib/rexml/validation/validation.rb                 |   15 +-
 lib/rexml/validation/validationexception.rb        |    1 +
 lib/rexml/xmldecl.rb                               |   41 +-
 lib/rexml/xmltokens.rb                             |   77 +-
 lib/rexml/xpath.rb                                 |   17 +-
 lib/rexml/xpath_parser.rb                          | 1099 +++++----
 test/rexml/data/t75.xml                            |    2 +-
 test/rexml/data/ticket_110_utf16.xml               |  Bin 207464 -> 0 bytes
 test/rexml/data/utf16.xml                          |  Bin 0 -> 207464 bytes
 test/rexml/formatter/test_default.rb               |   19 +
 test/rexml/functions/test_base.rb                  |  261 ++
 test/rexml/functions/test_boolean.rb               |   75 +
 test/rexml/functions/test_local_name.rb            |   44 +
 test/rexml/functions/test_number.rb                |   38 +
 test/rexml/listener.rb                             |   95 +-
 test/rexml/parse/test_document_type_declaration.rb |   51 +-
 test/rexml/parse/test_element.rb                   |    2 +-
 test/rexml/parse/test_notation_declaration.rb      |  127 +-
 test/rexml/parse/test_processing_instruction.rb    |   44 +
 test/rexml/parser/test_sax2.rb                     |    3 +
 test/rexml/parser/test_stream.rb                   |   32 +
 test/rexml/parser/test_tree.rb                     |    3 +
 test/rexml/parser/test_ultra_light.rb              |    5 +-
 test/rexml/rexml_test_utils.rb                     |    6 +-
 test/rexml/test_attribute.rb                       |   14 +
 test/rexml/test_attributes.rb                      |  343 +--
 test/rexml/test_attributes_mixin.rb                |   49 +-
 test/rexml/test_changing_encoding.rb               |   68 +-
 test/rexml/test_comment.rb                         |    3 +-
 test/rexml/test_contrib.rb                         |  882 +++----
 test/rexml/test_core.rb                            | 2496 ++++++++++----------
 test/rexml/test_doctype.rb                         |  174 +-
 test/rexml/test_document.rb                        |  505 ++--
 test/rexml/test_element.rb                         |   18 +
 test/rexml/test_elements.rb                        |  197 +-
 test/rexml/test_encoding.rb                        |  162 +-
 test/rexml/test_encoding_2.rb                      |   59 -
 test/rexml/test_entity.rb                          |  337 +--
 test/rexml/test_functions.rb                       |  223 --
 test/rexml/test_functions_number.rb                |   32 -
 test/rexml/test_instruction.rb                     |   14 +
 test/rexml/test_jaxen.rb                           |  215 +-
 test/rexml/test_light.rb                           |  171 +-
 test/rexml/test_lightparser.rb                     |   18 +-
 test/rexml/test_listener.rb                        |  202 +-
 test/rexml/test_martin_fowler.rb                   |   41 +-
 test/rexml/test_namespace.rb                       |   55 +-
 test/rexml/test_order.rb                           |  175 +-
 test/rexml/test_preceding_sibling.rb               |   57 +-
 test/rexml/test_pullparser.rb                      |  161 +-
 test/rexml/test_rexml_issuezilla.rb                |   21 +-
 test/rexml/test_sax.rb                             |  484 ++--
 test/rexml/test_stream.rb                          |  195 +-
 test/rexml/test_text.rb                            |   84 +-
 test/rexml/test_ticket_80.rb                       |   47 +-
 test/rexml/test_validation_rng.rb                  |  617 ++---
 test/rexml/test_xml_declaration.rb                 |   57 +-
 test/rexml/test_xpath.rb                           | 1079 ---------
 test/rexml/test_xpath_attribute_query.rb           |   89 -
 test/rexml/test_xpath_msw.rb                       |   38 -
 test/rexml/test_xpath_pred.rb                      |   80 -
 test/rexml/test_xpathtext.rb                       |   72 -
 test/rexml/xpath/test_attribute.rb                 |   38 +
 test/rexml/xpath/test_axis_preceding_sibling.rb    |   40 +
 test/rexml/xpath/test_base.rb                      | 1125 +++++++++
 test/rexml/xpath/test_compare.rb                   |  256 ++
 test/rexml/xpath/test_node.rb                      |   43 +
 test/rexml/xpath/test_predicate.rb                 |   83 +
 test/rexml/xpath/test_text.rb                      |   77 +
 114 files changed, 7690 insertions(+), 6481 deletions(-)
 create mode 100644 lib/rexml/rexml.gemspec
 delete mode 100644 test/rexml/data/ticket_110_utf16.xml
 create mode 100644 test/rexml/data/utf16.xml
 create mode 100644 test/rexml/formatter/test_default.rb
 create mode 100644 test/rexml/functions/test_base.rb
 create mode 100644 test/rexml/functions/test_boolean.rb
 create mode 100644 test/rexml/functions/test_local_name.rb
 create mode 100644 test/rexml/functions/test_number.rb
 create mode 100644 test/rexml/parse/test_processing_instruction.rb
 create mode 100644 test/rexml/parser/test_stream.rb
 create mode 100644 test/rexml/test_attribute.rb
 create mode 100644 test/rexml/test_element.rb
 delete mode 100644 test/rexml/test_encoding_2.rb
 delete mode 100644 test/rexml/test_functions.rb
 delete mode 100644 test/rexml/test_functions_number.rb
 create mode 100644 test/rexml/test_instruction.rb
 delete mode 100644 test/rexml/test_xpath.rb
 delete mode 100644 test/rexml/test_xpath_attribute_query.rb
 delete mode 100644 test/rexml/test_xpath_msw.rb
 delete mode 100644 test/rexml/test_xpath_pred.rb
 delete mode 100644 test/rexml/test_xpathtext.rb
 create mode 100644 test/rexml/xpath/test_attribute.rb
 create mode 100644 test/rexml/xpath/test_axis_preceding_sibling.rb
 create mode 100644 test/rexml/xpath/test_base.rb
 create mode 100644 test/rexml/xpath/test_compare.rb
 create mode 100644 test/rexml/xpath/test_node.rb
 create mode 100644 test/rexml/xpath/test_predicate.rb
 create mode 100644 test/rexml/xpath/test_text.rb

diff --git a/lib/rexml/attlistdecl.rb b/lib/rexml/attlistdecl.rb
index ec4e6c3..44a91d6 100644
--- a/lib/rexml/attlistdecl.rb
+++ b/lib/rexml/attlistdecl.rb
@@ -1,6 +1,7 @@
+# frozen_string_literal: false
 #vim:ts=2 sw=2 noexpandtab:
-require 'rexml/child'
-require 'rexml/source'
+require_relative 'child'
+require_relative 'source'
 
 module REXML
   # This class needs:
@@ -23,7 +24,7 @@ module REXML
     # Create an AttlistDecl, pulling the information from a Source.  Notice
     # that this isn't very convenient; to create an AttlistDecl, you basically
     # have to format it yourself, and then have the initializer parse it.
-    # Sorry, but for the forseeable future, DTD support in REXML is pretty
+    # Sorry, but for the foreseeable future, DTD support in REXML is pretty
     # weak on convenience.  Have I mentioned how much I hate DTDs?
     def initialize(source)
       super()
diff --git a/lib/rexml/attribute.rb b/lib/rexml/attribute.rb
index 803d021..8933a01 100644
--- a/lib/rexml/attribute.rb
+++ b/lib/rexml/attribute.rb
@@ -1,5 +1,6 @@
-require "rexml/namespace"
-require 'rexml/text'
+# frozen_string_literal: false
+require_relative "namespace"
+require_relative 'text'
 
 module REXML
   # Defines an Element Attribute; IE, a attribute=value pair, as in:
@@ -66,15 +67,11 @@ module REXML
     #  e.add_attribute( "nsa:a", "aval" )
     #  e.add_attribute( "b", "bval" )
     #  e.attributes.get_attribute( "a" ).prefix   # -> "nsa"
-    #  e.attributes.get_attribute( "b" ).prefix   # -> "elns"
+    #  e.attributes.get_attribute( "b" ).prefix   # -> ""
     #  a = Attribute.new( "x", "y" )
     #  a.prefix                                   # -> ""
     def prefix
-      pf = super
-      if pf == ""
-        pf = @element.prefix if @element
-      end
-      pf
+      super
     end
 
     # Returns the namespace URL, if defined, or nil otherwise
@@ -85,9 +82,26 @@ module REXML
     #  e.add_attribute("nsx:a", "c")
     #  e.attribute("ns:a").namespace # => "http://url"
     #  e.attribute("nsx:a").namespace # => nil
+    #
+    # This method always returns "" for no namespace attribute. Because
+    # the default namespace doesn't apply to attribute names.
+    #
+    # From https://www.w3.org/TR/xml-names/#uniqAttrs
+    #
+    # > the default namespace does not apply to attribute names
+    #
+    #  e = REXML::Element.new("el")
+    #  e.add_namespace("", "http://example.com/")
+    #  e.namespace # => "http://example.com/"
+    #  e.add_attribute("a", "b")
+    #  e.attribute("a").namespace # => ""
     def namespace arg=nil
       arg = prefix if arg.nil?
-      @element.namespace arg
+      if arg == ""
+        ""
+      else
+        @element.namespace(arg)
+      end
     end
 
     # Returns true if other is an Attribute and has the same name and value,
@@ -109,7 +123,7 @@ module REXML
     #  b.to_string     # -> "ns:x='y'"
     def to_string
       if @element and @element.context and @element.context[:attribute_quote] == :quote
-        %Q^#@expanded_name="#{to_s().gsub(/"/, '&quote;')}"^
+        %Q^#@expanded_name="#{to_s().gsub(/"/, '&quot;')}"^
       else
         "#@expanded_name='#{to_s().gsub(/'/, '&apos;')}'"
       end
@@ -159,7 +173,7 @@ module REXML
       self
     end
 
-    # Removes this Attribute from the tree, and returns true if successfull
+    # Removes this Attribute from the tree, and returns true if successful
     #
     # This method is usually not called directly.
     def remove
diff --git a/lib/rexml/cdata.rb b/lib/rexml/cdata.rb
index 73358ed..997f5a0 100644
--- a/lib/rexml/cdata.rb
+++ b/lib/rexml/cdata.rb
@@ -1,4 +1,5 @@
-require "rexml/text"
+# frozen_string_literal: false
+require_relative "text"
 
 module REXML
   class CData < Text
@@ -57,7 +58,7 @@ module REXML
     #  c = CData.new( " Some text " )
     #  c.write( $stdout )     #->  <![CDATA[ Some text ]]>
     def write( output=$stdout, indent=-1, transitive=false, ie_hack=false )
-      Kernel.warn( "#{self.class.name}.write is deprecated" )
+      Kernel.warn( "#{self.class.name}.write is deprecated", uplevel: 1)
       indent( output, indent )
       output << START
       output << @string
diff --git a/lib/rexml/child.rb b/lib/rexml/child.rb
index bf97d5f..cc6e9a4 100644
--- a/lib/rexml/child.rb
+++ b/lib/rexml/child.rb
@@ -1,4 +1,5 @@
-require "rexml/node"
+# frozen_string_literal: false
+require_relative "node"
 
 module REXML
   ##
diff --git a/lib/rexml/comment.rb b/lib/rexml/comment.rb
index 42a040c..52c58b4 100644
--- a/lib/rexml/comment.rb
+++ b/lib/rexml/comment.rb
@@ -1,4 +1,5 @@
-require "rexml/child"
+# frozen_string_literal: false
+require_relative "child"
 
 module REXML
   ##
@@ -21,7 +22,6 @@ module REXML
     # should be nil, not supplied, or a Parent to be set as the parent
     # of this object
     def initialize( first, second = nil )
-      #puts "IN COMMENT CONSTRUCTOR; SECOND IS #{second.type}"
       super(second)
       if first.kind_of? String
         @string = first
@@ -48,7 +48,7 @@ module REXML
     # ie_hack::
     #    Needed for conformity to the child API, but not used by this class.
     def write( output, indent=-1, transitive=false, ie_hack=false )
-      Kernel.warn("Comment.write is deprecated.  See REXML::Formatters")
+      Kernel.warn("Comment.write is deprecated.  See REXML::Formatters", uplevel: 1)
       indent( output, indent )
       output << START
       output << @string
diff --git a/lib/rexml/doctype.rb b/lib/rexml/doctype.rb
index dbb7259..a4e9152 100644
--- a/lib/rexml/doctype.rb
+++ b/lib/rexml/doctype.rb
@@ -1,19 +1,25 @@
-require "rexml/parent"
-require "rexml/parseexception"
-require "rexml/namespace"
-require 'rexml/entity'
-require 'rexml/attlistdecl'
-require 'rexml/xmltokens'
+# frozen_string_literal: false
+require_relative "parent"
+require_relative "parseexception"
+require_relative "namespace"
+require_relative 'entity'
+require_relative 'attlistdecl'
+require_relative 'xmltokens'
 
 module REXML
   class ReferenceWriter
     def initialize(id_type,
                    public_id_literal,
-                   system_literal)
+                   system_literal,
+                   context=nil)
       @id_type = id_type
       @public_id_literal = public_id_literal
       @system_literal = system_literal
-      @default_quote = "\""
+      if context and context[:prologue_quote] == :apostrophe
+        @default_quote = "'"
+      else
+        @default_quote = "\""
+      end
     end
 
     def write(output)
@@ -149,7 +155,8 @@ module REXML
       if @external_id
         reference_writer = ReferenceWriter.new(@external_id,
                                                @long_name,
-                                               @uri)
+                                               @uri,
+                                               context)
         reference_writer.write(output)
       end
       unless @children.empty?
@@ -164,7 +171,11 @@ module REXML
     end
 
     def context
-      @parent.context
+      if @parent
+        @parent.context
+      else
+        nil
+      end
     end
 
     def entity( name )
@@ -286,8 +297,10 @@ module REXML
     end
 
     def to_s
+      context = nil
+      context = parent.context if parent
       notation = "<!NOTATION #{@name}"
-      reference_writer = ReferenceWriter.new(@middle, @public, @system)
+      reference_writer = ReferenceWriter.new(@middle, @public, @system, context)
       reference_writer.write(notation)
       notation << ">"
       notation
diff --git a/lib/rexml/document.rb b/lib/rexml/document.rb
index f92eb62..adec293 100644
--- a/lib/rexml/document.rb
+++ b/lib/rexml/document.rb
@@ -1,16 +1,17 @@
-require "rexml/security"
-require "rexml/element"
-require "rexml/xmldecl"
-require "rexml/source"
-require "rexml/comment"
-require "rexml/doctype"
-require "rexml/instruction"
-require "rexml/rexml"
-require "rexml/parseexception"
-require "rexml/output"
-require "rexml/parsers/baseparser"
-require "rexml/parsers/streamparser"
-require "rexml/parsers/treeparser"
+# frozen_string_literal: false
+require_relative "security"
+require_relative "element"
+require_relative "xmldecl"
+require_relative "source"
+require_relative "comment"
+require_relative "doctype"
+require_relative "instruction"
+require_relative "rexml"
+require_relative "parseexception"
+require_relative "output"
+require_relative "parsers/baseparser"
+require_relative "parsers/streamparser"
+require_relative "parsers/treeparser"
 
 module REXML
   # Represents a full XML document, including PIs, a doctype, etc.  A
@@ -123,7 +124,7 @@ module REXML
     def xml_decl
       rv = @children[0]
       return rv if rv.kind_of? XMLDecl
-      rv = @children.unshift(XMLDecl.default)[0]
+      @children.unshift(XMLDecl.default)[0]
     end
 
     # @return the XMLDecl version of this document as a String.
@@ -225,7 +226,7 @@ module REXML
       end
       formatter = if indent > -1
           if transitive
-            require "rexml/formatters/transitive"
+            require_relative "formatters/transitive"
             REXML::Formatters::Transitive.new( indent, ie_hack )
           else
             REXML::Formatters::Pretty.new( indent, ie_hack )
diff --git a/lib/rexml/dtd/attlistdecl.rb b/lib/rexml/dtd/attlistdecl.rb
index 25955ee..1326cb2 100644
--- a/lib/rexml/dtd/attlistdecl.rb
+++ b/lib/rexml/dtd/attlistdecl.rb
@@ -1,4 +1,5 @@
-require "rexml/child"
+# frozen_string_literal: false
+require_relative "../child"
 module REXML
   module DTD
     class AttlistDecl < Child
diff --git a/lib/rexml/dtd/dtd.rb b/lib/rexml/dtd/dtd.rb
index 966e39e..8b0f2d7 100644
--- a/lib/rexml/dtd/dtd.rb
+++ b/lib/rexml/dtd/dtd.rb
@@ -1,9 +1,10 @@
-require "rexml/dtd/elementdecl"
-require "rexml/dtd/entitydecl"
-require "rexml/comment"
-require "rexml/dtd/notationdecl"
-require "rexml/dtd/attlistdecl"
-require "rexml/parent"
+# frozen_string_literal: false
+require_relative "elementdecl"
+require_relative "entitydecl"
+require_relative "../comment"
+require_relative "notationdecl"
+require_relative "attlistdecl"
+require_relative "../parent"
 
 module REXML
   module DTD
@@ -24,23 +25,18 @@ module REXML
           case input
           when ElementDecl.PATTERN_RE
             match = $&
-            source = $'
             contents << ElementDecl.new( match )
           when AttlistDecl.PATTERN_RE
             matchdata = $~
-            source = $'
             contents << AttlistDecl.new( matchdata )
           when EntityDecl.PATTERN_RE
             matchdata = $~
-            source = $'
             contents << EntityDecl.new( matchdata )
           when Comment.PATTERN_RE
             matchdata = $~
-            source = $'
             contents << Comment.new( matchdata )
           when NotationDecl.PATTERN_RE
             matchdata = $~
-            source = $'
             contents << NotationDecl.new( matchdata )
           end
         end
diff --git a/lib/rexml/dtd/elementdecl.rb b/lib/rexml/dtd/elementdecl.rb
index a0bf641..20ed023 100644
--- a/lib/rexml/dtd/elementdecl.rb
+++ b/lib/rexml/dtd/elementdecl.rb
@@ -1,11 +1,12 @@
-require "rexml/child"
+# frozen_string_literal: false
+require_relative "../child"
 module REXML
   module DTD
     class ElementDecl < Child
       START = "<!ELEMENT"
       START_RE = /^\s*#{START}/um
-      PATTERN_RE = /^\s*(#{START}.*?)>/um
-      PATTERN_RE = /^\s*#{START}\s+((?:[:\w_][-\.\w_]*:)?[-!\*\.\w_]*)(.*?)>/
+      # PATTERN_RE = /^\s*(#{START}.*?)>/um
+      PATTERN_RE = /^\s*#{START}\s+((?:[:\w][-\.\w]*:)?[-!\*\.\w]*)(.*?)>/
       #\s*((((["']).*?\5)|[^\/'">]*)*?)(\/)?>/um, true)
 
       def initialize match
diff --git a/lib/rexml/dtd/entitydecl.rb b/lib/rexml/dtd/entitydecl.rb
index a9286b2..312df65 100644
--- a/lib/rexml/dtd/entitydecl.rb
+++ b/lib/rexml/dtd/entitydecl.rb
@@ -1,4 +1,5 @@
-require "rexml/child"
+# frozen_string_literal: false
+require_relative "../child"
 module REXML
   module DTD
     class EntityDecl < Child
diff --git a/lib/rexml/dtd/notationdecl.rb b/lib/rexml/dtd/notationdecl.rb
index 17d1b9e..04a9b08 100644
--- a/lib/rexml/dtd/notationdecl.rb
+++ b/lib/rexml/dtd/notationdecl.rb
@@ -1,4 +1,5 @@
-require "rexml/child"
+# frozen_string_literal: false
+require_relative "../child"
 module REXML
   module DTD
     class NotationDecl < Child
diff --git a/lib/rexml/element.rb b/lib/rexml/element.rb
index c30b150..c706a7c 100644
--- a/lib/rexml/element.rb
+++ b/lib/rexml/element.rb
@@ -1,9 +1,10 @@
-require "rexml/parent"
-require "rexml/namespace"
-require "rexml/attribute"
-require "rexml/cdata"
-require "rexml/xpath"
-require "rexml/parseexception"
+# frozen_string_literal: false
+require_relative "parent"
+require_relative "namespace"
+require_relative "attribute"
+require_relative "cdata"
+require_relative "xpath"
+require_relative "parseexception"
 
 module REXML
   # An implementation note about namespaces:
@@ -206,7 +207,7 @@ module REXML
       return namespaces
     end
 
-    # Evalutas to the URI for a prefix, or the empty string if no such
+    # Evaluates to the URI for a prefix, or the empty string if no such
     # namespace is declared for this element. Evaluates recursively for
     # ancestors.  Returns the default namespace, if there is one.
     # prefix::
@@ -550,6 +551,30 @@ module REXML
     # Attributes                                    #
     #################################################
 
+    # Fetches an attribute value or a child.
+    #
+    # If String or Symbol is specified, it's treated as attribute
+    # name. Attribute value as String or +nil+ is returned. This case
+    # is shortcut of +attributes[name]+.
+    #
+    # If Integer is specified, it's treated as the index of
+    # child. It returns Nth child.
+    #
+    #   doc = REXML::Document.new("<a attr='1'><b/><c/></a>")
+    #   doc.root["attr"]             # => "1"
+    #   doc.root.attributes["attr"]  # => "1"
+    #   doc.root[1]                  # => <c/>
+    def [](name_or_index)
+      case name_or_index
+      when String
+        attributes[name_or_index]
+      when Symbol
+        attributes[name_or_index.to_s]
+      else
+        super
+      end
+    end
+
     def attribute( name, namespace=nil )
       prefix = nil
       if namespaces.respond_to? :key
@@ -685,10 +710,10 @@ module REXML
     #  doc.write( out )     #-> doc is written to the string 'out'
     #  doc.write( $stdout ) #-> doc written to the console
     def write(output=$stdout, indent=-1, transitive=false, ie_hack=false)
-      Kernel.warn("#{self.class.name}.write is deprecated.  See REXML::Formatters")
+      Kernel.warn("#{self.class.name}.write is deprecated.  See REXML::Formatters", uplevel: 1)
       formatter = if indent > -1
           if transitive
-            require "rexml/formatters/transitive"
+            require_relative "formatters/transitive"
             REXML::Formatters::Transitive.new( indent, ie_hack )
           else
             REXML::Formatters::Pretty.new( indent, ie_hack )
@@ -1008,6 +1033,7 @@ module REXML
     #    p attr.expanded_name+" => "+attr.value
     #  }
     def each_attribute # :yields: attribute
+      return to_enum(__method__) unless block_given?
       each_value do |val|
         if val.kind_of? Attribute
           yield val
@@ -1023,6 +1049,7 @@ module REXML
     #  doc = Document.new '<a x="1" y="2"/>'
     #  doc.root.attributes.each {|name, value| p name+" => "+value }
     def each
+      return to_enum(__method__) unless block_given?
       each_attribute do |attr|
         yield [attr.expanded_name, attr.value]
       end
@@ -1105,16 +1132,18 @@ module REXML
         old_attr[value.prefix] = value
       elsif old_attr.prefix != value.prefix
         # Check for conflicting namespaces
-        raise ParseException.new(
-          "Namespace conflict in adding attribute \"#{value.name}\": "+
-          "Prefix \"#{old_attr.prefix}\" = "+
-          "\"#{@element.namespace(old_attr.prefix)}\" and prefix "+
-          "\"#{value.prefix}\" = \"#{@element.namespace(value.prefix)}\"") if
-          value.prefix != "xmlns" and old_attr.prefix != "xmlns" and
-          @element.namespace( old_attr.prefix ) ==
-            @element.namespace( value.prefix )
-          store value.name, { old_attr.prefix   => old_attr,
-            value.prefix                => value }
+        if value.prefix != "xmlns" and old_attr.prefix != "xmlns"
+          old_namespace = old_attr.namespace
+          new_namespace = value.namespace
+          if old_namespace == new_namespace
+            raise ParseException.new(
+                    "Namespace conflict in adding attribute \"#{value.name}\": "+
+                    "Prefix \"#{old_attr.prefix}\" = \"#{old_namespace}\" and "+
+                    "prefix \"#{value.prefix}\" = \"#{new_namespace}\"")
+          end
+        end
+        store value.name, {old_attr.prefix => old_attr,
+                           value.prefix    => value}
       else
         store value.name, value
       end
@@ -1181,9 +1210,8 @@ module REXML
         prefix = '' unless prefix
       end
       old = fetch(name, nil)
-      attr = nil
       if old.kind_of? Hash # the supplied attribute is one of many
-        attr = old.delete(prefix)
+        old.delete(prefix)
         if old.size == 1
           repl = nil
           old.each_value{|v| repl = v}
@@ -1192,7 +1220,6 @@ module REXML
       elsif old.nil?
         return @element
       else # the supplied attribute is a top-level one
-        attr = old
         super(name)
       end
       @element
diff --git a/lib/rexml/encoding.rb b/lib/rexml/encoding.rb
index 1c7e79a..da2d70d 100644
--- a/lib/rexml/encoding.rb
+++ b/lib/rexml/encoding.rb
@@ -1,4 +1,5 @@
 # coding: US-ASCII
+# frozen_string_literal: false
 module REXML
   module Encoding
     # ID ---> Encoding name
diff --git a/lib/rexml/entity.rb b/lib/rexml/entity.rb
index 3a35ec6..89a9e84 100644
--- a/lib/rexml/entity.rb
+++ b/lib/rexml/entity.rb
@@ -1,10 +1,9 @@
-require 'rexml/child'
-require 'rexml/source'
-require 'rexml/xmltokens'
+# frozen_string_literal: false
+require_relative 'child'
+require_relative 'source'
+require_relative 'xmltokens'
 
 module REXML
-  # God, I hate DTDs.  I really do.  Why this idiot standard still
-  # plagues us is beyond me.
   class Entity < Child
     include XMLTokens
     PUBIDCHAR = "\x20\x0D\x0Aa-zA-Z0-9\\-()+,./:=?;!*@$_%#"
@@ -28,8 +27,7 @@ module REXML
     # the constructor with the entity definition, or use the accessor methods.
     # +WARNING+: There is no validation of entity state except when the entity
     # is read from a stream.  If you start poking around with the accessors,
-    # you can easily create a non-conformant Entity.  The best thing to do is
-    # dump the stupid DTDs and use XMLSchema instead.
+    # you can easily create a non-conformant Entity.
     #
     #  e = Entity.new( 'amp', '&' )
     def initialize stream, value=nil, parent=nil, reference=false
@@ -92,7 +90,7 @@ module REXML
     # object itself is valid.)
     #
     # out::
-    #   An object implementing <TT>&lt;&lt;<TT> to which the entity will be
+    #   An object implementing <TT>&lt;&lt;</TT> to which the entity will be
     #   output
     # indent::
     #   *DEPRECATED* and ignored
diff --git a/lib/rexml/formatters/default.rb b/lib/rexml/formatters/default.rb
index 574c821..811b2ff 100644
--- a/lib/rexml/formatters/default.rb
+++ b/lib/rexml/formatters/default.rb
@@ -1,7 +1,9 @@
+# frozen_string_literal: false
+
 module REXML
   module Formatters
     class Default
-      # Prints out the XML document with no formatting -- except if id_hack is
+      # Prints out the XML document with no formatting -- except if ie_hack is
       # set.
       #
       # ie_hack::
@@ -100,11 +102,14 @@ module REXML
       end
 
       def write_instruction( node, output )
-        output << Instruction::START.sub(/\\/u, '')
+        output << Instruction::START
         output << node.target
-        output << ' '
-        output << node.content
-        output << Instruction::STOP.sub(/\\/u, '')
+        content = node.content
+        if content
+          output << ' '
+          output << content
+        end
+        output << Instruction::STOP
       end
     end
   end
diff --git a/lib/rexml/formatters/pretty.rb b/lib/rexml/formatters/pretty.rb
index e5ba561..562ef94 100644
--- a/lib/rexml/formatters/pretty.rb
+++ b/lib/rexml/formatters/pretty.rb
@@ -1,4 +1,5 @@
-require 'rexml/formatters/default'
+# frozen_string_literal: false
+require_relative 'default'
 
 module REXML
   module Formatters
diff --git a/lib/rexml/formatters/transitive.rb b/lib/rexml/formatters/transitive.rb
index 6cc690d..5ff51e1 100644
--- a/lib/rexml/formatters/transitive.rb
+++ b/lib/rexml/formatters/transitive.rb
@@ -1,4 +1,5 @@
-require 'rexml/formatters/pretty'
+# frozen_string_literal: false
+require_relative 'pretty'
 
 module REXML
   module Formatters
diff --git a/lib/rexml/functions.rb b/lib/rexml/functions.rb
index 20c8961..77926bf 100644
--- a/lib/rexml/functions.rb
+++ b/lib/rexml/functions.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 module REXML
   # If you add a method, keep in mind two things:
   # (1) the first argument will always be a list of nodes from which to
@@ -7,10 +8,28 @@ module REXML
   # Therefore, in XML, "local-name()" is identical (and actually becomes)
   # "local_name()"
   module Functions
+    @@available_functions = {}
     @@context = nil
     @@namespace_context = {}
     @@variables = {}
 
+    INTERNAL_METHODS = [
+      :namespace_context,
+      :namespace_context=,
+      :variables,
+      :variables=,
+      :context=,
+      :get_namespace,
+      :send,
+    ]
+    class << self
+      def singleton_method_added(name)
+        unless INTERNAL_METHODS.include?(name)
+          @@available_functions[name] = true
+        end
+      end
+    end
+
     def Functions::namespace_context=(x) ; @@namespace_context=x ; end
     def Functions::variables=(x) ; @@variables=x ; end
     def Functions::namespace_context ; @@namespace_context ; end
@@ -47,11 +66,11 @@ module REXML
     def Functions::id( object )
     end
 
-    # UNTESTED
-    def Functions::local_name( node_set=nil )
-      get_namespace( node_set ) do |node|
+    def Functions::local_name(node_set=nil)
+      get_namespace(node_set) do |node|
         return node.local_name
       end
+      ""
     end
 
     def Functions::namespace_uri( node_set=nil )
@@ -67,10 +86,14 @@ module REXML
     # Helper method.
     def Functions::get_namespace( node_set = nil )
       if node_set == nil
-        yield @@context[:node] if defined? @@context[:node].namespace
+        yield @@context[:node] if @@context[:node].respond_to?(:namespace)
       else
         if node_set.respond_to? :each
-          node_set.each { |node| yield node if defined? node.namespace }
+          result = []
+          node_set.each do |node|
+            result << yield(node) if node.respond_to?(:namespace)
+          end
+          result
         elsif node_set.respond_to? :namespace
           yield node_set
         end
@@ -112,22 +135,38 @@ module REXML
     #
     # An object of a type other than the four basic types is converted to a
     # string in a way that is dependent on that type.
-    def Functions::string( object=nil )
-      #object = @context unless object
-      if object.instance_of? Array
-        string( object[0] )
-      elsif defined? object.node_type
-        if object.node_type == :attribute
+    def Functions::string( object=@@context[:node] )
+      if object.respond_to?(:node_type)
+        case object.node_type
+        when :attribute
           object.value
-        elsif object.node_type == :element || object.node_type == :document
+        when :element
           string_value(object)
+        when :document
+          string_value(object.root)
+        when :processing_instruction
+          object.content
         else
           object.to_s
         end
-      elsif object.nil?
-        return ""
       else
-        object.to_s
+        case object
+        when Array
+          string(object[0])
+        when Float
+          if object.nan?
+            "NaN"
+          else
+            integer = object.to_i
+            if object == integer
+              "%d" % integer
+            else
+              object.to_s
+            end
+          end
+        else
+          object.to_s
+        end
       end
     end
 
@@ -148,9 +187,12 @@ module REXML
       rv
     end
 
-    # UNTESTED
     def Functions::concat( *objects )
-      objects.join
+      concatenated = ""
+      objects.each do |object|
+        concatenated << string(object)
+      end
+      concatenated
     end
 
     # Fixed by Mike Stok
@@ -204,8 +246,8 @@ module REXML
 
       # Now, get the bounds.  The XPath bounds are 1..length; the ruby bounds
       # are 0..length.  Therefore, we have to offset the bounds by one.
-      ruby_start = ruby_start.round - 1
-      ruby_length = ruby_length.round
+      ruby_start = round(ruby_start) - 1
+      ruby_length = round(ruby_length)
 
       if ruby_start < 0
        ruby_length += ruby_start unless infinite_length
@@ -273,18 +315,23 @@ module REXML
       end
     end
 
-    # UNTESTED
-    def Functions::boolean( object=nil )
-      if object.kind_of? String
-        if object =~ /\d+/u
-          return object.to_f != 0
-        else
-          return object.size > 0
-        end
-      elsif object.kind_of? Array
-        object = object.find{|x| x and true}
+    def Functions::boolean(object=@@context[:node])
+      case object
+      when true, false
+        object
+      when Float
+        return false if object.zero?
+        return false if object.nan?
+        true
+      when Numeric
+        not object.zero?
+      when String
+        not object.empty?
+      when Array
+        not object.empty?
+      else
+        object ? true : false
       end
-      return object ? true : false
     end
 
     # UNTESTED
@@ -338,32 +385,30 @@ module REXML
     #
     # an object of a type other than the four basic types is converted to a
     # number in a way that is dependent on that type
-    def Functions::number( object=nil )
-      object = @@context[:node] unless object
+    def Functions::number(object=@@context[:node])
       case object
       when true
         Float(1)
       when false
         Float(0)
       when Array
-        number(string( object ))
+        number(string(object))
       when Numeric
         object.to_f
       else
-        str = string( object )
-        # If XPath ever gets scientific notation...
-        #if str =~ /^\s*-?(\d*\.?\d+|\d+\.)([Ee]\d*)?\s*$/
-        if str =~ /^\s*-?(\d*\.?\d+|\d+\.)\s*$/
-          str.to_f
+        str = string(object)
+        case str.strip
+        when /\A\s*(-?(?:\d+(?:\.\d*)?|\.\d+))\s*\z/
+          $1.to_f
         else
-          (0.0 / 0.0)
+          Float::NAN
         end
       end
     end
 
     def Functions::sum( nodes )
       nodes = [nodes] unless nodes.kind_of? Array
-      nodes.inject(0) { |r,n| r += number(string(n)) }
+      nodes.inject(0) { |r,n| r + number(string(n)) }
     end
 
     def Functions::floor( number )
@@ -375,10 +420,13 @@ module REXML
     end
 
     def Functions::round( number )
+      number = number(number)
       begin
-        number(number).round
+        neg = number.negative?
+        number = number.abs.round
+        neg ? -number : number
       rescue FloatDomainError
-        number(number)
+        number
       end
     end
 
@@ -386,9 +434,14 @@ module REXML
       node.node_type == :processing_instruction
     end
 
-    def Functions::method_missing( id )
-      puts "METHOD MISSING #{id.id2name}"
-      XPath.match( @@context[:node], id.id2name )
+    def Functions::send(name, *args)
+      if @@available_functions[name.to_sym]
+        super
+      else
+        # TODO: Maybe, this is not XPath spec behavior.
+        # This behavior must be reconsidered.
+        XPath.match(@@context[:node], name.to_s)
+      end
     end
   end
 end
diff --git a/lib/rexml/instruction.rb b/lib/rexml/instruction.rb
index f8b734a..318741f 100644
--- a/lib/rexml/instruction.rb
+++ b/lib/rexml/instruction.rb
@@ -1,12 +1,14 @@
-require "rexml/child"
-require "rexml/source"
+# frozen_string_literal: false
+
+require_relative "child"
+require_relative "source"
 
 module REXML
   # Represents an XML Instruction; IE, <? ... ?>
   # TODO: Add parent arg (3rd arg) to constructor
   class Instruction < Child
-    START = '<\?'
-    STOP = '\?>'
+    START = "<?"
+    STOP = "?>"
 
     # target is the "name" of the Instruction; IE, the "tag" in <?tag ...?>
     # content is everything else.
@@ -16,20 +18,25 @@ module REXML
     # @param target can be one of a number of things.  If String, then
     # the target of this instruction is set to this.  If an Instruction,
     # then the Instruction is shallowly cloned (target and content are
-    # copied).  If a Source, then the source is scanned and parsed for
-    # an Instruction declaration.
+    # copied).
     # @param content Must be either a String, or a Parent.  Can only
     # be a Parent if the target argument is a Source.  Otherwise, this
     # String is set as the content of this instruction.
     def initialize(target, content=nil)
-      if target.kind_of? String
+      case target
+      when String
         super()
         @target = target
         @content = content
-      elsif target.kind_of? Instruction
+      when Instruction
         super(content)
         @target = target.target
         @content = target.content
+      else
+        message =
+          "processing instruction target must be String or REXML::Instruction: "
+        message << "<#{target.inspect}>"
+        raise ArgumentError, message
       end
       @content.strip! if @content
     end
@@ -42,13 +49,15 @@ module REXML
     # See the rexml/formatters package
     #
     def write writer, indent=-1, transitive=false, ie_hack=false
-      Kernel.warn( "#{self.class.name}.write is deprecated" )
+      Kernel.warn( "#{self.class.name}.write is deprecated", uplevel: 1)
       indent(writer, indent)
-      writer << START.sub(/\\/u, '')
+      writer << START
       writer << @target
-      writer << ' '
-      writer << @content
-      writer << STOP.sub(/\\/u, '')
+      if @content
+        writer << ' '
+        writer << @content
+      end
+      writer << STOP
     end
 
     # @return true if other is an Instruction, and the content and target
diff --git a/lib/rexml/light/node.rb b/lib/rexml/light/node.rb
index b33f78f..01177c6 100644
--- a/lib/rexml/light/node.rb
+++ b/lib/rexml/light/node.rb
@@ -1,4 +1,5 @@
-require 'rexml/xmltokens'
+# frozen_string_literal: false
+require_relative '../xmltokens'
 
 # [ :element, parent, name, attributes, children* ]
   # a = Node.new
diff --git a/lib/rexml/namespace.rb b/lib/rexml/namespace.rb
index aeb339e..924edf9 100644
--- a/lib/rexml/namespace.rb
+++ b/lib/rexml/namespace.rb
@@ -1,4 +1,6 @@
-require 'rexml/xmltokens'
+# frozen_string_literal: false
+
+require_relative 'xmltokens'
 
 module REXML
   # Adds named attributes to an object.
@@ -13,14 +15,24 @@ module REXML
     # Sets the name and the expanded name
     def name=( name )
       @expanded_name = name
-      name =~ NAMESPLIT
-      if $1
-        @prefix = $1
+      case name
+      when NAMESPLIT
+        if $1
+          @prefix = $1
+        else
+          @prefix = ""
+          @namespace = ""
+        end
+        @name = $2
+      when ""
+        @prefix = nil
+        @namespace = nil
+        @name = nil
       else
-        @prefix = ""
-        @namespace = ""
+        message = "name must be \#{PREFIX}:\#{LOCAL_NAME} or \#{LOCAL_NAME}: "
+        message += "<#{name.inspect}>"
+        raise ArgumentError, message
       end
-      @name = $2
     end
 
     # Compares names optionally WITH namespaces
diff --git a/lib/rexml/node.rb b/lib/rexml/node.rb
index cab6e9f..081caba 100644
--- a/lib/rexml/node.rb
+++ b/lib/rexml/node.rb
@@ -1,6 +1,7 @@
-require "rexml/parseexception"
-require "rexml/formatters/pretty"
-require "rexml/formatters/default"
+# frozen_string_literal: false
+require_relative "parseexception"
+require_relative "formatters/pretty"
+require_relative "formatters/default"
 
 module REXML
   # Represents a node in the tree.  Nodes are never encountered except as
@@ -25,7 +26,7 @@ module REXML
     #   REXML::Formatters package for changing the output style.
     def to_s indent=nil
       unless indent.nil?
-        Kernel.warn( "#{self.class.name}.to_s(indent) parameter is deprecated" )
+        Kernel.warn( "#{self.class.name}.to_s(indent) parameter is deprecated", uplevel: 1)
         f = REXML::Formatters::Pretty.new( indent )
         f.write( self, rv = "" )
       else
diff --git a/lib/rexml/output.rb b/lib/rexml/output.rb
index 0c6cc7a..88a5fb3 100644
--- a/lib/rexml/output.rb
+++ b/lib/rexml/output.rb
@@ -1,4 +1,5 @@
-require 'rexml/encoding'
+# frozen_string_literal: false
+require_relative 'encoding'
 
 module REXML
   class Output
diff --git a/lib/rexml/parent.rb b/lib/rexml/parent.rb
index 0a9f805..6a53b37 100644
--- a/lib/rexml/parent.rb
+++ b/lib/rexml/parent.rb
@@ -1,4 +1,5 @@
-require "rexml/child"
+# frozen_string_literal: false
+require_relative "child"
 
 module REXML
   # A parent has children, and has methods for accessing them.  The Parent
@@ -15,10 +16,8 @@ module REXML
     end
 
     def add( object )
-      #puts "PARENT GOTS #{size} CHILDREN"
       object.parent = self
       @children << object
-      #puts "PARENT NOW GOTS #{size} CHILDREN"
       object
     end
 
diff --git a/lib/rexml/parseexception.rb b/lib/rexml/parseexception.rb
index 0c4d55a..7b16cd1 100644
--- a/lib/rexml/parseexception.rb
+++ b/lib/rexml/parseexception.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 module REXML
   class ParseException < RuntimeError
     attr_accessor :source, :parser, :continued_exception
diff --git a/lib/rexml/parsers/baseparser.rb b/lib/rexml/parsers/baseparser.rb
index 69b4a40..305b120 100644
--- a/lib/rexml/parsers/baseparser.rb
+++ b/lib/rexml/parsers/baseparser.rb
@@ -1,9 +1,9 @@
-require "strscan"
-
-require 'rexml/parseexception'
-require 'rexml/undefinednamespaceexception'
-require 'rexml/source'
+# frozen_string_literal: false
+require_relative '../parseexception'
+require_relative '../undefinednamespaceexception'
+require_relative '../source'
 require 'set'
+require "strscan"
 
 module REXML
   module Parsers
@@ -59,7 +59,7 @@ module REXML
       XMLDECL_START = /\A<\?xml\s/u;
       XMLDECL_PATTERN = /<\?xml\s+(.*?)\?>/um
       INSTRUCTION_START = /\A<\?/u
-      INSTRUCTION_PATTERN = /<\?(.*?)(\s+.*?)?\?>/um
+      INSTRUCTION_PATTERN = /<\?#{NAME}(\s+.*?)?\?>/um
       TAG_MATCH = /\A<((?>#{QNAME_STR}))/um
       CLOSE_MATCH = /\A\s*<\/(#{QNAME_STR})\s*>/um
 
@@ -112,13 +112,6 @@ module REXML
         "apos" => [/&apos;/, "&apos;", "'", /'/]
       }
 
-
-      ######################################################################
-      # These are patterns to identify common markup errors, to make the
-      # error messages more informative.
-      ######################################################################
-      MISSING_ATTRIBUTE_QUOTES = /^<#{QNAME_STR}\s+#{QNAME_STR}\s*=\s*[^"']/um
-
       def initialize( source )
         self.stream = source
         @listeners = []
@@ -227,7 +220,7 @@ module REXML
             standalone = standalone[1] unless standalone.nil?
             return [ :xmldecl, version, encoding, standalone ]
           when INSTRUCTION_START
-            return [ :processing_instruction, *@source.match(INSTRUCTION_PATTERN, true)[1,2] ]
+            return process_instruction
           when DOCTYPE_START
             base_error_message = "Malformed DOCTYPE"
             @source.match(DOCTYPE_START, true)
@@ -248,7 +241,7 @@ module REXML
                 id[1], id[2] = id[2], nil
               end
               if @source.match(/\A\s*\[/um, true)
-               @document_status = :in_doctype
+                @document_status = :in_doctype
               elsif @source.match(/\A\s*>/um, true)
                 @document_status = :after_doctype
               else
@@ -361,7 +354,6 @@ module REXML
             if @source.buffer[1] == ?/
               @nsstack.shift
               last_tag = @tags.pop
-              #md = @source.match_to_consume( '>', CLOSE_MATCH)
               md = @source.match( CLOSE_MATCH, true )
               if md and !last_tag
                 message = "Unexpected top-level end tag (got '#{md[1]}')"
@@ -393,16 +385,11 @@ module REXML
               raise REXML::ParseException.new( "Declarations can only occur "+
                 "in the doctype declaration.", @source)
             elsif @source.buffer[1] == ??
-              md = @source.match( INSTRUCTION_PATTERN, true )
-              return [ :processing_instruction, md[1], md[2] ] if md
-              raise REXML::ParseException.new( "Bad instruction declaration",
-                @source)
+              return process_instruction
             else
               # Get the next tag
               md = @source.match(TAG_MATCH, true)
               unless md
-                # Check for missing attribute quotes
-                raise REXML::ParseException.new("missing attribute quote", @source) if @source.match(MISSING_ATTRIBUTE_QUOTES )
                 raise REXML::ParseException.new("malformed XML: missing tag start", @source)
               end
               @document_status = :in_element
@@ -440,7 +427,7 @@ module REXML
           raise
         rescue REXML::ParseException
           raise
-        rescue Exception, NameError => error
+        rescue => error
           raise REXML::ParseException.new( "Exception parsing",
             @source, self, (error ? error : $!) )
         end
@@ -590,6 +577,15 @@ module REXML
         end
       end
 
+      def process_instruction
+        match_data = @source.match(INSTRUCTION_PATTERN, true)
+        unless match_data
+          message = "Invalid processing instruction node"
+          raise REXML::ParseException.new(message, @source)
+        end
+        [:processing_instruction, match_data[1], match_data[2]]
+      end
+
       def parse_attributes(prefixes, curr_ns)
         attributes = {}
         closed = false
diff --git a/lib/rexml/parsers/lightparser.rb b/lib/rexml/parsers/lightparser.rb
index 8104168..bdc0827 100644
--- a/lib/rexml/parsers/lightparser.rb
+++ b/lib/rexml/parsers/lightparser.rb
@@ -1,6 +1,7 @@
-require 'rexml/parsers/streamparser'
-require 'rexml/parsers/baseparser'
-require 'rexml/light/node'
+# frozen_string_literal: false
+require_relative 'streamparser'
+require_relative 'baseparser'
+require_relative '../light/node'
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/pullparser.rb b/lib/rexml/parsers/pullparser.rb
index 68a4ff7..f8b232a 100644
--- a/lib/rexml/parsers/pullparser.rb
+++ b/lib/rexml/parsers/pullparser.rb
@@ -1,8 +1,9 @@
+# frozen_string_literal: false
 require 'forwardable'
 
-require 'rexml/parseexception'
-require 'rexml/parsers/baseparser'
-require 'rexml/xmltokens'
+require_relative '../parseexception'
+require_relative 'baseparser'
+require_relative '../xmltokens'
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/sax2parser.rb b/lib/rexml/parsers/sax2parser.rb
index 46ea8fa..6a24ce2 100644
--- a/lib/rexml/parsers/sax2parser.rb
+++ b/lib/rexml/parsers/sax2parser.rb
@@ -1,7 +1,8 @@
-require 'rexml/parsers/baseparser'
-require 'rexml/parseexception'
-require 'rexml/namespace'
-require 'rexml/text'
+# frozen_string_literal: false
+require_relative 'baseparser'
+require_relative '../parseexception'
+require_relative '../namespace'
+require_relative '../text'
 
 module REXML
   module Parsers
@@ -229,7 +230,6 @@ module REXML
       def get_procs( symbol, name )
         return nil if @procs.size == 0
         @procs.find_all do |sym, match, block|
-          #puts sym.inspect+"=="+symbol.inspect+ "\t"+match.inspect+"=="+name.inspect+ "\t"+( (sym.nil? or symbol == sym) and ((name.nil? and match.nil?) or match.nil? or ( (name == match) or (match.kind_of? Regexp and name =~ match)))).to_s
           (
             (sym.nil? or symbol == sym) and
             ((name.nil? and match.nil?) or match.nil? or (
diff --git a/lib/rexml/parsers/streamparser.rb b/lib/rexml/parsers/streamparser.rb
index 9ea65ed..9e0eb0b 100644
--- a/lib/rexml/parsers/streamparser.rb
+++ b/lib/rexml/parsers/streamparser.rb
@@ -1,4 +1,5 @@
-require "rexml/parsers/baseparser"
+# frozen_string_literal: false
+require_relative "baseparser"
 
 module REXML
   module Parsers
@@ -6,6 +7,7 @@ module REXML
       def initialize source, listener
         @listener = listener
         @parser = BaseParser.new( source )
+        @tag_stack = []
       end
 
       def add_listener( listener )
@@ -18,14 +20,21 @@ module REXML
           event = @parser.pull
           case event[0]
           when :end_document
+            unless @tag_stack.empty?
+              tag_path = "/" + @tag_stack.join("/")
+              raise ParseException.new("Missing end tag for '#{tag_path}'",
+                                       @parser.source)
+            end
             return
           when :start_element
+            @tag_stack << event[1]
             attrs = event[2].each do |n, v|
               event[2][n] = @parser.unnormalize( v )
             end
             @listener.tag_start( event[1], attrs )
           when :end_element
             @listener.tag_end( event[1] )
+            @tag_stack.pop
           when :text
             normalized = @parser.unnormalize( event[1] )
             @listener.text( normalized )
diff --git a/lib/rexml/parsers/treeparser.rb b/lib/rexml/parsers/treeparser.rb
index 68edb77..bf9a425 100644
--- a/lib/rexml/parsers/treeparser.rb
+++ b/lib/rexml/parsers/treeparser.rb
@@ -1,5 +1,6 @@
-require 'rexml/validation/validationexception'
-require 'rexml/undefinednamespaceexception'
+# frozen_string_literal: false
+require_relative '../validation/validationexception'
+require_relative '../undefinednamespaceexception'
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/ultralightparser.rb b/lib/rexml/parsers/ultralightparser.rb
index 4e2d7a8..e0029f4 100644
--- a/lib/rexml/parsers/ultralightparser.rb
+++ b/lib/rexml/parsers/ultralightparser.rb
@@ -1,5 +1,6 @@
-require 'rexml/parsers/streamparser'
-require 'rexml/parsers/baseparser'
+# frozen_string_literal: false
+require_relative 'streamparser'
+require_relative 'baseparser'
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/xpathparser.rb b/lib/rexml/parsers/xpathparser.rb
index e643d11..d01d325 100644
--- a/lib/rexml/parsers/xpathparser.rb
+++ b/lib/rexml/parsers/xpathparser.rb
@@ -1,5 +1,6 @@
-require 'rexml/namespace'
-require 'rexml/xmltokens'
+# frozen_string_literal: false
+require_relative '../namespace'
+require_relative '../xmltokens'
 
 module REXML
   module Parsers
@@ -21,7 +22,7 @@ module REXML
         path.gsub!(/([\(\[])\s+/, '\1') # Strip ignorable spaces
         path.gsub!( /\s+([\]\)])/, '\1')
         parsed = []
-        path = OrExpr(path, parsed)
+        OrExpr(path, parsed)
         parsed
       end
 
@@ -184,8 +185,7 @@ module REXML
       #  | '/' RelativeLocationPath?
       #  | '//' RelativeLocationPath
       def LocationPath path, parsed
-        #puts "LocationPath '#{path}'"
-        path = path.strip
+        path = path.lstrip
         if path[0] == ?/
           parsed << :document
           if path[1] == ?/
@@ -196,7 +196,6 @@ module REXML
             path = path[1..-1]
           end
         end
-        #puts parsed.inspect
         return RelativeLocationPath( path, parsed ) if path.size > 0
       end
 
@@ -210,8 +209,12 @@ module REXML
       #  | RelativeLocationPath '//' Step
       AXIS = /^(ancestor|ancestor-or-self|attribute|child|descendant|descendant-or-self|following|following-sibling|namespace|parent|preceding|preceding-sibling|self)::/
       def RelativeLocationPath path, parsed
-        #puts "RelativeLocationPath #{path}"
-        while path.size > 0
+        loop do
+          original_path = path
+          path = path.lstrip
+
+          return original_path if path.empty?
+
           # (axis or @ or <child::>) nodetest predicate  >
           # OR                                          >  / Step
           # (. or ..)                                    >
@@ -227,7 +230,6 @@ module REXML
             end
           else
             if path[0] == ?@
-              #puts "ATTRIBUTE"
               parsed << :attribute
               path = path[1..-1]
               # Goto Nodetest
@@ -239,33 +241,28 @@ module REXML
               parsed << :child
             end
 
-            #puts "NODETESTING '#{path}'"
             n = []
             path = NodeTest( path, n)
-            #puts "NODETEST RETURNED '#{path}'"
 
-            if path[0] == ?[
-              path = Predicate( path, n )
-            end
+            path = Predicate( path, n )
 
             parsed.concat(n)
           end
 
-          if path.size > 0
-            if path[0] == ?/
-              if path[1] == ?/
-                parsed << :descendant_or_self
-                parsed << :node
-                path = path[2..-1]
-              else
-                path = path[1..-1]
-              end
-            else
-              return path
-            end
+          original_path = path
+          path = path.lstrip
+          return original_path if path.empty?
+
+          return original_path if path[0] != ?/
+
+          if path[1] == ?/
+            parsed << :descendant_or_self
+            parsed << :node
+            path = path[2..-1]
+          else
+            path = path[1..-1]
           end
         end
-        return path
       end
 
       # Returns a 1-1 map of the nodeset
@@ -274,16 +271,26 @@ module REXML
       #   String, if a name match
       #NodeTest
       #  | ('*' | NCNAME ':' '*' | QNAME)                NameTest
-      #  | NODE_TYPE '(' ')'                              NodeType
+      #  | '*' ':' NCNAME                                NameTest since XPath 2.0
+      #  | NODE_TYPE '(' ')'                             NodeType
       #  | PI '(' LITERAL ')'                            PI
       #    | '[' expr ']'                                Predicate
-      NCNAMETEST= /^(#{NCNAME_STR}):\*/u
+      PREFIX_WILDCARD = /^\*:(#{NCNAME_STR})/u
+      LOCAL_NAME_WILDCARD = /^(#{NCNAME_STR}):\*/u
       QNAME     = Namespace::NAMESPLIT
       NODE_TYPE  = /^(comment|text|node)\(\s*\)/m
       PI        = /^processing-instruction\(/
       def NodeTest path, parsed
-        #puts "NodeTest with #{path}"
+        original_path = path
+        path = path.lstrip
         case path
+        when PREFIX_WILDCARD
+          prefix = nil
+          name = $1
+          path = $'
+          parsed << :qname
+          parsed << prefix
+          parsed << name
         when /^\*/
           path = $'
           parsed << :any
@@ -303,14 +310,12 @@ module REXML
           end
           parsed << :processing_instruction
           parsed << (literal || '')
-        when NCNAMETEST
-          #puts "NCNAMETEST"
+        when LOCAL_NAME_WILDCARD
           prefix = $1
           path = $'
           parsed << :namespace
           parsed << prefix
         when QNAME
-          #puts "QNAME"
           prefix = $1
           name = $2
           path = $'
@@ -318,28 +323,28 @@ module REXML
           parsed << :qname
           parsed << prefix
           parsed << name
+        else
+          path = original_path
         end
         return path
       end
 
       # Filters the supplied nodeset on the predicate(s)
       def Predicate path, parsed
-        #puts "PREDICATE with #{path}"
-        return nil unless path[0] == ?[
+        original_path = path
+        path = path.lstrip
+        return original_path unless path[0] == ?[
         predicates = []
         while path[0] == ?[
           path, expr = get_group(path)
           predicates << expr[1..-2] if expr
         end
-        #puts "PREDICATES = #{predicates.inspect}"
         predicates.each{ |pred|
-          #puts "ORING #{pred}"
           preds = []
           parsed << :predicate
           parsed << preds
           OrExpr(pred, preds)
         }
-        #puts "PREDICATES = #{predicates.inspect}"
         path
       end
 
@@ -350,10 +355,8 @@ module REXML
       #| OrExpr S 'or' S AndExpr
       #| AndExpr
       def OrExpr path, parsed
-        #puts "OR >>> #{path}"
         n = []
         rest = AndExpr( path, n )
-        #puts "OR <<< #{rest}"
         if rest != path
           while rest =~ /^\s*( or )/
             n = [ :or, n, [] ]
@@ -371,16 +374,12 @@ module REXML
       #| AndExpr S 'and' S EqualityExpr
       #| EqualityExpr
       def AndExpr path, parsed
-        #puts "AND >>> #{path}"
         n = []
         rest = EqualityExpr( path, n )
-        #puts "AND <<< #{rest}"
         if rest != path
           while rest =~ /^\s*( and )/
             n = [ :and, n, [] ]
-            #puts "AND >>> #{rest}"
             rest = EqualityExpr( $', n[-1] )
-            #puts "AND <<< #{rest}"
           end
         end
         if parsed.size == 0 and n.size != 0
@@ -394,10 +393,8 @@ module REXML
       #| EqualityExpr ('=' | '!=')  RelationalExpr
       #| RelationalExpr
       def EqualityExpr path, parsed
-        #puts "EQUALITY >>> #{path}"
         n = []
         rest = RelationalExpr( path, n )
-        #puts "EQUALITY <<< #{rest}"
         if rest != path
           while rest =~ /^\s*(!?=)\s*/
             if $1[0] == ?!
@@ -419,10 +416,8 @@ module REXML
       #| RelationalExpr ('<' | '>' | '<=' | '>=') AdditiveExpr
       #| AdditiveExpr
       def RelationalExpr path, parsed
-        #puts "RELATION >>> #{path}"
         n = []
         rest = AdditiveExpr( path, n )
-        #puts "RELATION <<< #{rest}"
         if rest != path
           while rest =~ /^\s*([<>]=?)\s*/
             if $1[0] == ?<
@@ -443,15 +438,13 @@ module REXML
         rest
       end
 
-      #| AdditiveExpr ('+' | S '-') MultiplicativeExpr
+      #| AdditiveExpr ('+' | '-') MultiplicativeExpr
       #| MultiplicativeExpr
       def AdditiveExpr path, parsed
-        #puts "ADDITIVE >>> #{path}"
         n = []
         rest = MultiplicativeExpr( path, n )
-        #puts "ADDITIVE <<< #{rest}"
         if rest != path
-          while rest =~ /^\s*(\+| -)\s*/
+          while rest =~ /^\s*(\+|-)\s*/
             if $1[0] == ?+
               n = [ :plus, n, [] ]
             else
@@ -471,10 +464,8 @@ module REXML
       #| MultiplicativeExpr ('*' | S ('div' | 'mod') S) UnaryExpr
       #| UnaryExpr
       def MultiplicativeExpr path, parsed
-        #puts "MULT >>> #{path}"
         n = []
         rest = UnaryExpr( path, n )
-        #puts "MULT <<< #{rest}"
         if rest != path
           while rest =~ /^\s*(\*| div | mod )\s*/
             if $1[0] == ?*
@@ -507,10 +498,8 @@ module REXML
         end
         parsed << :neg if mult < 0
 
-        #puts "UNARY >>> #{path}"
         n = []
         path = UnionExpr( path, n )
-        #puts "UNARY <<< #{path}"
         parsed.concat( n )
         path
       end
@@ -518,10 +507,8 @@ module REXML
       #| UnionExpr '|' PathExpr
       #| PathExpr
       def UnionExpr path, parsed
-        #puts "UNION >>> #{path}"
         n = []
         rest = PathExpr( path, n )
-        #puts "UNION <<< #{rest}"
         if rest != path
           while rest =~ /^\s*(\|)\s*/
             n = [ :union, n, [] ]
@@ -539,18 +526,16 @@ module REXML
       #| LocationPath
       #| FilterExpr ('/' | '//') RelativeLocationPath
       def PathExpr path, parsed
-        path =~ /^\s*/
-        path = $'
-        #puts "PATH >>> #{path}"
+        path = path.lstrip
         n = []
         rest = FilterExpr( path, n )
-        #puts "PATH <<< '#{rest}'"
         if rest != path
           if rest and rest[0] == ?/
-            return RelativeLocationPath(rest, n)
+            rest = RelativeLocationPath(rest, n)
+            parsed.concat(n)
+            return rest
           end
         end
-        #puts "BEFORE WITH '#{rest}'"
         rest = LocationPath(rest, n) if rest =~ /\A[\/\.\@\[\w*]/
         parsed.concat(n)
         return rest
@@ -559,12 +544,9 @@ module REXML
       #| FilterExpr Predicate
       #| PrimaryExpr
       def FilterExpr path, parsed
-        #puts "FILTER >>> #{path}"
         n = []
         path = PrimaryExpr( path, n )
-        #puts "FILTER <<< #{path}"
-        path = Predicate(path, n) if path and path[0] == ?[
-        #puts "FILTER <<< #{path}"
+        path = Predicate(path, n)
         parsed.concat(n)
         path
       end
@@ -586,23 +568,19 @@ module REXML
           parsed << varname
           #arry << @variables[ varname ]
         when /^(\w[-\w]*)(?:\()/
-          #puts "PrimaryExpr :: Function >>> #$1 -- '#$''"
           fname = $1
           tmp = $'
-          #puts "#{fname} =~ #{NT.inspect}"
           return path if fname =~ NT
           path = tmp
           parsed << :function
           parsed << fname
           path = FunctionCall(path, parsed)
         when NUMBER
-          #puts "LITERAL or NUMBER: #$1"
           varname = $1.nil? ? $2 : $1
           path = $'
           parsed << :literal
           parsed << (varname.include?('.') ? varname.to_f : varname.to_i)
         when LITERAL
-          #puts "LITERAL or NUMBER: #$1"
           varname = $1.nil? ? $2 : $1
           path = $'
           parsed << :literal
diff --git a/lib/rexml/quickpath.rb b/lib/rexml/quickpath.rb
index 9bec215..a0466b2 100644
--- a/lib/rexml/quickpath.rb
+++ b/lib/rexml/quickpath.rb
@@ -1,5 +1,6 @@
-require 'rexml/functions'
-require 'rexml/xmltokens'
+# frozen_string_literal: false
+require_relative 'functions'
+require_relative 'xmltokens'
 
 module REXML
   class QuickPath
@@ -193,7 +194,7 @@ module REXML
         case res
         when true
           results << element
-        when Fixnum
+        when Integer
           results << element if Functions.pair[0] == res
         when String
           results << element
@@ -229,7 +230,7 @@ module REXML
         case res
         when true
           results << element
-        when Fixnum
+        when Integer
           results << element if Functions.pair[0] == res
         end
       end
diff --git a/lib/rexml/rexml.gemspec b/lib/rexml/rexml.gemspec
new file mode 100644
index 0000000..263f013
--- /dev/null
+++ b/lib/rexml/rexml.gemspec
@@ -0,0 +1,84 @@
+begin
+  require_relative "lib/rexml/rexml"
+rescue LoadError
+  # for Ruby core repository
+  require_relative "rexml"
+end
+
+Gem::Specification.new do |spec|
+  spec.name          = "rexml"
+  spec.version       = REXML::VERSION
+  spec.authors       = ["Kouhei Sutou"]
+  spec.email         = ["kou@cozmixng.org"]
+
+  spec.summary       = %q{An XML toolkit for Ruby}
+  spec.description   = %q{An XML toolkit for Ruby}
+  spec.homepage      = "https://github.com/ruby/rexml"
+  spec.license       = "BSD-2-Clause"
+
+  spec.files         = [
+    ".gitignore",
+    ".travis.yml",
+    "Gemfile",
+    "LICENSE.txt",
+    "NEWS.md",
+    "README.md",
+    "Rakefile",
+    "lib/rexml/attlistdecl.rb",
+    "lib/rexml/attribute.rb",
+    "lib/rexml/cdata.rb",
+    "lib/rexml/child.rb",
+    "lib/rexml/comment.rb",
+    "lib/rexml/doctype.rb",
+    "lib/rexml/document.rb",
+    "lib/rexml/dtd/attlistdecl.rb",
+    "lib/rexml/dtd/dtd.rb",
+    "lib/rexml/dtd/elementdecl.rb",
+    "lib/rexml/dtd/entitydecl.rb",
+    "lib/rexml/dtd/notationdecl.rb",
+    "lib/rexml/element.rb",
+    "lib/rexml/encoding.rb",
+    "lib/rexml/entity.rb",
+    "lib/rexml/formatters/default.rb",
+    "lib/rexml/formatters/pretty.rb",
+    "lib/rexml/formatters/transitive.rb",
+    "lib/rexml/functions.rb",
+    "lib/rexml/instruction.rb",
+    "lib/rexml/light/node.rb",
+    "lib/rexml/namespace.rb",
+    "lib/rexml/node.rb",
+    "lib/rexml/output.rb",
+    "lib/rexml/parent.rb",
+    "lib/rexml/parseexception.rb",
+    "lib/rexml/parsers/baseparser.rb",
+    "lib/rexml/parsers/lightparser.rb",
+    "lib/rexml/parsers/pullparser.rb",
+    "lib/rexml/parsers/sax2parser.rb",
+    "lib/rexml/parsers/streamparser.rb",
+    "lib/rexml/parsers/treeparser.rb",
+    "lib/rexml/parsers/ultralightparser.rb",
+    "lib/rexml/parsers/xpathparser.rb",
+    "lib/rexml/quickpath.rb",
+    "lib/rexml/rexml.rb",
+    "lib/rexml/sax2listener.rb",
+    "lib/rexml/security.rb",
+    "lib/rexml/source.rb",
+    "lib/rexml/streamlistener.rb",
+    "lib/rexml/text.rb",
+    "lib/rexml/undefinednamespaceexception.rb",
+    "lib/rexml/validation/relaxng.rb",
+    "lib/rexml/validation/validation.rb",
+    "lib/rexml/validation/validationexception.rb",
+    "lib/rexml/xmldecl.rb",
+    "lib/rexml/xmltokens.rb",
+    "lib/rexml/xpath.rb",
+    "lib/rexml/xpath_parser.rb",
+    "rexml.gemspec",
+  ]
+  spec.bindir        = "exe"
+  spec.executables   = spec.files.grep(%r{^exe/}) { |f| File.basename(f) }
+  spec.require_paths = ["lib"]
+
+  spec.add_development_dependency "bundler"
+  spec.add_development_dependency "rake"
+end
diff --git a/lib/rexml/rexml.rb b/lib/rexml/rexml.rb
index 8a1d5e5..3c991a1 100644
--- a/lib/rexml/rexml.rb
+++ b/lib/rexml/rexml.rb
@@ -1,4 +1,5 @@
-# -*- encoding: utf-8 -*-
+# -*- coding: utf-8 -*-
+# frozen_string_literal: false
 # REXML is an XML toolkit for Ruby[http://www.ruby-lang.org], in Ruby.
 #
 # REXML is a _pure_ Ruby, XML 1.0 conforming,
@@ -23,8 +24,8 @@
 module REXML
   COPYRIGHT = "Copyright  2001-2008 Sean Russell <ser@germane-software.com>"
   DATE = "2008/019"
-  VERSION = "3.1.7.4"
-  REVISION = %w$Revision$[1] || ''
+  VERSION = "3.2.3.1"
+  REVISION = ""
 
   Copyright = COPYRIGHT
   Version = VERSION
diff --git a/lib/rexml/sax2listener.rb b/lib/rexml/sax2listener.rb
index 9f276eb..5afdc80 100644
--- a/lib/rexml/sax2listener.rb
+++ b/lib/rexml/sax2listener.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 module REXML
   # A template for stream parser listeners.
   # Note that the declarations (attlistdecl, elementdecl, etc) are trivially
diff --git a/lib/rexml/security.rb b/lib/rexml/security.rb
index 593b652..99b7460 100644
--- a/lib/rexml/security.rb
+++ b/lib/rexml/security.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 module REXML
   module Security
     @@entity_expansion_limit = 10_000
diff --git a/lib/rexml/source.rb b/lib/rexml/source.rb
index b653714..90b370b 100644
--- a/lib/rexml/source.rb
+++ b/lib/rexml/source.rb
@@ -1,5 +1,6 @@
 # coding: US-ASCII
-require 'rexml/encoding'
+# frozen_string_literal: false
+require_relative 'encoding'
 
 module REXML
   # Generates Source-s.  USE THIS CLASS.
@@ -62,7 +63,7 @@ module REXML
     # requirements; for another, the source can be consumed.  You can easily
     # confuse this method.  Originally, the patterns were easier
     # to construct and this method more robust, because this method
-    # generated search regexes on the fly; however, this was
+    # generated search regexps on the fly; however, this was
     # computationally expensive and slowed down the entire REXML package
     # considerably, since this is by far the most commonly called method.
     # @param pattern must be a Regexp, and must be in the form of
@@ -185,7 +186,7 @@ module REXML
       # You'll notice that this next section is very similar to the same
       # section in match(), but just a liiittle different.  This is
       # because it is a touch faster to do it this way with scan()
-      # than the way match() does it; enough faster to warrent duplicating
+      # than the way match() does it; enough faster to warrant duplicating
       # some code
       if rv.size == 0
         until @buffer =~ pattern or @source.nil?
@@ -199,7 +200,7 @@ module REXML
         end
         rv = super
       end
-      rv.taint
+      rv.taint if RUBY_VERSION < '2.7'
       rv
     end
 
@@ -227,7 +228,7 @@ module REXML
           @source = nil
         end
       end
-      rv.taint
+      rv.taint if RUBY_VERSION < '2.7'
       rv
     end
 
@@ -253,6 +254,7 @@ module REXML
           end
         rescue
         end
+        @er_source.seek(pos)
       rescue IOError
         pos = -1
         line = -1
@@ -285,7 +287,7 @@ module REXML
       case @encoding
       when "UTF-16BE", "UTF-16LE"
         @source.binmode
-        @source.set_encoding(@encoding)
+        @source.set_encoding(@encoding, @encoding)
       end
       @line_break = encode(">")
       @pending_buffer, @buffer = @buffer, ""
diff --git a/lib/rexml/streamlistener.rb b/lib/rexml/streamlistener.rb
index 8805ffb..30c8945 100644
--- a/lib/rexml/streamlistener.rb
+++ b/lib/rexml/streamlistener.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 module REXML
   # A template for stream parser listeners.
   # Note that the declarations (attlistdecl, elementdecl, etc) are trivially
@@ -13,7 +14,7 @@ module REXML
     def tag_start name, attrs
     end
     # Called when the end tag is reached.  In the case of <tag/>, tag_end
-    # will be called immidiately after tag_start
+    # will be called immediately after tag_start
     # @p the name of the tag
     def tag_end name
     end
diff --git a/lib/rexml/syncenumerator.rb b/lib/rexml/syncenumerator.rb
index 11609bd..a9d2ad7 100644
--- a/lib/rexml/syncenumerator.rb
+++ b/lib/rexml/syncenumerator.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 module REXML
   class SyncEnumerator
     include Enumerable
diff --git a/lib/rexml/text.rb b/lib/rexml/text.rb
index d3242ee..050b09c 100644
--- a/lib/rexml/text.rb
+++ b/lib/rexml/text.rb
@@ -1,9 +1,10 @@
-require 'rexml/security'
-require 'rexml/entity'
-require 'rexml/doctype'
-require 'rexml/child'
-require 'rexml/doctype'
-require 'rexml/parseexception'
+# frozen_string_literal: false
+require_relative 'security'
+require_relative 'entity'
+require_relative 'doctype'
+require_relative 'child'
+require_relative 'doctype'
+require_relative 'parseexception'
 
 module REXML
   # Represents text nodes in an XML document
@@ -32,7 +33,7 @@ module REXML
       VALID_XML_CHARS = Regexp.new('^['+
         VALID_CHAR.map { |item|
           case item
-          when Fixnum
+          when Integer
             [item].pack('U').force_encoding('utf-8')
           when Range
             [item.first, '-'.ord, item.last].pack('UUU').force_encoding('utf-8')
@@ -95,27 +96,28 @@ module REXML
 
       @raw = false
       @parent = nil
+      @entity_filter = nil
 
       if parent
         super( parent )
         @raw = parent.raw
       end
 
-      @raw = raw unless raw.nil?
-      @entity_filter = entity_filter
-      clear_cache
-
       if arg.kind_of? String
         @string = arg.dup
-        @string.squeeze!(" \n\t") unless respect_whitespace
       elsif arg.kind_of? Text
-        @string = arg.to_s
+        @string = arg.instance_variable_get(:@string).dup
         @raw = arg.raw
-      elsif
+        @entity_filter = arg.instance_variable_get(:@entity_filter)
+      else
         raise "Illegal argument of type #{arg.type} for Text constructor (#{arg})"
       end
 
-      @string.gsub!( /\r\n?/, "\n" )
+      @string.squeeze!(" \n\t") unless respect_whitespace
+      @string.gsub!(/\r\n?/, "\n")
+      @raw = raw unless raw.nil?
+      @entity_filter = entity_filter if entity_filter
+      clear_cache
 
       Text.check(@string, illegal, doctype) if @raw
     end
@@ -135,7 +137,7 @@ module REXML
             case c.ord
             when *VALID_CHAR
             else
-              raise "Illegal character #{c.inspect} in raw string \"#{string}\""
+              raise "Illegal character #{c.inspect} in raw string #{string.inspect}"
             end
           end
         else
@@ -143,7 +145,7 @@ module REXML
             case c.unpack('U')
             when *VALID_CHAR
             else
-              raise "Illegal character #{c.inspect} in raw string \"#{string}\""
+              raise "Illegal character #{c.inspect} in raw string #{string.inspect}"
             end
           end
         end
@@ -152,13 +154,13 @@ module REXML
       # context sensitive
       string.scan(pattern) do
         if $1[-1] != ?;
-          raise "Illegal character '#{$1}' in raw string \"#{string}\""
+          raise "Illegal character #{$1.inspect} in raw string #{string.inspect}"
         elsif $1[0] == ?&
           if $5 and $5[0] == ?#
             case ($5[1] == ?x ? $5[2..-1].to_i(16) : $5[1..-1].to_i)
             when *VALID_CHAR
             else
-              raise "Illegal character '#{$1}' in raw string \"#{string}\""
+              raise "Illegal character #{$1.inspect} in raw string #{string.inspect}"
             end
           # FIXME: below can't work but this needs API change.
           # elsif @parent and $3 and !SUBSTITUTES.include?($1)
@@ -180,7 +182,7 @@ module REXML
 
 
     def clone
-      return Text.new(self)
+      return Text.new(self, true)
     end
 
 
@@ -225,9 +227,7 @@ module REXML
     #   u.to_s   #-> "sean russell"
     def to_s
       return @string if @raw
-      return @normalized if @normalized
-
-      @normalized = Text::normalize( @string, doctype, @entity_filter )
+      @normalized ||= Text::normalize( @string, doctype, @entity_filter )
     end
 
     def inspect
@@ -248,8 +248,7 @@ module REXML
     #   u = Text.new( "sean russell", false, nil, true )
     #   u.value   #-> "sean russell"
     def value
-      return @unnormalized if @unnormalized
-      @unnormalized = Text::unnormalize( @string, doctype )
+      @unnormalized ||= Text::unnormalize( @string, doctype )
     end
 
     # Sets the contents of this text node.  This expects the text to be
@@ -265,16 +264,16 @@ module REXML
       @raw = false
     end
 
-     def wrap(string, width, addnewline=false)
-       # Recursively wrap string at width.
-       return string if string.length <= width
-       place = string.rindex(' ', width) # Position in string with last ' ' before cutoff
-       if addnewline then
-         return "\n" + string[0,place] + "\n" + wrap(string[place+1..-1], width)
-       else
-         return string[0,place] + "\n" + wrap(string[place+1..-1], width)
-       end
-     end
+    def wrap(string, width, addnewline=false)
+      # Recursively wrap string at width.
+      return string if string.length <= width
+      place = string.rindex(' ', width) # Position in string with last ' ' before cutoff
+      if addnewline then
+        return "\n" + string[0,place] + "\n" + wrap(string[place+1..-1], width)
+      else
+        return string[0,place] + "\n" + wrap(string[place+1..-1], width)
+      end
+    end
 
     def indent_text(string, level=1, style="\t", indentfirstline=true)
       return string if level < 0
@@ -292,7 +291,7 @@ module REXML
     # See REXML::Formatters
     #
     def write( writer, indent=-1, transitive=false, ie_hack=false )
-      Kernel.warn("#{self.class.name}.write is deprecated.  See REXML::Formatters")
+      Kernel.warn("#{self.class.name}.write is deprecated.  See REXML::Formatters", uplevel: 1)
       formatter = if indent > -1
           REXML::Formatters::Pretty.new( indent )
         else
diff --git a/lib/rexml/undefinednamespaceexception.rb b/lib/rexml/undefinednamespaceexception.rb
index 8ebfdfd..492a098 100644
--- a/lib/rexml/undefinednamespaceexception.rb
+++ b/lib/rexml/undefinednamespaceexception.rb
@@ -1,4 +1,5 @@
-require 'rexml/parseexception'
+# frozen_string_literal: false
+require_relative 'parseexception'
 module REXML
   class UndefinedNamespaceException < ParseException
     def initialize( prefix, source, parser )
diff --git a/lib/rexml/validation/relaxng.rb b/lib/rexml/validation/relaxng.rb
index 2441901..f29a2c0 100644
--- a/lib/rexml/validation/relaxng.rb
+++ b/lib/rexml/validation/relaxng.rb
@@ -1,5 +1,6 @@
-require "rexml/validation/validation"
-require "rexml/parsers/baseparser"
+# frozen_string_literal: false
+require_relative "validation"
+require_relative "../parsers/baseparser"
 
 module REXML
   module Validation
@@ -145,7 +146,6 @@ module REXML
 
       def next( event )
         #print "In next with #{event.inspect}.  "
-        #puts "Next (#@current) is #{@events[@current]}"
         #p @previous
         return @previous.pop.next( event ) if @events[@current].nil?
         expand_ref_in( @events, @current ) if @events[@current].class == Ref
@@ -154,19 +154,15 @@ module REXML
           @events[@current-1].previous = self
           return @events[@current-1].next( event )
         end
-        #puts "Current isn't a state"
         if ( @events[@current].matches?(event) )
           @current += 1
           if @events[@current].nil?
-            #puts "#{inspect[0,5]} 1RETURNING #{@previous.inspect[0,5]}"
             return @previous.pop
           elsif @events[@current].kind_of? State
             @current += 1
-            #puts "#{inspect[0,5]} 2RETURNING (#{@current-1}) #{@events[@current-1].inspect[0,5]}; on return, next is #{@events[@current]}"
             @events[@current-1].previous = self
             return @events[@current-1]
           else
-            #puts "#{inspect[0,5]} RETURNING self w/ next(#@current) = #{@events[@current]}"
             return self
           end
         else
@@ -393,13 +389,10 @@ module REXML
           # Remove the references
           # Find the events
         end
-        #puts "In next with #{event.inspect}."
-        #puts "events is #{@events.inspect}"
         unless @events
           @events = []
           return nil
         end
-        #puts "current = #@current"
         super
       end
 
@@ -409,8 +402,6 @@ module REXML
       end
 
       def expected
-        #puts "IN CHOICE EXPECTED"
-        #puts "EVENTS = #{@events.inspect}"
         return [@events[@current]] if @events.size > 0
         return @choices.collect do |x|
           if x[0].kind_of? State
@@ -479,8 +470,6 @@ module REXML
           @choice += 1
         end
 
-       #puts "In next with #{event.inspect}."
-       #puts "events is #{@events.inspect}"
         @events = [] unless @events
       end
 
@@ -491,29 +480,22 @@ module REXML
         return nil unless @events[@current]
 
         expand_ref_in( @events, @current ) if @events[@current].class == Ref
-       #puts "In next with #{event.inspect}."
-       #puts "Next (#@current) is #{@events[@current]}"
         if ( @events[@current].kind_of? State )
           @current += 1
           @events[@current-1].previous = self
           return @events[@current-1].next( event )
         end
-       #puts "Current isn't a state"
         return @previous.pop.next( event ) if @events[@current].nil?
         if ( @events[@current].matches?(event) )
           @current += 1
           if @events[@current].nil?
-           #puts "#{inspect[0,5]} 1RETURNING self" unless @choices[@choice].nil?
             return self unless @choices[@choice].nil?
-           #puts "#{inspect[0,5]} 1RETURNING #{@previous[-1].inspect[0,5]}"
             return @previous.pop
           elsif @events[@current].kind_of? State
             @current += 1
-           #puts "#{inspect[0,5]} 2RETURNING (#{@current-1}) #{@events[@current-1].inspect[0,5]}; on return, next is #{@events[@current]}"
             @events[@current-1].previous = self
             return @events[@current-1]
           else
-           #puts "#{inspect[0,5]} RETURNING self w/ next(#@current) = #{@events[@current]}"
             return self
           end
         else
@@ -527,8 +509,6 @@ module REXML
       end
 
       def expected
-        #puts "IN CHOICE EXPECTED"
-        #puts "EVENTS = #{@events.inspect}"
         return [@events[@current]] if @events[@current]
         return @choices[@choice..-1].collect do |x|
           if x[0].kind_of? State
diff --git a/lib/rexml/validation/validation.rb b/lib/rexml/validation/validation.rb
index 8042e5d..0ad6ada 100644
--- a/lib/rexml/validation/validation.rb
+++ b/lib/rexml/validation/validation.rb
@@ -1,4 +1,5 @@
-require 'rexml/validation/validationexception'
+# frozen_string_literal: false
+require_relative 'validationexception'
 
 module REXML
   module Validation
@@ -15,8 +16,6 @@ module REXML
         puts @root.inspect
       end
       def validate( event )
-        #puts "Current: #@current"
-        #puts "Event: #{event.inspect}"
         @attr_stack = [] unless defined? @attr_stack
         match = @current.next(event)
         raise ValidationException.new( "Validation error.  Expected: "+
@@ -27,7 +26,6 @@ module REXML
         # Check for attributes
         case event[0]
         when :start_element
-          #puts "Checking attributes"
           @attr_stack << event[2]
           begin
             sattr = [:start_attribute, nil]
@@ -35,22 +33,14 @@ module REXML
             text = [:text, nil]
             k, = event[2].find { |key,value|
               sattr[1] = key
-              #puts "Looking for #{sattr.inspect}"
               m = @current.next( sattr )
-              #puts "Got #{m.inspect}"
               if m
                 # If the state has text children...
-                #puts "Looking for #{eattr.inspect}"
-                #puts "Expect #{m.expected}"
                 if m.matches?( eattr )
-                  #puts "Got end"
                   @current = m
                 else
-                  #puts "Didn't get end"
                   text[1] = value
-                  #puts "Looking for #{text.inspect}"
                   m = m.next( text )
-                  #puts "Got #{m.inspect}"
                   text[1] = nil
                   return false unless m
                   @current = m if m
@@ -94,7 +84,6 @@ module REXML
       end
 
       def matches?( event )
-        #puts "#@event_type =? #{event[0]} && #@event_arg =? #{event[1]} "
         return false unless event[0] == @event_type
         case event[0]
         when nil
diff --git a/lib/rexml/validation/validationexception.rb b/lib/rexml/validation/validationexception.rb
index 4723d9e..78cd63f 100644
--- a/lib/rexml/validation/validationexception.rb
+++ b/lib/rexml/validation/validationexception.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 module REXML
   module Validation
     class ValidationException < RuntimeError
diff --git a/lib/rexml/xmldecl.rb b/lib/rexml/xmldecl.rb
index 465e6ab..d19407c 100644
--- a/lib/rexml/xmldecl.rb
+++ b/lib/rexml/xmldecl.rb
@@ -1,16 +1,18 @@
-require 'rexml/encoding'
-require 'rexml/source'
+# frozen_string_literal: false
+
+require_relative 'encoding'
+require_relative 'source'
 
 module REXML
   # NEEDS DOCUMENTATION
   class XMLDecl < Child
     include Encoding
 
-    DEFAULT_VERSION = "1.0";
-    DEFAULT_ENCODING = "UTF-8";
-    DEFAULT_STANDALONE = "no";
-    START = '<\?xml';
-    STOP = '\?>';
+    DEFAULT_VERSION = "1.0"
+    DEFAULT_ENCODING = "UTF-8"
+    DEFAULT_STANDALONE = "no"
+    START = "<?xml"
+    STOP = "?>"
 
     attr_accessor :version, :standalone
     attr_reader :writeencoding, :writethis
@@ -24,6 +26,7 @@ module REXML
         self.encoding = version.encoding
         @writeencoding = version.writeencoding
         @standalone = version.standalone
+        @writethis = version.writethis
       else
         super()
         @version = version
@@ -45,9 +48,9 @@ module REXML
     #   Ignored
     def write(writer, indent=-1, transitive=false, ie_hack=false)
       return nil unless @writethis or writer.kind_of? Output
-      writer << START.sub(/\\/u, '')
+      writer << START
       writer << " #{content encoding}"
-      writer << STOP.sub(/\\/u, '')
+      writer << STOP
     end
 
     def ==( other )
@@ -101,14 +104,26 @@ module REXML
     end
 
     def inspect
-      START.sub(/\\/u, '') + " ... " + STOP.sub(/\\/u, '')
+      "#{START} ... #{STOP}"
     end
 
     private
     def content(enc)
-      rv = "version='#@version'"
-      rv << " encoding='#{enc}'" if @writeencoding || enc !~ /\Autf-8\z/i
-      rv << " standalone='#@standalone'" if @standalone
+      context = nil
+      context = parent.context if parent
+      if context and context[:prologue_quote] == :quote
+        quote = "\""
+      else
+        quote = "'"
+      end
+
+      rv = "version=#{quote}#{@version}#{quote}"
+      if @writeencoding or enc !~ /\Autf-8\z/i
+        rv << " encoding=#{quote}#{enc}#{quote}"
+      end
+      if @standalone
+        rv << " standalone=#{quote}#{@standalone}#{quote}"
+      end
       rv
     end
   end
diff --git a/lib/rexml/xmltokens.rb b/lib/rexml/xmltokens.rb
index 7dc4e8b..392b47b 100644
--- a/lib/rexml/xmltokens.rb
+++ b/lib/rexml/xmltokens.rb
@@ -1,13 +1,80 @@
+# frozen_string_literal: false
 module REXML
   # Defines a number of tokens used for parsing XML.  Not for general
   # consumption.
   module XMLTokens
-    NCNAME_STR= '[\w:][\-\w.]*'
-    NAME_STR= "(?:#{NCNAME_STR}:)?#{NCNAME_STR}"
+    # From http://www.w3.org/TR/REC-xml/#sec-common-syn
+    #
+    #   [4] NameStartChar ::=
+    #         ":" |
+    #         [A-Z] |
+    #         "_" |
+    #         [a-z] |
+    #         [#xC0-#xD6] |
+    #         [#xD8-#xF6] |
+    #         [#xF8-#x2FF] |
+    #         [#x370-#x37D] |
+    #         [#x37F-#x1FFF] |
+    #         [#x200C-#x200D] |
+    #         [#x2070-#x218F] |
+    #         [#x2C00-#x2FEF] |
+    #         [#x3001-#xD7FF] |
+    #         [#xF900-#xFDCF] |
+    #         [#xFDF0-#xFFFD] |
+    #         [#x10000-#xEFFFF]
+    name_start_chars = [
+      ":",
+      "A-Z",
+      "_",
+      "a-z",
+      "\\u00C0-\\u00D6",
+      "\\u00D8-\\u00F6",
+      "\\u00F8-\\u02FF",
+      "\\u0370-\\u037D",
+      "\\u037F-\\u1FFF",
+      "\\u200C-\\u200D",
+      "\\u2070-\\u218F",
+      "\\u2C00-\\u2FEF",
+      "\\u3001-\\uD7FF",
+      "\\uF900-\\uFDCF",
+      "\\uFDF0-\\uFFFD",
+      "\\u{10000}-\\u{EFFFF}",
+    ]
+    # From http://www.w3.org/TR/REC-xml/#sec-common-syn
+    #
+    #   [4a] NameChar ::=
+    #      NameStartChar |
+    #      "-" |
+    #      "." |
+    #      [0-9] |
+    #      #xB7 |
+    #      [#x0300-#x036F] |
+    #      [#x203F-#x2040]
+    name_chars = name_start_chars + [
+      "\\-",
+      "\\.",
+      "0-9",
+      "\\u00B7",
+      "\\u0300-\\u036F",
+      "\\u203F-\\u2040",
+    ]
+    NAME_START_CHAR = "[#{name_start_chars.join('')}]"
+    NAME_CHAR = "[#{name_chars.join('')}]"
+    NAMECHAR = NAME_CHAR # deprecated. Use NAME_CHAR instead.
 
-    NAMECHAR = '[\-\w\.:]'
-    NAME = "([\\w:]#{NAMECHAR}*)"
-    NMTOKEN = "(?:#{NAMECHAR})+"
+    # From http://www.w3.org/TR/xml-names11/#NT-NCName
+    #
+    #   [6] NCNameStartChar ::= NameStartChar - ':'
+    ncname_start_chars = name_start_chars - [":"]
+    # From http://www.w3.org/TR/xml-names11/#NT-NCName
+    #
+    #   [5] NCNameChar ::= NameChar - ':'
+    ncname_chars = name_chars - [":"]
+    NCNAME_STR = "[#{ncname_start_chars.join('')}][#{ncname_chars.join('')}]*"
+    NAME_STR = "(?:#{NCNAME_STR}:)?#{NCNAME_STR}"
+
+    NAME = "(#{NAME_START_CHAR}#{NAME_CHAR}*)"
+    NMTOKEN = "(?:#{NAME_CHAR})+"
     NMTOKENS = "#{NMTOKEN}(\\s+#{NMTOKEN})*"
     REFERENCE = "(?:&#{NAME};|&#\\d+;|&#x[0-9a-fA-F]+;)"
 
diff --git a/lib/rexml/xpath.rb b/lib/rexml/xpath.rb
index 0f99808..a0921bd 100644
--- a/lib/rexml/xpath.rb
+++ b/lib/rexml/xpath.rb
@@ -1,5 +1,6 @@
-require 'rexml/functions'
-require 'rexml/xpath_parser'
+# frozen_string_literal: false
+require_relative 'functions'
+require_relative 'xpath_parser'
 
 module REXML
   # Wrapper class.  Use this class to access the XPath functions.
@@ -27,10 +28,10 @@ module REXML
     #  XPath.first( doc, "//b"} )
     #  XPath.first( node, "a/x:b", { "x"=>"http://doofus" } )
     #  XPath.first( node, '/book/publisher/text()=$publisher', {}, {"publisher"=>"O'Reilly"})
-    def XPath::first element, path=nil, namespaces=nil, variables={}
+    def XPath::first(element, path=nil, namespaces=nil, variables={}, options={})
       raise "The namespaces argument, if supplied, must be a hash object." unless namespaces.nil? or namespaces.kind_of?(Hash)
       raise "The variables argument, if supplied, must be a hash object." unless variables.kind_of?(Hash)
-      parser = XPathParser.new
+      parser = XPathParser.new(**options)
       parser.namespaces = namespaces
       parser.variables = variables
       path = "*" unless path
@@ -56,10 +57,10 @@ module REXML
     #  XPath.each( node, 'ancestor::x' ) { |el| ... }
     #  XPath.each( node, '/book/publisher/text()=$publisher', {}, {"publisher"=>"O'Reilly"}) \
     #    {|el| ... }
-    def XPath::each element, path=nil, namespaces=nil, variables={}, &block
+    def XPath::each(element, path=nil, namespaces=nil, variables={}, options={}, &block)
       raise "The namespaces argument, if supplied, must be a hash object." unless namespaces.nil? or namespaces.kind_of?(Hash)
       raise "The variables argument, if supplied, must be a hash object." unless variables.kind_of?(Hash)
-      parser = XPathParser.new
+      parser = XPathParser.new(**options)
       parser.namespaces = namespaces
       parser.variables = variables
       path = "*" unless path
@@ -68,8 +69,8 @@ module REXML
     end
 
     # Returns an array of nodes matching a given XPath.
-    def XPath::match element, path=nil, namespaces=nil, variables={}
-      parser = XPathParser.new
+    def XPath::match(element, path=nil, namespaces=nil, variables={}, options={})
+      parser = XPathParser.new(**options)
       parser.namespaces = namespaces
       parser.variables = variables
       path = "*" unless path
diff --git a/lib/rexml/xpath_parser.rb b/lib/rexml/xpath_parser.rb
index 0fc9da2..b989725 100644
--- a/lib/rexml/xpath_parser.rb
+++ b/lib/rexml/xpath_parser.rb
@@ -1,8 +1,11 @@
-require 'rexml/namespace'
-require 'rexml/xmltokens'
-require 'rexml/attribute'
-require 'rexml/syncenumerator'
-require 'rexml/parsers/xpathparser'
+# frozen_string_literal: false
+
+require "pp"
+
+require_relative 'namespace'
+require_relative 'xmltokens'
+require_relative 'attribute'
+require_relative 'parsers/xpathparser'
 
 class Object
   # provides a unified +clone+ operation, for REXML::XPathParser
@@ -16,7 +19,7 @@ class Symbol
   # to use across multiple Object types
   def dclone ; self ; end
 end
-class Fixnum
+class Integer
   # provides a unified +clone+ operation, for REXML::XPathParser
   # to use across multiple Object types
   def dclone ; self ; end
@@ -46,10 +49,15 @@ module REXML
     include XMLTokens
     LITERAL    = /^'([^']*)'|^"([^"]*)"/u
 
-    def initialize( )
+    DEBUG = (ENV["REXML_XPATH_PARSER_DEBUG"] == "true")
+
+    def initialize(strict: false)
+      @debug = DEBUG
       @parser = REXML::Parsers::XPathParser.new
       @namespaces = nil
       @variables = {}
+      @nest = 0
+      @strict = strict
     end
 
     def namespaces=( namespaces={} )
@@ -63,24 +71,18 @@ module REXML
     end
 
     def parse path, nodeset
-     #puts "#"*40
-     path_stack = @parser.parse( path )
-     #puts "PARSE: #{path} => #{path_stack.inspect}"
-     #puts "PARSE: nodeset = #{nodeset.inspect}"
-     match( path_stack, nodeset )
+      path_stack = @parser.parse( path )
+      match( path_stack, nodeset )
     end
 
     def get_first path, nodeset
-     #puts "#"*40
-     path_stack = @parser.parse( path )
-     #puts "PARSE: #{path} => #{path_stack.inspect}"
-     #puts "PARSE: nodeset = #{nodeset.inspect}"
-     first( path_stack, nodeset )
+      path_stack = @parser.parse( path )
+      first( path_stack, nodeset )
     end
 
     def predicate path, nodeset
       path_stack = @parser.parse( path )
-      expr( path_stack, nodeset )
+      match( path_stack, nodeset )
     end
 
     def []=( variable_name, value )
@@ -93,7 +95,6 @@ module REXML
     #
     # FIXME: This method is incomplete!
     def first( path_stack, node )
-      #puts "#{depth}) Entering match( #{path.inspect}, #{tree.inspect} )"
       return nil if path.size == 0
 
       case path[0]
@@ -102,16 +103,12 @@ module REXML
         return first( path[1..-1], node )
       when :child
         for c in node.children
-          #puts "#{depth}) CHILD checking #{name(c)}"
           r = first( path[1..-1], c )
-          #puts "#{depth}) RETURNING #{r.inspect}" if r
           return r if r
         end
       when :qname
         name = path[2]
-        #puts "#{depth}) QNAME #{name(tree)} == #{name} (path => #{path.size})"
         if node.name == name
-          #puts "#{depth}) RETURNING #{tree.inspect}" if path.size == 3
           return node if path.size == 3
           return first( path[3..-1], node )
         else
@@ -133,16 +130,24 @@ module REXML
     end
 
 
-    def match( path_stack, nodeset )
-      #puts "MATCH: path_stack = #{path_stack.inspect}"
-      #puts "MATCH: nodeset = #{nodeset.inspect}"
-      r = expr( path_stack, nodeset )
-      #puts "MAIN EXPR => #{r.inspect}"
-      r
+    def match(path_stack, nodeset)
+      nodeset = nodeset.collect.with_index do |node, i|
+        position = i + 1
+        XPathNode.new(node, position: position)
+      end
+      result = expr(path_stack, nodeset)
+      case result
+      when Array # nodeset
+        unnode(result)
+      else
+        [result]
+      end
     end
 
     private
-
+    def strict?
+      @strict
+    end
 
     # Returns a String namespace for a node, given a prefix
     # The rules are:
@@ -161,399 +166,477 @@ module REXML
 
     # Expr takes a stack of path elements and a set of nodes (either a Parent
     # or an Array and returns an Array of matching nodes
-    ALL = [ :attribute, :element, :text, :processing_instruction, :comment ]
-    ELEMENTS = [ :element ]
     def expr( path_stack, nodeset, context=nil )
-      #puts "#"*15
-      #puts "In expr with #{path_stack.inspect}"
-      #puts "Returning" if path_stack.length == 0 || nodeset.length == 0
-      node_types = ELEMENTS
+      enter(:expr, path_stack, nodeset) if @debug
       return nodeset if path_stack.length == 0 || nodeset.length == 0
       while path_stack.length > 0
-        #puts "#"*5
-        #puts "Path stack = #{path_stack.inspect}"
-        #puts "Nodeset is #{nodeset.inspect}"
+        trace(:while, path_stack, nodeset) if @debug
         if nodeset.length == 0
           path_stack.clear
           return []
         end
-        case (op = path_stack.shift)
+        op = path_stack.shift
+        case op
         when :document
-          nodeset = [ nodeset[0].root_node ]
-          #puts ":document, nodeset = #{nodeset.inspect}"
-
-        when :qname
-          #puts "IN QNAME"
-          prefix = path_stack.shift
-          name = path_stack.shift
-          nodeset.delete_if do |node|
-            # FIXME: This DOUBLES the time XPath searches take
-            ns = get_namespace( node, prefix )
-            #puts "NS = #{ns.inspect}"
-            #puts "node.node_type == :element => #{node.node_type == :element}"
-            if node.node_type == :element
-              #puts "node.name == #{name} => #{node.name == name}"
-              if node.name == name
-                #puts "node.namespace == #{ns.inspect} => #{node.namespace == ns}"
-              end
-            end
-            !(node.node_type == :element and
-              node.name == name and
-              node.namespace == ns )
-          end
-          node_types = ELEMENTS
-
-        when :any
-          #puts "ANY 1: nodeset = #{nodeset.inspect}"
-          #puts "ANY 1: node_types = #{node_types.inspect}"
-          nodeset.delete_if { |node| !node_types.include?(node.node_type) }
-          #puts "ANY 2: nodeset = #{nodeset.inspect}"
-
+          first_raw_node = nodeset.first.raw_node
+          nodeset = [XPathNode.new(first_raw_node.root_node, position: 1)]
         when :self
-          # This space left intentionally blank
-
-        when :processing_instruction
-          target = path_stack.shift
-          nodeset.delete_if do |node|
-            (node.node_type != :processing_instruction) or
-            ( target!='' and ( node.target != target ) )
+          nodeset = step(path_stack) do
+            [nodeset]
           end
-
-        when :text
-          nodeset.delete_if { |node| node.node_type != :text }
-
-        when :comment
-          nodeset.delete_if { |node| node.node_type != :comment }
-
-        when :node
-          # This space left intentionally blank
-          node_types = ALL
-
         when :child
-          new_nodeset = []
-          nt = nil
-          nodeset.each do |node|
-            nt = node.node_type
-            new_nodeset += node.children if nt == :element or nt == :document
+          nodeset = step(path_stack) do
+            child(nodeset)
           end
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
         when :literal
+          trace(:literal, path_stack, nodeset) if @debug
           return path_stack.shift
-
         when :attribute
-          new_nodeset = []
-          case path_stack.shift
-          when :qname
-            prefix = path_stack.shift
-            name = path_stack.shift
-            for element in nodeset
-              if element.node_type == :element
-                #puts "Element name = #{element.name}"
-                #puts "get_namespace( #{element.inspect}, #{prefix} ) = #{get_namespace(element, prefix)}"
-                attrib = element.attribute( name, get_namespace(element, prefix) )
-                #puts "attrib = #{attrib.inspect}"
-                new_nodeset << attrib if attrib
+          nodeset = step(path_stack, any_type: :attribute) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              next unless raw_node.node_type == :element
+              attributes = raw_node.attributes
+              next if attributes.empty?
+              nodesets << attributes.each_attribute.collect.with_index do |attribute, i|
+                XPathNode.new(attribute, position: i + 1)
               end
             end
-          when :any
-            #puts "ANY"
-            for element in nodeset
-              if element.node_type == :element
-                new_nodeset += element.attributes.to_a
+            nodesets
+          end
+        when :namespace
+          pre_defined_namespaces = {
+            "xml" => "http://www.w3.org/XML/1998/namespace",
+          }
+          nodeset = step(path_stack, any_type: :namespace) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              case raw_node.node_type
+              when :element
+                if @namespaces
+                  nodesets << pre_defined_namespaces.merge(@namespaces)
+                else
+                  nodesets << pre_defined_namespaces.merge(raw_node.namespaces)
+                end
+              when :attribute
+                if @namespaces
+                  nodesets << pre_defined_namespaces.merge(@namespaces)
+                else
+                  nodesets << pre_defined_namespaces.merge(raw_node.element.namespaces)
+                end
               end
             end
+            nodesets
           end
-          nodeset = new_nodeset
-
         when :parent
-          #puts "PARENT 1: nodeset = #{nodeset}"
-          nodeset = nodeset.collect{|n| n.parent}.compact
-          #nodeset = expr(path_stack.dclone, nodeset.collect{|n| n.parent}.compact)
-          #puts "PARENT 2: nodeset = #{nodeset.inspect}"
-          node_types = ELEMENTS
-
-        when :ancestor
-          new_nodeset = []
-          nodeset.each do |node|
-            while node.parent
-              node = node.parent
-              new_nodeset << node unless new_nodeset.include? node
+          nodeset = step(path_stack) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              if raw_node.node_type == :attribute
+                parent = raw_node.element
+              else
+                parent = raw_node.parent
+              end
+              nodesets << [XPathNode.new(parent, position: 1)] if parent
             end
+            nodesets
           end
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
-        when :ancestor_or_self
-          new_nodeset = []
-          nodeset.each do |node|
-            if node.node_type == :element
-              new_nodeset << node
-              while ( node.parent )
-                node = node.parent
-                new_nodeset << node unless new_nodeset.include? node
+        when :ancestor
+          nodeset = step(path_stack) do
+            nodesets = []
+            # new_nodes = {}
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              new_nodeset = []
+              while raw_node.parent
+                raw_node = raw_node.parent
+                # next if new_nodes.key?(node)
+                new_nodeset << XPathNode.new(raw_node,
+                                             position: new_nodeset.size + 1)
+                # new_nodes[node] = true
               end
+              nodesets << new_nodeset unless new_nodeset.empty?
             end
+            nodesets
           end
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
-        when :predicate
-          new_nodeset = []
-          subcontext = { :size => nodeset.size }
-          pred = path_stack.shift
-          nodeset.each_with_index { |node, index|
-            subcontext[ :node ] = node
-            #puts "PREDICATE SETTING CONTEXT INDEX TO #{index+1}"
-            subcontext[ :index ] = index+1
-            pc = pred.dclone
-            #puts "#{node.hash}) Recursing with #{pred.inspect} and [#{node.inspect}]"
-            result = expr( pc, [node], subcontext )
-            result = result[0] if result.kind_of? Array and result.length == 1
-            #puts "#{node.hash}) Result = #{result.inspect} (#{result.class.name})"
-            if result.kind_of? Numeric
-              #puts "Adding node #{node.inspect}" if result == (index+1)
-              new_nodeset << node if result == (index+1)
-            elsif result.instance_of? Array
-              if result.size > 0 and result.inject(false) {|k,s| s or k}
-                #puts "Adding node #{node.inspect}" if result.size > 0
-                new_nodeset << node if result.size > 0
+        when :ancestor_or_self
+          nodeset = step(path_stack) do
+            nodesets = []
+            # new_nodes = {}
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              next unless raw_node.node_type == :element
+              new_nodeset = [XPathNode.new(raw_node, position: 1)]
+              # new_nodes[node] = true
+              while raw_node.parent
+                raw_node = raw_node.parent
+                # next if new_nodes.key?(node)
+                new_nodeset << XPathNode.new(raw_node,
+                                             position: new_nodeset.size + 1)
+                # new_nodes[node] = true
               end
-            else
-              #puts "Adding node #{node.inspect}" if result
-              new_nodeset << node if result
+              nodesets << new_nodeset unless new_nodeset.empty?
             end
-          }
-          #puts "New nodeset = #{new_nodeset.inspect}"
-          #puts "Path_stack  = #{path_stack.inspect}"
-          nodeset = new_nodeset
-=begin
-          predicate = path_stack.shift
-          ns = nodeset.clone
-          result = expr( predicate, ns )
-          #puts "Result = #{result.inspect} (#{result.class.name})"
-          #puts "nodeset = #{nodeset.inspect}"
-          if result.kind_of? Array
-            nodeset = result.zip(ns).collect{|m,n| n if m}.compact
-          else
-            nodeset = result ? nodeset : []
+            nodesets
           end
-          #puts "Outgoing NS = #{nodeset.inspect}"
-=end
-
         when :descendant_or_self
-          rv = descendant_or_self( path_stack, nodeset )
-          path_stack.clear
-          nodeset = rv
-          node_types = ELEMENTS
-
+          nodeset = step(path_stack) do
+            descendant(nodeset, true)
+          end
         when :descendant
-          results = []
-          nt = nil
-          nodeset.each do |node|
-            nt = node.node_type
-            results += expr( path_stack.dclone.unshift( :descendant_or_self ),
-              node.children ) if nt == :element or nt == :document
+          nodeset = step(path_stack) do
+            descendant(nodeset, false)
           end
-          nodeset = results
-          node_types = ELEMENTS
-
         when :following_sibling
-          #puts "FOLLOWING_SIBLING 1: nodeset = #{nodeset}"
-          results = []
-          nodeset.each do |node|
-            next if node.parent.nil?
-            all_siblings = node.parent.children
-            current_index = all_siblings.index( node )
-            following_siblings = all_siblings[ current_index+1 .. -1 ]
-            results += expr( path_stack.dclone, following_siblings )
-          end
-          #puts "FOLLOWING_SIBLING 2: nodeset = #{nodeset}"
-          nodeset = results
-
+          nodeset = step(path_stack) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              next unless raw_node.respond_to?(:parent)
+              next if raw_node.parent.nil?
+              all_siblings = raw_node.parent.children
+              current_index = all_siblings.index(raw_node)
+              following_siblings = all_siblings[(current_index + 1)..-1]
+              next if following_siblings.empty?
+              nodesets << following_siblings.collect.with_index do |sibling, i|
+                XPathNode.new(sibling, position: i + 1)
+              end
+            end
+            nodesets
+          end
         when :preceding_sibling
-          results = []
-          nodeset.each do |node|
-            next if node.parent.nil?
-            all_siblings = node.parent.children
-            current_index = all_siblings.index( node )
-            preceding_siblings = all_siblings[ 0, current_index ].reverse
-            results += preceding_siblings
+          nodeset = step(path_stack, order: :reverse) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              next unless raw_node.respond_to?(:parent)
+              next if raw_node.parent.nil?
+              all_siblings = raw_node.parent.children
+              current_index = all_siblings.index(raw_node)
+              preceding_siblings = all_siblings[0, current_index].reverse
+              next if preceding_siblings.empty?
+              nodesets << preceding_siblings.collect.with_index do |sibling, i|
+                XPathNode.new(sibling, position: i + 1)
+              end
+            end
+            nodesets
           end
-          nodeset = results
-          node_types = ELEMENTS
-
         when :preceding
-          new_nodeset = []
-          nodeset.each do |node|
-            new_nodeset += preceding( node )
+          nodeset = step(path_stack, order: :reverse) do
+            unnode(nodeset) do |node|
+              preceding(node)
+            end
           end
-          #puts "NEW NODESET => #{new_nodeset.inspect}"
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
         when :following
-          new_nodeset = []
-          nodeset.each do |node|
-            new_nodeset += following( node )
-          end
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
-        when :namespace
-          #puts "In :namespace"
-          new_nodeset = []
-          prefix = path_stack.shift
-          nodeset.each do |node|
-            if (node.node_type == :element or node.node_type == :attribute)
-              if @namespaces
-                namespaces = @namespaces
-              elsif (node.node_type == :element)
-                namespaces = node.namespaces
-              else
-                namespaces = node.element.namesapces
-              end
-              #puts "Namespaces = #{namespaces.inspect}"
-              #puts "Prefix = #{prefix.inspect}"
-              #puts "Node.namespace = #{node.namespace}"
-              if (node.namespace == namespaces[prefix])
-                new_nodeset << node
-              end
+          nodeset = step(path_stack) do
+            unnode(nodeset) do |node|
+              following(node)
             end
           end
-          nodeset = new_nodeset
-
         when :variable
           var_name = path_stack.shift
-          return @variables[ var_name ]
+          return [@variables[var_name]]
 
-        # :and, :or, :eq, :neq, :lt, :lteq, :gt, :gteq
-        # TODO: Special case for :or and :and -- not evaluate the right
-        # operand if the left alone determines result (i.e. is true for
-        # :or and false for :and).
-        when :eq, :neq, :lt, :lteq, :gt, :gteq, :or
+        when :eq, :neq, :lt, :lteq, :gt, :gteq
           left = expr( path_stack.shift, nodeset.dup, context )
-          #puts "LEFT => #{left.inspect} (#{left.class.name})"
           right = expr( path_stack.shift, nodeset.dup, context )
-          #puts "RIGHT => #{right.inspect} (#{right.class.name})"
           res = equality_relational_compare( left, op, right )
-          #puts "RES => #{res.inspect}"
+          trace(op, left, right, res) if @debug
           return res
 
+        when :or
+          left = expr(path_stack.shift, nodeset.dup, context)
+          return true if Functions.boolean(left)
+          right = expr(path_stack.shift, nodeset.dup, context)
+          return Functions.boolean(right)
+
         when :and
-          left = expr( path_stack.shift, nodeset.dup, context )
-          #puts "LEFT => #{left.inspect} (#{left.class.name})"
-          return [] unless left
-          if left.respond_to?(:inject) and !left.inject(false) {|a,b| a | b}
-            return []
+          left = expr(path_stack.shift, nodeset.dup, context)
+          return false unless Functions.boolean(left)
+          right = expr(path_stack.shift, nodeset.dup, context)
+          return Functions.boolean(right)
+
+        when :div, :mod, :mult, :plus, :minus
+          left = expr(path_stack.shift, nodeset, context)
+          right = expr(path_stack.shift, nodeset, context)
+          left = unnode(left) if left.is_a?(Array)
+          right = unnode(right) if right.is_a?(Array)
+          left = Functions::number(left)
+          right = Functions::number(right)
+          case op
+          when :div
+            return left / right
+          when :mod
+            return left % right
+          when :mult
+            return left * right
+          when :plus
+            return left + right
+          when :minus
+            return left - right
+          else
+            raise "[BUG] Unexpected operator: <#{op.inspect}>"
           end
-          right = expr( path_stack.shift, nodeset.dup, context )
-          #puts "RIGHT => #{right.inspect} (#{right.class.name})"
-          res = equality_relational_compare( left, op, right )
-          #puts "RES => #{res.inspect}"
-          return res
-
-        when :div
-          left = Functions::number(expr(path_stack.shift, nodeset, context)).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context)).to_f
-          return (left / right)
-
-        when :mod
-          left = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          return (left % right)
-
-        when :mult
-          left = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          return (left * right)
-
-        when :plus
-          left = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          return (left + right)
-
-        when :minus
-          left = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          return (left - right)
-
         when :union
           left = expr( path_stack.shift, nodeset, context )
           right = expr( path_stack.shift, nodeset, context )
+          left = unnode(left) if left.is_a?(Array)
+          right = unnode(right) if right.is_a?(Array)
           return (left | right)
-
         when :neg
           res = expr( path_stack, nodeset, context )
-          return -(res.to_f)
-
+          res = unnode(res) if res.is_a?(Array)
+          return -Functions.number(res)
         when :not
         when :function
           func_name = path_stack.shift.tr('-','_')
           arguments = path_stack.shift
-          #puts "FUNCTION 0: #{func_name}(#{arguments.collect{|a|a.inspect}.join(', ')})"
-          subcontext = context ? nil : { :size => nodeset.size }
-
-          res = []
-          cont = context
-          nodeset.each_with_index { |n, i|
-            if subcontext
-              subcontext[:node]  = n
-              subcontext[:index] = i
-              cont = subcontext
+
+          if nodeset.size != 1
+            message = "[BUG] Node set size must be 1 for function call: "
+            message += "<#{func_name}>: <#{nodeset.inspect}>: "
+            message += "<#{arguments.inspect}>"
+            raise message
+          end
+
+          node = nodeset.first
+          if context
+            target_context = context
+          else
+            target_context = {:size => nodeset.size}
+            if node.is_a?(XPathNode)
+              target_context[:node]  = node.raw_node
+              target_context[:index] = node.position
+            else
+              target_context[:node]  = node
+              target_context[:index] = 1
             end
-            arg_clone = arguments.dclone
-            args = arg_clone.collect { |arg|
-              #puts "FUNCTION 1: Calling expr( #{arg.inspect}, [#{n.inspect}] )"
-              expr( arg, [n], cont )
-            }
-            #puts "FUNCTION 2: #{func_name}(#{args.collect{|a|a.inspect}.join(', ')})"
-            Functions.context = cont
-            res << Functions.send( func_name, *args )
-            #puts "FUNCTION 3: #{res[-1].inspect}"
-          }
-          return res
+          end
+          args = arguments.dclone.collect do |arg|
+            result = expr(arg, nodeset, target_context)
+            result = unnode(result) if result.is_a?(Array)
+            result
+          end
+          Functions.context = target_context
+          return Functions.send(func_name, *args)
 
+        else
+          raise "[BUG] Unexpected path: <#{op.inspect}>: <#{path_stack.inspect}>"
         end
       end # while
-      #puts "EXPR returning #{nodeset.inspect}"
       return nodeset
+    ensure
+      leave(:expr, path_stack, nodeset) if @debug
+    end
+
+    def step(path_stack, any_type: :element, order: :forward)
+      nodesets = yield
+      begin
+        enter(:step, path_stack, nodesets) if @debug
+        nodesets = node_test(path_stack, nodesets, any_type: any_type)
+        while path_stack[0] == :predicate
+          path_stack.shift # :predicate
+          predicate_expression = path_stack.shift.dclone
+          nodesets = evaluate_predicate(predicate_expression, nodesets)
+        end
+        if nodesets.size == 1
+          ordered_nodeset = nodesets[0]
+        else
+          raw_nodes = []
+          nodesets.each do |nodeset|
+            nodeset.each do |node|
+              if node.respond_to?(:raw_node)
+                raw_nodes << node.raw_node
+              else
+                raw_nodes << node
+              end
+            end
+          end
+          ordered_nodeset = sort(raw_nodes, order)
+        end
+        new_nodeset = []
+        ordered_nodeset.each do |node|
+          # TODO: Remove duplicated
+          new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
+        end
+        new_nodeset
+      ensure
+        leave(:step, path_stack, new_nodeset) if @debug
+      end
     end
 
+    def node_test(path_stack, nodesets, any_type: :element)
+      enter(:node_test, path_stack, nodesets) if @debug
+      operator = path_stack.shift
+      case operator
+      when :qname
+        prefix = path_stack.shift
+        name = path_stack.shift
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            case raw_node.node_type
+            when :element
+              if prefix.nil?
+                raw_node.name == name
+              elsif prefix.empty?
+                if strict?
+                  raw_node.name == name and raw_node.namespace == ""
+                else
+                  # FIXME: This DOUBLES the time XPath searches take
+                  ns = get_namespace(raw_node, prefix)
+                  raw_node.name == name and raw_node.namespace == ns
+                end
+              else
+                # FIXME: This DOUBLES the time XPath searches take
+                ns = get_namespace(raw_node, prefix)
+                raw_node.name == name and raw_node.namespace == ns
+              end
+            when :attribute
+              if prefix.nil?
+                raw_node.name == name
+              elsif prefix.empty?
+                raw_node.name == name and raw_node.namespace == ""
+              else
+                # FIXME: This DOUBLES the time XPath searches take
+                ns = get_namespace(raw_node.element, prefix)
+                raw_node.name == name and raw_node.namespace == ns
+              end
+            else
+              false
+            end
+          end
+        end
+      when :namespace
+        prefix = path_stack.shift
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            case raw_node.node_type
+            when :element
+              namespaces = @namespaces || raw_node.namespaces
+              raw_node.namespace == namespaces[prefix]
+            when :attribute
+              namespaces = @namespaces || raw_node.element.namespaces
+              raw_node.namespace == namespaces[prefix]
+            else
+              false
+            end
+          end
+        end
+      when :any
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            raw_node.node_type == any_type
+          end
+        end
+      when :comment
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            raw_node.node_type == :comment
+          end
+        end
+      when :text
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            raw_node.node_type == :text
+          end
+        end
+      when :processing_instruction
+        target = path_stack.shift
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            (raw_node.node_type == :processing_instruction) and
+              (target.empty? or (raw_node.target == target))
+          end
+        end
+      when :node
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            true
+          end
+        end
+      else
+        message = "[BUG] Unexpected node test: " +
+          "<#{operator.inspect}>: <#{path_stack.inspect}>"
+        raise message
+      end
+      new_nodesets
+    ensure
+      leave(:node_test, path_stack, new_nodesets) if @debug
+    end
 
-    ##########################################################
-    # FIXME
-    # The next two methods are BAD MOJO!
-    # This is my achilles heel.  If anybody thinks of a better
-    # way of doing this, be my guest.  This really sucks, but
-    # it is a wonder it works at all.
-    # ########################################################
-
-    def descendant_or_self( path_stack, nodeset )
-      rs = []
-      #puts "#"*80
-      #puts "PATH_STACK = #{path_stack.inspect}"
-      #puts "NODESET = #{nodeset.collect{|n|n.inspect}.inspect}"
-      d_o_s( path_stack, nodeset, rs )
-      #puts "RS = #{rs.collect{|n|n.inspect}.inspect}"
-      document_order(rs.flatten.compact)
-      #rs.flatten.compact
-    end
-
-    def d_o_s( p, ns, r )
-      #puts "IN DOS with #{ns.inspect}; ALREADY HAVE #{r.inspect}"
-      nt = nil
-      ns.each_index do |i|
-        n = ns[i]
-        #puts "P => #{p.inspect}"
-        x = expr( p.dclone, [ n ] )
-        nt = n.node_type
-        d_o_s( p, n.children, x ) if nt == :element or nt == :document and n.children.size > 0
-        r.concat(x) if x.size > 0
+    def filter_nodeset(nodeset)
+      new_nodeset = []
+      nodeset.each do |node|
+        next unless yield(node)
+        new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
       end
+      new_nodeset
     end
 
+    def evaluate_predicate(expression, nodesets)
+      enter(:predicate, expression, nodesets) if @debug
+      new_nodesets = nodesets.collect do |nodeset|
+        new_nodeset = []
+        subcontext = { :size => nodeset.size }
+        nodeset.each_with_index do |node, index|
+          if node.is_a?(XPathNode)
+            subcontext[:node] = node.raw_node
+            subcontext[:index] = node.position
+          else
+            subcontext[:node] = node
+            subcontext[:index] = index + 1
+          end
+          result = expr(expression.dclone, [node], subcontext)
+          trace(:predicate_evaluate, expression, node, subcontext, result) if @debug
+          result = result[0] if result.kind_of? Array and result.length == 1
+          if result.kind_of? Numeric
+            if result == node.position
+              new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
+            end
+          elsif result.instance_of? Array
+            if result.size > 0 and result.inject(false) {|k,s| s or k}
+              if result.size > 0
+                new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
+              end
+            end
+          else
+            if result
+              new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
+            end
+          end
+        end
+        new_nodeset
+      end
+      new_nodesets
+    ensure
+      leave(:predicate, new_nodesets) if @debug
+    end
+
+    def trace(*args)
+      indent = "  " * @nest
+      PP.pp(args, "").each_line do |line|
+        puts("#{indent}#{line}")
+      end
+    end
+
+    def enter(tag, *args)
+      trace(:enter, tag, *args)
+      @nest += 1
+    end
+
+    def leave(tag, *args)
+      @nest -= 1
+      trace(:leave, tag, *args)
+    end
 
     # Reorders an array of nodes so that they are in document order
     # It tries to do this efficiently.
@@ -563,7 +646,7 @@ module REXML
     # in and out of function calls.  If I knew what the index of the nodes was,
     # I wouldn't have to do this.  Maybe add a document IDX for each node?
     # Problems with mutable documents.  Or, rewrite everything.
-    def document_order( array_of_nodes )
+    def sort(array_of_nodes, order)
       new_arry = []
       array_of_nodes.each { |node|
         node_idx = []
@@ -574,52 +657,71 @@ module REXML
         end
         new_arry << [ node_idx.reverse, node ]
       }
-      #puts "new_arry = #{new_arry.inspect}"
-      new_arry.sort{ |s1, s2| s1[0] <=> s2[0] }.collect{ |s| s[1] }
+      ordered = new_arry.sort_by do |index, node|
+        if order == :forward
+          index
+        else
+          -index
+        end
+      end
+      ordered.collect do |_index, node|
+        node
+      end
     end
 
-
-    def recurse( nodeset, &block )
-      for node in nodeset
-        yield node
-        recurse( node, &block ) if node.node_type == :element
+    def descendant(nodeset, include_self)
+      nodesets = []
+      nodeset.each do |node|
+        new_nodeset = []
+        new_nodes = {}
+        descendant_recursive(node.raw_node, new_nodeset, new_nodes, include_self)
+        nodesets << new_nodeset unless new_nodeset.empty?
       end
+      nodesets
     end
 
+    def descendant_recursive(raw_node, new_nodeset, new_nodes, include_self)
+      if include_self
+        return if new_nodes.key?(raw_node)
+        new_nodeset << XPathNode.new(raw_node, position: new_nodeset.size + 1)
+        new_nodes[raw_node] = true
+      end
 
+      node_type = raw_node.node_type
+      if node_type == :element or node_type == :document
+        raw_node.children.each do |child|
+          descendant_recursive(child, new_nodeset, new_nodes, true)
+        end
+      end
+    end
 
     # Builds a nodeset of all of the preceding nodes of the supplied node,
     # in reverse document order
     # preceding:: includes every element in the document that precedes this node,
     # except for ancestors
-    def preceding( node )
-      #puts "IN PRECEDING"
+    def preceding(node)
       ancestors = []
-      p = node.parent
-      while p
-        ancestors << p
-        p = p.parent
+      parent = node.parent
+      while parent
+        ancestors << parent
+        parent = parent.parent
       end
 
-      acc = []
-      p = preceding_node_of( node )
-      #puts "P = #{p.inspect}"
-      while p
-        if ancestors.include? p
-          ancestors.delete(p)
+      precedings = []
+      preceding_node = preceding_node_of(node)
+      while preceding_node
+        if ancestors.include?(preceding_node)
+          ancestors.delete(preceding_node)
         else
-          acc << p
+          precedings << XPathNode.new(preceding_node,
+                                      position: precedings.size + 1)
         end
-        p = preceding_node_of( p )
-        #puts "P = #{p.inspect}"
+        preceding_node = preceding_node_of(preceding_node)
       end
-      acc
+      precedings
     end
 
     def preceding_node_of( node )
-     #puts "NODE: #{node.inspect}"
-     #puts "PREVIOUS NODE: #{node.previous_sibling_node.inspect}"
-     #puts "PARENT NODE: #{node.parent}"
       psn = node.previous_sibling_node
       if psn.nil?
         if node.parent.nil? or node.parent.class == Document
@@ -634,23 +736,18 @@ module REXML
       psn
     end
 
-    def following( node )
-      #puts "IN PRECEDING"
-      acc = []
-      p = next_sibling_node( node )
-      #puts "P = #{p.inspect}"
-      while p
-        acc << p
-        p = following_node_of( p )
-        #puts "P = #{p.inspect}"
+    def following(node)
+      followings = []
+      following_node = next_sibling_node(node)
+      while following_node
+        followings << XPathNode.new(following_node,
+                                    position: followings.size + 1)
+        following_node = following_node_of(following_node)
       end
-      acc
+      followings
     end
 
     def following_node_of( node )
-      #puts "NODE: #{node.inspect}"
-      #puts "PREVIOUS NODE: #{node.previous_sibling_node.inspect}"
-      #puts "PARENT NODE: #{node.parent}"
       if node.kind_of? Element and node.children.size > 0
         return node.children[0]
       end
@@ -665,58 +762,72 @@ module REXML
         end
         node = node.parent
         psn = node.next_sibling_node
-        #puts "psn = #{psn.inspect}"
       end
       return psn
     end
 
+    def child(nodeset)
+      nodesets = []
+      nodeset.each do |node|
+        raw_node = node.raw_node
+        node_type = raw_node.node_type
+        # trace(:child, node_type, node)
+        case node_type
+        when :element
+          nodesets << raw_node.children.collect.with_index do |child_node, i|
+            XPathNode.new(child_node, position: i + 1)
+          end
+        when :document
+          new_nodeset = []
+          raw_node.children.each do |child|
+            case child
+            when XMLDecl, Text
+              # Ignore
+            else
+              new_nodeset << XPathNode.new(child, position: new_nodeset.size + 1)
+            end
+          end
+          nodesets << new_nodeset unless new_nodeset.empty?
+        end
+      end
+      nodesets
+    end
+
     def norm b
       case b
       when true, false
         return b
       when 'true', 'false'
         return Functions::boolean( b )
-      when /^\d+(\.\d+)?$/
+      when /^\d+(\.\d+)?$/, Numeric
         return Functions::number( b )
       else
         return Functions::string( b )
       end
     end
 
-    def equality_relational_compare( set1, op, set2 )
-      #puts "EQ_REL_COMP(#{set1.inspect} #{op.inspect} #{set2.inspect})"
+    def equality_relational_compare(set1, op, set2)
+      set1 = unnode(set1) if set1.is_a?(Array)
+      set2 = unnode(set2) if set2.is_a?(Array)
+
       if set1.kind_of? Array and set2.kind_of? Array
-        #puts "#{set1.size} & #{set2.size}"
-        if set1.size == 1 and set2.size == 1
-          set1 = set1[0]
-          set2 = set2[0]
-        elsif set1.size == 0 or set2.size == 0
-          nd = set1.size==0 ? set2 : set1
-          rv = nd.collect { |il| compare( il, op, nil ) }
-          #puts "RV = #{rv.inspect}"
-          return rv
-        else
-          res = []
-          SyncEnumerator.new( set1, set2 ).each { |i1, i2|
-            #puts "i1 = #{i1.inspect} (#{i1.class.name})"
-            #puts "i2 = #{i2.inspect} (#{i2.class.name})"
-            i1 = norm( i1 )
-            i2 = norm( i2 )
-            res << compare( i1, op, i2 )
-          }
-          return res
+        # If both objects to be compared are node-sets, then the
+        # comparison will be true if and only if there is a node in the
+        # first node-set and a node in the second node-set such that the
+        # result of performing the comparison on the string-values of
+        # the two nodes is true.
+        set1.product(set2).any? do |node1, node2|
+          node_string1 = Functions.string(node1)
+          node_string2 = Functions.string(node2)
+          compare(node_string1, op, node_string2)
         end
-      end
-      #puts "EQ_REL_COMP: #{set1.inspect} (#{set1.class.name}), #{op}, #{set2.inspect} (#{set2.class.name})"
-      #puts "COMPARING VALUES"
-      # If one is nodeset and other is number, compare number to each item
-      # in nodeset s.t. number op number(string(item))
-      # If one is nodeset and other is string, compare string to each item
-      # in nodeset s.t. string op string(item)
-      # If one is nodeset and other is boolean, compare boolean to each item
-      # in nodeset s.t. boolean op boolean(item)
-      if set1.kind_of? Array or set2.kind_of? Array
-        #puts "ISA ARRAY"
+      elsif set1.kind_of? Array or set2.kind_of? Array
+        # If one is nodeset and other is number, compare number to each item
+        # in nodeset s.t. number op number(string(item))
+        # If one is nodeset and other is string, compare string to each item
+        # in nodeset s.t. string op string(item)
+        # If one is nodeset and other is boolean, compare boolean to each item
+        # in nodeset s.t. boolean op boolean(item)
         if set1.kind_of? Array
           a = set1
           b = set2
@@ -727,17 +838,23 @@ module REXML
 
         case b
         when true, false
-          return a.collect {|v| compare( Functions::boolean(v), op, b ) }
+          each_unnode(a).any? do |unnoded|
+            compare(Functions.boolean(unnoded), op, b)
+          end
         when Numeric
-          return a.collect {|v| compare( Functions::number(v), op, b )}
-        when /^\d+(\.\d+)?$/
-          b = Functions::number( b )
-          #puts "B = #{b.inspect}"
-          return a.collect {|v| compare( Functions::number(v), op, b )}
+          each_unnode(a).any? do |unnoded|
+            compare(Functions.number(unnoded), op, b)
+          end
+        when /\A\d+(\.\d+)?\z/
+          b = Functions.number(b)
+          each_unnode(a).any? do |unnoded|
+            compare(Functions.number(unnoded), op, b)
+          end
         else
-          #puts "Functions::string( #{b}(#{b.class.name}) ) = #{Functions::string(b)}"
-          b = Functions::string( b )
-          return a.collect { |v| compare( Functions::string(v), op, b ) }
+          b = Functions::string(b)
+          each_unnode(a).any? do |unnoded|
+            compare(Functions::string(unnoded), op, b)
+          end
         end
       else
         # If neither is nodeset,
@@ -747,38 +864,52 @@ module REXML
         #     Else, convert to string
         #   Else
         #     Convert both to numbers and compare
-        s1 = set1.to_s
-        s2 = set2.to_s
-        #puts "EQ_REL_COMP: #{set1}=>#{s1}, #{set2}=>#{s2}"
-        if s1 == 'true' or s1 == 'false' or s2 == 'true' or s2 == 'false'
-          #puts "Functions::boolean(#{set1})=>#{Functions::boolean(set1)}"
-          #puts "Functions::boolean(#{set2})=>#{Functions::boolean(set2)}"
-          set1 = Functions::boolean( set1 )
-          set2 = Functions::boolean( set2 )
+        compare(set1, op, set2)
+      end
+    end
+
+    def value_type(value)
+      case value
+      when true, false
+        :boolean
+      when Numeric
+        :number
+      when String
+        :string
+      else
+        raise "[BUG] Unexpected value type: <#{value.inspect}>"
+      end
+    end
+
+    def normalize_compare_values(a, operator, b)
+      a_type = value_type(a)
+      b_type = value_type(b)
+      case operator
+      when :eq, :neq
+        if a_type == :boolean or b_type == :boolean
+          a = Functions.boolean(a) unless a_type == :boolean
+          b = Functions.boolean(b) unless b_type == :boolean
+        elsif a_type == :number or b_type == :number
+          a = Functions.number(a) unless a_type == :number
+          b = Functions.number(b) unless b_type == :number
         else
-          if op == :eq or op == :neq
-            if s1 =~ /^\d+(\.\d+)?$/ or s2 =~ /^\d+(\.\d+)?$/
-              set1 = Functions::number( s1 )
-              set2 = Functions::number( s2 )
-            else
-              set1 = Functions::string( set1 )
-              set2 = Functions::string( set2 )
-            end
-          else
-            set1 = Functions::number( set1 )
-            set2 = Functions::number( set2 )
-          end
+          a = Functions.string(a) unless a_type == :string
+          b = Functions.string(b) unless b_type == :string
         end
-        #puts "EQ_REL_COMP: #{set1} #{op} #{set2}"
-        #puts ">>> #{compare( set1, op, set2 )}"
-        return compare( set1, op, set2 )
+      when :lt, :lteq, :gt, :gteq
+        a = Functions.number(a) unless a_type == :number
+        b = Functions.number(b) unless b_type == :number
+      else
+        message = "[BUG] Unexpected compare operator: " +
+          "<#{operator.inspect}>: <#{a.inspect}>: <#{b.inspect}>"
+        raise message
       end
-      return false
+      [a, b]
     end
 
-    def compare a, op, b
-      #puts "COMPARE #{a.inspect}(#{a.class.name}) #{op} #{b.inspect}(#{b.class.name})"
-      case op
+    def compare(a, operator, b)
+      a, b = normalize_compare_values(a, operator, b)
+      case operator
       when :eq
         a == b
       when :neq
@@ -791,13 +922,47 @@ module REXML
         a > b
       when :gteq
         a >= b
-      when :and
-        a and b
-      when :or
-        a or b
       else
-        false
+        message = "[BUG] Unexpected compare operator: " +
+          "<#{operator.inspect}>: <#{a.inspect}>: <#{b.inspect}>"
+        raise message
       end
     end
+
+    def each_unnode(nodeset)
+      return to_enum(__method__, nodeset) unless block_given?
+      nodeset.each do |node|
+        if node.is_a?(XPathNode)
+          unnoded = node.raw_node
+        else
+          unnoded = node
+        end
+        yield(unnoded)
+      end
+    end
+
+    def unnode(nodeset)
+      each_unnode(nodeset).collect do |unnoded|
+        unnoded = yield(unnoded) if block_given?
+        unnoded
+      end
+    end
+  end
+
+  # @private
+  class XPathNode
+    attr_reader :raw_node, :context
+    def initialize(node, context=nil)
+      if node.is_a?(XPathNode)
+        @raw_node = node.raw_node
+      else
+        @raw_node = node
+      end
+      @context = context || {}
+    end
+
+    def position
+      @context[:position]
+    end
   end
 end
diff --git a/test/rexml/data/t75.xml b/test/rexml/data/t75.xml
index 0911fb1..eb3ccce 100644
--- a/test/rexml/data/t75.xml
+++ b/test/rexml/data/t75.xml
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="ISO-8859-1"?><?pos="3"?>
+<?xml version="1.0" encoding="ISO-8859-1"?>
 <!-- generated by hnb 1.9.17 (http://hnb.sourceforge.net) -->
 
 <!DOCTYPE tree[
diff --git a/test/rexml/data/ticket_110_utf16.xml b/test/rexml/data/ticket_110_utf16.xml
deleted file mode 100644
index f7e5e90..0000000
--- a/test/rexml/data/ticket_110_utf16.xml
+++ /dev/null
@@ -1,1802 +0,0 @@
-< ? x m l   v e r s i o n = " 1 . 0 "   e n c o d i n g = " U T F - 1 6 " ? >  
- < r e s t i n g e c g d a t a   c r c = " F A 6 6 E B 4 B "   x m l n s = " h t t p : / / w w w 3 . m e d i c a l . p h i l i p s . c o m "   x m l n s : x s i = " h t t p : / / w w w . w 3 . o r g / 2 0 0 1 / X M L S c h e m a - i n s t a n c e "   x s i : s c h e m a L o c a t i o n = " h t t p : / / w w w 3 . m e d i c a l . p h i l i p s . c o m  
- S i e r r a E C G . x s d "   s t a t u s = " N o t   y e t   d e t e r m i n e d "   l a n g = " n l "   l o c a l e = " N L " >  
- 	 < d o c u m e n t i n f o >  
- 	 	 < d o c u m e n t n a m e > 1 5 a c 5 9 8 0 - 4 4 6 1 - 1 1 d c - 4 8 2 3 - 0 0 3 1 6 8 c 4 0 0 2 9 . x m l < / d o c u m e n t n a m e >  
- 	 	 < d o c u m e n t t y p e > S i e r r a E C G < / d o c u m e n t t y p e >  
- 	 	 < d o c u m e n t v e r s i o n > 1 . 0 3 < / d o c u m e n t v e r s i o n >  
- 	 < / d o c u m e n t i n f o >  
- 	 < u s e r d e f i n e s >  
- 	 	 < u s e r d e f i n e >  
- 	 	 	 < l a b e l > E i g e n   v e l d   1 < / l a b e l >  
- 	 	 	 < v a l u e > < / v a l u e >  
- 	 	 < / u s e r d e f i n e >  
- 	 	 < u s e r d e f i n e >  
- 	 	 	 < l a b e l > E i g e n   v e l d   2 < / l a b e l >  
- 	 	 	 < v a l u e > < / v a l u e >  
- 	 	 < / u s e r d e f i n e >  
- 	 	 < u s e r d e f i n e >  
- 	 	 	 < l a b e l > E i g e n   v e l d   3 < / l a b e l >  
- 	 	 	 < v a l u e > < / v a l u e >  
- 	 	 < / u s e r d e f i n e >  
- 	 	 < u s e r d e f i n e >  
- 	 	 	 < l a b e l > E i g e n   v e l d   4 < / l a b e l >  
- 	 	 	 < v a l u e > < / v a l u e >  
- 	 	 < / u s e r d e f i n e >  
- 	 	 < u s e r d e f i n e >  
- 	 	 	 < l a b e l > E i g e n   v e l d   5 < / l a b e l >  
- 	 	 	 < v a l u e > < / v a l u e >  
- 	 	 < / u s e r d e f i n e >  
- 	 	 < u s e r d e f i n e >  
- 	 	 	 < l a b e l > E i g e n   v e l d   6 < / l a b e l >  
- 	 	 	 < v a l u e > < / v a l u e >  
- 	 	 < / u s e r d e f i n e >  
- 	 	 < u s e r d e f i n e >  
- 	 	 	 < l a b e l > < / l a b e l >  
- 	 	 	 < v a l u e > < / v a l u e >  
- 	 	 < / u s e r d e f i n e >  
- 	 	 < u s e r d e f i n e >  
- 	 	 	 < l a b e l > < / l a b e l >  
- 	 	 	 < v a l u e > < / v a l u e >  
- 	 	 < / u s e r d e f i n e >  
- 	 < / u s e r d e f i n e s >  
- 	 < o r d e r i n f o   p r i o r i t y = " " >  
- 	 	 < e n c o u n t e r i d / >  
- 	 	 < o p e r a t o r i d / >  
- 	 	 < o r d e r n u m b e r > < / o r d e r n u m b e r >  
- 	 	 < v i p e r u n i q u e o r d e r i d / >  
- 	 	 < o r d e r i n g c l i n i c i a n n a m e / >  
- 	 	 < o r d e r i n g c l i n i c i a n U P I N / >  
- 	 	 < r e a s o n f o r o r d e r > < / r e a s o n f o r o r d e r >  
- 	 	 < d r g c a t e g o r i e s / >  
- 	 < / o r d e r i n f o >  
- 	 < r e p o r t i n f o   d a t e = " 2 0 0 7 - 0 8 - 0 6 "   t i m e = " 1 3 : 0 1 : 5 1 " >  
- 	 	 < r e p o r t t y p e > S T D - 1 2 < / r e p o r t t y p e >  
- 	 	 < r e p o r t d e s c r i p t i o n > S t a n d a r d   1 2   L e a d   R e p o r t < / r e p o r t d e s c r i p t i o n >  
- 	 	 < r e p o r t f o r m a t   e x t e n d e d m e a s f l a g = " F a l s e "   p r i n t t r u n c a t i o n f l a g = " F a l s e " >  
- 	 	 	 < i n t e r p r e t a t i o n f o r m a t > I n t e r p r e t a t i o n s   a n d   r e a s o n s < / i n t e r p r e t a t i o n f o r m a t >  
- 	 	 	 < w a v e f o r m f o r m a t   l e a d s e q u e n c e = " S t a n d a r d "   t i m e s e q u e n c e = " C o n t i n u o u s " >  
- 	 	 	 	 < m a i n w a v e f o r m f o r m a t   n r o w = " 3 "   n c o l u m n = " 4 " > I   I I   I I I   a V R   a V L   a V F   V 1   V 2   V 3   V 4   V 5   V 6 < / m a i n w a v e f o r m f o r m a t >  
- 	 	 	 	 < r h y t h m w a v e f o r m f o r m a t   n r h y t h m = " 1 " > I I < / r h y t h m w a v e f o r m f o r m a t >  
- 	 	 	 < / w a v e f o r m f o r m a t >  
- 	 	 < / r e p o r t f o r m a t >  
- 	 	 < r e p o r t g a i n >  
- 	 	 	 < a m p l i t u d e g a i n   u n i t = " m m / m v " >  
- 	 	 	 	 < o v e r a l l g a i n > 1 0 . 0 0 < / o v e r a l l g a i n >  
- 	 	 	 < / a m p l i t u d e g a i n >  
- 	 	 	 < t i m e g a i n   u n i t = " m m / s " > 2 5 . 0 0 < / t i m e g a i n >  
- 	 	 < / r e p o r t g a i n >  
- 	 	 < r e p o r t b a n d w i d t h >  
- 	 	 	 < h i g h p a s s f i l t e r s e t t i n g > 0 . 1 5 < / h i g h p a s s f i l t e r s e t t i n g >  
- 	 	 	 < l o w p a s s f i l t e r s e t t i n g > 1 5 0 < / l o w p a s s f i l t e r s e t t i n g >  
- 	 	 	 < n o t c h f i l t e r s e t t i n g > 6 0 < / n o t c h f i l t e r s e t t i n g >  
- 	 	 	 < n o t c h h a r m o n i c s s e t t i n g > N o n e < / n o t c h h a r m o n i c s s e t t i n g >  
- 	 	 	 < a r t i f a c t f i l t e r f l a g > F a l s e < / a r t i f a c t f i l t e r f l a g >  
- 	 	 	 < h y s t e r i s i s f i l t e r s f l a g > F a l s e < / h y s t e r i s i s f i l t e r s f l a g >  
- 	 	 < / r e p o r t b a n d w i d t h >  
- 	 < / r e p o r t i n f o >  
- 	 < d a t a a c q u i s i t i o n   d a t e = " 2 0 0 7 - 0 8 - 0 6 "   t i m e = " 1 3 : 0 1 : 5 1 "   s t a t f l a g = " F a l s e " >  
- 	 	 < m a c h i n e   m a c h i n e i d = " "   d e t a i l d e s c r i p t i o n = " P h i l i p s   M e d i c a l   P r o d u c t s : M 4 9 9 4 : " > P a g e W r i t e r   T r i m < / m a c h i n e >  
- 	 	 < a c q u i r e r >  
- 	 	 	 < e n c o u n t e r i d > < / e n c o u n t e r i d >  
- 	 	 	 < o p e r a t o r i d > < / o p e r a t o r i d >  
- 	 	 	 < e d i t i n g o p e r a t o r i d / >  
- 	 	 	 < r o o m > < / r o o m >  
- 	 	 	 < d e p a r t m e n t i d > < / d e p a r t m e n t i d >  
- 	 	 	 < d e p a r t m e n t n a m e > K C < / d e p a r t m e n t n a m e >  
- 	 	 	 < i n s t i t u t i o n i d > < / i n s t i t u t i o n i d >  
- 	 	 	 < i n s t i t u t i o n n a m e > X e n d o   D r u g   D e v e l o p m e n t   B . V . < / i n s t i t u t i o n n a m e >  
- 	 	 	 < i n s t i t u t i o n l o c a t i o n i d > < / i n s t i t u t i o n l o c a t i o n i d >  
- 	 	 	 < i n s t i t u t i o n l o c a t i o n n a m e > K C < / i n s t i t u t i o n l o c a t i o n n a m e >  
- 	 	 	 < o r d e r i n g c l i n i c i a n n a m e > < / o r d e r i n g c l i n i c i a n n a m e >  
- 	 	 	 < o r d e r i n g c l i n i c i a n U P I N > < / o r d e r i n g c l i n i c i a n U P I N >  
- 	 	 < / a c q u i r e r >  
- 	 	 < s i g n a l c h a r a c t e r i s t i c s >  
- 	 	 	 < s a m p l i n g r a t e > 5 0 0 < / s a m p l i n g r a t e >  
- 	 	 	 < s i g n a l r e s o l u t i o n > 5 < / s i g n a l r e s o l u t i o n >  
- 	 	 	 < s i g n a l b a n d w i d t h > 0 . 0 5 - 1 5 0 < / s i g n a l b a n d w i d t h >  
- 	 	 	 < a c s e t t i n g > 6 0 < / a c s e t t i n g >  
- 	 	 	 < a c q u i s i t i o n t y p e > S T D - 1 2 < / a c q u i s i t i o n t y p e >  
- 	 	 	 < b i t s p e r s a m p l e > 1 6 < / b i t s p e r s a m p l e >  
- 	 	 	 < s i g n a l o f f s e t > 0 < / s i g n a l o f f s e t >  
- 	 	 	 < s i g n a l s i g n e d > T r u e < / s i g n a l s i g n e d >  
- 	 	 	 < n u m b e r c h a n n e l s a l l o c a t e d > 1 2 < / n u m b e r c h a n n e l s a l l o c a t e d >  
- 	 	 	 < n u m b e r c h a n n e l s v a l i d > 1 2 < / n u m b e r c h a n n e l s v a l i d >  
- 	 	 	 < l e a d s e t > S T D - 1 2 < / l e a d s e t >  
- 	 	 < / s i g n a l c h a r a c t e r i s t i c s >  
- 	 < / d a t a a c q u i s i t i o n >  
- 	 < p a t i e n t   c r i t e r i a v e r s i o n f o r p a t i e n t d a t a = " 0 A " >  
- 	 	 < g e n e r a l p a t i e n t d a t a >  
- 	 	 	 < p a t i e n t i d > 0 7 0 9 8 3 < / p a t i e n t i d >  
- 	 	 	 < v i p e r u n i q u e p a t i e n t i d / >  
- 	 	 	 < n a m e >  
- 	 	 	 	 < l a s t n a m e > 0 6 0 2 8 4 - 0 7 0 9 8 3 < / l a s t n a m e >  
- 	 	 	 	 < f i r s t n a m e > M / 1 0 1 0 5 7 / 0 1   J W O < / f i r s t n a m e >  
- 	 	 	 	 < m i d d l e n a m e > < / m i d d l e n a m e >  
- 	 	 	 < / n a m e >  
- 	 	 	 < a g e   d e f a u l t a g e = " 5 0 " >  
- 	 	 	 	 < d a t e o f b i r t h > 1 9 8 2 - 0 5 - 0 7 < / d a t e o f b i r t h >  
- 	 	 	 < / a g e >  
- 	 	 	 < p a c e s t a t u s > U n k n o w n < / p a c e s t a t u s >  
- 	 	 	 < s e x > M a l e < / s e x >  
- 	 	 	 < h e i g h t >  
- 	 	 	 	 < c m / >  
- 	 	 	 < / h e i g h t >  
- 	 	 	 < w e i g h t >  
- 	 	 	 	 < k g / >  
- 	 	 	 < / w e i g h t >  
- 	 	 < / g e n e r a l p a t i e n t d a t a >  
- 	 	 < p a t i e n t m e d i c a l d a t a >  
- 	 	 	 < b l o o d p r e s s u r e >  
- 	 	 	 	 < s y s t o l i c >  
- 	 	 	 	 	 < m m H g / >  
- 	 	 	 	 < / s y s t o l i c >  
- 	 	 	 	 < d i a s t o l i c >  
- 	 	 	 	 	 < m m H g / >  
- 	 	 	 	 < / d i a s t o l i c >  
- 	 	 	 < / b l o o d p r e s s u r e >  
- 	 	 < / p a t i e n t m e d i c a l d a t a >  
- 	 < / p a t i e n t >  
- 	 < m e a s u r e m e n t s   d a t e = " 2 0 0 7 - 0 8 - 0 6 "   t i m e = " 1 3 : 0 1 : 5 1 "   m e a s u r e m e n t v e r s i o n = " 8 " >  
- 	 	 < g l o b a l m e a s u r e m e n t s   f i x e d m u l t p f l a g = " T r u e "   m u l t p t e s t v a l i d f l a g = " T r u e "   q r s l i k e a r t f f l a g = " F a l s e "   p a c e b e a t m e a s f l a g = " F a l s e " >  
- 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 < p a c e m o d e s / >  
- 	 	 	 < p a c e m a l f / >  
- 	 	 	 < p a c e m i s c / >  
- 	 	 	 < e c t o p i c r h y t h m / >  
- 	 	 	 < q t i n t d i s p e r s i o n > 6 8 < / q t i n t d i s p e r s i o n >  
- 	 	 	 < n u m b e r o f c o m p l e x e s > 9 < / n u m b e r o f c o m p l e x e s >  
- 	 	 	 < n u m b e r o f g r o u p s > 1 < / n u m b e r o f g r o u p s >  
- 	 	 	 < b e a t c l a s s i f i c a t i o n > 1   1   1   1   1   1   1   1   1 < / b e a t c l a s s i f i c a t i o n >  
- 	 	 	 < q a m e s s a g e c o d e s > < q a m e s s a g e c o d e > A c c e p t a b l e   t r a c e < / q a m e s s a g e c o d e > < / q a m e s s a g e c o d e s >  
- 	 	 	 < q a a c t i o n c o d e > E C G   O K < / q a a c t i o n c o d e >  
- 	 	 	 < p o n > 3 8 6 2 < / p o n >  
- 	 	 	 < q r s o n > 3 9 6 0 < / q r s o n >  
- 	 	 	 < q r s o f f > 4 0 0 0 < / q r s o f f >  
- 	 	 	 < t o n > 4 0 6 4 < / t o n >  
- 	 	 	 < t o f f > 4 2 1 6 < / t o f f >  
- 	 	 	 < p f r o n t a x i s > - 1 7 < / p f r o n t a x i s >  
- 	 	 	 < p h o r i z a x i s > 3 8 < / p h o r i z a x i s >  
- 	 	 	 < i 4 0 f r o n t a x i s > 5 0 < / i 4 0 f r o n t a x i s >  
- 	 	 	 < i 4 0 h o r i z a x i s > 2 7 < / i 4 0 h o r i z a x i s >  
- 	 	 	 < q r s f r o n t a x i s > 9 0 < / q r s f r o n t a x i s >  
- 	 	 	 < q r s h o r i z a x i s > - 2 6 < / q r s h o r i z a x i s >  
- 	 	 	 < t 4 0 f r o n t a x i s > 1 0 3 < / t 4 0 f r o n t a x i s >  
- 	 	 	 < t 4 0 h o r i z a x i s > - 5 2 < / t 4 0 h o r i z a x i s >  
- 	 	 	 < s t f r o n t a x i s > 3 8 < / s t f r o n t a x i s >  
- 	 	 	 < s t h o r i z a x i s > 6 9 < / s t h o r i z a x i s >  
- 	 	 	 < t f r o n t a x i s > 5 0 < / t f r o n t a x i s >  
- 	 	 	 < t h o r i z a x i s > 4 9 < / t h o r i z a x i s >  
- 	 	 	 < a t r i a l r a t e > 5 9 < / a t r i a l r a t e >  
- 	 	 	 < l o w v e n t r a t e > 5 7 < / l o w v e n t r a t e >  
- 	 	 	 < m e a n v e n t r a t e > 6 1 < / m e a n v e n t r a t e >  
- 	 	 	 < h i g h v e n t r a t e > 6 3 < / h i g h v e n t r a t e >  
- 	 	 	 < m e a n p r i n t > 1 8 0 < / m e a n p r i n t >  
- 	 	 	 < m e a n p r s e g > 7 8 < / m e a n p r s e g >  
- 	 	 	 < m e a n q r s d u r > 8 6 < / m e a n q r s d u r >  
- 	 	 	 < m e a n q t i n t > 4 5 2 < / m e a n q t i n t >  
- 	 	 	 < m e a n q t c > 4 5 5 < / m e a n q t c >  
- 	 	 	 < d e l t a w a v e c o u n t > 0 < / d e l t a w a v e c o u n t >  
- 	 	 	 < d e l t a w a v e p e r c e n t > 0 < / d e l t a w a v e p e r c e n t >  
- 	 	 	 < b i g e m i n y c o u n t > 0 < / b i g e m i n y c o u n t >  
- 	 	 	 < b i g e m i n y s t r i n g > 0 < / b i g e m i n y s t r i n g >  
- 	 	 	 < t r i g e m i n y c o u n t > 0 < / t r i g e m i n y c o u n t >  
- 	 	 	 < t r i g e m i n y s t r i n g > 0 < / t r i g e m i n y s t r i n g >  
- 	 	 	 < w e n c k c o u n t > 0 < / w e n c k c o u n t >  
- 	 	 	 < w e n c k s t r i n g > 0 < / w e n c k s t r i n g >  
- 	 	 	 < f l u t t e r f i b c o u n t > 0 < / f l u t t e r f i b c o u n t >  
- 	 	 	 < q r s i n i t a n g l e > 7 5 < / q r s i n i t a n g l e >  
- 	 	 	 < q r s i n i t m a g > 1 1 5 < / q r s i n i t m a g >  
- 	 	 	 < q r s m a x a n g l e > 3 5 6 < / q r s m a x a n g l e >  
- 	 	 	 < q r s m a x m a g > 1 3 7 7 < / q r s m a x m a g >  
- 	 	 	 < q r s t e r m a n g l e > 2 4 3 < / q r s t e r m a n g l e >  
- 	 	 	 < q r s t e r m m a g > 7 8 2 < / q r s t e r m m a g >  
- 	 	 	 < q r s r o t a t i o n > - 1 0 0 < / q r s r o t a t i o n >  
- 	 	 	 < g l o b a l r e s e r v e d / >  
- 	 	 < / g l o b a l m e a s u r e m e n t s >  
- 	 	 < g r o u p m e a s u r e m e n t s >  
- 	 	 	 < g r o u p m e a s u r e m e n t   g r o u p n u m b e r = " 1 "   i n t e r p f l a g = " F a l s e "   s i n u s f l a g = " F a l s e "   p r p r o g f l a g = " F a l s e "   w e n c k f l a g = " F a l s e "   b i g f l a g = " F a l s e "   t r i g f l a g = " F a l s e "   a b e r r a n t f l a g = " F a l s e "   m u l t p t e s t f l a g = " T r u e "   q r s m e a s f l a g = " T r u e "   a t r i a l p a c e f l a g = " F a l s e "   v e n t d u a l p a c e f l a g = " F a l s e " >  
- 	 	 	 	 < m e m b e r c o u n t > 9 < / m e m b e r c o u n t >  
- 	 	 	 	 < m e m b e r p e r c e n t > 1 0 0 < / m e m b e r p e r c e n t >  
- 	 	 	 	 < l o n g e s t r u n > 9 < / l o n g e s t r u n >  
- 	 	 	 	 < m e a n q r s d u r > 8 0 < / m e a n q r s d u r >  
- 	 	 	 	 < l o w v e n t r a t e > 5 7 < / l o w v e n t r a t e >  
- 	 	 	 	 < m e a n v e n t r a t e > 6 1 < / m e a n v e n t r a t e >  
- 	 	 	 	 < h i g h v e n t r a t e > 6 3 < / h i g h v e n t r a t e >  
- 	 	 	 	 < v e n t r a t e s t d d e v > 2 < / v e n t r a t e s t d d e v >  
- 	 	 	 	 < m e a n r r i n t > 9 8 4 < / m e a n r r i n t >  
- 	 	 	 	 < a t r i a l r a t e > 5 9 < / a t r i a l r a t e >  
- 	 	 	 	 < a t r i a l r a t e s t d d e v > 2 < / a t r i a l r a t e s t d d e v >  
- 	 	 	 	 < a v g p c o u n t > 1 < / a v g p c o u n t >  
- 	 	 	 	 < n o t a v g p b e a t s > 0 < / n o t a v g p b e a t s >  
- 	 	 	 	 < l o w p r i n t > < / l o w p r i n t >  
- 	 	 	 	 < m e a n p r i n t > 1 7 2 < / m e a n p r i n t >  
- 	 	 	 	 < h i g h p r i n t > 1 8 0 < / h i g h p r i n t >  
- 	 	 	 	 < p r i n t s t d d e v > 4 < / p r i n t s t d d e v >  
- 	 	 	 	 < m e a n p r s e g > 9 2 < / m e a n p r s e g >  
- 	 	 	 	 < m e a n q t i n t > 4 1 6 < / m e a n q t i n t >  
- 	 	 	 	 < m e a n q t s e g > 3 3 6 < / m e a n q t s e g >  
- 	 	 	 	 < c o m p p a u s e c o u n t > 0 < / c o m p p a u s e c o u n t >  
- 	 	 	 	 < g r o u p r e s e r v e d / >  
- 	 	 	 < / g r o u p m e a s u r e m e n t >  
- 	 	 < / g r o u p m e a s u r e m e n t s >  
- 	 	 < l e a d m e a s u r e m e n t s >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " I "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 9 0 < / p a m p >  
- 	 	 	 	 < p d u r > 8 8 < / p d u r >  
- 	 	 	 	 < p a r e a > 1 3 < / p a r e a >  
- 	 	 	 	 < p p a m p > 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 8 9 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > 1 3 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > 0 < / q a m p >  
- 	 	 	 	 < q d u r > < / q d u r >  
- 	 	 	 	 < r a m p > 2 4 0 < / r a m p >  
- 	 	 	 	 < r d u r > 4 8 < / r d u r >  
- 	 	 	 	 < s a m p > - 3 5 0 < / s a m p >  
- 	 	 	 	 < s d u r > 2 8 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 3 2 < / v a t >  
- 	 	 	 	 < q r s p p k > 5 9 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 7 6 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > 0 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 4 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 8 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 1 1 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 1 2 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 1 0 4 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 1 8 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 3 5 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 3 6 < / t d u r >  
- 	 	 	 	 < t a r e a > 1 1 3 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 3 6 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 1 1 3 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 8 4 < / p r i n t >  
- 	 	 	 	 < p r s e g > 8 8 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 4 0 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " I I "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 6 0 < / p a m p >  
- 	 	 	 	 < p d u r > 1 2 0 < / p d u r >  
- 	 	 	 	 < p a r e a > 5 < / p a r e a >  
- 	 	 	 	 < p p a m p > - 2 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > 8 4 < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 8 8 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > - 3 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > 2 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > - 9 0 < / q a m p >  
- 	 	 	 	 < q d u r > 1 6 < / q d u r >  
- 	 	 	 	 < r a m p > 1 4 1 0 < / r a m p >  
- 	 	 	 	 < r d u r > 4 4 < / r d u r >  
- 	 	 	 	 < s a m p > - 3 3 0 < / s a m p >  
- 	 	 	 	 < s d u r > 1 6 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 4 4 < / v a t >  
- 	 	 	 	 < q r s p p k > 1 7 4 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 7 6 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > 5 3 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 5 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 8 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 1 2 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 1 3 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 8 0 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 1 8 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 5 4 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 6 8 < / t d u r >  
- 	 	 	 	 < t a r e a > 1 7 9 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 6 8 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 1 7 9 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 7 2 < / p r i n t >  
- 	 	 	 	 < p r s e g > 1 6 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 5 2 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " I I I "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 1 0 < / p a m p >  
- 	 	 	 	 < p d u r > 2 8 < / p d u r >  
- 	 	 	 	 < p a r e a > 1 < / p a r e a >  
- 	 	 	 	 < p p a m p > - 6 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > 1 2 4 < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 1 0 1 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > - 1 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > - 9 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > - 1 2 0 < / q a m p >  
- 	 	 	 	 < q d u r > 2 0 < / q d u r >  
- 	 	 	 	 < r a m p > 1 3 7 0 < / r a m p >  
- 	 	 	 	 < r d u r > 4 4 < / r d u r >  
- 	 	 	 	 < s a m p > - 1 7 0 < / s a m p >  
- 	 	 	 	 < s d u r > 1 2 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 4 4 < / v a t >  
- 	 	 	 	 < q r s p p k > 1 5 4 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 7 6 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > 5 4 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 1 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 2 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 2 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 3 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 1 1 6 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 3 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 2 1 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 9 6 < / t d u r >  
- 	 	 	 	 < t a r e a > 6 2 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 9 6 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 6 2 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 2 1 2 < / p r i n t >  
- 	 	 	 	 < p r s e g > 5 2 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 4 0 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " a V R "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > - 7 0 < / p a m p >  
- 	 	 	 	 < p d u r > 9 2 < / p d u r >  
- 	 	 	 	 < p a r e a > - 8 < / p a r e a >  
- 	 	 	 	 < p p a m p > 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 8 4 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > - 8 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > 0 < / q a m p >  
- 	 	 	 	 < q d u r > < / q d u r >  
- 	 	 	 	 < r a m p > 4 0 < / r a m p >  
- 	 	 	 	 < r d u r > 2 4 < / r d u r >  
- 	 	 	 	 < s a m p > - 8 1 0 < / s a m p >  
- 	 	 	 	 < s d u r > 3 6 < / s d u r >  
- 	 	 	 	 < r p a m p > 3 0 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > 2 4 < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 7 2 < / v a t >  
- 	 	 	 	 < q r s p p k > 1 1 1 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 8 4 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > - 2 7 < / q r s a r e a >  
- 	 	 	 	 < s t o n > - 4 0 < / s t o n >  
- 	 	 	 	 < s t m i d > - 9 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > - 1 1 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > - 1 4 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 1 1 2 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > - 1 9 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > - 4 5 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 3 6 < / t d u r >  
- 	 	 	 	 < t a r e a > - 1 4 5 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 3 6 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > - 1 4 5 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 6 4 < / p r i n t >  
- 	 	 	 	 < p r s e g > 7 2 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 5 6 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " a V L "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 6 0 < / p a m p >  
- 	 	 	 	 < p d u r > 1 2 0 < / p d u r >  
- 	 	 	 	 < p a r e a > 1 0 < / p a r e a >  
- 	 	 	 	 < p p a m p > 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 9 7 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > 1 0 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > 0 < / q a m p >  
- 	 	 	 	 < q d u r > < / q d u r >  
- 	 	 	 	 < r a m p > 7 0 < / r a m p >  
- 	 	 	 	 < r d u r > 2 8 < / r d u r >  
- 	 	 	 	 < s a m p > - 6 2 0 < / s a m p >  
- 	 	 	 	 < s d u r > 4 0 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 1 6 < / v a t >  
- 	 	 	 	 < q r s p p k > 6 9 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 6 8 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > - 2 7 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 1 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 3 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 3 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 4 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 1 3 6 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 7 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 8 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 2 8 < / t d u r >  
- 	 	 	 	 < t a r e a > 2 9 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 2 8 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 2 9 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 8 4 < / p r i n t >  
- 	 	 	 	 < p r s e g > 5 6 < / p r s e g >  
- 	 	 	 	 < q t i n t > 3 9 6 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " a V F "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > - 3 0 < / p a m p >  
- 	 	 	 	 < p d u r > 2 4 < / p d u r >  
- 	 	 	 	 < p a r e a > - 3 < / p a r e a >  
- 	 	 	 	 < p p a m p > 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 6 1 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > - 3 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > - 1 1 0 < / q a m p >  
- 	 	 	 	 < q d u r > 2 0 < / q d u r >  
- 	 	 	 	 < r a m p > 1 4 3 0 < / r a m p >  
- 	 	 	 	 < r d u r > 4 0 < / r d u r >  
- 	 	 	 	 < s a m p > - 2 5 0 < / s a m p >  
- 	 	 	 	 < s d u r > 1 6 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 4 4 < / v a t >  
- 	 	 	 	 < q r s p p k > 1 6 8 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 7 6 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > 5 4 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 3 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 5 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 7 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 6 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 8 0 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 1 1 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 3 8 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 7 2 < / t d u r >  
- 	 	 	 	 < t a r e a > 1 2 7 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 7 2 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 1 2 7 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 8 8 < / p r i n t >  
- 	 	 	 	 < p r s e g > 2 8 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 5 2 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 1 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N e g a t i v e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 2 0 < / p a m p >  
- 	 	 	 	 < p d u r > 3 2 < / p d u r >  
- 	 	 	 	 < p a r e a > 1 < / p a r e a >  
- 	 	 	 	 < p p a m p > - 4 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > 4 8 < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 7 1 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > - 3 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > - 2 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > 0 < / q a m p >  
- 	 	 	 	 < q d u r > < / q d u r >  
- 	 	 	 	 < r a m p > 1 3 0 < / r a m p >  
- 	 	 	 	 < r d u r > 3 2 < / r d u r >  
- 	 	 	 	 < s a m p > - 5 5 0 < / s a m p >  
- 	 	 	 	 < s d u r > 5 6 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 2 0 < / v a t >  
- 	 	 	 	 < q r s p p k > 6 8 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 8 8 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > - 4 6 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 6 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 6 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 6 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 6 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 5 6 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > - 1 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 5 0 < / t a m p >  
- 	 	 	 	 < t d u r > 1 0 4 < / t d u r >  
- 	 	 	 	 < t a r e a > 1 4 < / t a r e a >  
- 	 	 	 	 < t p a m p > - 1 9 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 3 2 8 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > 2 2 4 < / t p d u r >  
- 	 	 	 	 < t p a r e a > - 3 9 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > - 2 5 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 7 6 < / p r i n t >  
- 	 	 	 	 < p r s e g > 8 8 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 3 6 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 2 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 1 1 0 < / p a m p >  
- 	 	 	 	 < p d u r > 1 2 0 < / p d u r >  
- 	 	 	 	 < p a r e a > 8 < / p a r e a >  
- 	 	 	 	 < p p a m p > 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 6 1 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > 8 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > 0 < / q a m p >  
- 	 	 	 	 < q d u r > < / q d u r >  
- 	 	 	 	 < r a m p > 2 9 0 < / r a m p >  
- 	 	 	 	 < r d u r > 3 2 < / r d u r >  
- 	 	 	 	 < s a m p > - 2 0 3 0 < / s a m p >  
- 	 	 	 	 < s d u r > 5 6 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 2 0 < / v a t >  
- 	 	 	 	 < q r s p p k > 2 3 2 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 8 8 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > - 1 5 4 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 2 1 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 3 5 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 3 5 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 4 7 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 1 2 8 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 4 1 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 6 6 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 8 8 < / t d u r >  
- 	 	 	 	 < t a r e a > 2 9 4 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 8 8 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 2 9 4 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 7 6 < / p r i n t >  
- 	 	 	 	 < p r s e g > 1 1 2 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 5 6 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 3 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 9 0 < / p a m p >  
- 	 	 	 	 < p d u r > 6 4 < / p d u r >  
- 	 	 	 	 < p a r e a > 7 < / p a r e a >  
- 	 	 	 	 < p p a m p > 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 7 0 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > 7 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > 0 < / q a m p >  
- 	 	 	 	 < q d u r > < / q d u r >  
- 	 	 	 	 < r a m p > 3 5 0 < / r a m p >  
- 	 	 	 	 < r d u r > 4 0 < / r d u r >  
- 	 	 	 	 < s a m p > - 1 9 0 0 < / s a m p >  
- 	 	 	 	 < s d u r > 4 8 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 3 2 < / v a t >  
- 	 	 	 	 < q r s p p k > 2 2 5 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 8 8 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > - 8 4 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 1 9 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 3 9 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 4 0 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 5 5 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 1 2 0 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 4 9 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 9 1 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 8 4 < / t d u r >  
- 	 	 	 	 < t a r e a > 3 7 0 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 8 4 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 3 7 0 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 8 0 < / p r i n t >  
- 	 	 	 	 < p r s e g > 9 2 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 6 0 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 4 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 7 0 < / p a m p >  
- 	 	 	 	 < p d u r > 9 2 < / p d u r >  
- 	 	 	 	 < p a r e a > 6 < / p a r e a >  
- 	 	 	 	 < p p a m p > 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 6 9 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > 6 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > - 2 0 < / q a m p >  
- 	 	 	 	 < q d u r > 1 2 < / q d u r >  
- 	 	 	 	 < r a m p > 1 8 1 0 < / r a m p >  
- 	 	 	 	 < r d u r > 4 0 < / r d u r >  
- 	 	 	 	 < s a m p > - 1 2 2 0 < / s a m p >  
- 	 	 	 	 < s d u r > 2 8 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 4 0 < / v a t >  
- 	 	 	 	 < q r s p p k > 3 0 3 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 8 0 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > 4 5 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 1 2 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 2 5 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 2 7 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 3 7 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 1 0 0 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 4 3 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 1 0 2 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 9 6 < / t d u r >  
- 	 	 	 	 < t a r e a > 3 6 3 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 9 6 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 3 6 3 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 8 0 < / p r i n t >  
- 	 	 	 	 < p r s e g > 8 8 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 4 8 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 5 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 5 0 < / p a m p >  
- 	 	 	 	 < p d u r > 9 6 < / p d u r >  
- 	 	 	 	 < p a r e a > 6 < / p a r e a >  
- 	 	 	 	 < p p a m p > 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 7 1 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > 6 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > - 1 2 0 < / q a m p >  
- 	 	 	 	 < q d u r > 2 4 < / q d u r >  
- 	 	 	 	 < r a m p > 1 8 3 0 < / r a m p >  
- 	 	 	 	 < r d u r > 3 6 < / r d u r >  
- 	 	 	 	 < s a m p > - 4 2 0 < / s a m p >  
- 	 	 	 	 < s d u r > 2 4 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 4 8 < / v a t >  
- 	 	 	 	 < q r s p p k > 2 2 5 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 8 4 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > 6 6 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 4 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 1 3 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 1 4 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 2 2 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 1 2 0 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 3 0 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 7 5 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 3 2 < / t d u r >  
- 	 	 	 	 < t a r e a > 2 2 2 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 3 2 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 2 2 2 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 6 4 < / p r i n t >  
- 	 	 	 	 < p r s e g > 7 6 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 6 4 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 6 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
- 	 	 	 	 < p a c e p u l s e s / >  
- 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
- 	 	 	 	 	 < i n o p s / >  
- 	 	 	 	 	 < s a t u r a t i o n s / >  
- 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
- 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
- 	 	 	 	 < p a m p > 4 0 < / p a m p >  
- 	 	 	 	 < p d u r > 9 2 < / p d u r >  
- 	 	 	 	 < p a r e a > 4 < / p a r e a >  
- 	 	 	 	 < p p a m p > 0 < / p p a m p >  
- 	 	 	 	 < p p d u r > < / p p d u r >  
- 	 	 	 	 < p p p p d u r > 6 2 < / p p p p d u r >  
- 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
- 	 	 	 	 < p p p p a r e a > 4 < / p p p p a r e a >  
- 	 	 	 	 < q a m p > - 1 1 0 < / q a m p >  
- 	 	 	 	 < q d u r > 2 0 < / q d u r >  
- 	 	 	 	 < r a m p > 1 2 6 0 < / r a m p >  
- 	 	 	 	 < r d u r > 4 0 < / r d u r >  
- 	 	 	 	 < s a m p > - 1 6 0 < / s a m p >  
- 	 	 	 	 < s d u r > 2 0 < / s d u r >  
- 	 	 	 	 < r p a m p > 0 < / r p a m p >  
- 	 	 	 	 < r p d u r > < / r p d u r >  
- 	 	 	 	 < s p a m p > 0 < / s p a m p >  
- 	 	 	 	 < s p d u r > < / s p d u r >  
- 	 	 	 	 < v a t > 4 4 < / v a t >  
- 	 	 	 	 < q r s p p k > 1 4 2 0 < / q r s p p k >  
- 	 	 	 	 < q r s d u r > 8 0 < / q r s d u r >  
- 	 	 	 	 < q r s a r e a > 5 1 < / q r s a r e a >  
- 	 	 	 	 < s t o n > 2 0 < / s t o n >  
- 	 	 	 	 < s t m i d > 7 0 < / s t m i d >  
- 	 	 	 	 < s t 8 0 > 8 0 < / s t 8 0 >  
- 	 	 	 	 < s t e n d > 1 2 0 < / s t e n d >  
- 	 	 	 	 < s t d u r > 1 2 0 < / s t d u r >  
- 	 	 	 	 < s t s l o p e > 1 9 < / s t s l o p e >  
- 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
- 	 	 	 	 < t a m p > 4 9 0 < / t a m p >  
- 	 	 	 	 < t d u r > 2 3 6 < / t d u r >  
- 	 	 	 	 < t a r e a > 1 4 2 < / t a r e a >  
- 	 	 	 	 < t p a m p > 0 < / t p a m p >  
- 	 	 	 	 < t p t p d u r > 2 3 6 < / t p t p d u r >  
- 	 	 	 	 < t p d u r > < / t p d u r >  
- 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
- 	 	 	 	 < t p t p a r e a > 1 4 2 < / t p t p a r e a >  
- 	 	 	 	 < p r i n t > 1 7 2 < / p r i n t >  
- 	 	 	 	 < p r s e g > 8 0 < / p r s e g >  
- 	 	 	 	 < q t i n t > 4 6 0 < / q t i n t >  
- 	 	 	 < / l e a d m e a s u r e m e n t >  
- 	 	 < / l e a d m e a s u r e m e n t s >  
- 	 < / m e a s u r e m e n t s >  
- 	 < i n t e r p r e t a t i o n s >  
- 	 	 < i n t e r p r e t a t i o n   d a t e = " 2 0 0 7 - 0 8 - 0 6 "   t i m e = " 1 3 : 0 1 : 5 1 "   c r i t e r i a v e r s i o n = " 0 A "   c r i t e r i a v e r s i o n d a t e = " 2 0 0 2 - 0 3 - 1 5 " >  
- 	 	 	 < i n t e r p r e t a t i o n d a t a s t r u c t u r e / >  
- 	 	 	 < i n t e r p r e t a t i o n m e a s u r e m e n t s   a r r h y f l a g = " F a l s e "   e d i t e d f l a g = " F a l s e " >  
- 	 	 	 	 < h e a r t r a t e   e d i t e d f l a g = " F a l s e " > 6 1 < / h e a r t r a t e >  
- 	 	 	 	 < m e a n p r i n t   e d i t e d f l a g = " F a l s e " > 1 8 0 < / m e a n p r i n t >  
- 	 	 	 	 < m e a n q r s d u r   e d i t e d f l a g = " F a l s e " > 8 6 < / m e a n q r s d u r >  
- 	 	 	 	 < m e a n q t i n t   e d i t e d f l a g = " F a l s e " > 4 5 2 < / m e a n q t i n t >  
- 	 	 	 	 < m e a n q t c   e d i t e d f l a g = " F a l s e " > 4 5 5 < / m e a n q t c >  
- 	 	 	 	 < p f r o n t a x i s   e d i t e d f l a g = " F a l s e " > - 1 7 < / p f r o n t a x i s >  
- 	 	 	 	 < i 4 0 f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 5 0 < / i 4 0 f r o n t a x i s >  
- 	 	 	 	 < t 4 0 f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 1 0 3 < / t 4 0 f r o n t a x i s >  
- 	 	 	 	 < q r s f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 9 0 < / q r s f r o n t a x i s >  
- 	 	 	 	 < s t f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 3 8 < / s t f r o n t a x i s >  
- 	 	 	 	 < t f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 5 0 < / t f r o n t a x i s >  
- 	 	 	 	 < p h o r i z a x i s   e d i t e d f l a g = " F a l s e " > 3 8 < / p h o r i z a x i s >  
- 	 	 	 	 < i 4 0 h o r i z a x i s   e d i t e d f l a g = " F a l s e " > 2 7 < / i 4 0 h o r i z a x i s >  
- 	 	 	 	 < t 4 0 h o r i z a x i s   e d i t e d f l a g = " F a l s e " > - 5 2 < / t 4 0 h o r i z a x i s >  
- 	 	 	 	 < q r s h o r i z a x i s   e d i t e d f l a g = " F a l s e " > - 2 6 < / q r s h o r i z a x i s >  
- 	 	 	 	 < s t h o r i z a x i s   e d i t e d f l a g = " F a l s e " > 6 9 < / s t h o r i z a x i s >  
- 	 	 	 	 < t h o r i z a x i s   e d i t e d f l a g = " F a l s e " > 4 9 < / t h o r i z a x i s >  
- 	 	 	 < / i n t e r p r e t a t i o n m e a s u r e m e n t s >  
- 	 	 	 < m d s i g n a t u r e l i n e > N i e t   g e c o n t r o l e e r d e   d i a g n o s e < / m d s i g n a t u r e l i n e >  
- 	 	 	 < s e v e r i t y   c o d e = " O N " > - O v e r i g e n s   N o r m a a l   E C G - < / s e v e r i t y >  
- 	 	 	 < s t a t e m e n t   e d i t e d f l a g = " F a l s e " >  
- 	 	 	 	 < s t a t e m e n t c o d e > S R         < / s t a t e m e n t c o d e >  
- 	 	 	 	 < l e f t s t a t e m e n t > S i n u s   r i t m e < / l e f t s t a t e m e n t >  
- 	 	 	 	 < r i g h t s t a t e m e n t > n o r m a l e   P   a s ,   V - f r e q .     5 0 -   9 9 < / r i g h t s t a t e m e n t >  
- 	 	 	 < / s t a t e m e n t >  
- 	 	 	 < s t a t e m e n t   e d i t e d f l a g = " F a l s e " >  
- 	 	 	 	 < s t a t e m e n t c o d e > A X R       < / s t a t e m e n t c o d e >  
- 	 	 	 	 < l e f t s t a t e m e n t > L i c h t   a f w i j k e n d   r e c h t e r   a s   d e v i a t i e < / l e f t s t a t e m e n t >  
- 	 	 	 	 < r i g h t s t a t e m e n t > Q R S   a s   (   9 0 , 1 1 0 ) < / r i g h t s t a t e m e n t >  
- 	 	 	 < / s t a t e m e n t >  
- 	 	 	 < s t a t e m e n t   e d i t e d f l a g = " F a l s e " >  
- 	 	 	 	 < s t a t e m e n t c o d e > E R E P O L < / s t a t e m e n t c o d e >  
- 	 	 	 	 < l e f t s t a t e m e n t > S T   e l e v a t i e ,   w s l   n o r m a a l   r e p o l a r i s a t i e   p a t r o o n < / l e f t s t a t e m e n t >  
- 	 	 	 	 < r i g h t s t a t e m e n t > S T   e l e v a t i o n ,   l f t & l t ; 5 5 < / r i g h t s t a t e m e n t >  
- 	 	 	 < / s t a t e m e n t >  
- 	 	 < / i n t e r p r e t a t i o n >  
- 	 < / i n t e r p r e t a t i o n s >  
- 	 < w a v e f o r m s >  
- 	 	 < p a r s e d w a v e f o r m s   c o m p r e s s f l a g = " T r u e "   c o m p r e s s m e t h o d = " X L I "   d a t a e n c o d i n g = " B a s e 6 4 "   d u r a t i o n p e r c h a n n e l = " 1 1 0 0 0 "   n b i t s p e r s a m p l e = " 1 6 " > r Q g A A A E A A A A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I 0 k S V  
- J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F R V J U  
- 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 L w G A k P Q + E M Q Q / E E Q h G E Q P g / E U R Q / E I Q w / D Y N g  
- 4 D 0 Q B E E E Q R D E A P h C E U Q Q + E B j x A Y 1 c 2 N Y g P R B Y 8 Q 1 4 E B f m W E I P x A X N k Q / D 5 l 2 i X J o m P E J n Q / D 0 Q 2 Z  
- Y 4 Q B C E B g 1 3 Z 9 p 2 R Y l u G Q a B m x B D 1 t l 0 D 4 P W y X M P 2 c Z 5 n m 7 X x v m G D 9 n 1 x D s Q V 3 a R p W 4 Z 8 R G W a B l 2 l b  
- Z c 3 U a B x W R b d n 2 J c F c 2 y c N k F y b B o H J Y Z 5 X W b d j 2 n c V n m T c 5 y V 8 b x o W Q Z N 1 H k b s Q l 4 d t 4 W 8 c R f I A f 1  
- m 3 O c q B G P f i A m 7 b x m 2 J c V h n / g 9 d G D e Z c n L g 9 + n g e J j n 2 a V 4 1 8 i N v m i c Z k l 0 i y G n G D 5 c G N Y Z t I V b p p  
- I C f p i l y c N 8 o R f V 8 H P a N u G X a R / I f b 0 P W W j x x n O E Q R R C E Q P A + X Z s W Z Y E O 1 4 e c R B A D w Q 2 M e R n 3 E a R q G  
- y m S J 4 g Y 1 4 o A a G A I k a N f Z D Z d + I S e F 1 W O h p s Y T e M Q p q n V 1 X 9 e + d G 8 a e h Y M E K J H g Y h 2 m Q Z 5 r Z + f 6 c 2 6  
- c 5 l 2 W E S D G m b C a n y e q R W H n K E 4 K n O B 6 A h 1 c n v m S D W e m d 7 m f f d 2 n 6 q 5 + Z m i J z X q q l i Z 9 e S n H a p 5 k Y Y h  
- 1 u o S s N 9 1 w f t 9 n J Y 8 P m 1 g S Y m f Y q d J w o y p 7 O d u A 2 p q 6 e m W a + l 4 M s G i H C r q b b i f 1 c 2 I D x x J r f S a 3 t Z p  
- i I x i N z o Q X q K V 2 e c P g 1 D Q P G 9 n 1 q W H e W m 6 b o S b X m b G 0 K U Z V 8 2 K q F 8 8 K i C O W o p J m I x n O p 3 c h 1 s q w h a B  
- n 4 m x d J y p J t 6 n o S 2 L j h J c n 2 k B i s H j N q m b g O L M Q o i z 5 z y u 1 m x x i O c j Y 4 P 6 X m d s X O X 5 o 2 H E G + 8 V t O e G  
- l d S e I 5 m a g G T b m e o A j O D 3 2 0 K C H 3 q / J 7 e w r O H s a S l 4 b o F q L D h l 9 K 2 c p m G J a R m Y I Y l i K u x a 2 Y c w K R Y 6  
- h 5 c 4 b c R 2 3 g b K a q v m a I M R t m K t q m S Z K + s H F a + a H S t A f y x a V b K + + B E N i x G j G T 1 z E U Q A 4 D Q N 5 L Y y B m F d  
- 6 e p G x K 6 X h Z 7 A p i i O e I W a P l r X h m D b K x m l K + d p q p 9 e x o G Z 4 p 8 7 S p y R e + p X K G 2 s S e t V 2 P E Y Z r u 8 h A E W  
- W n M r 1 5 b J f S A s H k S h d l e l k F w p R v L v 4 2 3 s Q b p 9 t j f R x / B r f F t / f m J Z w n O r 5 2 b j p / 2 b q p s p / G O 3 w d a C  
- I 7 m 2 Y m 5 x 9 6 d U j j 3 3 N 4 1 8 H / Z e q / s a l s 8 N j p 7 9 S c V 5 + E c n C / z X A Q 1 v s K N J F 7 J 6 V 8 o + G + K / S F 3 i g 9 o I  
- y a P p W 8 D 2 T 6 I E M P B B E Z c X B D Y N w 6 D y L e W k s R K 0 6 b D d l d 1 z W h d 9 u G D u l z X A b N y a 0 p P D e l o K a r p e O n 3 Z  
- e q Y c X 0 C u P 2 X 5 3 6 M 1 X U P I 1 q s a n q n x t l 8 h t u T i J 7 f I b b 8 H F k f A v 9 r J 4 M V z r 7 P 6 7 P 7 H 8 x B 2 I 4 k h z X A i  
- F p c y b O / f y e R i q r h e y X 9 m N f o z q + O B C 0 a w a 1 j T i q x w i 3 p i q a y u G c + h P a 0 3 r d Q q l y 3 s y b r 3 N 1 j T t 3 d x  
- + 5 n X Q Q x G E N v x F Y i U Q + D c N A 6 o 9 h s Z 5 Z / X o 6 u s H W s m s M X / O 1 K e x j B K M g r 6 N H + V e L p + z 7 I G q H G / s e p 3  
- X t s 6 R 6 F 0 6 Y o P e 2 n q a e O v 8 X d 1 7 Y z q Z o Z 4 r h 4 o f 7 9 j X f q Z 7 W 5 q i t u N q m p q m i q z b N Y a K e r m G g I G b 6 y Y  
- q i V j m Z q J k 4 p z 2 F X c 0 6 K t P 2 i E I V i C 5 v T r 3 c 9 Y e i E d o 8 h 3 O m l T a 4 5 t 3 R 3 W 8 y u 5 k h H 9 t P 3 z i N z q u H W 1  
- y R 5 c U e t c R F E b R R B E h j W M D g N g 1 c P f q L X F 7 t R 2 h f G D v 2 r t 4 1 D v a F j 3 W Y L 1 F 3 K T a a h 8 M v e v c u 8 H k I O g  
- 1 3 L O f N p 1 4 l x v I 7 6 u 8 e D x Y P M f 8 D z 7 Q 8 F 3 P K g z c Y G h H J c Y k G Y 9 + 0 u g r l 3 B t v o 9 a f m R Z 1 k r I e C o 9 T e y  
- G r p 9 Z q v 9 v G K o X 6 u u P 0 w n 6 L I g W s I l w D 4 d Z d W Y p 7 g O Y o d m i 4 L L y 7 j W n 0 m u a m o X 2 v 6 b D 2 d + b n f G 5 8 e 3  
- 7 x z W E X S l N 1 Q 6 l E O x A E Z j H J X X f g 9 D c O A 7 b + i M Z X I R d C g / j 8 N e v t / w c 9 j r G p R 3 X L t L b 2 5 r S D + W v t 6 m  
- 2 Y 7 b Y X g u s q y p C g K E E P R q e 0 d 3 8 k 1 C u / 5 1 P / n q e V e B E a q S / I 8 h 5 2 D 4 W C P H + z g X V Z O S 8 6 w 3 H t 9 l L k H v  
- k u 1 I C h 2 T Y B k O w v k g 1 3 G 7 + D W / i n i 8 Z t c d j b J r f Q M N t 6 f t o m 3 U I T p T v P K 0 y l I Q D x 3 F x e n 4 Z t 7 X D X d e  
- 3 / m 2 z q u a e s G s Z 4 Z q l J c E c R Q 9 l 4 R m x 9 I O A 4 D c O u W Y a X G O E T b a 2 d / y X V 2 6 J 9 H w O n o g 8 h o m O X f h c N b a  
- 0 N m s e D 2 7 1 T Z l 4 r p j a t q b 7 M j r 3 y P c 9 X U 8 M 8 5 q Z 4 n j J J h 3 v 9 p s e 7 G K i Y 2 K L e f L Z 6 / / G s K l + H W 9 j 7 u E  
- / 0 o D C u p 2 i 0 2 z 7 z p p E w z t H t d 3 Z a E e O D n d o K b X t r + 0 A + 5 z M J F u T I q E 2 f N e r g m h t n 2 e v 6 C m R f q 4 1 2 x m  
- O k a l H P d I R m z E E R 2 X 5 w O r 5 u i X M 4 i 3 f G w + i R K Y s L W 4 n d y s N S 0 f 6 a U c D h L B e L 1 q U d 2 k a m q K f I F c u m K N  
- 1 F z X v g + 7 H W b u h V 4 u C h 3 r w 1 x d Q 2 Z s 8 A e r D a / y V 2 r Q / B 8 q e k f Z f B + R o c 6 c r G c / c e p v z i W I 4 P t N 3 X A g  
- n 1 b Q c p x m q 0 F j W K h H z K r d y A r W u n A I K 4 H y n / / 1 5 K 0 x 9 3 q C Y 2 u n z t t o 4 I d y 9 4 W h d u 9 U 2 6 j I / a p d P f k 6  
- z 2 2 b + N O W E I S B D D o P 1 2 X Q Q g 7 D X o G t f P P h E 5 a D L R x G p r E y N u 4 d E N v 4 C 3 x 4 F 3 x y r s + / h f o h 2 j Z O P m L 1  
- G p j H Q r N c v 2 d 8 d 7 H / I f 7 v + 6 1 O 2 e 8 1 m q 3 B r + k 4 R s 2 E a h p 5 p W Z o 9 s L j d 2 O H e u Z u Z H w R 8 q v j N z 4 V 0 f g 6  
- R j N / H c r 3 w s A e D T 9 O o W I 2 g a Q P Z c 2 X Z d l 2 X Z d l h I e A I 2 X Z d l 2 X Z d l 2 X Z d l 2 X Z d l 2 X Z Q I H j Z d l 2 X Z d l  
- 2 W w w A / 8 A W A o A A A E A / P 8 / w A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E  
- h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O  
- U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R Z V e P 8 A V h A F A E v P g A A 8 E E P Q 5 D s P g 9 E A R A / E 8 d R f D  
- k M w 0 D g Q B F D o M g 1 D I O B D E Q R R F E Q Q g + E E P 2 P E A P w / E A Q B D E F j w 8 Z Q Q R C E E Q G e D 9 d h A Y 0 Q h C E A P m S Y 5  
- n 2 j E E P m Q D 1 m A / a V r m l D x q m z Z 8 Q Q 7 D 8 Q 2 U Z 1 p 2 o b l u Q + E J o W V a M Q 3 A Z R l B E a d x W n Z J m G Y Z J l W u X d r  
- W x d Z p m c X F n A + c R n n J Z J k 2 y Z 9 p g / Y 4 P W 8 Y 9 3 n o Z N 0 3 m d 9 s n z Y 9 l G w a t p h C b B j m Q Z V 3 m n Z t w m b b R c R  
- D a Z 6 m O Z 5 n H V c R 1 G s a p w Y K Z 9 k 2 o a Z 8 W U f x x W d X F 1 G Q Z h + m f e p 4 m x e R n 2 9 c d y 3 9 h p k 3 j d N j 4 g a C C m g  
- d + C 2 + Z R 4 4 b h 1 n 2 u Y 5 n W 9 a F x B D b R p R A X a N 3 F h h n G N h 6 G H 9 b J 5 2 p c K U H u h t 8 3 v e 9 2 5 N b k Q W X c c P Q 6 b  
- Y Q G a k U O A 5 e M R R D F A d B h D A L A 3 D o Q h D D 0 O A 2 D M N Q 8 Y k R B J b 0 P W w b J 0 3 z a g P n J Y 5 y X k Z u M o Y h W E o Q e V  
- s h E f J 6 I 5 a Z r n v d N x Z G Y 1 l n s a i N w + Y y R X V f 1 3 H k b S J 2 e Z J s I u Z G l Z x f 6 L G r Z 5 v 6 C Z y H n R f J 2 3 e d Z d  
- m M Z u R p M h N 4 2 Q f k Q m a i S H 6 H j 1 5 Y o c F v a 6 d S h G d i x w V 4 s F 2 q x l q l 5 F Z 2 c K E g u l Y S Z 1 o m u e J o 5 R r Z r H  
- q d F 0 n V k W N X i e 5 5 b I D 8 P K G k 9 k 6 Y h 5 s Y o s N p L J r G F l x q q 0 r f q N 0 I t n E P F 3 k V 1 q o g Z 6 n v Z J p X 1 l R k h D  
- n x w X m Z i l b K l y S G f D u Y Q 9 Z o P 5 l b K g 2 V F 8 c h Q Y U N 2 o D w N g x Y R l h I E g R G t j Y P W d e e N 6 w i O Y r 6 c 9 / W a h  
- t 2 W o i 6 l H j b l v K h g 5 v J 8 0 q J m t i G P X + 1 N 6 J b e x 6 N T k R y 3 1 c K Q n E t d l 6 d Z N l 2 / i y + I y q G A X T u D R 4 / c t  
- q G X q i g m n d J k b t 1 2 m m T b D N 2 Q 1 h 1 N d f N 6 r S t L c n c a C T Z E a O N I V h 5 x Y 8 l y C Z L a m k 5 i j t v I H o S 5 L y t l x  
- X S e q H B B E W x Y p Z V v Z T q q i a p q S + 3 G X e Q s 6 a 3 O n + c m v 3 C j H W H s r V l c R 0 z A o J X e S K w 3 M R W t j y 6 K M x L T K  
- 7 a B i J i f p v n + s z k K v q 1 r G P n 6 D c e Z 6 f Q 6 g y c A 9 D a c G T E U P R I G 4 a R A D M M 2 7 E A O g z D E M Q 7 z f N a 1 2 n A W e  
- Y 5 d Z d u Z w a S v v + 4 3 r J 3 W u u + A O + q t o o B k 9 3 4 O n H R 4 U e V s 3 B 5 S D e I e a o o v k f X 7 4 f h w K y a z d 7 U h N k e F j  
- d j J 9 a n v Y H c d u Z L 9 q K n 1 1 q y I 7 X V v 7 s d 9 0 W X 4 B q X E k T G W 3 3 l 5 K U q 6 4 7 m a O G H H i N m A 8 X S P m g u 6 w 4 v l F  
- q 9 W e O B L m a r h e g p p r r 7 Z d 7 t 3 j m h 2 W h U R J 9 4 B 0 o e 2 X e M H n 5 3 N 3 p i h m d 2 X C o G r J d b 4 c W B m Q d 8 P W X v j 1  
- 3 m 1 F c f A 1 / R 2 8 E Q P d l 1 n / O + t q h 7 9 s t x 5 F e o P F 0 Z Q O g 3 Z C 5 B E F o d R Q D A M w 5 7 M O F + D I O h D m g R x F o J l I  
- G s V x 2 q u b U 7 u r X R p Z v v 2 m j h p 1 f 7 4 r X 3 9 9 l 7 n w g q G H H l t + s N a z i 9 3 u b W N H 1 3 + / T i 6 6 n h v v e m V Z 2 n d 3  
- k L k 4 8 l K 7 q w p t 3 6 i h a F n Q q j + I l u x 1 I V c d l t A h N l 4 3 a n a / 7 j f u a K a X Z v I e X 3 K s b 6 L 3 v / y s o w k W w 4 k 5  
- n h t 3 p 2 m 4 3 a m f 2 j i x j 4 V h O n p K g o P d H x G P Z I a q 5 m q o R m / S Z t y e K 0 e l n P c B v + N g f b a o 4 t l u A 2 m s m / d V  
- t t 9 D x s A 7 D b O m o E V e R y F 0 P A 0 D R d B C D g M s y / U R R K 6 W A K j 5 B 6 I R e F 7 o O 2 j G 1 w o b P H L d u l H L r F o K i r W 4  
- n Q c + 3 8 4 q i s 3 k Z 2 P Y c d C H 3 R f a 7 G g d R r Y 5 q L / n w c D Z 2 P d b c 7 r 2 W t t f 9 G Q p Z i W E 9 J o j G + g d Z x 2 z f e f /  
- T u B / o W j R q 9 L 2 m q 9 b c T g M 3 m P E u 8 c F q q y w e + L D d T D a y e 9 3 9 k r L 2 v c i S g a X f x 0 H w X g P Y E Z T F 5 h o h u b j  
- d J s 3 8 4 D v t r j T Z A 9 x e V 8 o 2 W m + K a l 8 N 1 k y s n Q z 1 x X N 5 K y 7 p x n Z 4 K D p d G N D z C g / + R q R F E A R h q G w Q / t D  
- l x A 6 D Q N A y D d g R H Y p j 6 F X V l d d d R d n J g p 1 n H i 6 g r o Y 1 m H 3 a f F 3 A d F x 5 c x D E v U u 1 l L O u 2 w 7 r 3 b 1 M 8 g 6  
- H 5 R g 3 q I c h V q 4 T x 9 0 p C 7 6 W H Z / u E 6 z 4 v 1 H 9 d q 0 s c s O M q d l t 1 W P 0 d o 6 Y s F + K i 2 3 t + A a v V q 0 a t l u Y u t z  
- 7 t b 7 o a W s N k I 8 c 3 R 3 Z c e q K U Y + B L H h T F 1 2 n y A W j 5 G 7 Y v o T p 4 a 2 H / N I / l 1 P 4 X X w I G D 5 c H R Z M R G X Z M O 3  
- m d G j r 4 o 6 h 5 c Z H g I V 9 S N 9 K x N 3 + + c 9 l 5 + 6 i S g 6 D o P g 8 b Z / A 2 c Q O q D E Y W h z F Y M g v D S 3 f k D X 5 G O E U R 3 J  
- f V z d H a 7 S F 1 Z H B M 4 f P V s 4 c u u Y d Z v o L t i y B q e i y 7 G P c H k J X 1 i R G P f x m 3 9 5 x x 2 j 0 l 0 L s Z H W 4 W h Z x 7 Q Z  
- i f n U d L 0 m h Y j R I t a 5 0 m 8 a h d t a z y 0 H H a P f b y d m A W s f 2 6 q y j i x Q 9 g b 1 G h s O C s 9 u R l W d p 1 w Y b x n g H m 1 5  
- r r s k 6 G Y K t N o 7 D 8 W 4 u D d C 7 M U r a f 3 o a 5 z d W Y 9 d Z c h P b / H r B j 6 m a 2 k M 6 D 1 q u x q W Q 6 s j O C 6 1 p 1 0 b S d S Q  
- 4 e q 2 i I 5 v R t m T D w P L F D g O 5 n D 8 R h s G o Q A 2 D Q N g 9 E Q P A w X 4 N h B E c R h G z e n d a i Z 1 t e c K w q o d t w W 0 6 i h 9  
- W Z S Q v e k F 2 L n u z X 3 B 4 O I b h i X d 2 s d D F O M e N q n S i D d 4 K z x 9 e M d n 1 N o h S C v N a m q M f 0 p 2 6 v a G y 6 o c f l O Z  
- Y 9 w W l 2 m N m l 4 H E b s p 1 4 G j 4 j V o T 3 K G 5 L q y s o T e T a 6 s u t w + A / s Q a Q d H h Y 1 d R q n m p 6 o 4 K c H R 3 S 6 e T u H Z  
- F + Y s Y 9 d Z b c 1 3 6 L v e + a x d 1 x + g 1 G G d L c G t r 7 d / B H e n 6 l J E 0 d / Y G D 4 O 5 9 X U O m P X O c g 9 p A Q B p H A S A 3 D Q  
- N w 9 D 4 O A 0 D U N A 3 E E R h G E j e t L Z C N J c Z D Z W V j n / H O f C h 5 S 7 6 L I W h P 2 o y g d 1 b 7 d L W L 6 t Z z q x e N w c 7 h T +  
- 3 b u a 4 H + z x 1 O J r e s e 9 i V 2 + W g B k I G p F x 6 o q i V L i i 3 a m j k 6 B N 1 7 u 3 s f a 6 1 d J i z o G d d Z 0 I 5 b B j e 1 l m n p  
- S Z X C p I 3 S P H D q 6 l a j g r Z W x f B q d r h P h d J E U Q P v f D k W g h O L t Y i p x 4 0 h J n 6 Q m O G 6 d 0 d 2 3 U 9 p l s E a n u 9 n  
- a d d m R r K o n g b 7 F K v d v D Y N h f R + Q 0 J 0 w 7 D 1 3 w 8 s Y O Q 3 9 p i x A G A d B J C 4 N A 5 c Q P w 2 D Y N w y D k Q c 2 E d v c N b  
- H i m n Z d / d R v r U 4 t e b g Y V c 9 o + w u Z r e 3 a q J o A 1 v o K U Y + F f U i H O n n q j y I S h L F X b q q 1 2 x Z h c I u k L v v T g a  
- Y 5 H x J c a C r n F I J s O A K w d u D u + i 7 W N V u Z 9 4 O t 9 0 O g c P v v U j E Q c K d L k e W b H G 2 V 7 N q 6 3 q 9 2 8 6 1 h 2 2 r e 7 z  
- 6 v f f v H Y e 6 5 X H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x x A H g C H H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x 3  
- H c d x 3 H c d x 3 H c d x 3 H c d l Q I H h x 3 H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x w A / 8 O o G A A A B A P 3 / A A / w A Q J A 0 E Q V  
- B k H Q h C U K Q t D E N Q 5 D 0 Q R F E k T R R F U W R d G E Z R p G 0 c R 1 H k f S B I U i S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M  
- 0 0 T V N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F Q l D U R R V G U d S F J U p S 1 M U 1 T l P V B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F  
- h W J Y 1 k W V Z l e A F A V h P 8 A U x W k Q R A X E Q A / E I P w / X A Q V 3 D 4 Q g + E A Q V 5 X l c V 0 X 1 f F 1 X I Q Q + X B d 2 A Y l c 1 /  
- D 9 c l z Y V k G L X t d l 4 X Z h W N Y h e G J X l g 2 T Y N f 2 e Z t k G C X V d G X X F n 2 d Y 9 j m R a x h 1 7 Z Z i 2 m a d s 2 G Z J j W y a  
- 5 q W R b d j 2 p a k Q Q 9 E N u B A Y l o l + X p e W G b V f m b c l c G r a Z i 3 I Y p f G Y Z J t n Q X w Q B D D 1 h g + E N 3 H b Y h 2 X D D 0  
- R A 9 d N v m y d 9 7 F 0 X N k B C X N e 2 K Y 5 5 2 e D 9 4 1 3 a Z / W r b R 0 3 m a p y 3 C E B 2 X Q e B o 3 Z Y F g o M d F i l w E I P Y I a Z g  
- W V g h 1 3 Q g N n H A a t 9 n G b k P 4 L X d 1 I c X k P h E D w Q o Y a 2 I G W c h 5 H U g B d 1 8 f R u 2 x j p p G o Z 2 P Y Y Z q P 2 l f l l 4  
- O Z G J o c d R o o u g a P 4 F k B m Y x b p w W u b 9 t 4 J Z y H o n g + O 4 + Z B x H 1 Y y A 5 W i k Q 1 z X K S I P j e E n L k l p 3 z j 1 p 3 c  
- c q T W 4 l 9 j Y 2 D y M 5 o g x t m I g h e 3 X d Z u 4 o l F 0 5 A f u S 2 U c 2 M W 1 c K E 1 9 X R x Z P X Y Q 5 6 b R f H G Z W h 5 R a F 2 K J Z  
- N c 3 G a + b X K l m l J p b F h 2 Z g W A W d h p f W t j p 1 5 g k Z + m j Z i S J / X + Z 2 + a C d p y f 6 C 5 Q q l / 3 1 d 6 a W g c y y m V b m  
- U 4 e s S D Z F n a d I n t V n 4 j k K n q r i 6 2 G 7 r 6 Q b A p u d a h r 9 q I N k O j 2 y s 6 d L Q e W 4 G 2 u a o I 8 l K a L n b N 2 m v k y C  
- H x c G 2 X 7 d B f q r n K Z J 4 u e c 1 1 h 5 7 o m t D A H b l e w G c b 6 3 m A q d 2 7 g l L C q 8 b i U q 6 Z S Q p U k q u b o h R 9 b 8 m P C 3  
- 1 q 2 T X h o h k 6 7 n X I 3 H a p 8 o 8 y u D s M a p r H n o u + 4 2 e y q q P w 1 z r b z z H p c j l 1 b a o 1 m q y a W p 4 H 0 T T 2 Z e F v 5 G  
- x O + M M a T I a I l V z 8 / c 2 8 c q x e 9 7 S 1 q Y 7 r o S o n s 2 m 0 s P x 6 4 3 d d W P s O 0 j T X d a X Q q L l b D I b 0 a n 2 P b G N g + c  
- q z N L Y a x L 5 s G X q / h B q I W m 1 j m V q O S 7 4 w 9 + W e 3 5 d l + Y p / m h f V u K T y J o B A 1 V 1 N B a 7 Q c J v V t a B j u 6 K c 2 9  
- v d l q x w q e t 2 1 N e u H a N Q 2 X T L 4 u 6 u n z h a u 9 X u w Q Z r Z / k O o e e g u U 1 7 A s C g V z 4 G Y C / I / 1 W N 4 j 7 H s p Z b O s  
- M g f r d 8 8 b q 9 4 v l q K Z h 6 z s L Y l / m 5 9 s / P W J h S / r T l S 3 t u b / t s c 1 L X m P g C 9 s 6 / N f V x f 3 F M 7 o a Y M C Y T M +  
- e 3 W + q Y d G z p H o e i a H 8 D l p N e W R 3 a m m T c 9 2 K h m w 0 r W 9 4 + O A s D s q A a A Y W Z 3 I i 1 4 4 V X i t H F e P h P 3 5 v R J +  
- Y S F 2 Q j V u a 3 w V e H F h v Z J n m f o H w y j q W Q o G b Z l v V r H u l b a 4 9 9 S W m O s h 3 p O q 6 2 K T 6 S 9 e X + X 3 + p 3 t 8 r v l  
- j B q 9 p / o H o c 6 m o D c 9 g Y A l O p e K e 7 y n G g D k d a o B z u p w a n b 0 o f v 4 J i j l v k s X G J O l e n f A q y 9 u / p z + 9 N + L  
- Y t i 1 v x n R w n m 6 h g b k O Y d m y I v 3 j n 6 s v q h M W v a e L D o R w 6 s c i L V 6 u G 4 c H o 6 C d y 5 K V Y 0 n u U H j m e 9 n F m e f  
- K i X 1 2 6 B 5 H g 6 O e 3 9 5 F o K V Z c e X 5 N 6 q T R u 0 l / J d b b z c s X m z e J Y m d c X 9 l r h r 1 l d 5 Y u e 6 X H I o D I b r x / O q  
- d 5 b M a u g H 4 8 9 x + w J W 5 i H b x h D s b y c 7 i s E / G A Y J 3 h 6 K 8 / b 6 K s c j J v 0 Y F 4 8 Z X v p r I e 3 q 7 o w J + L F 1 q c f M  
- h f W 3 D 9 P i G U 5 D 1 Z 8 f h / o D j f n H c z i A 4 m y X c 3 D 1 S L c 2 u u R c f 2 r Q 9 7 g G P e D a D L X j 4 S 2 6 k z h 0 3 e m e v L x g  
- N w / 8 9 O s s f x / A O 2 p 2 o N K q y 9 v 2 1 D 9 6 d 3 u b q u + K n b x n 2 j v 3 q z Z M 9 e W w c H i T h P R 5 H k c L 9 G C u E z L s b N x +  
- w P l k X c 3 y p 2 E X D 5 b 6 P 2 r e 1 o d u / + e Y r n 8 L 6 5 a S s k g K b X 3 f 7 n q s m 6 T W Q f 3 O e N 5 H e N m o e O a g 3 O b n W p 3 w  
- H J g u V 8 9 f O Y 5 a X 6 k 4 6 c W g s v Z T n J w Z B 4 8 Z r H O 5 f y 2 7 3 a 5 X u r z m P 5 M 5 1 r T f k 2 / B 3 u k e L 8 i 9 X c p H l W R p  
- n 4 H a s E l e r M W m f q 9 o i T b G S f P Y X 5 r S q P j + v H a 4 o W p r z 7 y h I u e 6 W a T 1 2 q 9 n g S D + X m r h H f 4 T j 7 Z c y X H +  
- X H r v 8 f u R p T b x s H J Z q m o D c P 3 + z h e j Y S + i i 7 I h J g K L e m L a 9 h Z 7 t 4 e 2 o f 6 5 + 4 q 4 z u 7 / c c D F v U s r m P b q  
- W E N o w X J K G v u 3 a s n y S f N o T N X e 4 G 0 4 W c 9 x H G p z E s q k j Y G S 3 6 3 + z c i G m Q j X y N A y 2 r J J s 2 h P t x L t P l / b  
- c p W l a V p W l a V p W l Y C B 4 l a V p W l a V p W l a V p W l a V p W l a V p W l Z c R 4 A i V p W l a V p W l a V p W A D / w A P g U A A A E A  
- / / 8 A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I 0 k S V J k n S h K U q  
- S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F R V J U 1 U V V V l X V  
- h W V a V t X F d V 5 X 1 g W F Y l j W R X g B P 5 Y D + A F L 1 r E A P x C D 8 Q F y X N d B A E E P h B X J d x C D 5 c A / X l f x B D 9 b 1 x X d  
- e V y X 9 e m D E F g m I X B d V u Y 9 d G E Z B l W O X 1 c W Q Y R l G W Z 1 i G M X 1 o V + a N g 2 S Z x n W b X x k m o a Z q 2 R X F p 2 B Z l g  
- m J Z 9 j W a a t j V / b J c 2 b Y x m W O c B p 1 2 X h e 1 4 Z 5 e n H Y p t W G c t h 3 E X x z 3 Q X g P x D D 1 o H S c 4 Q Q 9 E N w H E Y J q m  
- F c p y G T a Z e W 3 c N d W B E B x X U b l p X j X Z i 2 6 a p o X Y d 9 c 3 N c t 0 X y b J t V v c d x m u c F l W G b x l W 8 e l b m g a 5 6 W U  
- g 9 j 4 Q b C E X Y b d 5 X e e R u G Z Y m F m v g R g Y B d 6 C o a g h 5 o d f p t m Y d V 1 4 l h u A 2 9 E I Q H c h N x Y Y h l r I Y i t 2 X 4 c  
- l 5 3 x i h d H G d m K H 6 k C M F / c e A G r i N n p M g g Q w + b V + Q + E B 4 W 0 j 5 v 4 A Y e Q H 0 j + K n P k V 4 5 O h 5 j l u g u Q Z J b 9  
- r 5 M g m a p K f C A 4 J a R v Y M j Z k Y 1 Z Z w 4 j Z x q W l f O L p f b S E a D c K h H q i 9 r 5 G h K Q W w g x 7 n A X d d o n f F m n 3 h 2 B  
- J n o K f q Y m O R 3 l Z i n 4 N o h u G i k i O 2 x d F t H W j u N 6 Y o e h Y T h N 7 K s i O Q q V X u m 6 R b + V 4 F o 1 / Z Y d + v G d o q o q  
- x r a a K s q 1 y X 8 e S b 7 N n W T W t q C F 4 f t J 5 5 2 n e S 6 p q V y J s e F n m 6 c 9 1 Z R Y C q b Y j 2 M J 4 n m j p z q h s 3 K o K l J G  
- j e w p T f y u G + f 1 9 Z Y v N k L 1 v 6 8 I h m e 9 s B k O v o k s t i 2 2 p C l I g X C 8 Z g e O 9 a 8 s e / 3 Q w p h r h t 2 a p T e D D L 3 f  
- a x 3 T Y K P r f c G i 5 9 s p k 4 V a K e M p s 2 c Z z Z d o 6 l s 6 W q a w t r M 1 y a R 6 a l L H c d v 3 A L i Y / E M i f n G H t p b L Z Z s m  
- 8 c 0 v u P a 2 l z S s Z x K f 3 M 0 x z Y C j N 6 5 w v D C r o q + y 9 V l 6 2 3 S k R 7 b M 2 K 6 J 6 t e J Z m v l 6 d H y + R 6 L m v T a 4 t m m  
- 7 R i 6 N o O z G O Z L t C t 5 w 3 y Z M r v q s L 0 o 3 Q t 1 v j R H i l W 7 7 J Z b V N O f Z 5 J G g K A Z e m C M 5 o X 6 1 5 y w e j J a s i r b  
- O h n N s c x Z d b / 1 v m b B 7 K 6 M T 5 6 J H D p G q 8 V v L E n c t O r s 5 n f H M r u H R o i q O 2 f A 8 X i 5 6 o O 3 G f f K n o K n z M u r  
- i / r q v l f E H I v P m 5 f g W l O z 6 P 5 O h + L p t n 1 P 4 u X 5 t w v l w D o p F o B h 6 d W 6 q + q Z T x v g 1 b b 4 g y X S n 4 k T B 9 H 3  
- u n m R r P r / n 0 P b I 4 3 2 r / 4 u a d N 6 4 D A q e i X y 4 L e h r d + o e 6 q f 2 / u P Y 0 r l s F 0 D Y t C o z A 3 4 l z p d I w P 3 X z + d  
- + 9 q i H W d n 2 S / J + X F k v 8 / X M 4 q y a k Y x 2 G 4 N Y 5 X 2 c U w X 1 c B w / Y P K 5 X 4 4 L e i 2 s h 4 2 2 M O 8 j h t j 2 O + c X v n F  
- 5 5 a 2 5 4 3 8 6 N L a 3 6 C 3 0 r P Q H 6 m / 2 c j v 5 8 9 K j y w o 6 o o Q R C d f G t s 0 i H O 0 9 3 B d k l v B e W h v l c j j y f W E 0 L Q P  
- D x n l O v 5 6 Q t W 6 K + s h 0 r U p U o h h I G 0 X p f 8 m T 1 e C q C f Y H q + U u Q 9 L i M I j i B 3 q 8 S a 2 t h v x M z 4 e C P E p 6 d F 2  
- r P + X w 5 W A J Q f 6 4 h B E K L L D + e T N H 2 S W 4 h h z S s j + G 5 p 0 u D a t J l v V 8 / f j Q t s t T K r D l R k v e j X D t a 2 H Q 8 X 6  
- f Q 7 d w / S e Y u V x X s 2 t z o 4 y e h P V p v z u C u e H I 1 g f w q h y H z X 1 t K F P S 4 i r 9 3 + G r L 9 7 z l Y 9 / l 8 O V 5 Z 3 H s 2 v  
- 5 r m 6 r A 7 I 5 D q M q y r K l 0 N A s M q y r K s q y q G S w N D K s q j c A P / A f g U A A A E A / v 8 A D / A B A k D Q R B U G Q d C E J Q p C  
- 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E  
- 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R Z V m  
- V 4 A U B W E / w B T I / x B E B c R B D 5 c F z X B c V 4 X E P x C D 9 e V 5 E F f Q / Y B f B A Y A P h D X 1 e h C D 5 i 2 E X 5 e l 1 Y l e 2 M Z  
- J i x B Y A Q G C Y V l F + X s P 2 C Z h e G T Y R o F 0 Y B o G S Z d p m f X x n m i a R j W J Y p g W X b J r m i b V m W x a 9 t m O X l r l 2 b x  
- t 2 g E B d G P b x c m r Z l d Q 9 E Q P V w b d x 2 / Y 5 d m e c B x m 6 Z l k 2 D Z x 0 n J Y B u X H d t o X R a d d 3 S a h y G z d 5 h W 0 X N r  
- W q Z Z j 3 B d J w W a e 9 2 l 3 X Y Q Q 9 Y h f n 2 b 5 1 W t b 5 3 n X Y 5 m m b f J x 3 v X R g h C c 9 e H 7 d h u m C Y y E 2 j a x s n s Y p n H  
- p Y 9 r n W e G H 2 w Z W G Y U i G E m x h h 0 Y Y h 9 4 Y o h p s 3 p b e D H n f N 2 G n Y 2 E 3 / Z 9 q o + f 9 p o W X W H Y / Z u Q 4 2 Z 6 N X J  
- g p 5 p G b y E o + X t + X T d 1 0 2 9 Y G B I b k 2 Q I 2 g t q 4 I l u E Z C X + Q Z I i p + p X d G T p U g O P X v l h f X B f R 8 4 9 i N x W D i  
- a T p q n N 3 1 y a y O J j k Z + 5 w i G Y m 1 Z p 6 V z Y V m H 3 l i H Y q l l n W k i 9 8 H t i O j n x h a b Y n Y 1 2 n y g y O m 5 a h o 4 T n x  
- 9 Y 7 n 2 S q G X + d Z + o W f Z A p W G 4 8 a W X Y J q W u K 2 f S c 3 l c a a p c m R l 3 9 n e t 6 i f q q K w r O E Z 1 q a y X o Z G H H x n B n  
- Y i Z B o a S b 1 m W 4 s W g o N p F i r a g i q 5 r r t l H b k u J W Q f W r Z y p q z I 7 f a m Y E i x l o 5 h m v 4 U s q M r S b + o l 8 q C Z Z  
- r a + V Z h s u 4 q p v C g W v s S R o 0 j t 1 o H b u v 8 T i S l 7 5 v q L r 2 w O 3 7 O k A Q H U s j B b Y o a z c G e e 5 a f s i 3 Z H d m X 5 M  
- a l y 1 w h e 3 3 W E O E J e d C m 6 r k l / a E l n I r B c u C b p d e 0 q I x G M b R n 5 6 o c b C j 7 u e N l a P m 6 e Z W n b K n k y d 2 H D 0  
- j G H s i 2 M r z m 2 q r j 1 6 y p v m C Q c f s S c 8 l s B h Q 9 E K 1 3 t g h q I C n G u b k u a 9 Z C u 1 5 6 k f B 4 N b Y S p t t c a q m G 3 L  
- V H r n K d Y t q q I M 6 n y G M l a f H 5 / p u + N C 2 i k L M 1 W b N P l m H s U j h 7 p V h v E G y h L H + n q 6 t s j z j Z a w 5 G 6 X i x V 6  
- 8 X 7 C e 7 w j 3 q X f f f r Z L 4 O d 6 8 E L D O o t X V r 4 2 7 B t O Z G j c H g L w X 0 m r U f K 8 b W 1 w g / l 6 C z 2 U G b 5 f t K n 9 z X v  
- M 7 l u J v e i J K N 7 D 6 p u 1 O V t g + J 6 7 0 3 u 9 8 R Y y U 6 x y p k 8 2 o f r 8 F k n C s d w K s 9 F y a F J N u X O Y a r v m K t u P d 5 N  
- w C a P A g e e L F w W i r 1 7 W N 5 o j O m a H s e w u K l r K s C 7 m T Z J q j X I V s f r 4 3 Y v 5 N f 9 i e N f / 7 1 / w t Z t o i 5 q + / p x  
- v i 9 c l W H r W 0 m l 6 j v W M X A 4 5 u 6 r f v c c y o e e M 4 1 z b K t a L / u 4 7 t q v k s v M a 4 g p 7 N A g D + e H q i A P 5 d 3 R + 1 e y  
- z Z N 4 2 t d l 0 W + v U 8 a 9 3 g Y u 4 v V y D a 7 v 6 / d p C 9 Z w 2 1 + b r u b i X g G 9 k R 5 K R i D y f X / B p d i 1 W Y O Y b S l r 7 v b 1  
- Z t 3 b 7 5 F 7 k P / + 0 H 7 H C z T y X I / V u + 2 v e / p E o x s d 3 2 / 5 8 O 6 + T e a 2 / X I x s 3 h r y 4 e g F 3 5 p s 7 l 1 q R 9 o 6 + d H  
- F Y j f n m 5 r 7 s m d m 9 4 2 j n e Z 7 b T y P p y P m m 6 c q B e d i D z 4 v o d u 2 6 m N 5 O 3 k / 9 s H 2 + y a M d z X b B 2 7 m v q 4 f U t d  
- i P e / H 6 i / + H w / y X e j X Z N m 7 H S 9 p s e N p N l C i r Q j f f M p l 3 l q H v 9 j M 9 7 b p 7 t p O 1 r u X L P c C + f G O + 2 j r 4 r p  
- H 4 u j p G h d z + i M e + 7 j 1 a T e Z o e F y r r v g g d k Y A / e G o A i a h f p o q k X 8 4 p w K t 2 V o / 6 x j Y F / 3 G N c y d x u 9 m 2 b  
- Z l x A g e N m 2 b Z t m 2 a y h 4 A j Z t m v o A P / A E w F A A A B A A A A A B A E B Q J A 0 E Q V B k H Q h C U K Q t D E N Q 5 D 0 Q R F E k T R  
- R F U W R d G E Z R p G 0 c R 1 H k f S B I U i S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M 0 0 T V N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F  
- Q l D U R R V G U d S F J U p S 1 M U 1 T l P V B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F h W J Y 1 k W V Z k o E A Q B B D 8 P x C D 4 Q  
- V q D 5 b l w W l b Q / X U Q V r W l a R B W 9 e 1 / X U Q l 3 X x d 1 3 Y J g F / X 1 b l z X F d G A X o Q A / X B a 1 t X J b 2 U Z N f m I Z h i F  
- x X N n G K X 5 e m S X t f V 0 Z R i 1 s Y J p G P Z d l m M Y 1 m 2 i W x j m R Y d s W B X d p m 2 Y N n W S X B c g / D 4 Q 2 q E B m m t Z l d F 2  
- Z 1 f H H Y R r F / Z V t 3 L b t a l s W p a 3 V b x u H M Z F e W 6 X 4 P x D D 1 y X a Y l x 2 c X t 1 H O b 5 3 3 d e J 5 H q e 5 v G k a h v X b a  
- V m n L d 1 i G / Z d k m F d 9 9 X B Z V c F 2 f t z V 5 c 5 o W n e x s X a a Z i m 9 d B m G o e x 9 m s e l z W r Y x 5 n 5 a t k 2 F b C C W N a O  
- C o n Y R t m a e m G o P f p 4 x A d O H G S e E Q n G b V 7 X Z W 9 1 A 9 c R / W 3 d F g m m g i Q Y B Z B e H W X i F W D f t y 5 O k B / X z f y U  
- 5 R k e U 4 e a 2 I 2 5 Z 6 D n q j N 7 5 A f W E 4 K l B g I I d J / 4 q l B 5 m h Z 8 P Y 2 f a V H M f t f Y x a p w 5 v j u Z X 8 b 9 9 3 d d W E Z  
- 3 g 1 j p Y f y F o 4 l y g 4 Q b R m 5 G g 6 R H I d u a J f k V v p 7 g e M o T n u W 4 / c G X m W g K m 5 8 Y t r 5 + p W m J M a m c o F l a R K Y  
- m l 9 J h p l + G B p 6 X q p n 6 d K M p K q n 4 m e o n t k l 3 m Q n 2 v o g h J n W g r t s p 2 q O N H K l K l q 4 m Z h 3 a d J q q a i J r q k f  
- O d a U n J n r L Y l t I M h C n n Q e d h 4 F s y q q / t O 1 5 U q 6 l 7 q i G V b Y v a B 4 o n G T n z p C k K F r y g r C u 6 8 r T p x u a s o x  
- o 7 q w y t p B t u d 2 f k a p r U t i / q k v O p r F k + 9 7 g p V t o 3 s R m Z a Y 1 l X j o j H q N c Y Q 8 O w e J q 0 n 2 D I f q V 3 r j u h z  
- I R l 2 G 4 r u T A o J z m h M 6 i V o t E e W K 9 F p C 8 Z Q x y 1 m r y f H 1 q m + w p X l 2 Q 5 k q C y L G x S k 4 E t + k p k i L G q y t q M 2  
- 7 f B t Z N v r L Y / x S O b 3 x f b 8 M b 2 h 3 W m i M d Y c a 3 N 1 c n S o A a x 8 L 0 d x + c j b O F N F b K O N A i T i J / g u 5 8 j 2 T W K C  
- o G w 8 8 n 1 c o 6 i C q L O f S 0 e D p V m O b p + Z Z 0 g T K H y l Z 5 r u t L S a / w 6 3 m v r a 8 K 1 r P n 9 m 4 F w O n h 4 Q Y 9 q W H u z w  
- e S r P 4 y L a 3 2 y W K A c f S W P r u b N H 7 q 4 n n 4 n p v M r 7 Y I Z 7 H f P M u i L K g u H N W l w q 5 P U z a i P I 1 J k O 8 j 6 s Y 3 8 B  
- / u e 6 W O K o 6 2 7 d L m G I c b 6 S / d e s a 5 + k / a f t N r n 8 G p w D q L Z s P Y e s a n H L w m L w Z q + 3 n v G l v p W p 4 Z m b N r T M  
- s y w + 1 Z 6 2 2 6 Y O m 3 C t C o b 3 p t 4 6 o X / 9 x r q E s v y W p u u k c y z / 5 K d r 2 T c Y r n 9 v i l e P a 4 k O w J 0 j 2 u b A k P / P  
- L m D W 5 S t 5 9 3 V 8 u c 1 w E J 8 e V / f W b 2 l u T d P r d a 3 D 1 u m f L 4 v 0 v G 6 B r q E + P + P a c + K H P y S E v Y o P n 6 R o 1 / m p  
- 4 b 2 v J b X y Y z z e y c C h L N 9 s m r j 5 W 2 6 p 7 A v L D t c 5 7 b v G m L x q 0 k i J p W w / n s w 4 T S 9 g x X T P P 4 v n L 8 1 n w d Q k  
- 3 9 n 3 v m B o D g J t f q 2 H K a J 4 z x p m y e Q 8 S y / O N d o 7 D a E t r p 4 p 9 x 6 P R b v u + x i D 4 c B u v f a 0 y m a s R t m t N s d H  
- n p I n G t J b x z t M t t f c J D p v o p I X p o Z 2 s X d L F 6 x p 2 D t 7 b b F r T M G p v m J p W o 3 h t o 0 u U s A x / B e K o B h b N 4 L O  
- P k 4 L i / h v n 2 4 c q W 6 / h z f g 8 v 8 7 p 8 / 8 / O 6 h 0 K 5 o G p t v 9 5 f q m / x r f A P n + v x t K + 2 Q m v j 1 g 2 7 k O m 7 F w D K c  
- p y n K c p y n K c p y n K c p y k Q A A / 8 A X w g A A A E A A g A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F  
- 0 Y R l G k b R x H U e R 9 I E h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F  
- F U Z R 1 I U l S l L U x T V O U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 L w t C o R B B E M R R B  
- D 0 P w 7 D k Q B B D M P R K D t e x I D 0 N x A E g R w 7 D Q N Q 6 E I R x F E Q Q B D E I Q F 4 E A P m Q Z E P 2 R E F l h A Z Z j 2 Q D 4 Q W a Z  
- g Q g / Z h n W i Z 9 k W a a M P 2 c Z B l m j Z B m G f Z l p G x a A P 2 r X h m W g b t m G r b d s G o Z 5 m m X a 5 s m V a d v 2 j c h q R B b R  
- e H C b c Q m 0 X N x G n b Z t X G Z Y Q W e a Z m W v a h x W v c s P m m b l 2 X W b F n n a c t r 3 K e 1 1 3 A a 5 u W c e F p 3 G a 0 Q H d Z R r  
- X N a p z 3 A a F k 3 a a M Q n q a p 1 m i f J 6 G j Z N p 4 F Z 1 t B D c U Q A 9 Z 9 n l v Z 1 k I V d J 2 2 Z g 1 s Y W b B 6 3 D e 1 n 2 k b l n n  
- 9 i J s 3 m a m L W k D 5 t 4 d E I Q x E g U Q R G E E Q l y D w P g 9 D p t w w D k T n b E c S B A D Q P B J E w R A 3 D A N w 9 E M R h F E O O n N  
- i R z n n i N w 3 D g 5 k 5 d f k P W P b + N 2 1 b p l I J h Z 6 G 5 c V p G i Z R 2 m 5 n B k Y P b 6 c Z y i W B 3 b h B w X 7 i J 7 H l m y J n f c  
- q D X x Z S K X u f x o G P l + i 5 y f x v m 1 e q J n 4 m C k J 6 f 5 1 6 T b F u J x l 9 9 p c n e n K Z m x q H 3 e u A 5 7 d i e 2 q m W f H f Z F  
- 6 n 5 f u A q V E I P a 0 D + A o 0 j B o n k Z V w 5 i e Z s m T m O g 5 7 f m M n Z Z C b 6 y i + A 2 S Z y n Q / h V l g + E O V W m E W N I 1 r k P  
- g 2 D w R g 6 D c R F 1 E c S Q 8 D k P 2 D D w N g 2 D h g h E j Y Q r 1 j K D J X p C X a d a S q W w o Z 2 5 X d 5 e G y e d 8 6 g c J 4 J / a B v c  
- B f b A 8 E s m X I q p Z x J n f i 1 H H r W + X Z j f B I y h B s n 0 i x s n a s B l Z 1 d Z u 3 4 s e W G w s m q s F w l m n d w F + 8 l s 1 u p q  
- Z m Y 3 / w V x r J m + J 3 r i m G X I z 1 v X V y B l K o i B u 6 U o r O M E q K C 5 w d i Y H y i K j X A X h d I 0 n C v 2 0 b p 7 2 o f t 0 a H f  
- 6 K t J d O Z 2 b n F 9 W V b d 0 Q + e S 9 L Y X J c W / D k O H S u E R Y 9 E k R A 8 D o Q x J E Z h Q 0 D s Q h J E I R J V c 2 J 5 c 0 L A 6 V 2 P  
- S o s 2 V 3 o m x L P N M h X T N Y 1 z Z n u w K D G s p 3 E w / E O A n m r H b X 9 r N q 2 n r P o M l o P Z a i d K l u Y x j W m / z R r p v g f T  
- H + d 9 9 8 r p h x I P y u Z s T s H J p W i 6 n v H 2 n c Y v a m C W X f i c d i w x w r M q f m s M w G o P T o m r m S w + / X t E P 2 I u Z O 3 H  
- J s m J p f 6 b R H I c q s v C 9 r c K K 2 b t 5 2 y r S a G 1 7 j m j 4 6 N R E D u M Q 7 4 Q O w v E A T Y 9 E g R m A E I T B J X k M g 1 E A R x G  
- j V / X I q G s + V w 2 e p c c P N a O c i + a x + D o p n i C C p + x V t c T y r l n 9 v 2 f n / 6 n q M M 8 a D f 5 t H T H p m b P Z c Z f S a x e  
- n B e g + J x 4 N / n 6 Z g t R y H 9 v 3 P 3 v 7 z t v G 2 N / d D w W c s 2 / 7 P u t p H A v r 7 p + M A 7 Z m I C Y 5 v a F f l m I x 1 Z + m z b 3  
- W 2 1 f F / u T 7 2 w d W p i M Y W 6 p b 2 Y l S N B F t U Q A 4 D m 5 g 0 E E R G I E s Q g 4 u I R x C D c N Q 3 D s R W K Y 6 V u / s S E 3 i 8 V 2  
- H v y T V M L 2 P S G q r H 2 c 3 0 P C 9 W c N 0 t y i e C 2 z e L s c v 3 L Y v C m l m 9 P x / K m z 6 T S 2 v g X a X k e x o Z w q r o P p b z x c  
- i g O J f d o t 6 X I w L Q 3 5 o n a 5 y v 3 I m 2 8 P x P I q i p 9 U e L 6 a x 6 1 8 K o b m V Y x t d p v t r t 9 3 k l V 8 n R d a u c O n 6 0 q l  
- p f G d l v 1 t b B m D N t y Z q Y r z d u O x B 4 4 Q w 8 E E O r x E M N g 6 E Y P Q 9 Y M P l 3 E k R W F D Y O h B E i V I 6 + 3 N + f y r V u t w  
- 1 / N D q e X K C 8 d u / Z 2 C f s 6 8 S Z 6 V 1 D Q m S 6 L V v D n b w 5 c x h q / n 7 5 5 2 1 n O a K q y B v q R a H F f M + n k p w 6 7 P d W w V  
- v 8 i 9 v Z e R 9 x 7 Y l s G c + Q / V 8 5 z 5 K m v c p 9 x / U + H w P 5 c N 3 K 7 h L k X Z 8 a J / r D 6 N v 6 3 T q o P 1 C e 3 S g p w 8 9 e 6 o  
- 8 Q p W W N u z t t K O D x e L z X i N X N E Y P d 0 D w P B A D w L w + E 8 P L s E o P Q 0 D 4 T B K E I M Q z v E R J T h x 2 P i v 6 / Y g z D K u  
- R 8 b 2 9 T x X w L B z e I p d 8 Z k s 0 n + 1 8 t 5 G o 9 Z 6 3 n K D d 7 Q s r z r H 5 t n 7 w 2 + p G p 2 t 8 b 0 P M a + l N i 0 l e P Z 7 2 c r 9  
- 7 e g m 8 5 a l Y k / y c 7 O z Z v I H b + a 8 g / 7 N u k 5 a d G Y j G L I S b / M o 6 g 9 5 N i q 1 2 2 P 2 t s 2 9 9 m o X Q 0 d z G 2 f q X f 5 Z  
- K u 4 W a v j m x t y O x C D w Q d 7 E A R A 1 D k S Q 9 D 0 S x G D 0 N h B E g R Q 6 D Y N 1 3 E c R o 2 j p p q O + F 8 K H o u / c F / n 6 X i x j  
- 4 t A y B t Z d i n Q 3 7 f q q n 5 j H w o L g e d 6 i n J t K O y q l 4 n 5 H K p c x / D e k x D H + o + j J r E q r A M V 2 7 q M k a / M + t e 9 0  
- q O 2 9 9 O 9 6 i e m g d C o W q z y q n Q 5 X V v 5 i 5 9 v n 1 O e 6 U l e x n y t h 9 K C e 6 D P A 7 d t o A h O I t W q P m v 5 q K e G q D w Q b  
- c c 2 O 3 S j Y P F z D X j W H 3 8 P h I X 8 O W J E U O g 0 D b h G K t m t M L n O I G v p T r a R r q s c 3 a 3 x m 2 n i + Y U Y 9 t Z z 7 i c 2 1  
- 8 n l a W 0 e 9 / E f z M 6 m 1 x v f L f S f 9 n v 3 A X l a p s 6 x b y k c B 9 x z J + r J y H 9 m r N 8 X Z v F f c a 3 w / d w z Z 9 L p K X P M a  
- q o 4 Q 8 O f b K p 6 X a S a 3 J J c b u B H D j G A K N 2 5 0 L 1 Z i x r L a O u d s 9 u O t j z / Y 8 F i L G I E 3 K W Y Q a q u 6 / f l c m a v P  
- j o F D 0 P V 9 E I O A x E U S e E E j f w 2 E M T V / D E M g 7 v K 9 G N 3 T H O W q H r 7 B / P B Y T m b D e 4 b O x q E w z y f h w 2 s d D s 2 X  
- G 2 c T 2 8 f a 2 + H 5 d C z Y x 5 D l K H z e B P 1 s R z I s m m L s U n P A t D s q z P q + l w 8 1 v e o d j m v c N x y r T H Q 7 f A a x s z D x  
- V C u f p + n 6 f p + n 6 f p + n 5 l B 4 A i f p + n 6 f p + n 6 f p + n 6 f p + n 6 f p + n 6 f p + n 6 f m U A g e J + n 6 f p + n 6 f p + n 6 f m U  
- A D / w e g g A A A E A A w A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I  
- 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F  
- R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 L w o C c S R J E 8 S B D E E O x B E A N w u D U R h B X o R w 2  
- C o K w 0 E M S B E E E P g 8 D 4 S h Q E U Q h D E M Q B A E E P x A D 9 d m S Z F k A / E I P 2 a Z N l g + Z d k G Y Z V o G V Z F p m T Z R l m V Z  
- N r G Y a d n m e a p o g + E A Q m S Z d s m U Z t o m U Z h d m i a 5 t m t Z t u n A a 5 d m b c B v X A c d m X D a g P m 8 b N v m q a Z q m g b 4  
- Q V 2 a R v 2 Z Y Z u G n d x 2 m a b N 2 W i d x u W W Z J q X X e F 7 X L c d r G W d V v X i a 1 k n K a l z x C d Z 6 n o b 5 s X 9 f V s n O b p 4  
- m 1 Z F q 2 1 f t / X c D 8 P m g d u E 3 O Z G A w + D 1 l 2 4 E E Q g + f B u 2 Z a h 2 3 k f 6 G m c e J p 3 B h t r Y R b U P Q / E M R G N b Y R x  
- H E w S R E E k P V 1 D A L A z E A T W 2 E 4 P Q s C c L A + E k S h C D 0 O Q 6 E Q U B L E F j G v f u G 3 V f N y 5 V d e A X K c F 1 I I l l 2 2 c  
- h W C n 4 l V k Y S b V q 5 f a N 8 o j i l 8 2 m f m C W Y d O A J l i R 7 2 u Z V o W U l t z 3 k f R + 2 i c W a H x a x r H 6 e N z G 0 e l 6 W k f  
- m c X 2 a N v Z 8 Z O H a J h J z 2 o d N 7 H h o u f 4 a g m i h A m p 6 G e e e l 5 X c t m G l n W f p 0 m 9 m Y R h y C m r h 2 H H S h C p W Q h t  
- l 5 q i Z w Z 2 a G B X z a W r I q e 5 k 4 Y s s O x D X s Q V z k k S x L E U R Q 9 q U N w v D O H A y E M U A 9 C s J Q x E E S B F Y Y P B A j a O  
- B B j J 9 W 9 b x y J U c W f G z m O v X I i d z a o i h n X C r 1 3 2 6 p a f n 0 l 5 3 m y m O r G G w C b X G w B o X N i G a 1 2 g l q X A q 5 k x  
- D n T B I A a 3 D 5 b q a K c B f m 9 r 1 Z 2 p X H g O i M R a h 1 H O d K p 8 U b h 5 Z 7 f F 1 o H n 0 P h D x Z 3 a H e h 5 5 g e 6 A X h f d / G x  
- b B v 8 1 c x + 5 b s H B m q z O Y 4 S i O t X W c G g 9 Q e C q 8 x m r N J w a + n m Q z D M 6 B a O H o Z h 4 P B D u d c x E E o S h O E c R B A D  
- x h g 2 D A N h G D s M x L E g N g o C k N o 5 Y U O w 8 E I S x N E Z j R C f q k 5 i o B y Z m v X V s x m i K n 3 o N 8 Y e w W 9 m v y K f n K b m  
- K K P d 9 y Y M b Z 2 X v w z K s P d B 1 6 W b m I p X n z M L 6 1 j W p y p V 3 9 L f O p 2 b 0 C u K Q v i B s R w R 7 G b h 3 I + Y 8 e I 2 g D 1 t  
- 6 a h / u Y B 0 m o H e 9 R w 9 R c e I 9 M 2 D H I g q W h c H v h 7 u p 2 O H p V i u 2 G q g 5 6 9 H Z v 6 8 u e y X v c 0 j L O v v u v b H n B 6 X  
- M g w P 9 o D 0 P h G Y 9 j R E E g S R O E U R B F 4 U P Q v D E N B G E k O x G E 0 N w p C c M x D E k S B B D k N w + E t c R D b d q 8 K x 7 L P H  
- x Z 4 L 3 l R / n W f 3 F m 7 x 5 2 q T x b A J j Z q E v d 0 n u 2 8 g b 3 o f 0 m K X A b y f Y K d m Y 8 t 5 S + N P i b F s P x W g r E 8 V + M d 2  
- H q u l b K u p y p e d M m 6 L E 8 e y y k 8 i i K J u 9 e l 2 b F a H U + U Z 6 Y m t g L A e b b Z v 8 K i G s b 7 a V v J 9 y 7 Y q O 0 d 2 r 4 s l  
- z W l D 1 t Y t E U Q 2 N D 8 R t 9 E 6 5 p + D c M g x D o R g 3 D p c Q w C U K w 8 E U S I d D 6 z h N E x e + L x X j / 9 l j L d E l 6 W K A 4 6 Z  
- u e z d z f z Z m A 8 B b u l q S h O d P T 5 C v X g c a y N g 6 + p 9 I 7 K J 8 W p S 9 8 A e 1 6 J Z g W m + e 0 W j L v i n y W z 6 q w r G o d 4 9  
- N x Z 2 c n z K W K A i J 2 4 Z p d s e i y T S q n n + p 5 / p N s n 9 r u D d I h 6 F n L f 1 n F z a Y P a x l a G X 2 9 r U G 0 5 7 / K h i d 0 H b  
- 2 e p Q 9 D 0 R I y X M Q R M E h c Y y D u H Q 4 C 8 N B E D 8 M x G E o O A s C h g t y Z Q P A / 4 g R 4 c E b m e p 5 f Q t P n 3 8 2 8 d t o J p v  
- v L e e q j 7 m S r r D N P m J 4 M O 5 T n u 9 n z Y Z 8 9 u G v D 2 J 2 4 S d 3 R 6 e 1 3 j 8 I 7 m x + w a Z 2 c n x C o 9 P Z l / b / e V 2 K s 8 H  
- U M 8 / N q 5 9 b O Z G + b d n M 8 6 z v c z / O + 8 y 6 X N a X c L T X t d D 9 e T Z S C c s h 3 p 2 3 e u m G 2 a f 6 H O b f t q e z L 9 s z / P L  
- H U 0 3 G 7 o Y Y P Q 9 E W M l z t Y S B O E U R B H D p t Q u C 4 N B E E w P B G E w O g r C Y M B B E k S B B D w O Q 8 E g T x J 4 y H N E 5 Z p 5  
- d y i 8 K 8 n 2 F d a g p o P 7 p P u 7 J a e n e 2 m L s Y O 1 b s K G d q p + 7 i l 2 2 l 6 G y a y p u G m 2 i / U G w p L y 9 N e B 5 6 P 7 3 q o g  
- 7 2 Y 3 l w F n n j n 3 l b 3 z G Y + 5 y v A L 8 c P n 2 z 2 S 9 p v v e p 2 w p + i M M j D C 4 e w z F / z Z r G n N b z L 2 z h p 9 a g d x / d M z  
- b H o r i n 0 X 9 Z y L R A D 0 P h E Y V j 9 u E c T R J E b O w + 3 s M A 0 Y U N h K E w O g o C Z g h H E Y Q A 9 D 0 P R J E 4 S Y c E N / X 4 e h  
- / 9 C s n 2 2 c r j D J m d P J 2 x 9 t + K s e 2 A 9 P Z q x H g m / t X l p P v e e e 6 y K f y 3 S 5 X p T 1 L 7 y u + N I 9 7 S o p p 7 s L / m W H  
- 3 v 2 G d 9 A p T Y a L 7 v N K e n K e / e f h m e s 7 v n 8 u d j R N B a v 8 4 K 1 d 1 c q w u H m P 8 i y N k r v Y O i 7 u l M u 8 J n t k i J n e  
- 4 m i 2 I e D s Q l 7 2 1 b x N E m 5 / P D 4 N w x D I R A + D M R h L D o L Q n D M Q t y E A P Y Z E k T R J b d c 8 4 5 R q 5 9 c 1 2 X Z 1 7 l 5 U  
- 7 2 f c 8 9 u Z + 0 o z 9 M w p N s 6 s z y a / y n / 1 4 q / 1 v q a n 6 K X n n r J 5 u s q K q L s T 4 9 C y 2 j L 5 1 6 x I D z e V q b z b 3 2 d n  
- 1 m X 9 0 z R N R e L F 6 O Z y F + e a / I e q Z 7 Z O 7 q q S 5 X g r S I Q b h t 7 1 e t 2 Y Q 7 m l 4 Q 8 X Q K n 7 u c n t 6 2 J 3 i 1 F p 4 v Z y  
- 6 e K t E Q B F E n i B C E Y Q w 4 E E P A t C 8 O R J E U O e J D Q K A q 4 I S h H j s O g + E s T x H 4 y 0 Q / 8 / S f 2 8 P L e e y v A K I b a J  
- G z x C C Y m l l 5 e k d r q m e Z f y X M 1 r C 4 r i n C / Q o p p n 9 o h / c C p 7 F q 8 8 f C Z m 1 D Q 2 z c W f c 0 e D C 5 v b F 1 6 F 0 1 4 N  
- M m K x L 7 q D N n 4 x 1 s 5 9 p P J 7 E z Z 7 Z 4 C s V a T p O k 6 T p O k 6 T p M e A I p O k 6 T p O k 6 T p O k 6 T p O k 6 T p O k 6 T p N k A I  
- H i k 6 T p O k 6 T p O k 6 T A D / w A e w g A A A E A + v 8 A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l  
- G k b R x H U e R 9 I E h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R  
- 1 I U l S l L U x T V O U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 L w O B Q P R I F I Q g / E Q Q R  
- I E Q M w 5 E 8 S w / E g T R I C s F A i D J c x D E Y R Q + D 8 S R K E U Q R D E I Q B B D 9 k A + E E Q R A D 9 l h A Z p l 2 Z Z B m m S Z 9 l W Y  
- Z J o G d Z B o A + X J l W X a B m m V Z Q Q W I Z 1 l m j Z x t G 0 Z t u W b Z Y P m n X J c m a b B m G n Z t w 2 z c N k B B a p o 2 W a J x G X b  
- p k W 9 a F o 2 1 Z E P 1 y a 1 n G 7 d B k m W a p v X e Z 5 t X e D 8 Q 3 C a B x n M D 9 x m x b x r 3 K a R k W f E B w H Z b V j 3 k Z l k W Z D 9  
- q X Y f R 4 m Y b d 0 G h f x p G e a d 8 3 Q a J t H l c 1 w 3 T f V 8 4 I c N j x A Y i E h D d 9 m 3 h E J 8 X s f K A 3 X a 5 7 H N a x s 4 F e 5 y  
- G u h h x H L g x 8 2 x a x p H m b w P g 5 D w R h T E Q Q B K c o R g 2 D c S B I E M S x O E U K A b C g M A 6 Y U R B E D 4 P R F E w R x C E M Q 3  
- J Z S J o J d e B I H b m X o U a a F H j a a K m 6 h i K W c e l y Z q h S H 5 b i x / V y f 9 r 3 A m F w 4 A b C H H Y e J r m 8 m l x X l o R r 5 p  
- i R k h C Z S J Z + i 2 B X R o V / H b d p n a L i W B 3 I b d 6 Y n c F 9 X s Y 9 w m X f l 6 p z a W X J + b h 2 3 P j O E G 4 g 9 z 3 F h C s Y L i  
- t m o f j V n 2 q o g P X K a t y W x e 2 N I P a u I Z 3 d q q n 9 i 6 t 4 l q q A 6 W n 9 t H h i E Q n 5 E E O Q 6 E U U R J D 4 R R E E c R Q 0 D E  
- R h O c o S x Q E M G A Q C o P x G E E R L t E E R R I E d j m O g x r Y Q c y l 3 l q K x 6 l c W j p l d x 6 6 H p S n 4 F e K Y 6 q o q m I X b l 5  
- c O r l t o T d H A 5 6 a J 7 M A w 9 w b E a e x 6 K m y Z 2 Z p a s L O s S C 4 A w C e r V w T K Y o b u M 4 s g q I s n y + A 6 P a l u 6 b i R + Y  
- M i 1 p Z b n i B m l i 6 K W t a N y 4 D f 6 F 6 u c m p n 0 c e k J 6 q J n 2 o Z V q 2 V o p r X 3 b F 2 X 1 y V 1 q u b e t L H m z I K y i S k s e  
- Z h i I m E N 2 A 8 D o P R K u c Q B D E Q S R C D E N x O E o P B F E 0 T g z B I G Q z v W 9 G Q E g S R F t S 1 G T n m s t m g H a n j g K D d F d  
- 6 B 8 k o a M t P f U P d f z 7 G a e 5 X Z 6 X 1 V 3 3 X o m J t q z f W H q r 3 S 2 S n Z n H T q z R 6 W q n H K C n P G n R y R u t c g m / O n p 2  
- n L K e v W n Z f O F 4 m p 9 j 2 R 6 D T q p 1 O v o m f + c Y L h h v + o e z b + V Z G e I O j L V J c Z v X s h Z 7 Q f m l 7 5 + z f R + W P 6 B t  
- Z R r + k 2 r D x y g + z n o e j a m B 6 K b 1 y m 2 / u W W 9 b T 4 o I 1 + i 5 / x v G R B D 1 5 h C D 1 i A 6 D 8 T B Q 4 l j R C D Q P x K E Q Q x  
- I E s Q w m B w K Q y D 6 7 1 0 D w Q B J E 0 R J Y 0 7 P 2 d x e k q n y f G W d n 7 B t f q Z 5 o h z q C a P z B 0 4 A b X U M z m G j t l f 2 k o D  
- y z V + Q a W K / E Z d q b P b j A s l f x / I z a G + 6 o c b 0 s 1 7 W e N n + v 4 Y S z p 9 W y m G b K q s z C d l s x o a x c T S v a q y + 9 Q b  
- e i + Z 4 + l O q i i H 3 c o G H 2 s 8 B + + 2 o v K H H y i X Z t 6 T H o y w p i I 0 4 4 Q A 7 D o P h P F B 2 L 0 E c O w v D 4 T 5 Z E k U B M C Y  
- D A i k 6 W O M 3 Y S R I Y x j r J m H K K A b V k 8 d 2 l x o o v p u t E c i C K c s + r X y / x 7 9 I c j O 8 D c L 0 P s c 3 l 4 t p r P J b s B u  
- J l b 2 K e 2 v i m 7 / m G H Z m g q w H 7 4 / 5 c / x V t W T q 2 p q o 8 b P 8 X s z I N Q 5 3 F 6 2 6 B + 2 s q C C 8 9 w + Z 7 I e S X d H c R y m  
- s m r r o Y s V 9 X 2 d 3 T I Y 8 5 + 2 v + x 2 s J g G X X V l 9 1 a O n 6 I R A 6 B j X B D g P B J F A R g + E Q Q + L D E N R N E y U x M E 4 N g U  
- B o M N 2 E I R R F 4 k S O M E S H 6 P 1 S Y Z b p x 6 X g s S + P D 0 T D + d o 7 7 N T r n n q Z d X a m d x e s Y d h / O n 8 r r w / Q v x y G 1 a  
- z O n d / z I L N z f N M 6 e 7 2 m 4 q x 9 Y S 9 q q f a s n F d s 9 Z n N a 0 b G / W w / 1 n C y d r W p s l o X F q P Q n 8 o v m X d 8 v T d 2 b L  
- 2 s 3 a x 2 3 N d O G n e w 5 v Y f j S j H 1 y C j 4 t d P p o H i S b n d g m j H j f X b R B D x 5 s M D w P A 8 E k U e J E K U A 2 D q 8 5 G E w Q  
- w k B 0 K g x 3 8 R Z Y Y g R x M E Z 9 R E z f G t j o T I M O y S p I E + q M s j y a B 5 g v u m u Z c j t o J m r s H v s i D G w w F 2 9 X w / r 9  
- T m r P 3 h c 5 9 P 3 d r m b 3 x P Z d d y q J 8 X l z y 3 d w y t P b v r R b M c T K 4 r w m h G e 5 3 M p g 9 u J a K z m m b 3 6 v H n E f x z u j  
- o D b H h d + o K + 8 x s P 7 d i D q 3 6 t 2 r Q p v A 6 q q p o X Q c D 7 8 Z 1 c Q Q 9 D h b x R E a 7 B E 4 w M Q 1 E w S V 8 F E T w y B A G w x E  
- C U B D E V k J U 4 x y h E 1 b M N H g n w 3 u x 5 w H W + q J a j s m s M o y e b Y N p v m d s l 9 1 P F Z P Y 2 2 p l 3 7 Q z 9 7 8 X 6 P C G 4 b 1  
- q m s 5 B 3 u 2 z e j 5 5 o K k I K y p + 7 3 d t n d H y f R 9 X e F p q N w r P 8 h f 1 y M 3 m y i / N c S / / p s n C b P r b a 4 G 4 + G G S l l 9  
- o R c 2 F H + r 7 k X y 1 S i + w 0 d + 9 s o 7 K Z b o z 7 4 A Z Y O A 9 E Y U B H D 4 R B D E i 4 A z E s T H m E 4 T w 5 B Q G A v X N j R F l k R x  
- J E a V / 6 x h q q T 9 O l J s r H H m 4 m e k 5 4 5 7 w 7 / l 6 A H a v q q H V m 7 G p k q a v m Z n j 3 8 M x V q M u 6 P M Y J d 3 w 8 g r G z H b  
- 5 2 s Y K m r A 6 e g i v u i 1 J 3 5 t i z y 8 Z c 7 2 t m i T U m 0 w y g H + 6 f I 3 8 l 6 d a e z n 2 n b x h p Z g r F 3 n A 6 O M m V D 3 b G 2 w  
- 5 + 9 I g h / 4 t j O W q x 6 d / q + s z U H E v j J e P i E P 2 H e z c R A E 8 T w 8 u 9 f N 6 D 8 T B F E M S h O D w I Q d C s N b s E R j u g E o  
- S x E l f G O R x j I n 6 l q M 4 t p i A I z w x 0 s R v j B 8 q i f U + Z s 7 M q e 8 7 E Y k Z 6 k q J o v E Y Q h / K J m d T J N s a G K h B 6 B u  
- J j d h v f W 2 K k t H f H L 2 2 m X q 8 Y o z l 9 H p z Z W 4 q y Y G S e e e c P c 7 H p d 7 t 6 h A C k V 6 C o K g q C o K g p p H g C K C o K g q  
- C o K g q C o K g q C o K g q C o I C B 4 o K g q C o K g q C m k A P / A A 0 J A A A B A P b / P 8 / w A Q J A 0 E Q V A 0 B Q Z C U K Q t D E N Q 5 D  
- 0 Q R F E k T R R F U W R d G E Z R p G 0 c R 1 H k f S B H k A S F J E l S Z J 0 o S l K k r S x L U u S 9 C k j T B M 0 0 T V N k 3 T h O U 6 T t L k  
- I T x P 1 A U F Q l D U R R V D T 5 R l J U p S 1 M U 1 T k V T J T 1 S V N V F V V Z T F I V d W l b V x X V e R x W V f W J Y 1 k W V P F h W Z a V q  
- W t b E q W h b V w X F c l z R p b 1 0 X d e F a P 8 A V 4 A F d k s O E 6 Q 0 D 0 R A 7 D 4 Q B B E Y Q A 7 E 0 a x l E 8 W R f E g B T 5 C M O Q / E  
- E P h G E U P x A E c R x D E B o m I Y g Q R A Z h o m Y D 8 P x C Z l o 2 i a Y Q A + E J n R A b R n W Z b E Q Q / b N t 2 d Z 0 Q 2 5 b V q G n b E  
- P m x Y h t W 7 c R s W / c t p G 7 a N u H I a d x X U a l r G 7 E F u 2 0 d t p G 2 b J 2 x D a p p x C e F z n V E E P W v c V 1 W j D 5 m H a d h 2  
- X l f B 0 G v e g Q n H a d u H x a d 4 2 H f x t G 0 c l q 2 t d F 4 W j c 1 0 W 4 b B u 3 H a p 3 n o b C E W r Y h 5 m r b w Q G h Z i B G p c V r G  
- o b 9 3 2 m c p h 3 b d F 8 G s a V x G r f J 2 3 w g i F 3 2 e s Q X m d 2 K W l e C F n V b W G I l h S J Y G k F / X 9 d 1 / I K c l r 3 6 d K I h C  
- g c P g 9 D w P A 0 D c O x F D s O 2 g h c T R k F 8 T x e G g Q z 8 P 0 K Q 4 D 1 r B C E R p x E E g R Y b i h s o J a 2 A X W c V x 4 l Z m G I d g  
- F n Y Y g V p m 5 a S E G y g e H 6 E a Z 5 p 9 g p m Q / a G A X N a l y I L k O Q 4 I b e k n m e B 5 n R n F q I M e x q I n Y e I W H n t r q O a K  
- p J 5 f J s 2 8 E G H G 1 h R q p / a + Q K 2 k 1 9 4 9 i + F X t c i F p M b a f o x d J t m u p K v o W b p 7 6 8 e y S n 4 h R 4 H u s i z 3 a c N 8  
- X T q B u A + a F s o a i i J Y c e l 3 3 H n h 0 4 Z j t p I T q 1 y 4 o i 2 B r t e 1 0 3 p f C A 5 p D 8 P A + D 4 N w 0 D o R J S b Q R h E D g Q B  
- Z G g W h T F 4 Z A 4 O s / A w k + j h F c E Q R E E Z r R D p i t 5 J q i y 6 o i y 1 n 4 d 2 s o R k p z 5 6 c S 3 p x n d x m t i O K 3 k s 6 M r R  
- b B / M q e 5 2 5 p a W L 7 x o 2 m s j a p y s 1 h m n Z M r K k a + i C 7 a / b O D K B e n R r 0 f J y Z 7 Z 1 v Y i g W R 3 o y / R X V a 2 T X N r  
- W y X y g Z 9 r i k 5 5 G m u a H 2 6 i K D X l Z j a t v h F t H 7 d q M Y e r e 5 s 4 s / N 9 c a W p H h n H P t v 2 m n 7 A 2 l 3 J 1 z R p 3 7 x 9  
- z 5 K s p + m 6 0 y G n l j C L m t D 2 m m Z D 4 O w 0 D Q P 2 F 0 x i g 3 E g a B l F E V x g F k F j q B Q O N e E Z w R C E P s p P j a L u N c l 1  
- N V a a j + F j a k o u k u i I u 2 m C r w i e 8 u B 3 S 9 9 6 s q w 3 4 2 y Q K f 5 e 6 r L d a i e O a L g 9 w f e 6 O I z C q 7 q k y A f d 1 P f L  
- w j X 0 p B d i y + U i 5 w I W f 6 B t o n h i K k 0 X w Z I d r I q Q 0 6 6 H p 7 i I 3 a 3 v c I G 5 v g I 7 b R 6 6 c e y M X x 2 N 7 f c / H N 9 J  
- j L x 8 4 o F 9 m u d 5 t H r j 5 t 7 u 3 Z t t 3 v W K 6 N s P T m q v W 4 h B D w Q B E D 8 P c 4 n / e Y o p D N J 4 8 p 3 L q D o P Q 6 D Y N 6 w D  
- f o e 4 E U W B j F g U R i G U N z 1 A I L Q 6 f A Q x D E M P R B E c S Z P h y D 3 e n n w + L i B 4 a a k i x o x s d 1 J C i + q s y r / Q N e 5 x  
- r I A 3 y S X O h 2 s u Q c X P q d o n O H x h K 7 r I o K E H k y P N 4 V i K v + H n 7 8 6 B 2 5 7 t M e r 3 P 4 z L 7 f 4 t P Y b R c a n X f 3 C J  
- c i t P T t X q r O I e s m I I E n m 3 8 4 p F v 6 c i B v 7 i t C w u 5 m n G o L h R + 6 f s L 8 4 6 r t 7 N N r b I 4 6 z / u P p 0 5 y w 9 D k M w  
- 3 k 8 O p p E U P g 6 F E Z h f F A X R m E 8 / T q C a 3 G H w J i G b k / t 4 j x r y d O 8 K 6 r q p + d / c 0 K L L j t B 7 e L 0 C f m w o T i 9 1  
- t i k L z g p 9 u b d K m q c d 6 k / Z u X b m p 3 X 3 n 2 d r Y 7 Q u r a + L f t 2 W / 8 a M u X 3 u M t N + y 7 K d 3 q A v G i B z H D d + t n b e  
- u 3 7 d e 6 T q q s K I f U g 7 U b I g j 9 K g k L m 3 D c l 4 4 f 5 G q u 9 j a n W I D 1 2 4 e f a J L S m h x X j c O k 4 g n 5 / a C z H x c 4 3 b  
- O m d D 3 n g 2 D 0 Q w 8 5 o P x H E I O h F G M a B T F U Y h X B o 7 Q T D d o x E E V 5 h E E e T + 0 4 y 2 P Y i D f J C j 9 s H w 0 y D v j z S s  
- n z e L g O 7 r K x a B i P i 6 y h + m t v j 2 O m u z i k 4 X 9 z h q a z T 8 X f b x q 3 j j 2 I H S 0 5 t f 3 e 7 h s g 8 i e X z s b b o T u T 3 P  
- 4 n 7 T 4 M h 6 H d A 8 Z 1 n O t b i G u h i r q B 1 f S Y L t O A X B n W n 4 f n L E K y p K C J 8 3 + 9 X e g + 1 b t 0 O w r G f y f o E b y f 9 M  
- E O + n + r O + p P r i H 7 I c h + 3 K 3 a r J y y 1 u w 9 D 4 O g 2 D U P R D D c P h I 7 c R B S G U W R S G I Z A 2 P U B g t D o P H b m p o h G E  
- e N 2 h d z 8 c v p K n b H n a s s z s 6 0 d Q s h y s w 1 P 6 + B c x / K m o G f X U 7 x 8 f U d p 3 t 7 d 6 m 7 y k d 8 6 F e W 3 q y / j G r Y b V  
- s / c Z j m r K r a s m j n u A v X 0 L L X 9 r O J a a r u Q q T g m s 6 p r v f 4 g i u e b m a y E I e k T N a T q q t X L b 5 3 t d u 3 w 4 + b z 9  
- W t b f T a J q O e J 5 / h 3 4 N a r 5 s y z P J Y x j D 1 6 3 g j O G 8 D s N Q 1 D y W G E E A R R B D k R h k G M U x Y G c W w R O g F Q 5 8 E R B  
- E b Q R e 2 o 7 X p 9 b F t 6 d r J t o n 8 Z y q y 4 u + q G k j G X p g y 8 O P h C 4 t P e W H / 4 z q d e U d f a J H / h 3 q w 9 x s 2 j p i C a h  
- k i C r l g z k o F 4 t i J o d C H r K a P k n D i + I L z d L H H j n e w r C g + f n f 0 + f o J q G H v s z i q 4 S a 5 u o P d m 9 f X g + I Y 6 c  
- N 3 G v p B r s 4 g 1 y K E 4 t v 5 + c j P o n r B v N D 0 6 B I x 0 2 z 8 o g j h p C 9 y E H d h B 3 f K b Z h 3 w D w O A 0 D u / w 7 d v F g 5 E Q  
- Y R p F M V R h F s I z q A 4 N 9 p E L F s Y w J 2 5 0 d T e 4 a 1 6 x e E s h w + 8 p P Q H a v H M L C / y Q q 3 o p 3 8 w k T S X f d i R 7 V n 7 N  
- M t z 7 + 5 J 0 C y r a b Z 6 3 t h + 4 7 R s p w t T 3 a t o n n r N c 0 g 1 6 K B 2 V v 9 B c e n L X t a n J y 5 h y n O c S i v c y 6 n 6 Z i P N 8  
- 4 b 9 2 b n p D 8 q 7 a t w a q n K G 7 b h 5 y q Y g X l s u 9 W x 6 a 1 O G Z + c r 1 G 2 i e s n W j z 2 J y x 8 Q p o g 1 3 n 8 c D a 4 D l I O w 5  
- D U O J r w R w Z v E M W B o F c U R k G A K T x A w M w 6 c D G G H E j A o o E O + r q s L L 7 q u q t m s f u k M g o X i I e D 8 P X b y K c o d 9  
- L 8 X X r L k q N j r K J 1 u 7 n M 6 d + K 6 F d C n P c i X d K U c b K I 8 / O g X L y + 2 4 O 8 Z 0 r t i v N + G E C a M Q d + A q u u q 6 n t y W  
- s n f 0 b Q H I n j I I I f F y 7 K d 5 7 q 0 g 3 I 3 I B Q b L O s 6 z r O s 6 z r O s 4 e A I s 6 z r O s 6 z r O s 6 z r O s 6 z r O s 6 z r O s 5 o  
- g I H i z r O s 6 z r O s 6 z r O A D / w E o I A A A B A P n / P 8 / w A Q J A 0 E Q V B k H Q h C U K Q t D E N Q 5 D 0 Q R F E k T R R F U W R d G E  
- Z R p G 0 c R 1 H k f S B I U i S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M 0 0 T V N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F Q l D U R R V G  
- U d S F J U p S 1 M U 1 T l P V B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F h W J Y 1 k W V Z l e P 8 A V i A F A U w M M y w 2 D w P g 4 D  
- 8 P x B E Q R A 8 E 4 a B h E k T h T D w G g d D M O g 8 D 0 O h D E Q P x C E E R R B D 8 Q B C E B k x B D 4 Q W T X Z k G X Z g Q G P Z t l W U Z p  
- j 2 Z X Z o W X Z A Q G Q Z J k 2 p a x o W d E A P m d X Z o x C X V l G u a l p W l a l p 2 Y a t s 2 x E F n n B a B l 3 H a 5 m 2 S Z t s G L Z p r  
- W c c k P X J a 1 q G Y D 8 Q 3 Q b d n 2 l D 5 i 3 E d B q W 2 c Q P X D b x k V 1 D 4 Q 1 1 c x r G i e 5 u 3 D d F m H m Z F s m Z Z F n H P b N n n  
- b Z t t 2 v Z J u 2 9 a x p 2 a a p v W W b l / X 4 Y 9 w G y b N 4 3 V a x q 2 y d 5 j H 1 c M P m W f J l 2 W Z B m W X g J 4 X / b 1 p W + Z 2 H 3 o  
- f 9 1 n j d a C 1 1 g I Q h D b Y P g 8 j c N w 2 D 5 h w 8 j N j B E E 8 Z B g E c U B V D U F A i X E P Q 7 D s Q B D Z c Q x F Z N j H N c J / I p c  
- F u H 0 h y J 4 Q g V v I K f 1 o W 7 g K B m m m Z v 2 s l y J 3 b g d z G j b R v W P a 9 / J v f l s J a l M P 4 K g d s H T i h o 4 G b Z t G o b J  
- 7 W + f h 2 a G e x u Y p a e L p z b x x K G n R 9 G v n O c o H c + h H o e W h 2 6 b 6 G m S o t 8 n 4 e d y Y K g S H p 5 b O n G L e G j W g n V 7  
- m t g 5 w l 1 a q G n y Z Y P h C b Z w Z 7 E E Q o c b C X m d Z W g a S d Z 7 6 a n p z n x p K t W w E J e Q 9 j Y O Q 3 D o P w 6 D q w x C E d 5 R  
- Z G Y V h J F I U w y B E I Q 2 D 0 P 2 G E S w n D k 9 k a D r S D m o d Z p 3 H b d z o l p e z 4 h c R u 4 n e F q H t d C + a y c + y a s g N 6 G 5  
- r 2 e o E n h q 2 M w W q o g n h u 6 9 g C m H V o 9 0 K p v S p 5 V c m L 4 N s N / G y r + Z s I f N q I S s u d 6 M e J t H e o 5 q 1 2 p S / n C m  
- V 1 a v n G I H E x 3 H W u m z P 2 8 p y k d C l y l q Y y O j n n f 2 x J a r z O H d c u c W g q 9 0 a R f m K G k y v Q Y I p t + 9 F 0 K Y G h 1 a  
- T p T Z e 7 J L D i 6 w + D m P Q + E U R A 9 E c Z B l E w T R U E g I g S C s O g 9 D 0 P J P v C N L H v m K q H v t y H w e Z z K M Z 6 q 6 t z C y  
- G q i F 7 H 7 v + w s m c a V c F 0 + I J U Z V l q D h J 1 H D n Z l B D h u + Z k f e z 9 U e 7 P a 4 4 / H G 4 1 3 s 4 j f u c 4 G 5 R s Y C 5 n o e  
- N p a e H a h T O c d l S H 9 b l i f Z T w S x 3 6 7 / G c X q 9 3 u r 5 n G M R 1 3 q M u Z S K J q x X N G l o O s u U r i B a / z 9 u H q m 1 o o a  
- r W b n W x C x 4 W Y y f I Z r d s K B x K x Y O i L + g + 4 M O w 4 X Q P A 3 D 2 T 5 P E c V x n F c R x V F A L g T C Q O A 7 3 K X G J l L j 7 S s  
- B 1 K t s / n o J f L B 3 b l / K M I x j m H c 5 P R Z y i b 5 O c Y v 9 3 N n P 9 + w r b b L S 4 / 4 7 A i a r a t s i Y n R v R 9 O Z + O M L 1 c 1  
- o v 1 g S / H a o + p r 2 m K I c k r X v 8 Y r a f d l b n U e 5 q H j G 4 9 3 k Y T 8 h n q 9 h d o 2 T o a V I v n K m K e n L o Z a v d 4 P A c 6 l  
- c Q + P Z a Y y t 2 R A t Y P A 7 D d d A 8 4 N k R G a k T x l F s T B O F c P Q X B k M 2 G k u 7 2 S E N 2 Z U s O y G c q H o v t 9 a C P a p j s J  
- f 9 d 4 m 6 + j C s x g W t I m s J 9 3 9 f + m H g 5 X j 3 U e h 2 c A g V 0 d T a m h r I Z P z v I 0 q L Y A Z x n 8 e o / N v I b j m 7 6 2 b 2 J v  
- f i j X N q e Y o h l n x 4 l 8 u p X u v a r c O b i j F 1 d l p L 5 c 1 m a / + 9 z c G Z x n 4 J l r K H 3 f K I 9 t k 6 D J u / 5 k 4 Q X a 9 M S 1  
- v G L 6 0 T J Y m d x 7 a + a n h A 9 D Y N 1 y 3 N k 9 2 D 4 R h h G Y T R M 3 4 J Q S C x h e F k 6 w q + c v n p 8 q x 8 8 G / R 4 K U r a X s B Z 7  
- + 5 s f T S Y Q 9 Z 0 X O s D q q M p t 9 X 0 w Z n p U 8 j / n P q S r d i c X j q o 8 C o c z 7 C j W 4 9 2 + q o Z 3 K K t 9 L H p y i Z z n 0 o h 4  
- G 5 w N + G T x C a O 4 2 b v 9 i f / w + o w J r p l q l 4 n X 9 K Y X b b i p s R o y c a 9 e a h m f h B o 7 H y J 9 r A l O H 8 w 2 Z z e g m y B K  
- 5 6 1 s Y 7 k s N w 4 Y Y N 3 q E O T x G F U Z h X E k U x Q C 4 E w n D e S 4 3 d i w h E r 7 b J h v e W X g 1 x x r 4 0 X E q / l a W t B x L R Z a  
- 0 j N I O f e B d O l 9 5 o D c i 9 4 d 8 9 n 3 A e 5 8 n w p b A r S d F 8 a 0 y 9 7 m j / 6 m n g f a 0 t D b H / s u f X Q K n s m + p f g e Z a p o  
- 2 p 9 E x K w M G 5 j 6 u / h y Y Z t f 3 + p Z r V o 5 8 r 5 j 6 k 8 9 m c Q p h 9 d m / 2 + q W 1 t l X 4 9 7 O s / 8 G w m x t Y P A 3 D e 1 g 5 e U  
- P 9 2 D w S R g G P f B W E c I A U C 3 g w / D s P 2 O Z G N K v 5 7 H P c v S Z 4 A x n 4 / X c n o B A D 1 w G v x b R W u + j H n O r T 4 t i l f K  
- c t l V y H L l + p b A c X m 2 a x u c + M x 3 9 a r c 5 w L 3 n a 9 / i 9 F r X A 5 v / q w 0 B o 5 4 f 3 T n 5 s v Z 9 m 0 C s v S x 6 X 5 f 6 f B +  
- b r a y 3 c h 7 v 7 I a P u v h i y y O e n G o P U h C m 6 + x h 7 K h d t / M m i u 9 3 2 9 T / X m / q M 4 7 n s P Q 4 D c O 9 y D x s R G Y o R B f  
- G U U B K F Q T A n B M K g 4 j Y O m R u + v u l x d u e k b m b r 1 6 K W a h 5 B 3 6 L 2 b H Z u g S L 8 k p v 6 K w e P j K Y h 7 K 2 f s f A 8 G a  
- a I M F 5 j J n N 0 q y r 3 c e q Z y i a w J v 0 G X 5 Z q q o J Z 2 a c Y J r O c P i 6 L I 6 D m z R Z X 9 f v o J Z X z Y V d + H N a 2 m t I c 7 /  
- G 4 m v q m K B s C V v b x b W 5 w c j L 8 e f T M 2 v a L Z H g h 6 m G f h O V G 0 d k P 5 L Y c N g 7 D 4 O w 4 Z 2 1 G J F s Z x S E k V R N C Y F  
- A q 3 M P g 6 y p n R G h h n b D / X y M W s j 9 H t 0 F z a R z j s H v f q r H z f / X 6 Q x x 5 4 v + 3 s G d s P C H v 4 r 8 n u Z 6 Y Y c h v 6 K  
- R Z q q Y e v 2 w 9 I 9 T m r R 0 G X 6 B 6 D w O Y m X Y n I Z q q f X t J r + + d X 6 H 8 x h 3 P f x b + 2 u B c a a N o 2 j a N o 2 j a N o 0 e A I  
- o 2 j a N o 2 j a N o 2 j a N o 2 j a N o 2 j a N o 1 k w I H i j a N o 2 j a N o 2 j a N A D / w B Y I A A A B A P n / P 8 / w A Q J A 0 E Q V B k H Q  
- h C U K Q t D E N Q 5 D 0 Q R F E k T R R F U W R d G E Z R p G 0 c R 1 H k f S B I U i S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M 0 0 T V  
- N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F Q l D U R R V G U d S F J U p S 1 M U 1 T l P V B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F h W J Y  
- 1 k W V Z l e P 8 A V i A F A U w O A 5 Q 8 D 0 P Q 7 D 4 Q Q / E M Q w + E g Y R X E A R B D D w M g 3 D p h A 6 D w Q R D E A Q h C X Y Q B A E E Q W  
- O E A P w / Y 8 Q V 1 Y 4 P 2 Q X V m m a Z E P w + E J n W i Z p k 2 S X Z k G V a Z j 2 n Z R r W R Z l p Q / E J k 2 N a Z t G r Z V j W f b B m G s  
- Z J l W l b B w G e c N k m P b N x m d Z B t W 5 c N d m g b B w 2 V a F q m b Z 9 p m R d g Q G h a h n X N c h n 2 U a J i m 6 Z N p X H Y 1 y 2 w c  
- F v 2 / Z R v H h e d v 3 b b p n m 1 D 5 4 X e Z l j W 0 f Z 2 X v g B y H H e h j m 2 e Z v 3 5 c h o n s Z e B h C D 5 1 G K d p 4 2 T f l j I H d C  
- B m Q Z d w Y U h B w G W c t w X J a M P W 2 g x 5 3 T f 5 9 B D X Z c g 8 D 4 O w 6 a A O 4 n E F j B D E o X h W Y 8 R A 5 D A O I 2 D 4 O Q 5 b N t  
- B E c 9 7 4 I b N 8 2 7 g Z 7 Y G c h / 3 0 a 5 4 W y a y T H Y e h m 2 1 b p m 3 o a G I W X d J t V 2 f l z I F d Z 6 X H h N 9 o r h p w I U f B q 4  
- g n J s 2 q Y 6 a I F Z E P W 0 d 2 c X g a d n J l a p 5 n s b K F J 3 e S B 4 i l N 2 G p e W E W 4 k 2 T m T e R j 2 c Z Z 2 Z o a + h n G Y 2 Y m t  
- e B 9 3 c a h 6 Y e o d k q E k 2 V l 1 h y e a m r C m Y d a m G G g c 1 w 6 E r l p q H f a C J Q d m X G 3 b q L o y j U O g + j J h 2 V E V l R U F  
- 4 T W I E M O g w D Z h A 9 j R i H M a g Q 6 p o l 4 q Q e l d a v m 1 3 6 g u R 2 p 3 Z K E H s f y W X Q d K o o K l J m Z t a m v 3 M e C F 6 t a e  
- / p p q e 9 Z 0 q i U X k o a W X l v Z p W k g K 9 W + k 2 r 2 u a h t r x w J 1 q t x W X 5 Y u 9 k a 7 m Z u W O f 5 6 m 8 l 2 e m 0 f s Q Q 9 h O o  
- s S q P E H u h n F n 6 l S v s h s q O M 0 c a j 3 g x 2 9 c J l a 4 W Z y L C J S d + m Y b f V / H e g 5 r J P n u a Z 4 x q W X m p V 8 G 4 Y w P w  
- 9 1 l c 4 2 D + R o G E Q P h F F w W x G E E R R B D I M w 3 D j X I Y h h p 4 N y 2 w W d i W I V 3 x F 5 9 D e q U 7 e c d m N 2 i q l 3 L d y I n 7  
- i q i o e e 7 C m R b i E W p d K s X k a K m L s z 2 B b m 1 F 0 5 e o 6 o d N q a g u b n K A 7 A b t 7 X M q 9 v s 2 u + / u q v 6 q e f 4 9 l d w l  
- F d s M c S H G x f J p K J w u C p c r + V X e m / w 8 w l 6 e Y s g S m 8 P Y / B o O Z 9 t I n 0 L P b u 0 O X m Y b T v L 3 a v n K U Z 5 8 P f 8 W  
- 8 o N x R 8 O N j h 3 A 9 X F c 9 a D z X 2 L 2 c U B g E 8 P l / D M N A 4 D w O / u D x r F 4 w C U H C i q e Z p 3 p 1 o Q 0 Z p J b 6 i D J k m y d  
- N 5 h l 9 9 1 4 u B s q 5 G 8 a l 0 m V d K w v n L 6 p B r m M v S a 6 s v a D K d m v d Y D i m n 5 k u a S s t m S r a q d + C H 7 6 W v a n f u a +  
- m 4 R 9 a n 0 H m N 8 e V t r 2 p i Z H W q f L b D r 3 t o k c V v X h a H y Z 7 0 2 i K l r 2 / 3 O 6 a 9 u R o 2 F J P Z F i Q / D z W f 6 D 0 P r Z  
- a Z e A + E s X R V E I R B E D w M Q 0 D s O f 6 D x i 4 T b B u K 9 f H f H e p j h K X f N 8 r 2 + X B u v u 7 2 6 G u 3 h 2 r j j K q e 4 d 8 r 2 f  
- q 9 o L h v F 6 M f z A 9 H 5 h 3 I g f H R / b 6 B q 7 6 y 2 + J r s P 4 K R o 3 k Z k 8 B w G k p F t q X 5 z N Y E 7 b V I I 4 e C I a e y K Z 0 7 P  
- x 8 B 6 R z 5 i m i D u V v b k W 2 f y I L 0 Z B o m Y E F h 2 L v b T 4 b r 2 l + 4 q q n 6 e k z y Y I q d 0 o Q a A P r Z X T 7 O 2 E Q P x E F o W  
- x H 2 c Q A 0 D Q N w 5 / o O o 4 b S x u N v a G q g 0 C U I a p W I Y L d X y n u r H A p k 3 G 5 L w g n p o M Z S w 3 4 p H c p P l d q I p x R r e  
- 8 c + h p r d x e W r d e B K l 8 z A O C q O 9 q b + b q r h 8 9 9 Z K k 6 B 4 M 4 D k W r u r d X x 9 q G 2 z v R 2 f i 9 / p K g r 2 U n b 0 r I G k  
- p H r K n + B 0 3 Q 4 7 J 4 e 6 K Z 2 R Y m e r w Z p n M G p t 3 3 r 8 e 8 P D f G 3 u 5 D 5 c t Z Y Y P 4 z D 6 L m M E U T x e E 9 i h C D b + P 7 D  
- 0 O Q 7 Z o Q l 4 a x 3 Y X 4 y 5 5 4 l 7 E + n e v g L + 0 f P r 2 m x u q d b b p M 6 m e 6 n 8 w N 0 8 U l C 5 5 K o f j n s g x s 2 c u d s q f x 3  
- t 2 7 m e T 5 L 9 D x 7 + 6 t 2 W 2 l N r L t d X N Z Q x r M Z 4 8 r n 6 x + H p 9 C 9 z 3 2 t 4 T U 6 n 4 e B I M p 1 1 n b b b Q m u u V j I R g N i  
- t H m f J / I n m C K d l f s 3 j d + 5 7 B q S l G K g 9 o A 9 D 6 2 Q 8 a D X 1 3 t 4 R B b F k R h C s 4 M g 0 k U P P 6 X e G M T g m p + z b q r M  
- 6 l q 9 r w 3 x m p / z / 2 3 O v D p 2 8 + D I c H r S + J t o 7 3 L q 5 z j Y D k 9 8 e K 8 p / O E Z R w v K w h 4 q l 6 Z w t G a u F G X w y + v g  
- g u w u l Z m r 3 b 3 x i s m p q 6 q p m W v X Q Y n g r E f v N d 8 5 G I W K 7 i Z m 6 v S Z d M d z W M F x X 1 G K e f v Y T v a a K n 7 X r 3 f y  
- L i r D 0 9 i m n E N c m g D 9 h g 8 1 7 K m K E R i h Y F 4 R 1 + E I N w x Y P + r J E N i 8 n 9 + q I h 8 K m s 6 e j V M o 3 S w 8 j + a q / Q x e  
- X n P l a 8 O c s P n M B x m 3 H C m K i r 3 l i a / c 7 r i W t w a g r m 5 H H W 8 n j f K K f u f M S d C m P P v D E u z 3 f C e k 8 7 U 8 J l e I  
- 8 A + C D H f a P 5 u F k r h X e p R q + Q r H h J b p G V 5 W h O K v I r S d H b v j R W 2 0 p 7 e V l u C 3 O c J 3 5 N d K 3 g / + v + o R D o O 2  
- S E U Q h D F Q X x J D / a A y D U O b J D x h G K Y s R L n h C v p q y G s a y b t m G Y c q l Z t 4 X e 3 5 b N m H 7 x p v N z l D q t y v 5 z W 6  
- d 2 e c U c 9 6 7 t l 5 0 I s m d 0 8 l x z h W 2 Y r j / d n e v r x l / 3 N 6 b 2 X a F i G D J 5 n y 9 m r u q p s a z 2 7 Y D 3 y k b m c O E H o 7  
- N k w s F S b Z t m 2 b Z t m 2 b Z t m 1 k h 4 A i b Z t m 2 b Z t m 2 b Z t m 2 b Z t m 2 b Z t m 2 b Z t m 2 b W S A g e J t m 2 b Z t m 2 b Z t m 2  
- b W S A D / w A F A E A A A E A A A A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E  
- h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O  
- U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 M R A W 1 b l v X B c V y X N d F 1 X Z d 1 4 X l e l 7 X  
- x f V + X 9 g G B Y J g 2 E Y V h m H Y h i W K Y t j G N Y 5 j 2 Q Z F k m T Z R l W W Z d m G Z Z p m 2 c Z 1 n m f a B o W i a N p G l a Z p 2 o a l  
- q m r a x r W u a 9 s G x b J s 2 0 b V t m 3 b h u W 6 b t v G 9 b 5 v 3 A c F w n D c R x X G c d y H J c p y 3 M c 1 z n P d B 0 X J H g C H N A g e  
- G b A D / w A U A Q A A A Q A A A A A Q B A U C Q N B E F Q Z B 0 I Q l C k L Q x D U O Q 9 E E R R J E 0 U R V F k X R h G U a R t H E d R 5 H 0 g S F  
- I k j S R J U m S d K E p S p K 0 s S 1 L k v T B M U y T N N E 1 T Z N 0 4 T l O k 7 T x P U + T 9 Q F B U J Q 1 E U V R l H U h S V K U t T F N U 5 T  
- 1 Q V F U l T V R V V W V d W F Z V p W 1 c V 1 X l f W B Y V i W N Z F e P 8 A V g A E / 0 x E B b V u W 9 c F x X J c 1 0 X V d l 3 X h e V 6 X t f F  
- 9 X 5 f 2 A Y F g m D Y R h W G Y d i G J Y p i 2 M Y 1 j m P Z B k W S Z N l G V Z Z l 2 Y Z l m m b Z x n W e Z 9 o G h a J o 2 k a V p m n a h q W q  
- a t r G t a 5 r 2 w b F s m z b R t W 2 b d u G 5 b p u 2 8 b 1 v m / c B w X C c N x H F c Z x 3 I c l y n L c x z X O c 9 0 H R c k e A I c 0 C B 4 Z  
- s A P / A B Q B A A A B A A A A A B A E B Q J A 0 E Q V B k H Q h C U K Q t D E N Q 5 D 0 Q R F E k T R R F U W R d G E Z R p G 0 c R 1 H k f S B I U i  
- S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M 0 0 T V N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F Q l D U R R V G U d S F J U p S 1 M U 1 T l P V  
- B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F h W J Y 1 k V 4 / w B W A A T / T E Q F t W 5 b 1 w X F c l z X R d V 2 X d e F 5 X p e 1 8 X 1  
- f l / Y B g W C Y N h G F Y Z h 2 I Y l i m L Y x j W O Y 9 k G R Z J k 2 U Z V l m X Z h m W a Z t n G d Z 5 n 2 g a F o m j a R p W m a d q G p a p q  
- 2 s a 1 r m v b B s W y b N t G 1 b Z t 2 4 b l u m 7 b x v W + b 9 w H B c J w 3 E c V x n H c h y X K c t z H N c 5 z 3 Q d F y R 4 A h z Q I H h m w  
- A / 8 A F A E A A A E A A A A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I  
- 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F  
- R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 M R A W 1 b l v X B c V y X N d F 1 X Z d 1 4 X l e l 7 X x f V +  
- X 9 g G B Y J g 2 E Y V h m H Y h i W K Y t j G N Y 5 j 2 Q Z F k m T Z R l W W Z d m G Z Z p m 2 c Z 1 n m f a B o W i a N p G l a Z p 2 o a l q m r a  
- x r W u a 9 s G x b J s 2 0 b V t m 3 b h u W 6 b t v G 9 b 5 v 3 A c F w n D c R x X G c d y H J c p y 3 M c 1 z n P d B 0 X J H g C H N A g e G b A D  
- / w A = < / p a r s e d w a v e f o r m s >  
- 	 	 < r e p b e a t s   d a t a e n c o d i n g = " B a s e 6 4 " > < r e p b e a t   l e a d n a m e = " I "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 6 "   p e n d = " 2 1 4 "   q o n s e t = " 2 5 8 "   q e n d = " 2 9 6 "   t o n s e t = " 3 6 0 "   t e n d = " 4 7 8 " > D A A N A A 0 A D A A O A A 4 A D g A O A A 8 A D w A P A A 0 A D w A O A A 0 A D Q A N A A 0 A D A A M A A w A D A A L A A s A C w A M A A w A D A A N  
- A A 0 A D g A N A A 0 A D Q A N A A 4 A D A A M A A s A C w A M A A w A D A A L A A o A C w A L A A w A D A A M A A s A C w A K A A s A C w A L A A o A  
- C g A K A A o A C g A L A A s A C g A J A A k A C g A K A A o A C A A J A A k A C g A K A A k A C g A K A A g A C g A J A A g A C A A I A A k A C g A I  
- A A g A B w A I A A g A C Q A I A A o A C A A H A A g A C A A I A A g A B w A H A A g A C A A I A A c A B w A H A A g A B w A H A A Y A C A A I A A c A  
- B w A H A A c A B w A H A A c A B Q A G A A c A B w A H A A U A B g A H A A c A B g A G A A c A B g A H A A c A C A A H A A c A B g A H A A c A B g A H  
- A A Y A B w A G A A c A C A A I A A c A B g A H A A c A C A A H A A g A C Q A I A A g A C Q A K A A s A C w A L A A o A C w A M A A w A D g A P A B I A  
- F A A W A B k A G g A c A B 4 A I A A i A C Q A J g A o A C g A K A A p A C k A J g A m A C U A J g A l A C M A I g A h A C E A I A A f A B 8 A H Q A b  
- A B s A G Q A Y A B Y A F A A T A A 8 A D Q A L A A k A C A A F A A U A B Q A F A A Q A A w A C A A M A A Q A A A A A A A A A A A P / / A A A B A P / /  
- / v / + / / 7 / / v / + / / 3 / / v / / / / 7 / / v / / / / / / / / / / / / / / / v / / / w A A A A A A A P / / A A A A A A A A / / 8 A A A A A A A A A  
- A A A A A w A E A A Q A B g A K A A 8 A F w A a A C I A L A A 2 A E A A T g B a A F 8 A X g B X A E c A O Q A x A C A A A w D o / 8 r / p v + F / 3 T /  
- e P + K / 6 L / t v / J / 9 n / 6 P / z / / 7 / B w A M A A w A C g A K A A 0 A D g A N A A 0 A D Q A N A A 0 A D g A Q A B A A E Q A S A B I A E g A T  
- A B Q A F A A V A B U A F Q A W A B c A F g A W A B Y A F w A Y A B k A G Q A a A B g A G Q A a A B o A G w A c A B 0 A H Q A g A C M A J Q A m A C g A  
- K Q A o A C k A K Q A r A C o A K w A r A C w A K w A r A C 0 A L A A t A C 4 A L w A v A D A A M Q A z A D M A M w A 0 A D U A N w A 5 A D w A P g B A  
- A E I A Q w B G A E c A S A B K A E w A T A B O A E 8 A U Q B S A F M A V Q B W A F g A W g B a A F 0 A X w B h A G Q A Z g B o A G o A b Q B v A H E A  
- c w B 2 A H g A e g B 8 A H 0 A f g C A A I E A g w C G A I Y A i Q C K A I o A j Q C O A J A A k A C S A J M A l A C U A J Y A l g C W A J Y A l g C V  
- A J U A l A C S A I 8 A j A C I A I U A g g B 9 A H o A d Q B w A G w A Z w B i A F 8 A W Q B T A E 8 A S Q B G A E M A P w A 6 A D Y A M g A v A C 0 A  
- K g A l A C M A I g A f A B w A G w A a A B k A G A A Y A B c A F Q A V A B Y A F A A R A B A A D w A M A A w A C g A I A A g A B w A H A A g A C g A M  
- A A 8 A E g A U A B U A F A A T A B Q A E g A Q A B A A D w A N A A 0 A C g A K A A k A C Q A K A A w A D A A N A A w A D A A N A A 0 A D g A O A A 4 A  
- D g A N A A w A D Q A M A A w A C w A L A A w A D A A N A A 0 A D A A M A A w A D Q A N A A 0 A D Q A N A A 0 A D Q A N A A w A D A A N A A s A C w A M  
- A A s A C w A M A A s A C w A K A A o A C g A L A A o A C w A K A A k A C Q A I A A g A C g A J A A k A C Q A I A A g A C A A I A A k A C A A J A A k A  
- C Q A J A A k A C Q A K A A k A C Q A J A A c A B w A H A A k A B w A G A A c A B w A I A A c A B g A I A A c A B w A G A A c A B w A H A A g A B w A G  
- A A g A A A A A A P / / / w / + / / 8 P / f / / D / / / / w / / / / 8 P / v / / D / 3 / / w / 7 / / 8 P + f / / D / b / / w / 1 / / 8 P 9 P / / D / T /  
- / w / 1 / / 8 P 9 / / / D / f / / w / 3 / / 8 P 9 / / / D / X / / w / 0 / / 8 P 9 P / / D / T / / w / y / / 8 P 8 / / / D / T / / w / 1 / / 8 P 9 f / /  
- D / P / / w / x / / 8 P 8 P / / D / H / / w / z / / 8 P 9 P / / D / T / / w / 2 / / 8 P 9 / / / D / b / / w / 1 / / 8 P 9 P / / D / P / / w / y / / 8 P  
- 8 f / / D / H / / w / 0 / / 8 P 9 v / / D / b / / w / 3 / / 8 P 9 / / / D / X / / w / z / / 8 P 8 f / / D / H / / w / y / / 8 P 9 P / / D / f / / w / 4  
- / / 8 P + P / / D / j / / w / 3 / / 8 P 9 f / / D / T / / w / z / / 8 P 8 / / / D / b / / w / 4 / / 8 P + f / / D / r / / w / 6 / / 8 P + P / / D / f /  
- / w / 1 / / 8 P 9 P / / D / X / / w / 3 / / 8 P + P / / D / r / / w / 6 / / 8 P + v / / D / j / / w / 3 / / 8 P 9 f / / D / X / / w / 2 / / 8 P + P / /  
- D / n / / w / 5 / / 8 P + v / / D / r / / w / 6 / / 8 P + P / / D / b / / w / 1 / / 8 P 9 v / / D / j / / w / 6 / / 8 P + / / / D / v / / w / 6 / / 8 P  
- + f / / D / j / / w / 3 / / 8 P 9 / / / D / f / / w / 5 / / 8 P + / / / D / r / / w / 4 / / 8 P 9 v / / D / P / / w / v / / 8 P 6 v / / D + n / / w / s  
- / / 8 P 8 v / / D / b / / w / 5 / / 8 P + v / / D / n / / w / 3 / / 8 P 9 v / / D / j / / w / 7 / / 8 P / f / / D / / / / w 8 B A A A A A g A A A A E A  
- A A A A A A A A / / / / D / z / / w / 6 / / 8 P + v / / D / v / / w / 8 / / 8 P / v / / D / 7 / / w / + / / 8 P / f / / D / z / / w / 5 / / 8 P 9 / / /  
- D / j / / w / 5 / / 8 P + v / / D / v / / w / 9 / / 8 P / f / / D / 3 / / w / 7 / / 8 P + f / / D / j / / w / 3 / / 8 P + f / / D / z / / w / + / / 8 P  
- / v / / D / 7 / / w / 9 / / 8 P / P / / D / r / / w / 5 / / 8 P 9 / / / D / f / / w / 7 / / 8 P / f / / D / z / / w / 9 / / 8 P / f / / D / v / / w / 5  
- / / 8 P + f / / D / j / / w / 5 / / 8 P + v / / D / 3 / / w / + / / 8 P / v / / D / 7 / / w / 8 / / 8 P + / / / D / v / / w / 6 / / 8 P + v / / D / z /  
- / w / + / / 8 P / / / / D / 7 / / w / / / / 8 P / f / / D / r / / w / 5 / / 8 P + f / / D / r / / w / 8 / / 8 P / v / / D / 7 / / w / + / / 8 P / v / /  
- D / z / / w / 5 / / 8 P + f / / D / r / / w / 6 / / 8 P / P / / D / 7 / / w / / / / 8 P A A A A A P 7 / / w / 7 / / 8 P + f / / D / n / / w / 6 / / 8 P  
- + / / / D / 3 / / w / / / / 8 P A Q A A A A E A A A A A A A A A A A A A A P / / / w / / / / 8 P / / / / D / / / / w 8 A A A A A A A A A A P / / / w / 9  
- / / 8 P / P / / D / n / / w / 1 / / 8 P 8 v / / D / H / / w / x / / 8 P 8 / / / D / f / / w / 6 / / 8 P + / / / D / r / / w / 3 / / 8 P 9 P / / D / H /  
- / w / v / / 8 P 7 / / / D / P / / w / 3 / / 8 P + P / / D / n / / w / 7 / / 8 P + / / / D / j / / w / 0 / / 8 P 8 v / / D + / / / w / v / / 8 P 8 v / /  
- D / P / / w / 0 / / 8 P 9 f / / D / X / / w / 0 / / 8 P 9 P / / D / T / / w / 0 / / 8 P 8 / / / D / T / / w / 2 / / 8 P 9 / / / D / j / / w / 4 / / 8 P  
- + P / / D / f / / w / 2 / / 8 P 9 / / / D / n / / w / 8 / / 8 P / v / / D / 7 / / w / + / / 8 P / f / / D / v / / w / 6 / / 8 P + / / / D / z / / w / +  
- / / 8 P A A A A A A A A A A A A A A A A A A A A A P / / / w / 9 / / 8 P / P / / D / z / / w / 8 / / 8 P / v / / D w A A A A A A A A A A A A A A A A E A  
- A A D / / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " I I "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 7 0 "   p e n d = " 2 4 8 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 4 "   t o n s e t = " 3 4 8 "   t e n d = " 4 8 2 " > C g A K A A s A D Q A M A A 4 A D Q A M A A s A D A A L A A w A D Q A N A A 0 A D Q A L A A o A C Q A I A A c A C Q A L A A w A D A A M A A 0 A C w A K  
- A A s A D A A M A A s A D A A N A A 4 A D g A M A A o A C Q A J A A o A C w A M A A w A C w A J A A g A C A A H A A g A C Q A L A A w A D Q A M A A w A  
- C g A J A A k A C Q A L A A w A D A A M A A s A C w A L A A o A C Q A I A A k A C g A K A A s A C w A K A A g A B Q A G A A Y A B g A H A A k A C g A L  
- A A k A C A A H A A c A B g A H A A g A C A A J A A o A C Q A I A A c A B w A G A A Y A C A A J A A k A C Q A I A A g A B w A G A A U A B g A I A A k A  
- C Q A I A A g A C A A H A A Y A B Q A F A A Y A B w A H A A c A B g A G A A Y A B Q A F A A Q A B g A H A A g A C Q A I A A c A B g A E A A Q A B Q A F  
- A A Y A C A A I A A g A B w A G A A U A B Q A F A A g A C Q A K A A 0 A D Q A M A A s A D A A N A B A A E Q A R A B I A E A A O A A s A C A A G A A c A  
- C A A K A A w A D Q A O A B A A E Q A T A B Q A F Q A X A B c A G Q A b A B s A G Q A X A B U A F Q A V A B Q A F A A R A A 4 A D A A J A A g A B g A F  
- A A U A B w A I A A g A B g A F A A E A / / / 7 / / n / + f / 5 / / r / + / / 9 / / 3 / / f / 8 / / v / + v / 6 / / z / / v / 9 / / 7 / / v / + / / 7 /  
- + / / 6 / / v / + / / 8 / / 3 / / / 8 A A A A A A A D + / / 3 / / f / / / / / / A A A C A A I A A g A B A A A A A A A A A A A A A Q A C A A Q A A w A B  
- A P z / 8 / / r / + D / 2 v / e / + f / 9 P 8 C A B k A O A B X A H g A q A D k A C M B Y Q G j A e E B H g J S A k U C 2 Q F U A e k A l A B Q A B U A  
- 1 v + e / 3 7 / d f + H / 6 7 / 0 / / 0 / w o A E g A W A B Y A F g A Y A B g A F w A W A B Y A G A A a A B o A G Q A X A B U A F Q A V A B U A G A A a  
- A B w A H Q A b A B o A G g A Y A B s A H A A c A B 4 A H w A e A B 4 A H g A f A B 0 A H Q A f A C I A J A A l A C c A K Q A p A C o A K w A u A C 8 A  
- M Q A y A D M A N Q A 1 A D Q A M g A x A D E A M g A 1 A D Y A O A A 5 A D o A O w A 9 A D 4 A P w B A A E M A R g B H A E s A T A B M A E 8 A U A B S  
- A F U A W A B c A F 8 A Y Q B i A G I A Z A B k A G Q A a A B s A G 8 A c w B 0 A H Q A d w B 4 A H o A f Q C A A I Y A i w C P A J I A l A C W A J g A  
- m w C f A K M A q Q C u A L I A t A C 1 A L c A u g C 9 A M A A x g D K A M 4 A 0 Q D T A N U A 1 A D W A N k A 3 A D e A O A A 4 w D k A O Y A 5 g D l  
- A O U A 5 A D j A O M A 4 g D f A N w A 1 w D S A M o A w w C 8 A L Y A s Q C s A K c A o A C W A I w A g Q B 4 A H E A a w B n A G I A X A B V A E 4 A  
- R g A 9 A D c A M w A w A C 0 A K g A o A C Q A H w A d A B o A G Q A Y A B Y A F g A U A B E A D w A M A A s A B w A G A A M A A g A D A A U A C A A L  
- A A 0 A D g A P A A 8 A D w A P A A 4 A E A A O A A w A C g A K A A g A B w A E A A M A B A A F A A c A C Q A L A A s A C Q A I A A k A C g A K A A w A  
- D A A N A A w A C w A L A A k A C A A I A A g A C w A N A A 0 A D Q A N A A w A C g A K A A s A C g A L A A w A C w A L A A o A C w A K A A k A C Q A I  
- A A o A C w A L A A s A C g A J A A g A C A A H A A g A C A A J A A k A C g A I A A c A B w A H A A Y A B w A I A A g A C A A I A A g A B Q A D A A I A  
- B A A F A A Y A C A A H A A g A C A A G A A U A B Q A G A A c A C A A I A A k A C Q A J A A c A B g A F A A Y A B w A I A A g A C Q A K A A o A C A A G  
- A A Y A / v / / D / 7 / / w / / / / 8 P A A A A A A A A A A A A A A A A A A A A A A A A A A D + / / 8 P / f / / D / z / / w / 9 / / 8 P / / / / D w A A  
- A A A A A A A A A A A A A A A A A A D / / / 8 P / v / / D / 7 / / w / 9 / / 8 P / f / / D / 7 / / w 8 A A A A A A Q A A A A E A A A A A A A A A A A A A  
- A P 7 / / w / 9 / / 8 P / f / / D / 3 / / w / + / / 8 P A A A A A A A A A A A A A A A A A A A A A P 3 / / w / 8 / / 8 P / P / / D / v / / w / 8 / / 8 P  
- / f / / D w A A A A A A A A A A A A A A A P / / / w / 9 / / 8 P / P / / D / v / / w / 7 / / 8 P / P / / D / 3 / / w / / / / 8 P A A A A A A A A A A A A  
- A A A A / / / / D / 3 / / w / 8 / / 8 P / P / / D / z / / w / + / / 8 P A A A A A P / / / w / / / / 8 P / / / / D / 3 / / w / 8 / / 8 P + / / / D / v /  
- / w / 7 / / 8 P / f / / D / 7 / / w / / / / 8 P / / / / D / / / / w / 9 / / 8 P + / / / D / v / / w / 6 / / 8 P + v / / D / z / / w / + / / 8 P / / / /  
- D / / / / w / / / / 8 P / v / / D / z / / w / 6 / / 8 P + f / / D / r / / w / 8 / / 8 P / f / / D / 7 / / w / / / / 8 P / / / / D / 7 / / w / 9 / / 8 P  
- / f / / D / 7 / / w / / / / 8 P A Q A A A A I A A A A C A A A A A g A A A A A A A A D 9 / / 8 P + f / / D / f / / w / 2 / / 8 P 9 f / / D / P / / w / z  
- / / 8 P 9 P / / D / X / / w / 2 / / 8 P 9 v / / D / X / / w / 0 / / 8 P 8 / / / D / H / / w / x / / 8 P 8 v / / D / P / / w / 0 / / 8 P 9 P / / D / P /  
- / w / z / / 8 P 9 f / / D / b / / w / 2 / / 8 P 9 f / / D / P / / w / x / / 8 P 7 / / / D + / / / w / v / / 8 P 7 v / / D + / / / w / v / / 8 P 8 P / /  
- D / P / / w / 2 / / 8 P 9 v / / D / T / / w / z / / 8 P 8 v / / D / H / / w / x / / 8 P 8 / / / D / T / / w / 1 / / 8 P 9 / / / D / j / / w / 5 / / 8 P  
- + f / / D / j / / w / 4 / / 8 P 9 / / / D / b / / w / 3 / / 8 P + v / / D / z / / w / 8 / / 8 P / P / / D / v / / w / 6 / / 8 P + P / / D / j / / w / 3  
- / / 8 P + P / / D / v / / w / 9 / / 8 P / v / / D / 7 / / w / + / / 8 P / f / / D / v / / w / 7 / / 8 P + / / / D / v / / w / 8 / / 8 P / v / / D / / /  
- / w / / / / 8 P / / / / D / 3 / / w / 7 / / 8 P + v / / D / v / / w / 7 / / 8 P / f / / D / / / / w 8 A A A A A A A A A A P 7 / / w / 9 / / 8 P + v / /  
- D / X / / w / v / / 8 P 6 f / / D + b / / w / o / / 8 P 6 v / / D + v / / w / v / / 8 P 9 f / / D / 7 / / w 8 I A A A A E g A A A C E A A A A 4 A A A A  
- V Q A A A H E A A A C R A A A A u A A A A N 0 A A A A B A Q A A E w E A A P k A A A D H A A A A l w A A A H U A A A B j A A A A V A A A A D w A A A A Z  
- A A A A 9 / / / D + H / / w / c / / 8 P 5 f / / D / b / / w 8 C A A A A D A A A A A 0 A A A A I A A A A A w A A A A E A A A A C A A A A A w A A A A Q A  
- A A A F A A A A B g A A A A c A A A A H A A A A B Q A A A A M A A A A A A A A A / / / / D / / / / w 8 A A A A A A A A A A A I A A A A C A A A A A w A A  
- A A E A A A A A A A A A / / / / D / / / / w / / / / 8 P A A A A A A A A A A A D A A A A A w A A A A M A A A A D A A A A A g A A A A E A A A A A A A A A  
- / / / / D w A A A A A D A A A A B Q A A A A U A A A A F A A A A B Q A A A A Q A A A A D A A A A A g A A A A I A A A A C A A A A B A A A A A Y A A A A G  
- A A A A B g A A A A Y A A A A E A A A A A g A A A A E A A A A C A A A A A w A A A A Q A A A A G A A A A B w A A A A c A A A A H A A A A B g A A A A Q A  
- A A A E A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " I I I "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 5 0 "   p e n d = " 2 3 0 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 4 "   t o n s e t = " 3 2 8 "   t e n d = " 4 7 6 " > / f / 9 / / 3 / / v / + / / 7 / / v / + / / z / + / / 8 / / z / / P / 9 / / / / / / / + / / 3 / / f / 8 / / v / / P / + / / / / A A A A A A A A / / / +  
- / / / / / f / + / / 7 / / v 8 A A P / / A A D / / / 7 / / v / / / / 7 / / / / / / / 3 / / f / 8 / / z / / P / 9 / / 7 / / v / + / / / / / / 8 A A A A A  
- A A A A A P / / / / / / / w A A A A A A A A A A A A A A A A A A / / / + / / / / / / / / / w A A / v / / / / 7 / / f / + / / 7 / / / 8 A A P / / A A A A  
- A P / / / / / 9 / / / / / / / / / / / / / / / / / w A A / / / / / / / / / / / + / / / / / / 8 A A P / / A A A A A A A A A A A A A P / / / / 8 A A A A A  
- A A A A A A E A A A D / / / / / / / / / / / / / A A D / / w A A A A D / / / / / / / / / / / 7 / A A D / / w A A A A A A A P / / / v / + / / 7 / / f / /  
- / / / / / v 8 A A A A A / / / + / / 7 / / / / / / w A A A Q A B A A I A A w A C A A Q A A w A D A A M A B A A E A A M A A g D / / / z / + f / 3 / / X /  
- 9 P / z / / L / 8 f / x / / H / 8 P / w / / H / 8 P / u / + / / 8 P / w / / H / 8 P / w / / D / 7 / / w / / D / 7 / / t / + v / 6 / / o / + f / 5 / / n  
- / + n / 6 / / u / + / / 8 P / x / / D / 7 / / u / + / / 8 P / x / / T / 9 v / 4 / / n / + f / 5 / / j / + P / 6 / / r / / P / 9 / / 3 / / / / + / / 3 /  
- / f / 9 / / 3 / / v 8 A A A A A A A A A A A A A A A A A A P / / A A A A A A A A A A A B A A E A A A A A A A A A A A A A A A A A A Q A C A A I A A Q A A  
- A P f / 7 f / h / 9 X / 0 / / W / 9 n / 4 / / v / w E A F g A q A E Y A b w C g A N k A F w F j A a 8 B 9 g E k A g A C n Q E / A f o A 0 A C 1 A I o A  
- S A A G A N X / v / / J / + H / + / 8 N A B M A D g A I A A Y A C g A M A A o A C g A J A A g A C w A L A A o A C A A F A A Q A A g A C A A M A B A A F  
- A A U A B Q A E A A Q A A w A D A A I A A w A E A A U A B Q A F A A U A B A A D A A M A A w A E A A U A B g A H A A g A C A A I A A Y A B g A H A A Y A  
- B g A H A A g A C g A I A A c A B g A G A A U A B g A I A A g A C Q A J A A o A C w A N A A 0 A D g A N A A 8 A E A A R A B I A E g A S A B I A E w A R  
- A B M A E g A U A B Q A F A A V A B U A F g A W A B U A F w A Y A B k A G w A b A B w A H Q A d A B w A H Q A e A C A A I g A k A C Y A J g A m A C Y A  
- J w A o A C o A L A A v A D E A M w A 0 A D U A N w A 4 A D s A P A A 9 A D 8 A Q Q B D A E Q A R A B D A E U A R g B I A E k A S w B M A E 0 A T g B O  
- A E 4 A T Q B P A F A A U Q B S A F E A U A B P A E w A S Q B I A E Y A R Q B E A E I A P w A 9 A D k A N A A v A C s A K A A m A C U A I w A g A B 4 A  
- G Q A V A B E A D w A N A A w A D A A K A A k A B g A E A A E A / / 8 A A P / / / / 8 A A P / / / v / / / / 3 / / f / 8 / / z / / P / 7 / / z / / f / 8  
- / / z / + v / 6 / / r / + f / 5 / / n / + v / 7 / / r / + / / 8 / / v / + / / 6 / / n / + v / 7 / / z / / f / 9 / / 3 / / P / 7 / / r / + / / 7 / / 3 /  
- / f / + / / / / / v / 9 / / 3 / / f / 9 / / 3 / / v / / / / / / A A A A A P / / / f / 7 / / 3 / / f / 8 / / 3 / / f / + / / 7 / / v / 9 / / z / / P / 9  
- / / 3 / / v / + / / / / / / / / / / 3 / / v / 8 / / z / / v / + / / / / / / / / / w A A / v / + / / 3 / / P / / / / / / / / 8 A A P / / / f / 6 / / n /  
- + v / 7 / / z / / v / + / / 7 / / f / 9 / / 3 / / v / / / / / / A A A A A A A A A A A A A A A A / / / / / / 7 / / / 8 A A A E A A A A A A A A A A A D /  
- / / / / B A A A A A Y A A A A H A A A A B w A A A A Y A A A A C A A A A / / / / D / 3 / / w / 7 / / 8 P + f / / D / j / / w / 5 / / 8 P + P / / D / n /  
- / w / 6 / / 8 P + f / / D / n / / w / 5 / / 8 P + P / / D / f / / w / 2 / / 8 P 9 / / / D / j / / w / 6 / / 8 P + v / / D / n / / w / 4 / / 8 P + P / /  
- D / r / / w / 7 / / 8 P + f / / D / j / / w / 2 / / 8 P 9 f / / D / P / / w / y / / 8 P 8 f / / D / L / / w / z / / 8 P 9 f / / D / j / / w / 7 / / 8 P  
- + / / / D / n / / w / 4 / / 8 P 9 / / / D / X / / w / 2 / / 8 P 9 / / / D / j / / w / 6 / / 8 P / P / / D / 3 / / w / + / / 8 P / v / / D / z / / w / 8  
- / / 8 P + / / / D / v / / w / 9 / / 8 P / / / / D w A A A A A B A A A A A Q A A A A A A A A A A A A A A A A A A A P / / / w / / / / 8 P / / / / D w A A  
- A A A B A A A A A g A A A A I A A A A C A A A A A A A A A P / / / w / + / / 8 P / v / / D / / / / w 8 A A A A A A g A A A A M A A A A D A A A A A g A A  
- A A A A A A A A A A A A / / / / D / / / / w 8 A A A A A A g A A A A M A A A A D A A A A A w A A A A E A A A D 9 / / 8 P 9 / / / D / D / / w / p / / 8 P  
- 6 P / / D + z / / w / w / / 8 P 8 / / / D / j / / w / / / / 8 P C A A A A B E A A A A e A A A A M g A A A E s A A A B n A A A A h g A A A K s A A A D R  
- A A A A 9 w A A A B Q B A A A I A Q A A 2 Q A A A K c A A A C A A A A A a w A A A F 4 A A A B K A A A A L A A A A A g A A A D t / / 8 P 4 P / / D + T /  
- / w / w / / 8 P / P / / D w Y A A A A M A A A A C w A A A A Y A A A A E A A A A B A A A A A U A A A A F A A A A B A A A A A Q A A A A F A A A A B g A A  
- A A Y A A A A G A A A A B Q A A A A Q A A A A C A A A A A A A A A A A A A A A A A A A A A g A A A A M A A A A D A A A A A w A A A A M A A A A D A A A A  
- A Q A A A A A A A A A A A A A A A A A A A A I A A A A E A A A A B A A A A A Q A A A A D A A A A A g A A A A I A A A A A A A A A A A A A A A A A A A A C  
- A A A A B A A A A A Q A A A A F A A A A B A A A A A M A A A A B A A A A A A A A A A A A A A A A A A A A A g A A A A Q A A A A F A A A A B g A A A A Y A  
- A A A E A A A A A w A A A A I A A A A C A A A A A g A A A A M A A A A F A A A A B Q A A A A Y A A A A H A A A A B Q A A A A M A A A A C A A A A A w A A  
- A A Q A A A A G A A A A C A A A A A k A A A A K A A A A C g A A A A c A A A A F A A A A B Q A A A A U A A A A G A A A A C A A A A A o A A A A L A A A A  
- C w A A A A o A A A A J A A A A C Q A A A A k A A A A J A A A A C g A A A A w A A A A N A A A A D w A A A A 8 A A A A P A A A A D g A A A A w A A A A M  
- A A A A D Q A A A A 0 A A A A Q A A A A E g A A A B M A A A A U A A A A F A A A A B Q A A A A T A A A A F A A A A B Q A A A A V A A A A G A A A A B o A  
- A A A b A A A A H A A A A B w A A A A b A A A A G g A A A B o A A A A a A A A A G w A A A B w A A A A f A A A A I A A A A C E A A A A h A A A A I Q A A  
- A B 8 A A A A g A A A A I Q A A A C I A A A A j A A A A J Q A A A C Y A A A A o A A A A K A A A A C c A A A A l A A A A J A A A A C Q A A A A l A A A A  
- K A A A A C o A A A A q A A A A K g A A A C k A A A A m A A A A I w A A A C M A A A A h A A A A I A A A A C E A A A A i A A A A I g A A A C E A A A A f  
- A A A A H Q A A A B g A A A A W A A A A F A A A A B M A A A A T A A A A E w A A A B I A A A A Q A A A A D g A A A A w A A A A I A A A A B g A A A A U A  
- A A A F A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " a V R "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 7 0 "   p e n d = " 2 1 6 "   q o n s e t = " 2 5 2 "   q e n d = " 2 9 4 "   t o n s e t = " 3 6 2 "   t e n d = " 4 8 0 " > 9 P / 1 / / X / 9 f / z / / P / 8 / / 0 / / L / 8 / / z / / T / 8 / / z / / T / 9 P / 1 / / X / 9 / / 2 / / f / 9 v / 2 / / X / 9 v / 1 / / X / 9 P / 1  
- / / T / 9 P / 0 / / T / 9 P / 0 / / T / 9 P / 1 / / b / 9 v / 2 / / X / 9 f / 2 / / b / 9 / / 3 / / b / 9 v / 2 / / f / 9 v / 1 / / X / 9 f / 1 / / X /  
- 9 v / 3 / / f / 9 v / 2 / / b / 9 v / 2 / / b / 9 v / 2 / / X / 9 / / 4 / / f / 9 / / 3 / / b / 9 / / 3 / / j / + P / 3 / / n / + f / 5 / / f / + P / 4  
- / / n / + f / 5 / / n / + f / 5 / / n / + P / 5 / / j / + P / 5 / / j / + f / 6 / / r / + P / 5 / / n / + / / 4 / / j / + v / 6 / / r / + f / 5 / / j /  
- + f / 6 / / n / + f / 6 / / v / / P / 7 / / r / + f / 7 / / r / + / / 6 / / r / + / / 8 / / v / + / / 6 / / n / + f / 5 / / r / + / / 7 / / r / + / / 6  
- / / v / + v / 5 / / j / + f / 5 / / v / + / / 5 / / j / + f / 4 / / b / 9 / / 3 / / f / 9 v / 1 / / T / 8 v / z / / P / 9 P / 0 / / X / 9 f / 1 / / T /  
- 8 v / x / + / / 7 f / r / + r / 6 P / m / + T / 5 P / h / + L / 4 f / f / + D / 4 v / j / + P / 4 v / j / + X / 5 / / o / + n / 6 / / t / + 7 / 7 / / x  
- / / D / 8 P / x / / P / 9 P / 2 / / j / + / / + / w A A A g A B A A E A A Q A A A A A A A A A C A A I A A g A C A A I A A g A D A A M A A g A B A A I A  
- B A A F A A Q A B A A D A A M A A g A B A A E A A g A C A A I A A Q A C A A E A A Q A A A A A A A A A B A A E A A A A A A A A A A Q A A A A A A A A A A  
- A A M A B Q A K A A 4 A E A A L A A Q A / P / w / 9 7 / y f + z / 5 z / f P 9 X / z b / F v / 3 / u L + y / 6 8 / t / + K / 9 3 / 7 f / 7 v 8 d A E c A  
- Z g B 2 A H U A a w B T A D g A H w A I A P v / 8 v / u / / D / 7 / / w / + / / 7 v / v / + / / 7 f / t / + 7 / 7 v / v / + 3 / 7 f / s / + z / 7 P / r  
- / + n / 6 v / p / + n / 6 f / p / + j / 6 P / n / + b / 5 v / m / + b / 5 f / l / + b / 5 v / k / + L / 4 f / g / 9 7 / 3 f / d / 9 r / 2 P / Y / 9 X /  
- 1 P / T / 9 P / 0 f / Q / 9 L / 0 / / S / 9 L / 0 v / R / 8 / / z / / N / 8 z / y / / L / 8 n / y P / H / 8 b / x f / D / 8 H / v v + 9 / 7 z / u f + 3  
- / 7 b / s / + w / 6 3 / r P + q / 6 n / q f + o / 6 f / o / + h / 5 / / n f + c / 5 r / m P + X / 5 X / k v + P / 4 z / i P + F / 4 P / g P 9 + / 3 z /  
- e f 9 2 / 3 L / b / 9 r / 2 j / a P 9 m / 2 T / Y f 9 e / 1 z / W P 9 X / 1 X / U v 9 R / 0 / / T v 9 M / 0 r / S f 9 I / 0 b / R f 9 E / 0 P / Q v 9 D  
- / 0 P / R P 9 F / 0 f / S v 9 N / 1 H / V f 9 a / 2 H / Z v 9 r / 3 H / d f 9 6 / 3 / / h / + O / 5 b / m / + i / 6 f / q / + y / 7 b / u / / A / 8 T /  
- y f / R / 9 X / 1 v / a / 9 3 / 3 / / h / + P / 5 f / m / + j / 6 f / r / + v / 7 P / v / / H / 8 f / 0 / / b / 9 / / 5 / / v / / P / 7 / / r / 9 / / 2  
- / / P / 8 f / w / + / / 7 v / v / + / / 8 P / x / / P / 9 P / 1 / / b / + P / 5 / / v / + / / 5 / / f / 9 v / 1 / / X / 9 f / 0 / / T / 9 P / 0 / / X /  
- 9 f / 0 / / X / 9 P / 1 / / X / 9 v / 4 / / b / 9 f / 0 / / T / 9 P / 0 / / T / 9 P / 0 / / T / 9 P / 0 / / X / 9 P / 1 / / b / 9 v / 1 / / X / 9 v / 3  
- / / b / 9 / / 2 / / b / 9 v / 3 / / j / 9 / / 3 / / j / 9 v / 2 / / f / 9 / / 5 / / j / + P / 5 / / n / + P / 5 / / n / + P / 4 / / j / + f / 7 / / r /  
- + / / 6 / / n / + P / 5 / / j / + P / 5 / / r / + v / 6 / / r / + v / 6 / / n / + P / 4 / / n / + f / 6 / / r / + f / 5 / / r / + f / 4 / / n / + v / 6  
- / / r / E Q A A A B w A A A A s A A A A Q g A A A F g A A A B 0 A A A A m Q A A A M M A A A D q A A A A C w E A A B I B A A D p A A A A s A A A A I Y A  
- A A B t A A A A Y Q A A A F g A A A B C A A A A J A A A A A o A A A D 0 / / 8 P 5 v / / D + X / / w / s / / 8 P 9 / / / D w A A A A A G A A A A B A A A  
- A A A A A A A A A A A A A Q A A A A Q A A A A F A A A A B A A A A A I A A A A B A A A A A A A A A A A A A A A B A A A A A g A A A A E A A A A B A A A A  
- A A A A A A A A A A D + / / 8 P / f / / D / 3 / / w / + / / 8 P A A A A A A I A A A A C A A A A A g A A A A I A A A A A A A A A / f / / D / z / / w / 9  
- / / 8 P / v / / D w A A A A A B A A A A A g A A A A E A A A A B A A A A A Q A A A A A A A A A A A A A A A A A A A A A A A A A C A A A A B A A A A A Q A  
- A A A E A A A A B A A A A A M A A A A C A A A A A A A A A A A A A A A B A A A A A w A A A A Q A A A A F A A A A B g A A A A U A A A A D A A A A A g A A  
- A A M A A A A D A A A A A g A A A A M A A A A F A A A A B w A A A A g A A A A I A A A A B w A A A A Q A A A A D A A A A A g A A A A Q A A A A G A A A A  
- C A A A A A k A A A A K A A A A C Q A A A A c A A A A G A A A A B g A A A A U A A A A G A A A A C A A A A A k A A A A K A A A A C w A A A A o A A A A J  
- A A A A C Q A A A A g A A A A I A A A A C g A A A A w A A A A P A A A A E A A A A B E A A A A Q A A A A D w A A A A 4 A A A A O A A A A D Q A A A A 4 A  
- A A A R A A A A E w A A A B Q A A A A V A A A A F g A A A B U A A A A U A A A A F A A A A B Q A A A A V A A A A F w A A A B o A A A A d A A A A H g A A  
- A B 4 A A A A d A A A A H A A A A B w A A A A c A A A A H Q A A A B 8 A A A A g A A A A I g A A A C M A A A A j A A A A I g A A A C E A A A A h A A A A  
- I Q A A A C E A A A A k A A A A J g A A A C c A A A A o A A A A J w A A A C Y A A A A k A A A A I w A A A C M A A A A j A A A A J A A A A C U A A A A m  
- A A A A J g A A A C U A A A A h A A A A H w A A A B 4 A A A A c A A A A G g A A A B o A A A A a A A A A G g A A A B g A A A A W A A A A F A A A A B E A  
- A A A O A A A A D Q A A A A s A A A A L A A A A D A A A A A s A A A A K A A A A C Q A A A A Y A A A A E A A A A A g A A A A A A A A A A A A A A A A A A  
- A A E A A A A C A A A A A g A A A A E A A A A A A A A A / v / / D / 7 / / w / 9 / / 8 P / f / / D / 7 / / w / / / / 8 P A A A A A A A A A A D / / / 8 P  
- / f / / D / v / / w / 7 / / 8 P + / / / D / v / / w / 9 / / 8 P / / / / D / / / / w / / / / 8 P / / / / D / 3 / / w / 8 / / 8 P / P / / D / v / / w / 6  
- / / 8 P / P / / D / 7 / / w / / / / 8 P A A A A A A A A A A D / / / 8 P / f / / D / z / / w / 8 / / 8 P / f / / D / / / / w 8 A A A A A A Q A A A A E A  
- A A A A A A A A A A A A A P 7 / / w / 9 / / 8 P / f / / D / 7 / / w 8 A A A A A A A A A A A I A A A A B A A A A A Q A A A A A A A A D / / / 8 P / v / /  
- D / 7 / / w / + / / 8 P A A A A A A E A A A A C A A A A A Q A A A A A A A A A A A A A A / v / / D / 3 / / w / 8 / / 8 P / P / / D / 7 / / w 8 A A A A A  
- A A A A A A A A A A A A A A A A / / / / D / / / / w / / / / 8 P / v / / D / 7 / / w 8 A A A A A A A A A A A A A A A A A A A A A A A A A A P / / / w / 9  
- / / 8 P / P / / D / 3 / / w / 9 / / 8 P / v / / D / / / / w 8 A A A A A A A A A A A A A A A D + / / 8 P / f / / D / z / / w / 8 / / 8 P / f / / D / 7 /  
- / w / / / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " a V L "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 4 "   p e n d = " 2 2 8 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 0 "   t o n s e t = " 3 4 0 "   t e n d = " 4 5 4 " > C Q A I A A g A C A A I A A g A C A A I A A o A C g A K A A k A C Q A I A A g A B w A H A A g A C A A H A A g A C A A H A A c A B g A G A A c A B w A G  
- A A g A C Q A I A A g A B w A G A A c A B g A H A A Y A B g A H A A c A B w A G A A Y A B w A I A A g A C A A H A A g A B w A G A A Y A B g A E A A Q A  
- B Q A F A A Y A B Q A F A A U A B Q A F A A U A B Q A F A A U A B Q A G A A Y A B g A F A A U A B g A G A A U A B g A G A A Y A B Q A F A A U A B Q A F  
- A A Q A B A A F A A Y A B Q A G A A U A B Q A E A A Q A B Q A E A A Q A B Q A F A A U A A w A E A A Q A A w A E A A U A B A A E A A Q A B Q A E A A Q A  
- B A A E A A Q A B A A E A A M A B A A E A A Q A B A A D A A M A A w A E A A Q A B A A E A A U A B A A D A A M A B A A E A A U A B A A F A A U A B Q A E  
- A A Q A B A A D A A Q A B A A G A A Q A B A A F A A Q A B A A D A A I A A g A C A A M A A w A D A A M A A w A D A A M A B Q A H A A k A C w A N A A 4 A  
- E A A S A B M A F A A V A B c A G A A Z A B s A H Q A d A B w A H A A c A B w A H A A a A B w A H A A b A B k A G g A b A B s A G g A b A B s A H A A a  
- A B g A F w A V A B M A E g A R A B A A D w A N A A w A C w A K A A g A B w A G A A U A B A A F A A Q A B Q A D A A M A A g A B A A E A A Q A B A A E A  
- A A A B A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A  
- A A U A D A A T A B c A G Q A a A B s A G Q A U A A 8 A C g A F A P 3 / 7 f / Y / 7 7 / n f 9 x / 0 P / G v 8 H / x r / P f 9 c / 2 v / a f 9 s / 3 z /  
- o / / O / + z / / f / + / / n / 9 / / 1 / / f / A A A C A A E A A A D / / w E A B A A D A A M A A Q A A A A I A A w A E A A U A B w A I A A g A B w A G  
- A A g A B w A I A A k A C A A K A A o A C g A K A A k A C Q A J A A k A C g A K A A o A C g A K A A k A C Q A K A A o A C w A M A A 0 A D g A O A B A A  
- E Q A Q A A 8 A E A A Q A B E A E g A S A B M A E g A R A B E A E Q A R A B E A E Q A R A B E A E Q A S A B E A E Q A Q A B E A E Q A S A B M A F Q A X  
- A B Y A F w A Y A B k A G Q A Z A B o A G g A b A B w A H A A b A B 0 A H Q A c A B 0 A H g A e A B 8 A I A A h A C E A I Q A i A C I A I w A j A C M A  
- J Q A l A C Y A J g A m A C Y A J Q A k A C U A J Q A l A C Y A J Q A l A C U A J A A l A C U A J g A m A C Y A J Q A m A C Y A J Q A k A C M A I g A j  
- A C M A I w A h A B 4 A H Q A b A B k A G A A X A B Y A F Q A T A B I A E A A O A A 4 A D A A K A A s A C w A M A A w A C g A J A A k A C A A H A A g A  
- C A A H A A g A C A A I A A g A C A A I A A g A C A A K A A o A C w A L A A w A C g A J A A k A C A A H A A c A B g A G A A Y A B g A G A A c A C A A J  
- A A o A C w A O A A 0 A D Q A O A A 0 A D Q A L A A s A C Q A I A A k A C A A I A A k A C A A I A A c A B w A I A A g A C A A J A A o A C Q A J A A k A  
- C A A I A A g A C A A I A A c A B w A H A A g A B w A H A A c A B g A H A A c A C A A H A A g A C Q A I A A k A B w A G A A Y A C A A H A A g A C A A I  
- A A c A B g A H A A Y A B Q A G A A Y A B g A H A A Y A B g A G A A Y A B g A G A A U A B Q A G A A U A B g A F A A Q A B Q A F A A U A B g A H A A c A  
- C A A H A A c A B g A H A A Q A B Q A F A A U A B Q A F A A U A B A A E A A M A B A A E A A Q A B A A F A A U A A w A D A A Q A B A A D A A M A B A A E  
- A A U A E g A A A B I A A A A Q A A A A E A A A A B A A A A A R A A A A E w A A A B U A A A A Y A A A A G Q A A A B k A A A A Y A A A A F w A A A B c A  
- A A A X A A A A G Q A A A B s A A A A d A A A A H w A A A C A A A A A g A A A A H w A A A B 0 A A A A d A A A A H g A A A B 8 A A A A h A A A A I w A A  
- A C Q A A A A l A A A A J Q A A A C M A A A A i A A A A I g A A A C I A A A A j A A A A J Q A A A C c A A A A n A A A A J w A A A C Y A A A A k A A A A  
- I Q A A A C A A A A A f A A A A H g A A A B 8 A A A A f A A A A H g A A A B 0 A A A A b A A A A G A A A A B Q A A A A R A A A A D w A A A A 4 A A A A P  
- A A A A D w A A A A 4 A A A A N A A A A C w A A A A g A A A A E A A A A A w A A A A I A A A A B A A A A A g A A A A I A A A A B A A A A A A A A A A A A  
- A A D + / / 8 P / P / / D / v / / w / 7 / / 8 P + / / / D / z / / w / 9 / / 8 P / P / / D / z / / w / 7 / / 8 P + f / / D / j / / w / 3 / / 8 P 9 / / /  
- D / j / / w / 6 / / 8 P + / / / D / z / / w / 8 / / 8 P / P / / D / r / / w / 5 / / 8 P 9 / / / D / b / / w / 2 / / 8 P 9 / / / D / n / / w / 6 / / 8 P  
- + v / / D / v / / w / 6 / / 8 P 9 / / / D / b / / w / 2 / / 8 P 9 / / / D / n / / w / 6 / / 8 P + / / / D / r / / w / 6 / / 8 P + f / / D / j / / w / 4  
- / / 8 P 9 / / / D / j / / w / 6 / / 8 P / P / / D / 3 / / w / 9 / / 8 P / f / / D / v / / w / 5 / / 8 P + P / / D / j / / w / 3 / / 8 P + f / / D / v /  
- / w / 8 / / 8 P / f / / D / 3 / / w / 8 / / 8 P + v / / D / n / / w / 4 / / 8 P + P / / D / n / / w / 6 / / 8 P + / / / D / z / / w / 8 / / 8 P + v / /  
- D / n / / w / 4 / / 8 P + P / / D / j / / w / 6 / / 8 P / P / / D / 3 / / w / 8 / / 8 P / P / / D / r / / w / 5 / / 8 P + P / / D / j / / w / 4 / / 8 P  
- + v / / D / z / / w / 8 / / 8 P + / / / D / v / / w / 6 / / 8 P + f / / D / n / / w / 6 / / 8 P + f / / D / n / / w / 7 / / 8 P / P / / D / z / / w / 8  
- / / 8 P + / / / D / n / / w / 4 / / 8 P + P / / D / j / / w / 6 / / 8 P / P / / D / z / / w / 8 / / 8 P / P / / D / v / / w / 5 / / 8 P + P / / D / j /  
- / w / 5 / / 8 P + v / / D / z / / w / 9 / / 8 P / v / / D / 3 / / w / 8 / / 8 P + v / / D / r / / w / 6 / / 8 P + / / / D / z / / w / 9 / / 8 P / v / /  
- D / 7 / / w / / / / 8 P / f / / D / r / / w / 5 / / 8 P + f / / D / n / / w / 7 / / 8 P / f / / D / 7 / / w / + / / 8 P / f / / D / v / / w / 6 / / 8 P  
- + v / / D / n / / w / 5 / / 8 P + / / / D / 3 / / w / + / / 8 P / f / / D / 3 / / w / 8 / / 8 P + v / / D / n / / w / 5 / / 8 P + v / / D / z / / w / 9  
- / / 8 P / v / / D / 7 / / w / + / / 8 P / P / / D / v / / w / 6 / / 8 P + v / / D / r / / w / 8 / / 8 P / f / / D / 7 / / w / + / / 8 P / f / / D / z /  
- / w / 6 / / 8 P + f / / D / n / / w / 5 / / 8 P + / / / D / 3 / / w / / / / 8 P A A A A A A A A A A D / / / 8 P / v / / D / 7 / / w / / / / 8 P A A A A  
- A A A A A A A B A A A A A A A A A P / / / w / 9 / / 8 P + v / / D / f / / w / 0 / / 8 P 8 f / / D / H / / w / z / / 8 P 9 f / / D / f / / w / 5 / / 8 P  
- + f / / D / f / / w / 0 / / 8 P 8 v / / D / D / / w / v / / 8 P 8 f / / D / X / / w / 3 / / 8 P 9 / / / D / j / / w / 4 / / 8 P 9 / / / D / T / / w / x  
- / / 8 P 7 v / / D + 7 / / w / v / / 8 P 8 P / / D / H / / w / y / / 8 P 8 f / / D / D / / w / w / / 8 P 8 v / / D / P / / w / 0 / / 8 P 9 f / / D / T /  
- / w / 0 / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " a V F "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 2 "   p e n d = " 2 4 2 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 4 "   t o n s e t = " 3 4 6 "   t e n d = " 4 8 2 " > A w A E A A Q A B A A E A A Q A B A A D A A Q A A w A E A A Q A B A A E A A Q A B A A E A A M A A g A B A A E A A g A D A A Q A B Q A F A A U A B A A E  
- A A Q A B A A D A A Q A B A A F A A Y A B Q A F A A M A A w A C A A M A B Q A E A A Q A A w A B A A E A A g A D A A M A B A A E A A U A B A A G A A U A  
- B g A E A A M A A w A F A A Y A B g A F A A Q A B Q A F A A U A A w A D A A Q A B A A D A A Q A B A A D A A M A A g A C A A E A A g A D A A Q A B Q A E  
- A A M A A g A C A A I A A Q A D A A M A A w A E A A Q A A w A D A A I A A g A B A A I A A w A D A A M A B A A E A A M A A w A C A A I A A g A D A A Q A  
- B A A E A A M A A w A B A A E A A Q A B A A E A A w A D A A M A A g A B A A E A A g A A A A E A A g A C A A M A A w A D A A I A A A A B A A E A A Q A B  
- A A I A A g A C A A M A A g A C A A E A A g A D A A Q A B A A F A A c A B w A I A A c A C A A J A A o A C Q A K A A k A B w A F A A E A A A D / / / 7 /  
- / v / / / w A A A A A A A A E A A A A B A A I A A g A D A A M A B A A F A A Q A B A A D A A I A A Q A B A A A A A A D / / / 3 / + / / 5 / / f / 9 v / 2  
- / / f / + v / 6 / / v / + v / 5 / / j / 9 P / 0 / / T / 9 P / 1 / / f / + f / 6 / / r / + / / 6 / / n / + f / 6 / / v / / P / 8 / / 7 / / f / 9 / / z /  
- / P / 7 / / z / / f / + / / / / A A A A A A A A / / / / / / / / / v / + / w A A A A A B A A I A A Q A A A A A A A A A A A A A A A Q A C A A I A A Q D 9  
- / / b / 7 f / i / 9 f / 1 / / c / + P / 7 v / / / x Q A M Q B K A G w A n A D V A B A B U A G X A d w B H Q I 9 A g Y C k g E n A d c A n w B x A D s A  
- / P / E / 6 L / n P + w / 9 L / 8 f 8 H A B I A E Q A Q A A 4 A D w A R A B A A D w A O A A 8 A E g A S A B E A D w A N A A w A D A A L A A 0 A D g A P  
- A B A A D w A P A A 8 A D g A O A A 8 A D w A R A B I A E Q A R A B A A E Q A Q A B A A E Q A T A B Q A F g A W A B c A G A A X A B g A G Q A Z A B s A  
- H A A d A B 0 A H Q A d A B s A G w A b A B o A H A A e A B 8 A I A A h A C I A I w A k A C Q A J g A o A C k A K w A t A C 0 A L g A v A D A A M Q A y  
- A D M A N g A 4 A D k A O w A 7 A D w A P Q A 9 A D 4 A Q A B C A E U A R g B H A E g A S Q B K A E s A T Q B Q A F Q A V w B a A F w A X Q B e A F 8 A  
- Y g B j A G c A b A B w A H I A c w B 1 A H Y A e A B 7 A H 4 A g g C F A I c A i Q C K A I w A j Q C N A J A A k Q C T A J U A l g C Y A J k A m Q C a  
- A J k A m Q C Z A J k A m A C X A J U A k g C O A I k A h A C A A H w A e g B 3 A H I A b A B m A F 8 A W A B R A E w A S Q B F A E I A P Q A 4 A D Q A  
- L Q A m A C I A I A A d A B w A G g A X A B M A E g A P A A 0 A D A A K A A o A C Q A I A A c A B Q A F A A Q A A Q A B A P / / / v / / / w E A A g A E  
- A A M A A w A E A A Q A A w A C A A Q A B A A D A A M A A Q A B A A A A A A D / / / / / / / 8 A A A E A A g A D A A I A A g A B A A E A A Q A D A A Q A  
- A w A E A A Q A A w A D A A I A A w A D A A I A B A A F A A U A B Q A F A A Q A A g A D A A M A A w A D A A M A A w A D A A M A A w A C A A I A A g A C  
- A A M A A w A E A A Q A B A A C A A I A A g A B A A I A A w A D A A Q A A w A C A A I A A g A C A A I A A g A D A A I A A g A C A A I A A A D / / / / /  
- / / 8 A A A A A A Q A C A A M A A g A B A A E A A Q A C A A I A A g A E A A Q A B Q A F A A M A A g A B A A I A A w A E A A M A B A A F A A Q A A g A B  
- A A E A + f / / D / n / / w / 5 / / 8 P + f / / D / v / / w / 9 / / 8 P / / / / D / / / / w / + / / 8 P / P / / D / n / / w / 4 / / 8 P + f / / D / v /  
- / w / 9 / / 8 P / v / / D / 7 / / w / + / / 8 P / / / / D / 3 / / w / 6 / / 8 P + P / / D / j / / w / 5 / / 8 P + / / / D / z / / w / 9 / / 8 P / v / /  
- D / 3 / / w / 7 / / 8 P + f / / D / n / / w / 5 / / 8 P + P / / D / r / / w / 8 / / 8 P / f / / D / 3 / / w / 9 / / 8 P + / / / D / n / / w / 4 / / 8 P  
- + P / / D / j / / w / 6 / / 8 P / f / / D / 7 / / w / / / / 8 P / / / / D / 3 / / w / 7 / / 8 P + v / / D / r / / w / 6 / / 8 P / P / / D / 3 / / w / 9  
- / / 8 P / v / / D / 7 / / w / 8 / / 8 P + v / / D / n / / w / 5 / / 8 P + v / / D / z / / w / + / / 8 P / / / / D / / / / w / / / / 8 P / P / / D / r /  
- / w / 6 / / 8 P + / / / D / v / / w / 8 / / 8 P / v / / D / / / / w / / / / 8 P / / / / D / 3 / / w / 8 / / 8 P / P / / D / v / / w / 7 / / 8 P / f / /  
- D / / / / w 8 A A A A A A A A A A A A A A A D / / / 8 P / v / / D / 3 / / w / 8 / / 8 P / P / / D / / / / w 8 A A A A A A A A A A A A A A A A A A A A A  
- / / / / D / 7 / / w / 8 / / 8 P / P / / D / z / / w / 9 / / 8 P A A A A A A A A A A A A A A A A A A A A A A A A A A D 9 / / 8 P + / / / D / v / / w / 8  
- / / 8 P / f / / D w A A A A A A A A A A A A A A A A A A A A D / / / 8 P / v / / D / 3 / / w / 9 / / 8 P / f / / D / / / / w 8 B A A A A A g A A A A I A  
- A A A B A A A A A Q A A A A A A A A D + / / 8 P / v / / D / 7 / / w / / / / 8 P A A A A A A I A A A A C A A A A A Q A A A A I A A A A B A A A A A A A A  
- A A E A A A A C A A A A A w A A A A M A A A A E A A A A B g A A A A Y A A A A E A A A A A Q A A A P / / / w / 9 / / 8 P / P / / D / 3 / / w / 9 / / 8 P  
- / P / / D / r / / w / 5 / / 8 P 9 / / / D / b / / w / 3 / / 8 P + P / / D / n / / w / 6 / / 8 P + / / / D / r / / w / 4 / / 8 P 9 v / / D / X / / w / 1  
- / / 8 P 9 f / / D / X / / w / 3 / / 8 P + / / / D / 3 / / w / 8 / / 8 P + f / / D / b / / w / y / / 8 P 7 / / / D + / / / w / v / / 8 P 8 f / / D / T /  
- / w / 3 / / 8 P + f / / D / v / / w / 5 / / 8 P 9 v / / D / T / / w / 0 / / 8 P 9 f / / D / b / / w / 5 / / 8 P / P / / D / 3 / / w / 8 / / 8 P / P / /  
- D / v / / w / 5 / / 8 P + P / / D / n / / w / 6 / / 8 P / P / / D / 7 / / w / / / / 8 P A A A A A A A A A A D / / / 8 P / P / / D / v / / w / 9 / / 8 P  
- / / / / D w A A A A A A A A A A A Q A A A A E A A A A B A A A A A A A A A P / / / w / / / / 8 P / / / / D / / / / w 8 A A A A A A g A A A A I A A A A B  
- A A A A A Q A A A A A A A A D + / / 8 P / v / / D / / / / w 8 A A A A A A A A A A A I A A A A D A A A A A w A A A A Q A A A A C A A A A A A A A A P 7 /  
- / w / 6 / / 8 P 9 v / / D / H / / w / t / / 8 P 6 v / / D + v / / w / t / / 8 P 7 / / / D / T / / w / + / / 8 P C A A A A B M A A A A f A A A A M Q A A  
- A E o A A A B l A A A A g w A A A K c A A A D N A A A A 8 g A A A B A B A A A O A Q A A 4 A A A A K s A A A C J A A A A d A A A A G k A A A B b A A A A  
- P w A A A B w A A A A B A A A A 7 P / / D + T / / w / p / / 8 P 9 f / / D w A A A A A I A A A A C g A A A A U A A A A A A A A A A A A A A A E A A A A E  
- A A A A B w A A A A k A A A A I A A A A B Q A A A A Q A A A A C A A A A A Q A A A A A A A A A A A A A A A Q A A A A M A A A A D A A A A A w A A A A M A  
- A A A C A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 1 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 6 "   p e n d = " 2 1 0 "   q o n s e t = " 2 5 4 "   q e n d = " 2 9 8 "   t o n s e t = " 3 0 8 "   t e n d = " 4 7 2 " > C A A H A A c A B w A I A A c A B w A H A A g A C A A J A A g A C A A I A A g A B w A H A A c A B w A G A A Y A B g A F A A Y A B g A G A A Y A B g A G  
- A A U A B g A F A A U A B Q A E A A Q A B A A E A A Q A B A A E A A Q A B A A E A A M A B A A F A A Q A B A A E A A Q A A w A D A A M A A w A C A A M A  
- A w A D A A M A A w A D A A I A A g A C A A I A A Q A C A A I A A g A C A A M A A w A D A A E A A Q A B A A E A A g A B A A I A A w A B A A E A A g A B  
- A A E A A g A C A A I A A g A C A A I A A Q A B A A I A A Q A B A A E A A A A A A A A A A Q A B A A E A A A A B A A E A A A A A A A A A A Q A A A A A A  
- A A A A A A A A A Q A A A A A A A A A B A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A  
- A A A A A A A A A P / / / / 8 A A A A A A A A A A P / / A A A A A P / / A A A A A P / / / / 8 A A P / / / / / / / / / / / / / / / w E A A Q A D A A Q A  
- B Q A G A A Y A B g A F A A U A B Q A G A A c A C A A H A A Y A A w A A A P 3 / + / / 6 / / j / 9 / / 2 / / T / 8 v / x / / D / 8 P / y / / P / 8 / / 0  
- / / T / 9 f / 2 / / f / + P / 5 / / n / + v / 6 / / r / / P / 8 / / z / / P / 8 / / z / / f / 9 / / 3 / / f / 9 / / 7 / / v / + / / 3 / / f / 9 / / 7 /  
- / v / / / w A A / / 8 A A P / / A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A E A B A A J  
- A A 4 A E w A e A C s A N A A 1 A D E A K w A l A B w A C A D x / 9 X / s P + M / 2 z / T f 8 6 / z T / L P 8 j / z D / R v 9 N / 1 r / b v 9 x / 2 f /  
- Z P 9 v / 3 b / a / 9 T / 0 f / U v 9 y / 6 H / y / / m / / j / A g A L A B E A E w A U A B Q A E w A T A B Q A F A A W A B c A G A A Y A B g A G A A Z  
- A B k A G Q A Z A B k A G Q A Y A B g A G Q A Y A B g A G A A Y A B c A G A A Y A B g A F w A Y A B c A F w A Y A B g A F w A Z A B g A G Q A Z A B o A  
- G Q A Y A B g A G A A Y A B c A G A A X A B c A F g A W A B U A F A A T A B I A E g A R A B E A E A A P A A 8 A D g A O A A 4 A D A A N A A s A C g A L  
- A A o A C Q A J A A g A B g A F A A Q A A w A C A A A A A A D / / / 3 / + / / 5 / / j / 9 / / 2 / / X / 8 / / y / / D / 7 v / t / + z / 6 f / p / + f /  
- 5 f / j / + D / 3 / / e / 9 r / 2 P / W / 9 X / 0 / / S / 9 D / z / / M / 8 r / y P / H / 8 b / x f / E / 8 P / w v + / / 7 7 / v P + 7 / 7 v / u / + 7  
- / 7 z / v P + 8 / 7 3 / v / / C / 8 P / x v / J / 8 z / z / / R / 9 T / 1 / / a / 9 3 / 4 P / h / + X / 6 P / q / + 3 / 8 P / x / / P / 9 v / 2 / / n /  
- + v / 8 / / 7 / / / 8 A A A A A A Q A B A A I A A w A E A A U A B g A H A A c A C A A H A A g A C A A I A A g A B w A H A A c A C A A H A A g A C Q A K  
- A A o A C g A L A A s A C w A L A A s A C w A K A A o A C Q A I A A g A B w A H A A c A C A A H A A k A C A A I A A g A C A A I A A k A C g A J A A k A  
- C A A I A A c A B w A G A A Y A B g A G A A c A B g A G A A Y A B Q A E A A U A B Q A E A A U A B Q A E A A U A B A A E A A U A B Q A F A A Q A B Q A F  
- A A Q A B A A E A A Q A B A A D A A M A A w A D A A M A A g A C A A I A A g A C A A M A A w A D A A M A A g A D A A I A A Q A C A A I A A g A D A A Q A  
- B A A D A A M A A g A B A A E A A g A B A A E A A Q A C A A E A A Q A B A A E A A Q A A A A A A A A A B A A E A A Q A B A A A A A A A A A A A A A A A A  
- A A A A A A A A A A E A A A A D A A A A B A A A A A U A A A A F A A A A B Q A A A A Q A A A A C A A A A A Q A A A A I A A A A C A A A A B A A A A A U A  
- A A A G A A A A B w A A A A g A A A A I A A A A B g A A A A Y A A A A G A A A A B w A A A A g A A A A J A A A A B w A A A A U A A A A D A A A A A g A A  
- A A A A A A D + / / 8 P + / / / D / r / / w / 8 / / 8 P / v / / D / / / / w 8 A A A A A A A A A A A A A A A D 9 / / 8 P + / / / D / j / / w / 3 / / 8 P  
- + v / / D / 3 / / w / + / / 8 P / / / / D w A A A A A A A A A A A A A A A P / / / w / 7 / / 8 P + f / / D / j / / w / 4 / / 8 P + f / / D / r / / w / 7  
- / / 8 P + v / / D / n / / w / 6 / / 8 P + / / / D / 3 / / w / 9 / / 8 P / P / / D / 3 / / w / + / / 8 P / v / / D / 3 / / w / 9 / / 8 P / f / / D / 3 /  
- / w / 9 / / 8 P / v / / D w A A A A A C A A A A B A A A A A Q A A A A B A A A A A A A A A A A A A A A A A A A A A A A A A A I A A A A E A A A A B Q A A  
- A A Y A A A A H A A A A B g A A A A M A A A A B A A A A A Q A A A A I A A A A E A A A A B Q A A A A Y A A A A H A A A A B w A A A A U A A A A E A A A A  
- A w A A A A I A A A A D A A A A B A A A A A Y A A A A H A A A A B w A A A A Y A A A A F A A A A A w A A A A I A A A A C A A A A A g A A A A Q A A A A E  
- A A A A A g A A A P / / / w / 5 / / 8 P 8 v / / D + z / / w / r / / 8 P 6 / / / D + 7 / / w / 2 / / 8 P A A A A A A 0 A A A A Z A A A A I g A A A C 8 A  
- A A B E A A A A X Q A A A H k A A A C c A A A A x g A A A O 4 A A A A S A Q A A I g E A A A I B A A D G A A A A l A A A A H M A A A B i A A A A V g A A  
- A E E A A A A k A A A A C A A A A P P / / w / n / / 8 P 6 P / / D / H / / w / 9 / / 8 P B Q A A A A w A A A A M A A A A C A A A A A g A A A A K A A A A  
- C w A A A A s A A A A K A A A A C Q A A A A k A A A A I A A A A C Q A A A A o A A A A L A A A A C w A A A A o A A A A I A A A A B g A A A A U A A A A F  
- A A A A B Q A A A A Y A A A A I A A A A C Q A A A A o A A A A K A A A A C A A A A A Y A A A A G A A A A B g A A A A Y A A A A I A A A A C g A A A A o A  
- A A A L A A A A C w A A A A k A A A A H A A A A B g A A A A Y A A A A H A A A A C Q A A A A o A A A A K A A A A C g A A A A k A A A A I A A A A B w A A  
- A A c A A A A H A A A A B w A A A A g A A A A K A A A A C w A A A A w A A A A L A A A A C g A A A A g A A A A I A A A A C A A A A A k A A A A K A A A A  
- D A A A A A 0 A A A A O A A A A D w A A A A 4 A A A A M A A A A C w A A A A o A A A A K A A A A D A A A A A 4 A A A A Q A A A A E A A A A B A A A A A P  
- A A A A D Q A A A A 0 A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A J C Q / / 8 A A D 8 G g R U A A P 7 / / w / / / / 8 P / / / / D / / /  
- / w / + / / 8 P + / / / D / r / / w / 6 / / 8 P + v / / D / z / / w / 9 / / 8 P + / / / D / n / / w / 3 / / 8 P 9 v / / D / f / / w / 3 / / 8 P 9 / / /  
- D / j / / w / 6 / / 8 P + / / / D / n / / w / 3 / / 8 P 9 / / / D / f / / w / 2 / / 8 P 9 v / / D / f / / w / 4 / / 8 P + P / / D / j / / w / 2 / / 8 P  
- 9 f / / D / P / / w / y / / 8 P 8 f / / D / D / / w / x / / 8 P 8 f / / D / D / / w / w / / 8 P 8 P / / D + 7 / / w / s / / 8 P 7 P / / D + r / / w / q  
- / / 8 P 6 / / / D + v / / w / p / / 8 P 6 v / / D + 3 / / w / t / / 8 P 6 / / / D + n / / w / o / / 8 P 6 P / / D + n / / w / p / / 8 P 5 / / / D + n /  
- / w / q / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 2 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 6 "   p e n d = " 1 9 8 "   q o n s e t = " 2 5 4 "   q e n d = " 2 9 8 "   t o n s e t = " 3 3 8 "   t e n d = " 4 8 2 " > J Q A l A C Q A J A A k A C M A I w A j A C I A I g A i A C I A I g A h A C A A H w A g A B 8 A H w A e A B 4 A H g A d A B 0 A G w A b A B w A G w A b  
- A B o A G g A a A B k A G Q A X A B c A F g A W A B Y A F g A V A B U A F Q A W A B Q A E w A U A B I A E w A R A B I A E Q A R A B A A D w A P A A 8 A  
- D w A P A A 4 A D g A O A A 4 A D Q A N A A 0 A D A A N A A w A D A A L A A s A C w A K A A o A C Q A K A A o A C g A K A A k A C A A I A A g A C A A I  
- A A g A B w A H A A g A C A A I A A c A C A A H A A c A B w A H A A c A B w A G A A c A B w A G A A Y A B g A G A A Y A B g A G A A Y A B g A F A A Y A  
- B Q A F A A U A B g A F A A U A B Q A F A A U A B Q A E A A Q A B Q A E A A Q A B A A F A A M A B A A D A A M A B A A E A A Q A B A A E A A Q A B A A E  
- A A M A A w A D A A I A A w A D A A M A B A A D A A Q A B A A E A A M A A g A C A A I A A w A D A A M A A w A D A A M A A w A F A A U A C A A K A A 0 A  
- E Q A T A B U A F w A Y A B s A H w A j A C c A L A A u A C 4 A L Q A r A C k A J g A h A B 4 A G w A X A B M A D g A K A A Y A B Q A E A A Q A A w A E  
- A A Q A A w A E A A M A A Q A B A A A A A A D / / / / / / / / / / / 7 / / / / + / / 3 / / f / 9 / / 7 / / f / + / / 7 / / v / 9 / / 3 / / f / 9 / / 3 /  
- / f / 9 / / 3 / / f / 9 / / z / / f / 8 / / z / / f / 9 / / 3 / / f / 9 / / 7 / / f / + / / 7 / / / / / / / / / / / 8 A A A A A A A A C A A M A B g A P  
- A B o A J w A 7 A F U A Z w B w A H U A d Q B 0 A G 0 A V w A u A O r / l P 8 z / 8 r + a v 4 N / r T 9 d P 1 S / U f 9 N f 0 d / R v 9 E f 3 v / N f 8  
- 6 P w p / Y b 9 3 v 0 p / m z + r f 7 3 / k j / m P / W / / r / C g A a A C g A M g A 4 A D s A P A A 9 A D 4 A Q Q B H A E w A U w B X A F c A W A B X  
- A F o A X A B g A G U A a A B q A G s A a Q B p A G s A b A B t A G 8 A b w B x A H E A c Q B y A H Q A d A B 3 A H k A e g B 9 A H 8 A g A C B A I I A  
- g w C F A I c A i A C L A I w A j g C R A J E A l A C W A J c A m g C c A J 4 A o Q C j A K Y A q Q C q A K 0 A r w C x A L U A u A C 7 A M A A w w D G  
- A M g A y g D N A M 8 A 0 g D W A N o A 3 A D e A O A A 4 g D l A O g A 6 g D s A O 8 A 8 g D 1 A P k A / A D / A A A B A w E F A Q g B C g E N A Q 8 B  
- E g E U A R U B F w E Y A R k B G g E a A R w B H g E d A R 8 B H w E e A R 8 B H w E g A S A B I Q E i A S E B I g E i A S I B I A E g A R 4 B H Q E c  
- A R k B F w E V A R E B D A E H A Q I B + w D 1 A O 8 A 6 Q D i A N s A 0 w D K A M A A u A C w A K g A o Q C Z A J A A i A C A A H g A c A B p A G Q A  
- X w B Z A F U A U A B K A E Y A Q g B A A D 0 A O g A 5 A D c A N Q A y A D E A L g A t A C w A K w A q A C k A K Q A p A C g A K A A o A C g A K A A o  
- A C g A K Q A p A C k A K Q A p A C g A K A A n A C Y A J Q A k A C U A J A A k A C Q A J A A k A C Q A I w A j A C M A I w A j A C M A J A A k A C M A  
- I w A h A C E A I A A g A B 8 A H g A e A B w A H Q A b A B s A G w A a A B o A G Q A Y A B g A G A A W A B Y A F Q A U A B Q A F A A T A B M A E w A U  
- A B I A E g A R A B E A E A A P A A 8 A D w A O A A 4 A D Q A N A A 0 A D A A M A A w A C w A M A A s A C w A L A A s A C g A K A A o A C g A K A A o A  
- C g A K A A k A C Q A J A A g A C A A H A A g A B w A H A A g A B w A H A A Y A B w A G A A Y A B g A G A A c A B w A H A A c A B w A H A A Y A B g A G  
- A A Y A 9 P / / D / X / / w / 1 / / 8 P 8 / / / D / P / / w / 1 / / 8 P + P / / D / r / / w / 6 / / 8 P + / / / D / v / / w / 7 / / 8 P / P / / D / 3 /  
- / w / + / / 8 P / / / / D / / / / w / + / / 8 P / P / / D / / / / w 8 B A A A A A g A A A A I A A A A D A A A A B Q A A A A Y A A A A G A A A A B g A A  
- A A Q A A A A F A A A A B A A A A A M A A A A D A A A A B Q A A A A Y A A A A H A A A A C A A A A A g A A A A H A A A A B g A A A A Y A A A A F A A A A  
- B g A A A A Y A A A A I A A A A C Q A A A A o A A A A J A A A A C A A A A A c A A A A F A A A A B g A A A A c A A A A H A A A A B w A A A A g A A A A H  
- A A A A B g A A A A c A A A A I A A A A B g A A A A U A A A A F A A A A B g A A A A c A A A A J A A A A C Q A A A A g A A A A H A A A A B Q A A A A U A  
- A A A F A A A A B g A A A A g A A A A J A A A A C w A A A A 0 A A A A Q A A A A E Q A A A A 8 A A A A J A A A A A g A A A P z / / w / 0 / / 8 P 6 f / /  
- D 9 7 / / w / T / / 8 P x P / / D 7 D / / w + f / / 8 P j / / / D 4 H / / w 9 2 / / 8 P a / / / D 2 f / / w + A / / 8 P r P / / D 8 / / / w / q / / 8 P  
- A A A A A B Q A A A A k A A A A M Q A A A D o A A A A + A A A A P A A A A D Q A A A A m A A A A G A A A A A 4 A A A A F A A A A / v / / D / v / / w / 9  
- / / 8 P A A A A A A A A A A D + / / 8 P / f / / D / v / / w / 6 / / 8 P + / / / D / z / / w / 8 / / 8 P + / / / D / v / / w / 7 / / 8 P + / / / D / r /  
- / w / 4 / / 8 P + P / / D / n / / w / 4 / / 8 P 9 / / / D / j / / w / 5 / / 8 P + v / / D / n / / w / 4 / / 8 P 9 v / / D / X / / w / 1 / / 8 P 9 f / /  
- D / X / / w / 1 / / 8 P 9 v / / D / f / / w / 4 / / 8 P 9 / / / D / X / / w / 0 / / 8 P 8 / / / D / P / / w / z / / 8 P 8 / / / D / P / / w / y / / 8 P  
- 8 f / / D / L / / w / x / / 8 P 7 / / / D + 7 / / w / u / / 8 P 6 / / / D + v / / w / t / / 8 P 7 / / / D + / / / w / u / / 8 P 7 P / / D + v / / w / p  
- / / 8 P 6 P / / D + f / / w / o / / 8 P 6 f / / D + r / / w / p / / 8 P 6 f / / D + j / / w / m / / 8 P 5 P / / D + P / / w / k / / 8 P 4 / / / D + T /  
- / w / l / / 8 P 4 / / / D + H / / w / f / / 8 P 3 / / / D 9 3 / / w / a / / 8 P 2 v / / D 9 r / / w / a / / 8 P 2 v / / D 9 n / / w / Z / / 8 P 1 / / /  
- D 9 b / / w / U / / 8 P 0 f / / D 9 H / / w / T / / 8 P 0 / / / D 9 L / / w / R / / 8 P 0 P / / D 8 7 / / w / M / / 8 P y v / / D 8 f / / w / G / / 8 P  
- x f / / D 8 X / / w / F / / 8 P x P / / D 8 L / / w + / / / 8 P v P / / D 7 r / / w + 6 / / 8 P u v / / D 7 j / / w + 3 / / 8 P t / / / D 7 j / / w + 3  
- / / 8 P t f / / D 7 P / / w + y / / 8 P s f / / D 6 / / / w + w / / 8 P s P / / D 6 / / / w + v / / 8 P r f / / D 6 v / / w + o / / 8 P p / / / D 6 j /  
- / w + p / / 8 P q v / / D 6 v / / w + s / / 8 P r P / / D 6 z / / w + t / / 8 P r / / / D 7 D / / w + y / / 8 P t P / / D 7 b / / w + 6 / / 8 P v v / /  
- D 8 H / / w / E / / 8 P x f / / D 8 f / / w / L / / 8 P z v / / D 9 H / / w / U / / 8 P 1 / / / D 9 r / / w / e / / 8 P 4 P / / D + H / / w / j / / 8 P  
- 5 P / / D + b / / w / o / / 8 P 6 / / / D + / / / w / y / / 8 P 8 / / / D / T / / w / 0 / / 8 P 8 / / / D / H / / w / 0 / / 8 P 9 / / / D / j / / w / 6  
- / / 8 P / f / / D / / / / w 8 A A A A A A A A A A A A A A A A A A A A A A Q A A A A E A A A A A A A A A A A A A A A A A A A A A A A A A / / / / D / 3 /  
- / w / 7 / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 3 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 4 "   p e n d = " 2 0 8 "   q o n s e t = " 2 5 4 "   q e n d = " 2 9 8 "   t o n s e t = " 3 4 2 "   t e n d = " 4 8 4 " > K w A p A C o A K Q A p A C g A K A A n A C c A J w A n A C c A J g A l A C Q A I w A j A C Q A I w A j A C M A I g A i A C E A I A A f A B 4 A H w A e  
- A B 4 A H Q A d A B s A G g A Z A B k A G g A Y A B k A G A A Y A B c A F w A W A B U A F A A U A B Q A E w A T A B I A E A A Q A B A A D w A O A A 4 A  
- D g A N A A 0 A D Q A O A A w A D Q A M A A s A C w A M A A s A C w A L A A s A C w A J A A k A C A A J A A k A C A A J A A g A C A A H A A c A B g A G  
- A A Y A B w A G A A c A B w A H A A Y A B w A G A A Y A B w A G A A Y A B g A G A A c A B g A G A A U A B g A F A A Y A B g A G A A U A B A A E A A Q A  
- B Q A E A A Q A B A A E A A U A B Q A F A A U A B Q A F A A Q A B A A F A A Q A B A A E A A M A A w A D A A Q A A w A D A A Q A B A A E A A Q A B A A D  
- A A Q A A w A D A A M A A w A D A A M A B A A E A A Q A B A A E A A M A A w A E A A Q A B A A G A A U A B Q A D A A Q A B A A E A A U A B g A H A A k A  
- C w A N A A 4 A E Q A T A B Y A G g A e A C I A J g A o A C c A J w A l A C I A H w A d A B o A G A A W A B M A D w A L A A g A B w A G A A U A B Q A F  
- A A U A B Q A D A A M A A A A A A P / / / f / 9 / / 3 / / P / 7 / / v / / P / 8 / / v / / P / 8 / / 3 / / P / 8 / / z / / f / 8 / / v / + / / 7 / / z /  
- + / / 7 / / z / / P / 8 / / z / / P / 8 / / z / / P / 8 / / z / / P / 9 / / 3 / / f / + / / 7 / / / / + / / / / A A A A A A A A A Q A B A A E A A g A F  
- A A s A E g A c A C g A M w A 4 A D w A Q Q B I A F w A e g C M A I A A Y w B J A C U A 9 / + + / 3 z / U P 8 9 / x r / 4 f 6 o / m L + B f 6 P / S X 9  
- C / 0 / / Z f 9 9 v 1 N / p 7 + 6 P 4 p / 2 r / q / / g / w I A F Q A k A C 8 A N Q A 5 A D 0 A Q A B D A E Y A S A B L A E 8 A U w B X A F o A W w B d  
- A F 8 A Y A B i A G Y A a Q B r A G 0 A b g B v A H A A c Q B y A H M A d w B 5 A H o A e w B 9 A H 8 A g A C C A I U A i A C K A I 4 A k A C S A J Q A  
- l Q C W A J o A n A C f A K M A p Q C o A K o A q w C t A K 8 A s A C 0 A L c A u w C + A M E A x A D H A M o A z Q D Q A N M A 1 w D a A N 8 A 4 w D m  
- A O k A 7 A D v A P M A 9 g D 6 A P 8 A A w E G A Q k B D Q E R A R Q B F w E c A S A B I w E p A S 0 B M A E 1 A T k B P A F B A U U B S Q F N A V E B  
- V Q F Z A V w B X w F j A W Y B a A F r A W 4 B c Q F 0 A X Y B e A F 6 A X w B f Q F / A Y I B h A G G A Y k B i g G L A Y w B j Q G M A Y w B j A G L  
- A Y o B h w G C A X 0 B d g F u A W c B X Q F U A U s B Q A E 1 A S k B H A E Q A Q Q B 9 g D r A O A A 1 A D I A L 0 A s A C m A J w A l A C K A I E A  
- e Q B w A G k A Z A B d A F k A U w B O A E o A R Q B D A E E A P w A 9 A D o A O A A 1 A D M A M Q A w A C 8 A L w A u A C 4 A L g A u A C 0 A L Q A t  
- A C 0 A L g A u A C 4 A L g A u A C 4 A L g A t A C w A L A A s A C s A K w A r A C o A K w A q A C o A K g A o A C g A K A A o A C g A K A A n A C c A  
- J w A m A C Q A J A A j A C M A I g A h A C A A H w A e A B 4 A H Q A d A B w A H A A b A B o A G g A Z A B g A G A A W A B Y A F g A W A B Y A F A A V  
- A B Q A E w A S A B E A E A A Q A A 8 A D w A P A A 4 A D Q A N A A w A C w A L A A w A D A A L A A s A C w A K A A k A C Q A K A A k A C Q A J A A k A  
- C Q A J A A g A C A A H A A c A C A A G A A Y A B w A H A A Y A B g A F A A U A B Q A F A A U A B Q A G A A U A B Q A G A A Y A B g A G A A U A B Q A F  
- A A U A / v / / D / 7 / / w / / / / 8 P / v / / D / 3 / / w / + / / 8 P / / / / D / 3 / / w / 7 / / 8 P / P / / D / 3 / / w / 9 / / 8 P / v / / D / 7 /  
- / w / + / / 8 P / f / / D / z / / w / 7 / / 8 P + v / / D / n / / w / 5 / / 8 P + f / / D / n / / w / 7 / / 8 P / f / / D / v / / w / 5 / / 8 P + P / /  
- D / f / / w / 4 / / 8 P + f / / D / n / / w / 4 / / 8 P + P / / D / n / / w / 7 / / 8 P + f / / D / b / / w / 1 / / 8 P 9 P / / D / T / / w / 0 / / 8 P  
- 9 f / / D / X / / w / 0 / / 8 P 8 v / / D / D / / w / u / / 8 P 7 f / / D + 3 / / w / t / / 8 P 7 v / / D + / / / w / v / / 8 P 7 v / / D + 3 / / w / t  
- / / 8 P 7 P / / D + z / / w / s / / 8 P 6 / / / D + v / / w / s / / 8 P 7 P / / D + r / / w / q / / 8 P 6 f / / D + j / / w / m / / 8 P 5 P / / D + T /  
- / w / m / / 8 P 5 / / / D + b / / w / k / / 8 P 4 / / / D + D / / w / e / / 8 P 3 P / / D 9 v / / w / b / / 8 P 3 P / / D 9 z / / w / c / / 8 P 3 P / /  
- D 9 v / / w / Y / / 8 P 1 v / / D 9 X / / w / V / / 8 P 1 P / / D 9 T / / w / U / / 8 P 0 / / / D 9 L / / w / P / / 8 P z f / / D 8 v / / w / I / / 8 P  
- x v / / D 8 b / / w / F / / 8 P x P / / D 8 T / / w / D / / 8 P w P / / D 7 / / / w + 9 / / 8 P u v / / D 7 j / / w + 4 / / 8 P u f / / D 7 f / / w + 1  
- / / 8 P t P / / D 7 T / / w + y / / 8 P s f / / D 6 / / / w + t / / 8 P r P / / D 6 z / / w + s / / 8 P r P / / D 6 v / / w + q / / 8 P q v / / D 6 f /  
- / w + m / / 8 P p f / / D 6 T / / w + l / / 8 P q P / / D 6 n / / w + p / / 8 P q v / / D 6 r / / w + p / / 8 P q v / / D 6 3 / / w + w / / 8 P s / / /  
- D 7 b / / w + 6 / / 8 P v f / / D 7 / / / w / C / / 8 P x P / / D 8 b / / w / J / / 8 P z P / / D 8 / / / w / T / / 8 P 2 P / / D 9 r / / w / d / / 8 P  
- 3 / / / D + H / / w / k / / 8 P 5 v / / D + j / / w / r / / 8 P 7 v / / D / H / / w / y / / 8 P 8 / / / D / X / / w / 2 / / 8 P 9 v / / D / f / / w / 5  
- / / 8 P + / / / D / z / / w / 9 / / 8 P / v / / D / 7 / / w / 8 / / 8 P + / / / D / z / / w / + / / 8 P A A A A A A I A A A A E A A A A B Q A A A A Y A  
- A A A F A A A A B A A A A A M A A A A B A A A A A A A A A A A A A A A A A A A A A A A A A P / / / w / / / / 8 P / / / / D / 7 / / w / 9 / / 8 P / f / /  
- D w A A A A A A A A A A A Q A A A A I A A A A D A A A A B A A A A A U A A A A E A A A A A Q A A A A A A A A A A A A A A A Q A A A A E A A A A D A A A A  
- A w A A A A I A A A A B A A A A A Q A A A A A A A A A A A A A A A A A A A A E A A A A C A A A A A g A A A A E A A A A D A A A A B Q A A A A Q A A A A C  
- A A A A A Q A A A A E A A A A A A A A A A A A A A A E A A A A C A A A A A Q A A A A E A A A A B A A A A A A A A A P / / / w / / / / 8 P A A A A A A E A  
- A A A C A A A A A g A A A A I A A A A C A A A A A Q A A A A A A A A D / / / 8 P A A A A A A A A A A A A A A A A A g A A A A Q A A A A D A A A A A g A A  
- A A I A A A A B A A A A A A A A A A A A A A A A A A A A A A A A A A I A A A A D A A A A A w A A A A I A A A A A A A A A A A A A A A A A A A A A A A A A  
- A A A A A A E A A A A C A A A A A w A A A A M A A A A D A A A A A g A A A A E A A A A A A A A A A A A A A A E A A A A B A A A A A w A A A A U A A A A E  
- A A A A B A A A A A Q A A A A D A A A A A Q A A A A E A A A A D A A A A A w A A A A M A A A A D A A A A B Q A A A A U A A A A E A A A A A w A A A A M A  
- A A A C A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 4 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 8 "   p e n d = " 2 1 4 "   q o n s e t = " 2 5 8 "   q e n d = " 2 9 8 "   t o n s e t = " 3 3 4 "   t e n d = " 4 8 2 " > H A A a A B o A G Q A Z A B g A G A A Z A B g A G A A Z A B g A G A A Z A B c A F g A W A B Y A F g A W A B U A F A A U A B M A E w A T A B M A E g A S  
- A B I A E g A Q A A 8 A D w A P A A 8 A E A A Q A A 8 A E A A Q A A 4 A D g A O A A 4 A D g A O A A 0 A D A A M A A s A C w A K A A k A C A A I A A g A  
- B w A G A A Y A B Q A F A A U A B Q A G A A U A B g A H A A Y A B g A G A A U A B A A E A A U A B Q A F A A U A B Q A F A A U A B Q A D A A Q A A w A D  
- A A I A A g A C A A M A B A A F A A Q A B A A F A A Q A B Q A E A A Q A B A A D A A M A A w A D A A M A A g A D A A M A A g A C A A I A A Q A C A A I A  
- A g A C A A M A A w A D A A I A A w A C A A M A B A A E A A M A A w A D A A M A A g A B A A E A A Q A B A A I A A w A D A A M A B Q A E A A Q A A w A C  
- A A I A A g A C A A I A A g A C A A I A A w A D A A M A A g A D A A I A A w A D A A Q A B A A E A A U A B Q A E A A U A B Q A E A A M A B A A E A A Y A  
- C A A K A A 0 A D g A R A B M A F g A a A B 0 A H g A g A B 8 A H Q A d A B o A G Q A X A B U A F Q A U A B I A E A A O A A w A C w A J A A k A B w A H  
- A A c A B w A G A A U A A w A B A P / / / v / + / / 7 / / v / 9 / / 3 / / f / 8 / / v / + / / 8 / / z / / f / 9 / / / / / v / 8 / / z / / f / 8 / / 3 /  
- / f / 8 / / z / / P / 7 / / v / / P / 8 / / z / / P / 8 / / z / + / / 8 / / 3 / / f / 9 / / 7 / / / / / / / / / A A A A A P / / / / 8 A A A A A A A D /  
- / / / / / / / + / / v / + P / 3 / / j / / P 8 N A D U A c g C 0 A O 8 A N Q F 9 A b 4 B / Q E z A m s C r A L S A q 8 C S g K / A f 0 A 9 P / V / i n +  
- G f 5 K / o f + w P 7 5 / j L / Y v + N / 7 f / 3 v / 9 / w s A F Q A d A C A A I Q A j A C Q A J w A p A C k A K w A r A C w A L w A x A D I A N Q A 2  
- A D c A O A A 5 A D s A P A A + A E A A Q Q B C A E M A R A B E A E c A S Q B L A E 0 A T g B P A F A A U Q B S A F Q A V g B Z A F s A X g B f A G E A  
- Y g B k A G Y A a A B r A G 0 A b g B x A H I A d A B 2 A H k A e w B 9 A I A A g w C F A I c A i w C O A J E A l Q C X A J o A n g C h A K U A q Q C t  
- A L A A s w C 2 A L k A v g D D A M g A z Q D R A N U A 2 g D e A O M A 5 w D r A O 8 A 9 A D 6 A P 8 A B A E K A R A B F g E b A S E B J Q E r A T E B  
- N w E 9 A U M B S Q F P A V Q B W g F f A W Q B a Q F u A X M B e A F 8 A Y E B h Q G L A Z E B l Q G Z A Z 0 B o A G j A a Y B q A G r A a 0 B r g G u  
- A a 0 B q g G l A a A B m A G O A Y Q B e Q F t A W I B V g F I A T s B K w E c A Q 0 B / g D x A O Q A 1 w D K A L 4 A s Q C m A J o A j w C F A H 0 A  
- d Q B t A G M A X Q B V A E 8 A S g B G A E I A P w A 7 A D k A N w A 0 A D M A M Q A u A C 0 A K g A n A C U A J Q A k A C M A I w A i A C A A I A A g  
- A C E A I A A i A C I A I Q A i A C E A I A A f A B 4 A H Q A d A B w A H A A b A B s A G w A a A B k A G Q A Y A B c A G A A Y A B g A G Q A Z A B g A  
- G A A X A B Y A F g A W A B U A F A A T A B M A E w A T A B I A E Q A Q A B A A D w A Q A B A A D w A N A A 0 A D Q A M A A 0 A D g A N A A w A D Q A N  
- A A 0 A D A A L A A o A C Q A J A A k A C A A I A A c A B w A H A A Y A B g A F A A Q A B A A G A A U A B Q A E A A Q A B g A F A A U A B g A G A A Y A  
- B g A F A A U A B Q A E A A U A B A A F A A Q A B Q A E A A M A A Q A A A A A A A A A A A A I A B A A E A A Q A B Q A E A A Q A B A A D A A M A A g A D  
- A A Q A 6 f / / D + n / / w / n / / 8 P 5 f / / D + T / / w / i / / 8 P 3 / / / D 9 7 / / w / f / / 8 P 3 / / / D 9 7 / / w / g / / 8 P 3 / / / D 9 7 /  
- / w / c / / 8 P 2 v / / D 9 j / / w / W / / 8 P 1 v / / D 9 f / / w / X / / 8 P 1 v / / D 9 T / / w / R / / 8 P z / / / D 8 3 / / w / M / / 8 P y / / /  
- D 8 r / / w / J / / 8 P y P / / D 8 f / / w / G / / 8 P x f / / D 8 L / / w / A / / 8 P v v / / D 7 3 / / w + 9 / / 8 P v f / / D 7 z / / w + 6 / / 8 P  
- t / / / D 7 b / / w + 1 / / 8 P t f / / D 7 P / / w + x / / 8 P s P / / D 6 / / / w + w / / 8 P r / / / D 6 / / / w + u / / 8 P r f / / D 6 v / / w + r  
- / / 8 P q v / / D 6 r / / w + q / / 8 P q v / / D 6 z / / w + s / / 8 P r P / / D 6 z / / w + s / / 8 P r f / / D 6 / / / w + x / / 8 P t P / / D 7 f /  
- / w + 5 / / 8 P u / / / D 7 3 / / w + / / / 8 P w P / / D 8 P / / w / I / / 8 P z P / / D 9 D / / w / U / / 8 P 2 P / / D 9 z / / w / e / / 8 P 3 / / /  
- D + L / / w / k / / 8 P 5 f / / D + f / / w / p / / 8 P 8 P / / D / T / / w / 2 / / 8 P + P / / D / n / / w / 4 / / 8 P + P / / D / n / / w / 5 / / 8 P  
- + v / / D / z / / w / + / / 8 P / v / / D / 7 / / w / / / / 8 P / / / / D / / / / w 8 A A A A A A g A A A A Q A A A A F A A A A B w A A A A k A A A A J  
- A A A A B w A A A A U A A A A D A A A A A g A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A E A  
- A A A D A A A A B Q A A A A Y A A A A I A A A A C g A A A A g A A A A G A A A A B Q A A A A Q A A A A E A A A A A w A A A A M A A A A E A A A A B Q A A  
- A A U A A A A E A A A A A w A A A A E A A A A A A A A A A Q A A A A M A A A A E A A A A B A A A A A U A A A A F A A A A B Q A A A A Q A A A A C A A A A  
- A A A A A A E A A A A C A A A A B A A A A A M A A A A C A A A A A g A A A A I A A A A B A A A A A A A A A A E A A A A C A A A A A w A A A A Q A A A A E  
- A A A A B A A A A A Q A A A A E A A A A A w A A A A M A A A A E A A A A A g A A A A I A A A A E A A A A B g A A A A Y A A A A G A A A A B Q A A A A U A  
- A A A E A A A A B A A A A A Q A A A A E A A A A B Q A A A A Y A A A A G A A A A B g A A A A Q A A A A E A A A A B A A A A A Y A A A A H A A A A C A A A  
- A A k A A A A L A A A A D g A A A A 4 A A A A M A A A A C Q A A A A c A A A A F A A A A B g A A A A Y A A A A G A A A A B g A A A A Y A A A A F A A A A  
- B A A A A A M A A A A C A A A A A g A A A A I A A A A C A A A A A w A A A A Q A A A A E A A A A A w A A A A M A A A A C A A A A A w A A A A M A A A A C  
- A A A A A g A A A A M A A A A D A A A A B Q A A A A Y A A A A G A A A A B Q A A A A M A A A A C A A A A A g A A A A I A A A A E A A A A B Q A A A A Q A  
- A A A F A A A A B g A A A A Y A A A A E A A A A A w A A A A M A A A A E A A A A B A A A A A Y A A A A H A A A A B g A A A A U A A A A F A A A A B Q A A  
- A A Q A A A A E A A A A A w A A A A Q A A A A G A A A A C A A A A A g A A A A H A A A A B w A A A A U A A A A E A A A A B A A A A A Q A A A A F A A A A  
- B w A A A A g A A A A I A A A A B w A A A A U A A A A F A A A A B g A A A A U A A A A E A A A A B Q A A A A g A A A A J A A A A C A A A A A c A A A A H  
- A A A A B g A A A A U A A A A F A A A A B g A A A A U A A A A F A A A A B g A A A A Y A A A A H A A A A B w A A A A U A A A A F A A A A B g A A A A Y A  
- A A A H A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 5 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 7 2 "   p e n d = " 2 1 6 "   q o n s e t = " 2 5 4 "   q e n d = " 2 9 6 "   t o n s e t = " 3 7 0 "   t e n d = " 4 8 6 " > C g A J A A g A C A A H A A g A B w A H A A c A B w A H A A c A C A A H A A c A B g A G A A Y A B g A G A A Y A B g A G A A U A B g A G A A U A B g A G  
- A A Y A B Q A F A A U A B A A F A A U A B Q A F A A U A B g A G A A Y A B Q A F A A U A B Q A F A A U A B Q A E A A U A A w A D A A I A A Q A B A A E A  
- A Q A A A A E A A A A B A A E A A Q A A A A A A A Q A D A A I A A g A C A A I A A Q A A A A E A A Q A B A A E A A A A B A A E A A Q A B A A E A A A A A  
- A A A A A Q A B A A E A A Q A C A A E A A g A B A A I A A Q A B A A E A A A A B A A E A A Q A B A A E A A Q A C A A I A A g A B A A I A A Q A C A A E A  
- A A A C A A I A A g A C A A I A A w A C A A I A A w A C A A I A A g A D A A I A A g A C A A I A A g A C A A I A A w A D A A M A A w A E A A Q A B A A D  
- A A I A A g A C A A M A A w A C A A I A A w A D A A M A A w A D A A Q A B A A E A A Q A B Q A F A A Y A B Q A E A A Q A B A A E A A M A B A A F A A Q A  
- B w A I A A k A C g A M A A 8 A E Q A U A B U A F w A Y A B g A F w A X A B c A F w A U A B Q A F A A U A B M A E Q A R A B A A D w A O A A 4 A D g A O  
- A A 4 A D Q A M A A o A C A A G A A Q A A w A C A A E A A A A A A P 7 / / / / + / / 7 / / v / + / / 7 / / v / / / w A A A A D / / / 7 / / v / / / / 7 /  
- / / / / / / / / / v / + / / 3 / / f / 9 / / 7 / / v / + / / / / / / 8 A A P / / / / / / / / / / A A A A A A A A A A A A A A A A A A A A A A A A / v / 8  
- / / j / 9 P / s / + D / 1 / / S / 9 L / 2 P / n / w c A O Q B y A L E A / g B Q A Z 8 B 7 g E y A n M C t A L b A r s C X g L p A V c B n A D l / 3 n /  
- W P 9 X / 2 H / b / + E / 6 D / u v / R / + b / + f 8 F A A 0 A E Q A T A B Q A E w A T A B Q A F Q A V A B Q A F A A V A B U A F g A X A B c A G A A Z  
- A B k A G g A b A B w A H g A f A B 8 A I A A h A C E A I Q A i A C M A J Q A m A C c A K A A o A C o A K g A s A C 0 A L g A w A D E A M w A 1 A D Y A  
- N w A 3 A D k A O g A 8 A D 0 A P g B A A E E A Q g B D A E Q A R Q B F A E g A S g B L A E 4 A T w B R A F M A V Q B X A F g A W w B e A G E A Z A B l  
- A G k A a w B t A G 8 A c g B 2 A H o A f Q B / A I I A h A C H A I o A j Q C R A J Q A m Q C e A K I A p Q C p A K 0 A s g C 3 A L s A w Q D G A M o A  
- z w D T A N g A 3 g D i A O c A 7 Q D w A P U A + Q D + A A I B B g E K A Q 4 B E g E W A R s B H g E i A S Y B K Q E s A S 8 B M A E y A T M B N Q E 1  
- A T U B N A E x A S w B J g E f A R Y B D g E G A f 0 A 9 Q D s A O I A 1 w D K A M A A t Q C q A K I A m A C Q A I Y A e w B z A G o A Y g B c A F Y A  
- U A B J A E M A P g A 6 A D Q A M Q A u A C o A K A A m A C M A I Q A e A B 0 A G w A Z A B g A F g A T A B M A E Q A Q A B A A D w A O A A 4 A D g A O  
- A A 4 A D w A P A A 8 A D w A P A A 4 A D g A N A A w A C w A L A A s A C g A L A A s A C g A K A A o A C Q A K A A o A C g A K A A s A C w A M A A s A  
- C w A L A A o A C g A K A A o A C Q A J A A o A C Q A J A A g A C A A I A A c A C A A I A A g A C Q A H A A g A B w A H A A c A B w A H A A c A B w A I  
- A A c A B w A H A A Y A B g A G A A Y A B Q A G A A U A B A A F A A Q A B A A E A A Q A B A A E A A Q A A w A D A A M A A w A E A A Q A B Q A F A A Y A  
- B Q A F A A U A B A A E A A Q A B A A D A A I A A w A D A A M A A g A B A A E A A g A C A A I A A w A E A A U A B A A E A A Q A B A A E A A Q A A w A E  
- A A Q A 1 P / / D 9 f / / w / Z / / 8 P 2 / / / D 9 3 / / w / g / / 8 P 4 / / / D + b / / w / r / / 8 P 7 v / / D / D / / w / x / / 8 P 8 v / / D / L /  
- / w / 0 / / 8 P 9 f / / D / b / / w / 5 / / 8 P + / / / D / z / / w / 9 / / 8 P / v / / D / / / / w / / / / 8 P / / / / D / / / / w 8 B A A A A B Q A A  
- A A Y A A A A G A A A A B g A A A A Y A A A A F A A A A A w A A A A E A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A  
- A A A A A A A A A A A A A A A A A Q A A A A E A A A A D A A A A B Q A A A A U A A A A F A A A A B Q A A A A M A A A A C A A A A A g A A A A I A A A A D  
- A A A A A w A A A A M A A A A D A A A A A w A A A A E A A A A A A A A A A A A A A A E A A A A B A A A A A Q A A A A E A A A A C A A A A B A A A A A Q A  
- A A A C A A A A A Q A A A A A A A A A A A A A A A A A A A A I A A A A D A A A A A w A A A A M A A A A E A A A A A w A A A A M A A A A D A A A A A g A A  
- A A M A A A A D A A A A A w A A A A Q A A A A G A A A A B g A A A A U A A A A E A A A A B A A A A A Q A A A A E A A A A B A A A A A U A A A A G A A A A  
- B w A A A A Y A A A A G A A A A B Q A A A A Q A A A A F A A A A B g A A A A Q A A A A F A A A A C A A A A A k A A A A H A A A A B g A A A A Y A A A A H  
- A A A A B g A A A A Y A A A A G A A A A B g A A A A Y A A A A H A A A A C A A A A A c A A A A F A A A A B A A A A A U A A A A G A A A A B g A A A A Y A  
- A A A H A A A A B w A A A A c A A A A H A A A A B w A A A A c A A A A G A A A A B A A A A A Y A A A A H A A A A B w A A A A Y A A A A I A A A A C A A A  
- A A c A A A A F A A A A B A A A A A U A A A A F A A A A B g A A A A c A A A A F A A A A B g A A A A c A A A A H A A A A B Q A A A A Y A A A A G A A A A  
- B g A A A A c A A A A I A A A A C A A A A A k A A A A J A A A A C A A A A A c A A A A G A A A A B g A A A A g A A A A J A A A A C A A A A A k A A A A K  
- A A A A C g A A A A g A A A A H A A A A B g A A A A Y A A A A H A A A A C A A A A A g A A A A H A A A A B w A A A A g A A A A J A A A A B w A A A A Y A  
- A A A G A A A A B w A A A A c A A A A H A A A A B Q A A A A U A A A A E A A A A A w A A A A I A A A A B A A A A A w A A A A U A A A A H A A A A C A A A  
- A A k A A A A H A A A A B g A A A A Q A A A A D A A A A A g A A A A E A A A A A A A A A / / / / D / 3 / / w / 8 / / 8 P / f / / D / 7 / / w / 9 / / 8 P  
- / P / / D / v / / w / 6 / / 8 P + f / / D / r / / w / 8 / / 8 P / P / / D / v / / w / 8 / / 8 P / v / / D w A A A A A A A A A A A A A A A P / / / w 8 A  
- A A A A A g A A A A I A A A A B A A A A A A A A A A A A A A A A A A A A A Q A A A A M A A A A G A A A A B w A A A A k A A A A L A A A A C g A A A A o A  
- A A A K A A A A C g A A A A k A A A A I A A A A C A A A A A o A A A A L A A A A C w A A A A s A A A A L A A A A C g A A A A o A A A A K A A A A C Q A A  
- A A o A A A A K A A A A C g A A A A w A A A A N A A A A D Q A A A A w A A A A L A A A A C g A A A A k A A A A K A A A A C g A A A A o A A A A L A A A A  
- C w A A A A s A A A A K A A A A C A A A A A c A A A A H A A A A C A A A A A k A A A A J A A A A C g A A A A o A A A A J A A A A C Q A A A A g A A A A I  
- A A A A B w A A A A c A A A A J A A A A C w A A A A 0 A A A A O A A A A E A A A A B A A A A A O A A A A C w A A A A c A A A A D A A A A / v / / D / X /  
- / w / q / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 6 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 7 0 "   p e n d = " 2 1 6 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 6 "   t o n s e t = " 3 6 8 "   t e n d = " 4 8 6 " > A g A D A A I A A Q A B A A I A A Q A B A A I A A g A C A A I A A g A C A A I A A Q A B A A E A A Q A B A A E A A Q A B A A E A A Q A B A A E A A Q A C  
- A A I A A g A C A A E A A Q A C A A A A A Q A B A A E A A Q A B A A E A A g A C A A I A A g A D A A M A A w A C A A I A A g A B A A A A A A A A A A A A  
- A A A A A A A A A A A A A A A A A A D / / / / / A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A Q A B A A E A A Q A B A A A A A A A A  
- A A A A A A A B A A I A A Q A C A A I A A Q A B A A E A A Q A B A A E A A Q A B A A A A A A A A A A E A A Q A A A A E A A Q A C A A I A A Q A B A A E A  
- A Q A B A A E A A Q A B A A E A A Q A B A A E A A g A B A A A A A Q A B A A I A A Q A B A A E A A Q A B A A E A A Q A C A A I A A g A C A A I A A g A C  
- A A I A A g A B A A I A A g A C A A I A A w A D A A I A A g A D A A M A A w A D A A Q A B A A F A A U A A w A D A A M A A w A C A A I A A Q A C A A I A  
- A w A D A A Q A B Q A H A A g A C g A N A A 4 A E A A Q A B A A D w A Q A B E A E Q A Q A B E A E Q A Q A B A A D g A N A A w A C w A K A A s A D A A L  
- A A s A C w A L A A k A B w A F A A I A A g A B A A A A A A A A A P / / / / / 9 / / 3 / / v / + / / 7 / / / / / / / / / A A D / / / 7 / / v / / / / 7 /  
- / / / + / / / / / v / + / / / / / f / + / / 7 / / v / + / / 7 / / / / / / / / / / v / / / / 7 / / / / / / / / / / / 8 A A A A A / / / / / w A A / v / 6  
- / / f / 8 / / s / + L / 2 f / V / 9 X / 2 f / j / / b / F Q A 6 A G E A l A D M A A M B O w F w A Z 8 B 0 Q H 5 A f M B t g F k A R I B u A B a A B Y A  
- 7 P / R / 8 b / w f / C / 9 D / 3 / / q / / f / A A A H A A w A D A A N A A w A C w A L A A o A C w A L A A o A C g A K A A o A C w A L A A s A C w A L  
- A A w A D A A N A A 4 A D g A P A A 8 A D w A Q A B A A E A A Q A B E A E g A U A B Q A F Q A W A B U A F g A X A B g A G A A Y A B o A G g A c A B w A  
- H Q A e A B 4 A H w A f A C A A I g A j A C Q A J Q A l A C U A J g A n A C g A K Q A q A C s A L A A t A C 4 A L w A v A D A A M g A z A D U A O A A 6  
- A D w A P Q A + A D 8 A Q A B D A E Y A S A B J A E s A T Q B P A F A A U g B U A F c A W Q B c A G A A Y g B l A G c A a g B t A H A A c w B 3 A H o A  
- f w C B A I Q A i A C L A I 8 A k Q C U A J g A n A C f A K I A o w C m A K g A q g C t A L E A t A C 3 A L o A v A C 9 A L 4 A w A D C A M M A w w D F  
- A M U A x Q D E A M E A v g C 5 A L Q A s A C p A K U A n w C a A J Q A j A C F A H 0 A d g B v A G o A Z Q B e A F g A U Q B L A E U A P w A 6 A D c A  
- M w A v A C s A J w A j A B 8 A H A A b A B k A G A A W A B U A E g A R A B A A D g A N A A w A C g A J A A g A B w A G A A Y A B Q A E A A Q A B A A E  
- A A Q A B A A F A A U A B g A H A A Y A B Q A F A A Q A A w A D A A I A A g A D A A Q A A w A D A A M A A g A D A A M A B A A E A A U A B Q A F A A U A  
- B Q A F A A Q A B A A E A A U A B A A E A A Q A A w A E A A Q A A w A E A A Q A A w A E A A Q A B A A D A A M A A w A D A A M A A w A D A A M A B A A E  
- A A Q A A w A D A A M A A g A C A A I A A g A C A A I A A g A C A A I A A g A C A A E A A g A C A A I A A g A C A A I A A g A D A A M A A w A E A A U A  
- B Q A E A A Q A A w A D A A M A A g A C A A I A A g A D A A I A A g A B A A E A A A A A A A A A A g A D A A I A A g A C A A E A A g A C A A I A A g A C  
- A A I A A g A A A A E A A A A A A A A A A A A A A A E A A A A C A A A A A w A A A A M A A A A D A A A A A w A A A A M A A A A C A A A A A w A A A A I A  
- A A A C A A A A A g A A A A Q A A A A E A A A A B Q A A A A Q A A A A D A A A A A g A A A A I A A A A C A A A A A g A A A A M A A A A D A A A A A w A A  
- A A M A A A A C A A A A A A A A A A E A A A A C A A A A A g A A A A A A A A A A A A A A A g A A A A Q A A A A F A A A A B A A A A A M A A A A D A A A A  
- A g A A A A I A A A A D A A A A B A A A A A Q A A A A E A A A A B A A A A A U A A A A E A A A A A w A A A A M A A A A D A A A A A w A A A A M A A A A E  
- A A A A B A A A A A Q A A A A E A A A A A w A A A A I A A A A B A A A A A Q A A A A A A A A A A A A A A A w A A A A Y A A A A G A A A A B A A A A A I A  
- A A A B A A A A A Q A A A A A A A A A A A A A A A A A A A A Q A A A A G A A A A B Q A A A A Q A A A A D A A A A A g A A A A E A A A A B A A A A A Q A A  
- A A I A A A A D A A A A A g A A A A E A A A A A A A A A / / / / D / 7 / / w / + / / 8 P / f / / D / / / / w 8 A A A A A A Q A A A A A A A A A A A A A A  
- A A A A A P / / / w / / / / 8 P / v / / D / 3 / / w / 8 / / 8 P + v / / D / j / / w / 3 / / 8 P 9 / / / D / f / / w / 4 / / 8 P 9 / / / D / X / / w / 0  
- / / 8 P 9 P / / D / b / / w / 1 / / 8 P 8 / / / D / T / / w / 3 / / 8 P + P / / D / j / / w / 6 / / 8 P + v / / D / n / / w / 7 / / 8 P / f / / D / 3 /  
- / w / 9 / / 8 P / f / / D / z / / w / 7 / / 8 P / P / / D / 7 / / w 8 A A A A A A g A A A A Q A A A A F A A A A B g A A A A Y A A A A G A A A A B g A A  
- A A Y A A A A G A A A A B g A A A A c A A A A H A A A A C A A A A A g A A A A G A A A A B g A A A A c A A A A H A A A A B g A A A A c A A A A I A A A A  
- C Q A A A A k A A A A J A A A A C Q A A A A g A A A A H A A A A B w A A A A Y A A A A G A A A A B w A A A A k A A A A K A A A A C Q A A A A g A A A A I  
- A A A A C A A A A A c A A A A H A A A A B w A A A A c A A A A I A A A A C g A A A A o A A A A J A A A A C A A A A A Y A A A A F A A A A B g A A A A c A  
- A A A I A A A A C g A A A A w A A A A O A A A A D g A A A A o A A A A G A A A A A g A A A P 7 / / w / 3 / / 8 P 7 P / / D + L / / w / Y / / 8 P y P / /  
- D 7 X / / w + j / / 8 P k f / / D 4 D / / w 9 2 / / 8 P a / / / D 2 L / / w 9 u / / 8 P l P / / D 7 z / / w / d / / 8 P + f / / D x E A A A A n A A A A  
- N w A A A D 8 A A A B A A A A A O w A A A D E A A A A h A A A A E w A A A A g A A A A B A A A A / v / / D / 3 / / w / 9 / / 8 P / v / / D / 7 / / w / +  
- / / 8 P A A A A A A A A A A A A A A A A / v / / D / z / / w / 8 / / 8 P / v / / D / / / / w 8 A A A A A / / / / D / / / / w / / / / 8 P / f / / D / v /  
- / w / 7 / / 8 P + / / / D / z / / w / 9 / / 8 P / f / / D / 3 / / w / 8 / / 8 P + / / / D / v / / w / 7 / / 8 P + / / / D / r / / w / 6 / / 8 P + / / /  
- D / 3 / / w / 9 / / 8 P / P / / D / v / / w / 4 / / 8 P 9 / / / D / b / / w / 1 / / 8 P 9 f / / D / X / / w / z / / 8 P 8 / / / D / P / / w / y / / 8 P  
- 8 f / / D / H / / w / w / / 8 P 7 v / / D + 7 / / w / x / / 8 P 8 / / / D / P / / w / y / / 8 P 8 v / / D / D / / w / v / / 8 P 7 / / / D + 7 / / w / t  
- / / 8 P 7 f / / D + / / / w / v / / 8 P 7 v / / D + 3 / / w / r / / 8 P 6 f / / D + n / / w / o / / 8 P 5 / / / D + b / / w / l / / 8 P 5 f / / D + X /  
- / w / k / / 8 P < / r e p b e a t > < / r e p b e a t s >  
- 	 < / w a v e f o r m s >  
- < / r e s t i n g e c g d a t a >  
- 
\ No newline at end of file
diff --git a/test/rexml/data/utf16.xml b/test/rexml/data/utf16.xml
new file mode 100644
index 0000000..f7e5e90
--- /dev/null
+++ b/test/rexml/data/utf16.xml
@@ -0,0 +1,1802 @@
+< ? x m l   v e r s i o n = " 1 . 0 "   e n c o d i n g = " U T F - 1 6 " ? >  
+ < r e s t i n g e c g d a t a   c r c = " F A 6 6 E B 4 B "   x m l n s = " h t t p : / / w w w 3 . m e d i c a l . p h i l i p s . c o m "   x m l n s : x s i = " h t t p : / / w w w . w 3 . o r g / 2 0 0 1 / X M L S c h e m a - i n s t a n c e "   x s i : s c h e m a L o c a t i o n = " h t t p : / / w w w 3 . m e d i c a l . p h i l i p s . c o m  
+ S i e r r a E C G . x s d "   s t a t u s = " N o t   y e t   d e t e r m i n e d "   l a n g = " n l "   l o c a l e = " N L " >  
+ 	 < d o c u m e n t i n f o >  
+ 	 	 < d o c u m e n t n a m e > 1 5 a c 5 9 8 0 - 4 4 6 1 - 1 1 d c - 4 8 2 3 - 0 0 3 1 6 8 c 4 0 0 2 9 . x m l < / d o c u m e n t n a m e >  
+ 	 	 < d o c u m e n t t y p e > S i e r r a E C G < / d o c u m e n t t y p e >  
+ 	 	 < d o c u m e n t v e r s i o n > 1 . 0 3 < / d o c u m e n t v e r s i o n >  
+ 	 < / d o c u m e n t i n f o >  
+ 	 < u s e r d e f i n e s >  
+ 	 	 < u s e r d e f i n e >  
+ 	 	 	 < l a b e l > E i g e n   v e l d   1 < / l a b e l >  
+ 	 	 	 < v a l u e > < / v a l u e >  
+ 	 	 < / u s e r d e f i n e >  
+ 	 	 < u s e r d e f i n e >  
+ 	 	 	 < l a b e l > E i g e n   v e l d   2 < / l a b e l >  
+ 	 	 	 < v a l u e > < / v a l u e >  
+ 	 	 < / u s e r d e f i n e >  
+ 	 	 < u s e r d e f i n e >  
+ 	 	 	 < l a b e l > E i g e n   v e l d   3 < / l a b e l >  
+ 	 	 	 < v a l u e > < / v a l u e >  
+ 	 	 < / u s e r d e f i n e >  
+ 	 	 < u s e r d e f i n e >  
+ 	 	 	 < l a b e l > E i g e n   v e l d   4 < / l a b e l >  
+ 	 	 	 < v a l u e > < / v a l u e >  
+ 	 	 < / u s e r d e f i n e >  
+ 	 	 < u s e r d e f i n e >  
+ 	 	 	 < l a b e l > E i g e n   v e l d   5 < / l a b e l >  
+ 	 	 	 < v a l u e > < / v a l u e >  
+ 	 	 < / u s e r d e f i n e >  
+ 	 	 < u s e r d e f i n e >  
+ 	 	 	 < l a b e l > E i g e n   v e l d   6 < / l a b e l >  
+ 	 	 	 < v a l u e > < / v a l u e >  
+ 	 	 < / u s e r d e f i n e >  
+ 	 	 < u s e r d e f i n e >  
+ 	 	 	 < l a b e l > < / l a b e l >  
+ 	 	 	 < v a l u e > < / v a l u e >  
+ 	 	 < / u s e r d e f i n e >  
+ 	 	 < u s e r d e f i n e >  
+ 	 	 	 < l a b e l > < / l a b e l >  
+ 	 	 	 < v a l u e > < / v a l u e >  
+ 	 	 < / u s e r d e f i n e >  
+ 	 < / u s e r d e f i n e s >  
+ 	 < o r d e r i n f o   p r i o r i t y = " " >  
+ 	 	 < e n c o u n t e r i d / >  
+ 	 	 < o p e r a t o r i d / >  
+ 	 	 < o r d e r n u m b e r > < / o r d e r n u m b e r >  
+ 	 	 < v i p e r u n i q u e o r d e r i d / >  
+ 	 	 < o r d e r i n g c l i n i c i a n n a m e / >  
+ 	 	 < o r d e r i n g c l i n i c i a n U P I N / >  
+ 	 	 < r e a s o n f o r o r d e r > < / r e a s o n f o r o r d e r >  
+ 	 	 < d r g c a t e g o r i e s / >  
+ 	 < / o r d e r i n f o >  
+ 	 < r e p o r t i n f o   d a t e = " 2 0 0 7 - 0 8 - 0 6 "   t i m e = " 1 3 : 0 1 : 5 1 " >  
+ 	 	 < r e p o r t t y p e > S T D - 1 2 < / r e p o r t t y p e >  
+ 	 	 < r e p o r t d e s c r i p t i o n > S t a n d a r d   1 2   L e a d   R e p o r t < / r e p o r t d e s c r i p t i o n >  
+ 	 	 < r e p o r t f o r m a t   e x t e n d e d m e a s f l a g = " F a l s e "   p r i n t t r u n c a t i o n f l a g = " F a l s e " >  
+ 	 	 	 < i n t e r p r e t a t i o n f o r m a t > I n t e r p r e t a t i o n s   a n d   r e a s o n s < / i n t e r p r e t a t i o n f o r m a t >  
+ 	 	 	 < w a v e f o r m f o r m a t   l e a d s e q u e n c e = " S t a n d a r d "   t i m e s e q u e n c e = " C o n t i n u o u s " >  
+ 	 	 	 	 < m a i n w a v e f o r m f o r m a t   n r o w = " 3 "   n c o l u m n = " 4 " > I   I I   I I I   a V R   a V L   a V F   V 1   V 2   V 3   V 4   V 5   V 6 < / m a i n w a v e f o r m f o r m a t >  
+ 	 	 	 	 < r h y t h m w a v e f o r m f o r m a t   n r h y t h m = " 1 " > I I < / r h y t h m w a v e f o r m f o r m a t >  
+ 	 	 	 < / w a v e f o r m f o r m a t >  
+ 	 	 < / r e p o r t f o r m a t >  
+ 	 	 < r e p o r t g a i n >  
+ 	 	 	 < a m p l i t u d e g a i n   u n i t = " m m / m v " >  
+ 	 	 	 	 < o v e r a l l g a i n > 1 0 . 0 0 < / o v e r a l l g a i n >  
+ 	 	 	 < / a m p l i t u d e g a i n >  
+ 	 	 	 < t i m e g a i n   u n i t = " m m / s " > 2 5 . 0 0 < / t i m e g a i n >  
+ 	 	 < / r e p o r t g a i n >  
+ 	 	 < r e p o r t b a n d w i d t h >  
+ 	 	 	 < h i g h p a s s f i l t e r s e t t i n g > 0 . 1 5 < / h i g h p a s s f i l t e r s e t t i n g >  
+ 	 	 	 < l o w p a s s f i l t e r s e t t i n g > 1 5 0 < / l o w p a s s f i l t e r s e t t i n g >  
+ 	 	 	 < n o t c h f i l t e r s e t t i n g > 6 0 < / n o t c h f i l t e r s e t t i n g >  
+ 	 	 	 < n o t c h h a r m o n i c s s e t t i n g > N o n e < / n o t c h h a r m o n i c s s e t t i n g >  
+ 	 	 	 < a r t i f a c t f i l t e r f l a g > F a l s e < / a r t i f a c t f i l t e r f l a g >  
+ 	 	 	 < h y s t e r i s i s f i l t e r s f l a g > F a l s e < / h y s t e r i s i s f i l t e r s f l a g >  
+ 	 	 < / r e p o r t b a n d w i d t h >  
+ 	 < / r e p o r t i n f o >  
+ 	 < d a t a a c q u i s i t i o n   d a t e = " 2 0 0 7 - 0 8 - 0 6 "   t i m e = " 1 3 : 0 1 : 5 1 "   s t a t f l a g = " F a l s e " >  
+ 	 	 < m a c h i n e   m a c h i n e i d = " "   d e t a i l d e s c r i p t i o n = " P h i l i p s   M e d i c a l   P r o d u c t s : M 4 9 9 4 : " > P a g e W r i t e r   T r i m < / m a c h i n e >  
+ 	 	 < a c q u i r e r >  
+ 	 	 	 < e n c o u n t e r i d > < / e n c o u n t e r i d >  
+ 	 	 	 < o p e r a t o r i d > < / o p e r a t o r i d >  
+ 	 	 	 < e d i t i n g o p e r a t o r i d / >  
+ 	 	 	 < r o o m > < / r o o m >  
+ 	 	 	 < d e p a r t m e n t i d > < / d e p a r t m e n t i d >  
+ 	 	 	 < d e p a r t m e n t n a m e > K C < / d e p a r t m e n t n a m e >  
+ 	 	 	 < i n s t i t u t i o n i d > < / i n s t i t u t i o n i d >  
+ 	 	 	 < i n s t i t u t i o n n a m e > X e n d o   D r u g   D e v e l o p m e n t   B . V . < / i n s t i t u t i o n n a m e >  
+ 	 	 	 < i n s t i t u t i o n l o c a t i o n i d > < / i n s t i t u t i o n l o c a t i o n i d >  
+ 	 	 	 < i n s t i t u t i o n l o c a t i o n n a m e > K C < / i n s t i t u t i o n l o c a t i o n n a m e >  
+ 	 	 	 < o r d e r i n g c l i n i c i a n n a m e > < / o r d e r i n g c l i n i c i a n n a m e >  
+ 	 	 	 < o r d e r i n g c l i n i c i a n U P I N > < / o r d e r i n g c l i n i c i a n U P I N >  
+ 	 	 < / a c q u i r e r >  
+ 	 	 < s i g n a l c h a r a c t e r i s t i c s >  
+ 	 	 	 < s a m p l i n g r a t e > 5 0 0 < / s a m p l i n g r a t e >  
+ 	 	 	 < s i g n a l r e s o l u t i o n > 5 < / s i g n a l r e s o l u t i o n >  
+ 	 	 	 < s i g n a l b a n d w i d t h > 0 . 0 5 - 1 5 0 < / s i g n a l b a n d w i d t h >  
+ 	 	 	 < a c s e t t i n g > 6 0 < / a c s e t t i n g >  
+ 	 	 	 < a c q u i s i t i o n t y p e > S T D - 1 2 < / a c q u i s i t i o n t y p e >  
+ 	 	 	 < b i t s p e r s a m p l e > 1 6 < / b i t s p e r s a m p l e >  
+ 	 	 	 < s i g n a l o f f s e t > 0 < / s i g n a l o f f s e t >  
+ 	 	 	 < s i g n a l s i g n e d > T r u e < / s i g n a l s i g n e d >  
+ 	 	 	 < n u m b e r c h a n n e l s a l l o c a t e d > 1 2 < / n u m b e r c h a n n e l s a l l o c a t e d >  
+ 	 	 	 < n u m b e r c h a n n e l s v a l i d > 1 2 < / n u m b e r c h a n n e l s v a l i d >  
+ 	 	 	 < l e a d s e t > S T D - 1 2 < / l e a d s e t >  
+ 	 	 < / s i g n a l c h a r a c t e r i s t i c s >  
+ 	 < / d a t a a c q u i s i t i o n >  
+ 	 < p a t i e n t   c r i t e r i a v e r s i o n f o r p a t i e n t d a t a = " 0 A " >  
+ 	 	 < g e n e r a l p a t i e n t d a t a >  
+ 	 	 	 < p a t i e n t i d > 0 7 0 9 8 3 < / p a t i e n t i d >  
+ 	 	 	 < v i p e r u n i q u e p a t i e n t i d / >  
+ 	 	 	 < n a m e >  
+ 	 	 	 	 < l a s t n a m e > 0 6 0 2 8 4 - 0 7 0 9 8 3 < / l a s t n a m e >  
+ 	 	 	 	 < f i r s t n a m e > M / 1 0 1 0 5 7 / 0 1   J W O < / f i r s t n a m e >  
+ 	 	 	 	 < m i d d l e n a m e > < / m i d d l e n a m e >  
+ 	 	 	 < / n a m e >  
+ 	 	 	 < a g e   d e f a u l t a g e = " 5 0 " >  
+ 	 	 	 	 < d a t e o f b i r t h > 1 9 8 2 - 0 5 - 0 7 < / d a t e o f b i r t h >  
+ 	 	 	 < / a g e >  
+ 	 	 	 < p a c e s t a t u s > U n k n o w n < / p a c e s t a t u s >  
+ 	 	 	 < s e x > M a l e < / s e x >  
+ 	 	 	 < h e i g h t >  
+ 	 	 	 	 < c m / >  
+ 	 	 	 < / h e i g h t >  
+ 	 	 	 < w e i g h t >  
+ 	 	 	 	 < k g / >  
+ 	 	 	 < / w e i g h t >  
+ 	 	 < / g e n e r a l p a t i e n t d a t a >  
+ 	 	 < p a t i e n t m e d i c a l d a t a >  
+ 	 	 	 < b l o o d p r e s s u r e >  
+ 	 	 	 	 < s y s t o l i c >  
+ 	 	 	 	 	 < m m H g / >  
+ 	 	 	 	 < / s y s t o l i c >  
+ 	 	 	 	 < d i a s t o l i c >  
+ 	 	 	 	 	 < m m H g / >  
+ 	 	 	 	 < / d i a s t o l i c >  
+ 	 	 	 < / b l o o d p r e s s u r e >  
+ 	 	 < / p a t i e n t m e d i c a l d a t a >  
+ 	 < / p a t i e n t >  
+ 	 < m e a s u r e m e n t s   d a t e = " 2 0 0 7 - 0 8 - 0 6 "   t i m e = " 1 3 : 0 1 : 5 1 "   m e a s u r e m e n t v e r s i o n = " 8 " >  
+ 	 	 < g l o b a l m e a s u r e m e n t s   f i x e d m u l t p f l a g = " T r u e "   m u l t p t e s t v a l i d f l a g = " T r u e "   q r s l i k e a r t f f l a g = " F a l s e "   p a c e b e a t m e a s f l a g = " F a l s e " >  
+ 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 < p a c e m o d e s / >  
+ 	 	 	 < p a c e m a l f / >  
+ 	 	 	 < p a c e m i s c / >  
+ 	 	 	 < e c t o p i c r h y t h m / >  
+ 	 	 	 < q t i n t d i s p e r s i o n > 6 8 < / q t i n t d i s p e r s i o n >  
+ 	 	 	 < n u m b e r o f c o m p l e x e s > 9 < / n u m b e r o f c o m p l e x e s >  
+ 	 	 	 < n u m b e r o f g r o u p s > 1 < / n u m b e r o f g r o u p s >  
+ 	 	 	 < b e a t c l a s s i f i c a t i o n > 1   1   1   1   1   1   1   1   1 < / b e a t c l a s s i f i c a t i o n >  
+ 	 	 	 < q a m e s s a g e c o d e s > < q a m e s s a g e c o d e > A c c e p t a b l e   t r a c e < / q a m e s s a g e c o d e > < / q a m e s s a g e c o d e s >  
+ 	 	 	 < q a a c t i o n c o d e > E C G   O K < / q a a c t i o n c o d e >  
+ 	 	 	 < p o n > 3 8 6 2 < / p o n >  
+ 	 	 	 < q r s o n > 3 9 6 0 < / q r s o n >  
+ 	 	 	 < q r s o f f > 4 0 0 0 < / q r s o f f >  
+ 	 	 	 < t o n > 4 0 6 4 < / t o n >  
+ 	 	 	 < t o f f > 4 2 1 6 < / t o f f >  
+ 	 	 	 < p f r o n t a x i s > - 1 7 < / p f r o n t a x i s >  
+ 	 	 	 < p h o r i z a x i s > 3 8 < / p h o r i z a x i s >  
+ 	 	 	 < i 4 0 f r o n t a x i s > 5 0 < / i 4 0 f r o n t a x i s >  
+ 	 	 	 < i 4 0 h o r i z a x i s > 2 7 < / i 4 0 h o r i z a x i s >  
+ 	 	 	 < q r s f r o n t a x i s > 9 0 < / q r s f r o n t a x i s >  
+ 	 	 	 < q r s h o r i z a x i s > - 2 6 < / q r s h o r i z a x i s >  
+ 	 	 	 < t 4 0 f r o n t a x i s > 1 0 3 < / t 4 0 f r o n t a x i s >  
+ 	 	 	 < t 4 0 h o r i z a x i s > - 5 2 < / t 4 0 h o r i z a x i s >  
+ 	 	 	 < s t f r o n t a x i s > 3 8 < / s t f r o n t a x i s >  
+ 	 	 	 < s t h o r i z a x i s > 6 9 < / s t h o r i z a x i s >  
+ 	 	 	 < t f r o n t a x i s > 5 0 < / t f r o n t a x i s >  
+ 	 	 	 < t h o r i z a x i s > 4 9 < / t h o r i z a x i s >  
+ 	 	 	 < a t r i a l r a t e > 5 9 < / a t r i a l r a t e >  
+ 	 	 	 < l o w v e n t r a t e > 5 7 < / l o w v e n t r a t e >  
+ 	 	 	 < m e a n v e n t r a t e > 6 1 < / m e a n v e n t r a t e >  
+ 	 	 	 < h i g h v e n t r a t e > 6 3 < / h i g h v e n t r a t e >  
+ 	 	 	 < m e a n p r i n t > 1 8 0 < / m e a n p r i n t >  
+ 	 	 	 < m e a n p r s e g > 7 8 < / m e a n p r s e g >  
+ 	 	 	 < m e a n q r s d u r > 8 6 < / m e a n q r s d u r >  
+ 	 	 	 < m e a n q t i n t > 4 5 2 < / m e a n q t i n t >  
+ 	 	 	 < m e a n q t c > 4 5 5 < / m e a n q t c >  
+ 	 	 	 < d e l t a w a v e c o u n t > 0 < / d e l t a w a v e c o u n t >  
+ 	 	 	 < d e l t a w a v e p e r c e n t > 0 < / d e l t a w a v e p e r c e n t >  
+ 	 	 	 < b i g e m i n y c o u n t > 0 < / b i g e m i n y c o u n t >  
+ 	 	 	 < b i g e m i n y s t r i n g > 0 < / b i g e m i n y s t r i n g >  
+ 	 	 	 < t r i g e m i n y c o u n t > 0 < / t r i g e m i n y c o u n t >  
+ 	 	 	 < t r i g e m i n y s t r i n g > 0 < / t r i g e m i n y s t r i n g >  
+ 	 	 	 < w e n c k c o u n t > 0 < / w e n c k c o u n t >  
+ 	 	 	 < w e n c k s t r i n g > 0 < / w e n c k s t r i n g >  
+ 	 	 	 < f l u t t e r f i b c o u n t > 0 < / f l u t t e r f i b c o u n t >  
+ 	 	 	 < q r s i n i t a n g l e > 7 5 < / q r s i n i t a n g l e >  
+ 	 	 	 < q r s i n i t m a g > 1 1 5 < / q r s i n i t m a g >  
+ 	 	 	 < q r s m a x a n g l e > 3 5 6 < / q r s m a x a n g l e >  
+ 	 	 	 < q r s m a x m a g > 1 3 7 7 < / q r s m a x m a g >  
+ 	 	 	 < q r s t e r m a n g l e > 2 4 3 < / q r s t e r m a n g l e >  
+ 	 	 	 < q r s t e r m m a g > 7 8 2 < / q r s t e r m m a g >  
+ 	 	 	 < q r s r o t a t i o n > - 1 0 0 < / q r s r o t a t i o n >  
+ 	 	 	 < g l o b a l r e s e r v e d / >  
+ 	 	 < / g l o b a l m e a s u r e m e n t s >  
+ 	 	 < g r o u p m e a s u r e m e n t s >  
+ 	 	 	 < g r o u p m e a s u r e m e n t   g r o u p n u m b e r = " 1 "   i n t e r p f l a g = " F a l s e "   s i n u s f l a g = " F a l s e "   p r p r o g f l a g = " F a l s e "   w e n c k f l a g = " F a l s e "   b i g f l a g = " F a l s e "   t r i g f l a g = " F a l s e "   a b e r r a n t f l a g = " F a l s e "   m u l t p t e s t f l a g = " T r u e "   q r s m e a s f l a g = " T r u e "   a t r i a l p a c e f l a g = " F a l s e "   v e n t d u a l p a c e f l a g = " F a l s e " >  
+ 	 	 	 	 < m e m b e r c o u n t > 9 < / m e m b e r c o u n t >  
+ 	 	 	 	 < m e m b e r p e r c e n t > 1 0 0 < / m e m b e r p e r c e n t >  
+ 	 	 	 	 < l o n g e s t r u n > 9 < / l o n g e s t r u n >  
+ 	 	 	 	 < m e a n q r s d u r > 8 0 < / m e a n q r s d u r >  
+ 	 	 	 	 < l o w v e n t r a t e > 5 7 < / l o w v e n t r a t e >  
+ 	 	 	 	 < m e a n v e n t r a t e > 6 1 < / m e a n v e n t r a t e >  
+ 	 	 	 	 < h i g h v e n t r a t e > 6 3 < / h i g h v e n t r a t e >  
+ 	 	 	 	 < v e n t r a t e s t d d e v > 2 < / v e n t r a t e s t d d e v >  
+ 	 	 	 	 < m e a n r r i n t > 9 8 4 < / m e a n r r i n t >  
+ 	 	 	 	 < a t r i a l r a t e > 5 9 < / a t r i a l r a t e >  
+ 	 	 	 	 < a t r i a l r a t e s t d d e v > 2 < / a t r i a l r a t e s t d d e v >  
+ 	 	 	 	 < a v g p c o u n t > 1 < / a v g p c o u n t >  
+ 	 	 	 	 < n o t a v g p b e a t s > 0 < / n o t a v g p b e a t s >  
+ 	 	 	 	 < l o w p r i n t > < / l o w p r i n t >  
+ 	 	 	 	 < m e a n p r i n t > 1 7 2 < / m e a n p r i n t >  
+ 	 	 	 	 < h i g h p r i n t > 1 8 0 < / h i g h p r i n t >  
+ 	 	 	 	 < p r i n t s t d d e v > 4 < / p r i n t s t d d e v >  
+ 	 	 	 	 < m e a n p r s e g > 9 2 < / m e a n p r s e g >  
+ 	 	 	 	 < m e a n q t i n t > 4 1 6 < / m e a n q t i n t >  
+ 	 	 	 	 < m e a n q t s e g > 3 3 6 < / m e a n q t s e g >  
+ 	 	 	 	 < c o m p p a u s e c o u n t > 0 < / c o m p p a u s e c o u n t >  
+ 	 	 	 	 < g r o u p r e s e r v e d / >  
+ 	 	 	 < / g r o u p m e a s u r e m e n t >  
+ 	 	 < / g r o u p m e a s u r e m e n t s >  
+ 	 	 < l e a d m e a s u r e m e n t s >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " I "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 9 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 8 8 < / p d u r >  
+ 	 	 	 	 < p a r e a > 1 3 < / p a r e a >  
+ 	 	 	 	 < p p a m p > 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 8 9 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > 1 3 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > 0 < / q a m p >  
+ 	 	 	 	 < q d u r > < / q d u r >  
+ 	 	 	 	 < r a m p > 2 4 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 4 8 < / r d u r >  
+ 	 	 	 	 < s a m p > - 3 5 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 2 8 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 3 2 < / v a t >  
+ 	 	 	 	 < q r s p p k > 5 9 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 7 6 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > 0 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 4 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 8 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 1 1 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 1 2 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 1 0 4 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 1 8 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 3 5 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 3 6 < / t d u r >  
+ 	 	 	 	 < t a r e a > 1 1 3 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 3 6 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 1 1 3 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 8 4 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 8 8 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 4 0 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " I I "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 6 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 1 2 0 < / p d u r >  
+ 	 	 	 	 < p a r e a > 5 < / p a r e a >  
+ 	 	 	 	 < p p a m p > - 2 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > 8 4 < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 8 8 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > - 3 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > 2 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > - 9 0 < / q a m p >  
+ 	 	 	 	 < q d u r > 1 6 < / q d u r >  
+ 	 	 	 	 < r a m p > 1 4 1 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 4 4 < / r d u r >  
+ 	 	 	 	 < s a m p > - 3 3 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 1 6 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 4 4 < / v a t >  
+ 	 	 	 	 < q r s p p k > 1 7 4 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 7 6 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > 5 3 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 5 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 8 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 1 2 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 1 3 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 8 0 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 1 8 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 5 4 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 6 8 < / t d u r >  
+ 	 	 	 	 < t a r e a > 1 7 9 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 6 8 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 1 7 9 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 7 2 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 1 6 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 5 2 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " I I I "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 1 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 2 8 < / p d u r >  
+ 	 	 	 	 < p a r e a > 1 < / p a r e a >  
+ 	 	 	 	 < p p a m p > - 6 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > 1 2 4 < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 1 0 1 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > - 1 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > - 9 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > - 1 2 0 < / q a m p >  
+ 	 	 	 	 < q d u r > 2 0 < / q d u r >  
+ 	 	 	 	 < r a m p > 1 3 7 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 4 4 < / r d u r >  
+ 	 	 	 	 < s a m p > - 1 7 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 1 2 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 4 4 < / v a t >  
+ 	 	 	 	 < q r s p p k > 1 5 4 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 7 6 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > 5 4 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 1 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 2 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 2 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 3 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 1 1 6 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 3 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 2 1 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 9 6 < / t d u r >  
+ 	 	 	 	 < t a r e a > 6 2 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 9 6 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 6 2 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 2 1 2 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 5 2 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 4 0 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " a V R "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > - 7 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 9 2 < / p d u r >  
+ 	 	 	 	 < p a r e a > - 8 < / p a r e a >  
+ 	 	 	 	 < p p a m p > 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 8 4 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > - 8 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > 0 < / q a m p >  
+ 	 	 	 	 < q d u r > < / q d u r >  
+ 	 	 	 	 < r a m p > 4 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 2 4 < / r d u r >  
+ 	 	 	 	 < s a m p > - 8 1 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 3 6 < / s d u r >  
+ 	 	 	 	 < r p a m p > 3 0 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > 2 4 < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 7 2 < / v a t >  
+ 	 	 	 	 < q r s p p k > 1 1 1 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 8 4 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > - 2 7 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > - 4 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > - 9 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > - 1 1 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > - 1 4 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 1 1 2 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > - 1 9 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > - 4 5 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 3 6 < / t d u r >  
+ 	 	 	 	 < t a r e a > - 1 4 5 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 3 6 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > - 1 4 5 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 6 4 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 7 2 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 5 6 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " a V L "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 6 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 1 2 0 < / p d u r >  
+ 	 	 	 	 < p a r e a > 1 0 < / p a r e a >  
+ 	 	 	 	 < p p a m p > 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 9 7 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > 1 0 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > 0 < / q a m p >  
+ 	 	 	 	 < q d u r > < / q d u r >  
+ 	 	 	 	 < r a m p > 7 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 2 8 < / r d u r >  
+ 	 	 	 	 < s a m p > - 6 2 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 4 0 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 1 6 < / v a t >  
+ 	 	 	 	 < q r s p p k > 6 9 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 6 8 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > - 2 7 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 1 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 3 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 3 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 4 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 1 3 6 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 7 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 8 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 2 8 < / t d u r >  
+ 	 	 	 	 < t a r e a > 2 9 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 2 8 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 2 9 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 8 4 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 5 6 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 3 9 6 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " a V F "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > - 3 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 2 4 < / p d u r >  
+ 	 	 	 	 < p a r e a > - 3 < / p a r e a >  
+ 	 	 	 	 < p p a m p > 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 6 1 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > - 3 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > - 1 1 0 < / q a m p >  
+ 	 	 	 	 < q d u r > 2 0 < / q d u r >  
+ 	 	 	 	 < r a m p > 1 4 3 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 4 0 < / r d u r >  
+ 	 	 	 	 < s a m p > - 2 5 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 1 6 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 4 4 < / v a t >  
+ 	 	 	 	 < q r s p p k > 1 6 8 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 7 6 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > 5 4 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 3 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 5 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 7 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 6 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 8 0 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 1 1 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 3 8 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 7 2 < / t d u r >  
+ 	 	 	 	 < t a r e a > 1 2 7 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 7 2 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 1 2 7 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 8 8 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 2 8 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 5 2 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 1 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N e g a t i v e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 2 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 3 2 < / p d u r >  
+ 	 	 	 	 < p a r e a > 1 < / p a r e a >  
+ 	 	 	 	 < p p a m p > - 4 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > 4 8 < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 7 1 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > - 3 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > - 2 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > 0 < / q a m p >  
+ 	 	 	 	 < q d u r > < / q d u r >  
+ 	 	 	 	 < r a m p > 1 3 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 3 2 < / r d u r >  
+ 	 	 	 	 < s a m p > - 5 5 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 5 6 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 2 0 < / v a t >  
+ 	 	 	 	 < q r s p p k > 6 8 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 8 8 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > - 4 6 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 6 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 6 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 6 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 6 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 5 6 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > - 1 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 5 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 1 0 4 < / t d u r >  
+ 	 	 	 	 < t a r e a > 1 4 < / t a r e a >  
+ 	 	 	 	 < t p a m p > - 1 9 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 3 2 8 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > 2 2 4 < / t p d u r >  
+ 	 	 	 	 < t p a r e a > - 3 9 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > - 2 5 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 7 6 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 8 8 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 3 6 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 2 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 1 1 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 1 2 0 < / p d u r >  
+ 	 	 	 	 < p a r e a > 8 < / p a r e a >  
+ 	 	 	 	 < p p a m p > 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 6 1 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > 8 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > 0 < / q a m p >  
+ 	 	 	 	 < q d u r > < / q d u r >  
+ 	 	 	 	 < r a m p > 2 9 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 3 2 < / r d u r >  
+ 	 	 	 	 < s a m p > - 2 0 3 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 5 6 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 2 0 < / v a t >  
+ 	 	 	 	 < q r s p p k > 2 3 2 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 8 8 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > - 1 5 4 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 2 1 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 3 5 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 3 5 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 4 7 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 1 2 8 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 4 1 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 6 6 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 8 8 < / t d u r >  
+ 	 	 	 	 < t a r e a > 2 9 4 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 8 8 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 2 9 4 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 7 6 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 1 1 2 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 5 6 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 3 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 9 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 6 4 < / p d u r >  
+ 	 	 	 	 < p a r e a > 7 < / p a r e a >  
+ 	 	 	 	 < p p a m p > 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 7 0 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > 7 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > 0 < / q a m p >  
+ 	 	 	 	 < q d u r > < / q d u r >  
+ 	 	 	 	 < r a m p > 3 5 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 4 0 < / r d u r >  
+ 	 	 	 	 < s a m p > - 1 9 0 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 4 8 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 3 2 < / v a t >  
+ 	 	 	 	 < q r s p p k > 2 2 5 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 8 8 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > - 8 4 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 1 9 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 3 9 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 4 0 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 5 5 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 1 2 0 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 4 9 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 9 1 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 8 4 < / t d u r >  
+ 	 	 	 	 < t a r e a > 3 7 0 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 8 4 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 3 7 0 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 8 0 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 9 2 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 6 0 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 4 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 7 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 9 2 < / p d u r >  
+ 	 	 	 	 < p a r e a > 6 < / p a r e a >  
+ 	 	 	 	 < p p a m p > 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 6 9 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > 6 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > - 2 0 < / q a m p >  
+ 	 	 	 	 < q d u r > 1 2 < / q d u r >  
+ 	 	 	 	 < r a m p > 1 8 1 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 4 0 < / r d u r >  
+ 	 	 	 	 < s a m p > - 1 2 2 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 2 8 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 4 0 < / v a t >  
+ 	 	 	 	 < q r s p p k > 3 0 3 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 8 0 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > 4 5 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 1 2 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 2 5 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 2 7 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 3 7 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 1 0 0 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 4 3 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 1 0 2 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 9 6 < / t d u r >  
+ 	 	 	 	 < t a r e a > 3 6 3 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 9 6 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 3 6 3 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 8 0 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 8 8 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 4 8 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 5 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 5 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 9 6 < / p d u r >  
+ 	 	 	 	 < p a r e a > 6 < / p a r e a >  
+ 	 	 	 	 < p p a m p > 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 7 1 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > 6 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > - 1 2 0 < / q a m p >  
+ 	 	 	 	 < q d u r > 2 4 < / q d u r >  
+ 	 	 	 	 < r a m p > 1 8 3 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 3 6 < / r d u r >  
+ 	 	 	 	 < s a m p > - 4 2 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 2 4 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 4 8 < / v a t >  
+ 	 	 	 	 < q r s p p k > 2 2 5 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 8 4 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > 6 6 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 4 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 1 3 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 1 4 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 2 2 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 1 2 0 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 3 0 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 7 5 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 3 2 < / t d u r >  
+ 	 	 	 	 < t a r e a > 2 2 2 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 3 2 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 2 2 2 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 6 4 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 7 6 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 6 4 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 	 < l e a d m e a s u r e m e n t   l e a d n a m e = " V 6 "   p e x i s t f l a g = " T r u e "   p m e a s f l a g = " T r u e "   p n o t c h f l a g = " F a l s e "   q r s e x i s t f l a g = " T r u e "   q r s s p i k e f l a g = " F a l s e "   q r s m e a s f l a g = " T r u e "   q r s n o t c h f l a g = " N o n e "   q r s d e l t a f l a g = " F a l s e "   s t e x i s t f l a g = " T r u e "   s t m e a s f l a g = " T r u e "   t e x i s t f l a g = " T r u e "   t m e a s f l a g = " T r u e "   t n o t c h f l a g = " F a l s e "   a t r i a l p a c e f l a g = " U n k n o w n "   v e n t p a c e f l a g = " T r u e " >  
+ 	 	 	 	 < p a c e p u l s e s / >  
+ 	 	 	 	 < l e a d q u a l i t y s t a t e s   q r s c l i p p i n g f l a g = " F a l s e "   o v e r r a n g e f l a g = " F a l s e "   m e a s u r e d f l a g = " T r u e " >  
+ 	 	 	 	 	 < i n o p s / >  
+ 	 	 	 	 	 < s a t u r a t i o n s / >  
+ 	 	 	 	 	 < b a s e a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < a c a r t i f a c t s   l e v e l = " N o n e " / >  
+ 	 	 	 	 	 < m u s c l e a r t i f a c t s   l e v e l = " N o n e " / > < / l e a d q u a l i t y s t a t e s >  
+ 	 	 	 	 < p a m p > 4 0 < / p a m p >  
+ 	 	 	 	 < p d u r > 9 2 < / p d u r >  
+ 	 	 	 	 < p a r e a > 4 < / p a r e a >  
+ 	 	 	 	 < p p a m p > 0 < / p p a m p >  
+ 	 	 	 	 < p p d u r > < / p p d u r >  
+ 	 	 	 	 < p p p p d u r > 6 2 < / p p p p d u r >  
+ 	 	 	 	 < p p a r e a > 0 < / p p a r e a >  
+ 	 	 	 	 < p p p p a r e a > 4 < / p p p p a r e a >  
+ 	 	 	 	 < q a m p > - 1 1 0 < / q a m p >  
+ 	 	 	 	 < q d u r > 2 0 < / q d u r >  
+ 	 	 	 	 < r a m p > 1 2 6 0 < / r a m p >  
+ 	 	 	 	 < r d u r > 4 0 < / r d u r >  
+ 	 	 	 	 < s a m p > - 1 6 0 < / s a m p >  
+ 	 	 	 	 < s d u r > 2 0 < / s d u r >  
+ 	 	 	 	 < r p a m p > 0 < / r p a m p >  
+ 	 	 	 	 < r p d u r > < / r p d u r >  
+ 	 	 	 	 < s p a m p > 0 < / s p a m p >  
+ 	 	 	 	 < s p d u r > < / s p d u r >  
+ 	 	 	 	 < v a t > 4 4 < / v a t >  
+ 	 	 	 	 < q r s p p k > 1 4 2 0 < / q r s p p k >  
+ 	 	 	 	 < q r s d u r > 8 0 < / q r s d u r >  
+ 	 	 	 	 < q r s a r e a > 5 1 < / q r s a r e a >  
+ 	 	 	 	 < s t o n > 2 0 < / s t o n >  
+ 	 	 	 	 < s t m i d > 7 0 < / s t m i d >  
+ 	 	 	 	 < s t 8 0 > 8 0 < / s t 8 0 >  
+ 	 	 	 	 < s t e n d > 1 2 0 < / s t e n d >  
+ 	 	 	 	 < s t d u r > 1 2 0 < / s t d u r >  
+ 	 	 	 	 < s t s l o p e > 1 9 < / s t s l o p e >  
+ 	 	 	 	 < s t s h a p e > S t r a i g h t < / s t s h a p e >  
+ 	 	 	 	 < t a m p > 4 9 0 < / t a m p >  
+ 	 	 	 	 < t d u r > 2 3 6 < / t d u r >  
+ 	 	 	 	 < t a r e a > 1 4 2 < / t a r e a >  
+ 	 	 	 	 < t p a m p > 0 < / t p a m p >  
+ 	 	 	 	 < t p t p d u r > 2 3 6 < / t p t p d u r >  
+ 	 	 	 	 < t p d u r > < / t p d u r >  
+ 	 	 	 	 < t p a r e a > 0 < / t p a r e a >  
+ 	 	 	 	 < t p t p a r e a > 1 4 2 < / t p t p a r e a >  
+ 	 	 	 	 < p r i n t > 1 7 2 < / p r i n t >  
+ 	 	 	 	 < p r s e g > 8 0 < / p r s e g >  
+ 	 	 	 	 < q t i n t > 4 6 0 < / q t i n t >  
+ 	 	 	 < / l e a d m e a s u r e m e n t >  
+ 	 	 < / l e a d m e a s u r e m e n t s >  
+ 	 < / m e a s u r e m e n t s >  
+ 	 < i n t e r p r e t a t i o n s >  
+ 	 	 < i n t e r p r e t a t i o n   d a t e = " 2 0 0 7 - 0 8 - 0 6 "   t i m e = " 1 3 : 0 1 : 5 1 "   c r i t e r i a v e r s i o n = " 0 A "   c r i t e r i a v e r s i o n d a t e = " 2 0 0 2 - 0 3 - 1 5 " >  
+ 	 	 	 < i n t e r p r e t a t i o n d a t a s t r u c t u r e / >  
+ 	 	 	 < i n t e r p r e t a t i o n m e a s u r e m e n t s   a r r h y f l a g = " F a l s e "   e d i t e d f l a g = " F a l s e " >  
+ 	 	 	 	 < h e a r t r a t e   e d i t e d f l a g = " F a l s e " > 6 1 < / h e a r t r a t e >  
+ 	 	 	 	 < m e a n p r i n t   e d i t e d f l a g = " F a l s e " > 1 8 0 < / m e a n p r i n t >  
+ 	 	 	 	 < m e a n q r s d u r   e d i t e d f l a g = " F a l s e " > 8 6 < / m e a n q r s d u r >  
+ 	 	 	 	 < m e a n q t i n t   e d i t e d f l a g = " F a l s e " > 4 5 2 < / m e a n q t i n t >  
+ 	 	 	 	 < m e a n q t c   e d i t e d f l a g = " F a l s e " > 4 5 5 < / m e a n q t c >  
+ 	 	 	 	 < p f r o n t a x i s   e d i t e d f l a g = " F a l s e " > - 1 7 < / p f r o n t a x i s >  
+ 	 	 	 	 < i 4 0 f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 5 0 < / i 4 0 f r o n t a x i s >  
+ 	 	 	 	 < t 4 0 f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 1 0 3 < / t 4 0 f r o n t a x i s >  
+ 	 	 	 	 < q r s f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 9 0 < / q r s f r o n t a x i s >  
+ 	 	 	 	 < s t f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 3 8 < / s t f r o n t a x i s >  
+ 	 	 	 	 < t f r o n t a x i s   e d i t e d f l a g = " F a l s e " > 5 0 < / t f r o n t a x i s >  
+ 	 	 	 	 < p h o r i z a x i s   e d i t e d f l a g = " F a l s e " > 3 8 < / p h o r i z a x i s >  
+ 	 	 	 	 < i 4 0 h o r i z a x i s   e d i t e d f l a g = " F a l s e " > 2 7 < / i 4 0 h o r i z a x i s >  
+ 	 	 	 	 < t 4 0 h o r i z a x i s   e d i t e d f l a g = " F a l s e " > - 5 2 < / t 4 0 h o r i z a x i s >  
+ 	 	 	 	 < q r s h o r i z a x i s   e d i t e d f l a g = " F a l s e " > - 2 6 < / q r s h o r i z a x i s >  
+ 	 	 	 	 < s t h o r i z a x i s   e d i t e d f l a g = " F a l s e " > 6 9 < / s t h o r i z a x i s >  
+ 	 	 	 	 < t h o r i z a x i s   e d i t e d f l a g = " F a l s e " > 4 9 < / t h o r i z a x i s >  
+ 	 	 	 < / i n t e r p r e t a t i o n m e a s u r e m e n t s >  
+ 	 	 	 < m d s i g n a t u r e l i n e > N i e t   g e c o n t r o l e e r d e   d i a g n o s e < / m d s i g n a t u r e l i n e >  
+ 	 	 	 < s e v e r i t y   c o d e = " O N " > - O v e r i g e n s   N o r m a a l   E C G - < / s e v e r i t y >  
+ 	 	 	 < s t a t e m e n t   e d i t e d f l a g = " F a l s e " >  
+ 	 	 	 	 < s t a t e m e n t c o d e > S R         < / s t a t e m e n t c o d e >  
+ 	 	 	 	 < l e f t s t a t e m e n t > S i n u s   r i t m e < / l e f t s t a t e m e n t >  
+ 	 	 	 	 < r i g h t s t a t e m e n t > n o r m a l e   P   a s ,   V - f r e q .     5 0 -   9 9 < / r i g h t s t a t e m e n t >  
+ 	 	 	 < / s t a t e m e n t >  
+ 	 	 	 < s t a t e m e n t   e d i t e d f l a g = " F a l s e " >  
+ 	 	 	 	 < s t a t e m e n t c o d e > A X R       < / s t a t e m e n t c o d e >  
+ 	 	 	 	 < l e f t s t a t e m e n t > L i c h t   a f w i j k e n d   r e c h t e r   a s   d e v i a t i e < / l e f t s t a t e m e n t >  
+ 	 	 	 	 < r i g h t s t a t e m e n t > Q R S   a s   (   9 0 , 1 1 0 ) < / r i g h t s t a t e m e n t >  
+ 	 	 	 < / s t a t e m e n t >  
+ 	 	 	 < s t a t e m e n t   e d i t e d f l a g = " F a l s e " >  
+ 	 	 	 	 < s t a t e m e n t c o d e > E R E P O L < / s t a t e m e n t c o d e >  
+ 	 	 	 	 < l e f t s t a t e m e n t > S T   e l e v a t i e ,   w s l   n o r m a a l   r e p o l a r i s a t i e   p a t r o o n < / l e f t s t a t e m e n t >  
+ 	 	 	 	 < r i g h t s t a t e m e n t > S T   e l e v a t i o n ,   l f t & l t ; 5 5 < / r i g h t s t a t e m e n t >  
+ 	 	 	 < / s t a t e m e n t >  
+ 	 	 < / i n t e r p r e t a t i o n >  
+ 	 < / i n t e r p r e t a t i o n s >  
+ 	 < w a v e f o r m s >  
+ 	 	 < p a r s e d w a v e f o r m s   c o m p r e s s f l a g = " T r u e "   c o m p r e s s m e t h o d = " X L I "   d a t a e n c o d i n g = " B a s e 6 4 "   d u r a t i o n p e r c h a n n e l = " 1 1 0 0 0 "   n b i t s p e r s a m p l e = " 1 6 " > r Q g A A A E A A A A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I 0 k S V  
+ J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F R V J U  
+ 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 L w G A k P Q + E M Q Q / E E Q h G E Q P g / E U R Q / E I Q w / D Y N g  
+ 4 D 0 Q B E E E Q R D E A P h C E U Q Q + E B j x A Y 1 c 2 N Y g P R B Y 8 Q 1 4 E B f m W E I P x A X N k Q / D 5 l 2 i X J o m P E J n Q / D 0 Q 2 Z  
+ Y 4 Q B C E B g 1 3 Z 9 p 2 R Y l u G Q a B m x B D 1 t l 0 D 4 P W y X M P 2 c Z 5 n m 7 X x v m G D 9 n 1 x D s Q V 3 a R p W 4 Z 8 R G W a B l 2 l b  
+ Z c 3 U a B x W R b d n 2 J c F c 2 y c N k F y b B o H J Y Z 5 X W b d j 2 n c V n m T c 5 y V 8 b x o W Q Z N 1 H k b s Q l 4 d t 4 W 8 c R f I A f 1  
+ m 3 O c q B G P f i A m 7 b x m 2 J c V h n / g 9 d G D e Z c n L g 9 + n g e J j n 2 a V 4 1 8 i N v m i c Z k l 0 i y G n G D 5 c G N Y Z t I V b p p  
+ I C f p i l y c N 8 o R f V 8 H P a N u G X a R / I f b 0 P W W j x x n O E Q R R C E Q P A + X Z s W Z Y E O 1 4 e c R B A D w Q 2 M e R n 3 E a R q G  
+ y m S J 4 g Y 1 4 o A a G A I k a N f Z D Z d + I S e F 1 W O h p s Y T e M Q p q n V 1 X 9 e + d G 8 a e h Y M E K J H g Y h 2 m Q Z 5 r Z + f 6 c 2 6  
+ c 5 l 2 W E S D G m b C a n y e q R W H n K E 4 K n O B 6 A h 1 c n v m S D W e m d 7 m f f d 2 n 6 q 5 + Z m i J z X q q l i Z 9 e S n H a p 5 k Y Y h  
+ 1 u o S s N 9 1 w f t 9 n J Y 8 P m 1 g S Y m f Y q d J w o y p 7 O d u A 2 p q 6 e m W a + l 4 M s G i H C r q b b i f 1 c 2 I D x x J r f S a 3 t Z p  
+ i I x i N z o Q X q K V 2 e c P g 1 D Q P G 9 n 1 q W H e W m 6 b o S b X m b G 0 K U Z V 8 2 K q F 8 8 K i C O W o p J m I x n O p 3 c h 1 s q w h a B  
+ n 4 m x d J y p J t 6 n o S 2 L j h J c n 2 k B i s H j N q m b g O L M Q o i z 5 z y u 1 m x x i O c j Y 4 P 6 X m d s X O X 5 o 2 H E G + 8 V t O e G  
+ l d S e I 5 m a g G T b m e o A j O D 3 2 0 K C H 3 q / J 7 e w r O H s a S l 4 b o F q L D h l 9 K 2 c p m G J a R m Y I Y l i K u x a 2 Y c w K R Y 6  
+ h 5 c 4 b c R 2 3 g b K a q v m a I M R t m K t q m S Z K + s H F a + a H S t A f y x a V b K + + B E N i x G j G T 1 z E U Q A 4 D Q N 5 L Y y B m F d  
+ 6 e p G x K 6 X h Z 7 A p i i O e I W a P l r X h m D b K x m l K + d p q p 9 e x o G Z 4 p 8 7 S p y R e + p X K G 2 s S e t V 2 P E Y Z r u 8 h A E W  
+ W n M r 1 5 b J f S A s H k S h d l e l k F w p R v L v 4 2 3 s Q b p 9 t j f R x / B r f F t / f m J Z w n O r 5 2 b j p / 2 b q p s p / G O 3 w d a C  
+ I 7 m 2 Y m 5 x 9 6 d U j j 3 3 N 4 1 8 H / Z e q / s a l s 8 N j p 7 9 S c V 5 + E c n C / z X A Q 1 v s K N J F 7 J 6 V 8 o + G + K / S F 3 i g 9 o I  
+ y a P p W 8 D 2 T 6 I E M P B B E Z c X B D Y N w 6 D y L e W k s R K 0 6 b D d l d 1 z W h d 9 u G D u l z X A b N y a 0 p P D e l o K a r p e O n 3 Z  
+ e q Y c X 0 C u P 2 X 5 3 6 M 1 X U P I 1 q s a n q n x t l 8 h t u T i J 7 f I b b 8 H F k f A v 9 r J 4 M V z r 7 P 6 7 P 7 H 8 x B 2 I 4 k h z X A i  
+ F p c y b O / f y e R i q r h e y X 9 m N f o z q + O B C 0 a w a 1 j T i q x w i 3 p i q a y u G c + h P a 0 3 r d Q q l y 3 s y b r 3 N 1 j T t 3 d x  
+ + 5 n X Q Q x G E N v x F Y i U Q + D c N A 6 o 9 h s Z 5 Z / X o 6 u s H W s m s M X / O 1 K e x j B K M g r 6 N H + V e L p + z 7 I G q H G / s e p 3  
+ X t s 6 R 6 F 0 6 Y o P e 2 n q a e O v 8 X d 1 7 Y z q Z o Z 4 r h 4 o f 7 9 j X f q Z 7 W 5 q i t u N q m p q m i q z b N Y a K e r m G g I G b 6 y Y  
+ q i V j m Z q J k 4 p z 2 F X c 0 6 K t P 2 i E I V i C 5 v T r 3 c 9 Y e i E d o 8 h 3 O m l T a 4 5 t 3 R 3 W 8 y u 5 k h H 9 t P 3 z i N z q u H W 1  
+ y R 5 c U e t c R F E b R R B E h j W M D g N g 1 c P f q L X F 7 t R 2 h f G D v 2 r t 4 1 D v a F j 3 W Y L 1 F 3 K T a a h 8 M v e v c u 8 H k I O g  
+ 1 3 L O f N p 1 4 l x v I 7 6 u 8 e D x Y P M f 8 D z 7 Q 8 F 3 P K g z c Y G h H J c Y k G Y 9 + 0 u g r l 3 B t v o 9 a f m R Z 1 k r I e C o 9 T e y  
+ G r p 9 Z q v 9 v G K o X 6 u u P 0 w n 6 L I g W s I l w D 4 d Z d W Y p 7 g O Y o d m i 4 L L y 7 j W n 0 m u a m o X 2 v 6 b D 2 d + b n f G 5 8 e 3  
+ 7 x z W E X S l N 1 Q 6 l E O x A E Z j H J X X f g 9 D c O A 7 b + i M Z X I R d C g / j 8 N e v t / w c 9 j r G p R 3 X L t L b 2 5 r S D + W v t 6 m  
+ 2 Y 7 b Y X g u s q y p C g K E E P R q e 0 d 3 8 k 1 C u / 5 1 P / n q e V e B E a q S / I 8 h 5 2 D 4 W C P H + z g X V Z O S 8 6 w 3 H t 9 l L k H v  
+ k u 1 I C h 2 T Y B k O w v k g 1 3 G 7 + D W / i n i 8 Z t c d j b J r f Q M N t 6 f t o m 3 U I T p T v P K 0 y l I Q D x 3 F x e n 4 Z t 7 X D X d e  
+ 3 / m 2 z q u a e s G s Z 4 Z q l J c E c R Q 9 l 4 R m x 9 I O A 4 D c O u W Y a X G O E T b a 2 d / y X V 2 6 J 9 H w O n o g 8 h o m O X f h c N b a  
+ 0 N m s e D 2 7 1 T Z l 4 r p j a t q b 7 M j r 3 y P c 9 X U 8 M 8 5 q Z 4 n j J J h 3 v 9 p s e 7 G K i Y 2 K L e f L Z 6 / / G s K l + H W 9 j 7 u E  
+ / 0 o D C u p 2 i 0 2 z 7 z p p E w z t H t d 3 Z a E e O D n d o K b X t r + 0 A + 5 z M J F u T I q E 2 f N e r g m h t n 2 e v 6 C m R f q 4 1 2 x m  
+ O k a l H P d I R m z E E R 2 X 5 w O r 5 u i X M 4 i 3 f G w + i R K Y s L W 4 n d y s N S 0 f 6 a U c D h L B e L 1 q U d 2 k a m q K f I F c u m K N  
+ 1 F z X v g + 7 H W b u h V 4 u C h 3 r w 1 x d Q 2 Z s 8 A e r D a / y V 2 r Q / B 8 q e k f Z f B + R o c 6 c r G c / c e p v z i W I 4 P t N 3 X A g  
+ n 1 b Q c p x m q 0 F j W K h H z K r d y A r W u n A I K 4 H y n / / 1 5 K 0 x 9 3 q C Y 2 u n z t t o 4 I d y 9 4 W h d u 9 U 2 6 j I / a p d P f k 6  
+ z 2 2 b + N O W E I S B D D o P 1 2 X Q Q g 7 D X o G t f P P h E 5 a D L R x G p r E y N u 4 d E N v 4 C 3 x 4 F 3 x y r s + / h f o h 2 j Z O P m L 1  
+ G p j H Q r N c v 2 d 8 d 7 H / I f 7 v + 6 1 O 2 e 8 1 m q 3 B r + k 4 R s 2 E a h p 5 p W Z o 9 s L j d 2 O H e u Z u Z H w R 8 q v j N z 4 V 0 f g 6  
+ R j N / H c r 3 w s A e D T 9 O o W I 2 g a Q P Z c 2 X Z d l 2 X Z d l h I e A I 2 X Z d l 2 X Z d l 2 X Z d l 2 X Z d l 2 X Z Q I H j Z d l 2 X Z d l  
+ 2 W w w A / 8 A W A o A A A E A / P 8 / w A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E  
+ h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O  
+ U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R Z V e P 8 A V h A F A E v P g A A 8 E E P Q 5 D s P g 9 E A R A / E 8 d R f D  
+ k M w 0 D g Q B F D o M g 1 D I O B D E Q R R F E Q Q g + E E P 2 P E A P w / E A Q B D E F j w 8 Z Q Q R C E E Q G e D 9 d h A Y 0 Q h C E A P m S Y 5  
+ n 2 j E E P m Q D 1 m A / a V r m l D x q m z Z 8 Q Q 7 D 8 Q 2 U Z 1 p 2 o b l u Q + E J o W V a M Q 3 A Z R l B E a d x W n Z J m G Y Z J l W u X d r  
+ W x d Z p m c X F n A + c R n n J Z J k 2 y Z 9 p g / Y 4 P W 8 Y 9 3 n o Z N 0 3 m d 9 s n z Y 9 l G w a t p h C b B j m Q Z V 3 m n Z t w m b b R c R  
+ D a Z 6 m O Z 5 n H V c R 1 G s a p w Y K Z 9 k 2 o a Z 8 W U f x x W d X F 1 G Q Z h + m f e p 4 m x e R n 2 9 c d y 3 9 h p k 3 j d N j 4 g a C C m g  
+ d + C 2 + Z R 4 4 b h 1 n 2 u Y 5 n W 9 a F x B D b R p R A X a N 3 F h h n G N h 6 G H 9 b J 5 2 p c K U H u h t 8 3 v e 9 2 5 N b k Q W X c c P Q 6 b  
+ Y Q G a k U O A 5 e M R R D F A d B h D A L A 3 D o Q h D D 0 O A 2 D M N Q 8 Y k R B J b 0 P W w b J 0 3 z a g P n J Y 5 y X k Z u M o Y h W E o Q e V  
+ s h E f J 6 I 5 a Z r n v d N x Z G Y 1 l n s a i N w + Y y R X V f 1 3 H k b S J 2 e Z J s I u Z G l Z x f 6 L G r Z 5 v 6 C Z y H n R f J 2 3 e d Z d  
+ m M Z u R p M h N 4 2 Q f k Q m a i S H 6 H j 1 5 Y o c F v a 6 d S h G d i x w V 4 s F 2 q x l q l 5 F Z 2 c K E g u l Y S Z 1 o m u e J o 5 R r Z r H  
+ q d F 0 n V k W N X i e 5 5 b I D 8 P K G k 9 k 6 Y h 5 s Y o s N p L J r G F l x q q 0 r f q N 0 I t n E P F 3 k V 1 q o g Z 6 n v Z J p X 1 l R k h D  
+ n x w X m Z i l b K l y S G f D u Y Q 9 Z o P 5 l b K g 2 V F 8 c h Q Y U N 2 o D w N g x Y R l h I E g R G t j Y P W d e e N 6 w i O Y r 6 c 9 / W a h  
+ t 2 W o i 6 l H j b l v K h g 5 v J 8 0 q J m t i G P X + 1 N 6 J b e x 6 N T k R y 3 1 c K Q n E t d l 6 d Z N l 2 / i y + I y q G A X T u D R 4 / c t  
+ q G X q i g m n d J k b t 1 2 m m T b D N 2 Q 1 h 1 N d f N 6 r S t L c n c a C T Z E a O N I V h 5 x Y 8 l y C Z L a m k 5 i j t v I H o S 5 L y t l x  
+ X S e q H B B E W x Y p Z V v Z T q q i a p q S + 3 G X e Q s 6 a 3 O n + c m v 3 C j H W H s r V l c R 0 z A o J X e S K w 3 M R W t j y 6 K M x L T K  
+ 7 a B i J i f p v n + s z k K v q 1 r G P n 6 D c e Z 6 f Q 6 g y c A 9 D a c G T E U P R I G 4 a R A D M M 2 7 E A O g z D E M Q 7 z f N a 1 2 n A W e  
+ Y 5 d Z d u Z w a S v v + 4 3 r J 3 W u u + A O + q t o o B k 9 3 4 O n H R 4 U e V s 3 B 5 S D e I e a o o v k f X 7 4 f h w K y a z d 7 U h N k e F j  
+ d j J 9 a n v Y H c d u Z L 9 q K n 1 1 q y I 7 X V v 7 s d 9 0 W X 4 B q X E k T G W 3 3 l 5 K U q 6 4 7 m a O G H H i N m A 8 X S P m g u 6 w 4 v l F  
+ q 9 W e O B L m a r h e g p p r r 7 Z d 7 t 3 j m h 2 W h U R J 9 4 B 0 o e 2 X e M H n 5 3 N 3 p i h m d 2 X C o G r J d b 4 c W B m Q d 8 P W X v j 1  
+ 3 m 1 F c f A 1 / R 2 8 E Q P d l 1 n / O + t q h 7 9 s t x 5 F e o P F 0 Z Q O g 3 Z C 5 B E F o d R Q D A M w 5 7 M O F + D I O h D m g R x F o J l I  
+ G s V x 2 q u b U 7 u r X R p Z v v 2 m j h p 1 f 7 4 r X 3 9 9 l 7 n w g q G H H l t + s N a z i 9 3 u b W N H 1 3 + / T i 6 6 n h v v e m V Z 2 n d 3  
+ k L k 4 8 l K 7 q w p t 3 6 i h a F n Q q j + I l u x 1 I V c d l t A h N l 4 3 a n a / 7 j f u a K a X Z v I e X 3 K s b 6 L 3 v / y s o w k W w 4 k 5  
+ n h t 3 p 2 m 4 3 a m f 2 j i x j 4 V h O n p K g o P d H x G P Z I a q 5 m q o R m / S Z t y e K 0 e l n P c B v + N g f b a o 4 t l u A 2 m s m / d V  
+ t t 9 D x s A 7 D b O m o E V e R y F 0 P A 0 D R d B C D g M s y / U R R K 6 W A K j 5 B 6 I R e F 7 o O 2 j G 1 w o b P H L d u l H L r F o K i r W 4  
+ n Q c + 3 8 4 q i s 3 k Z 2 P Y c d C H 3 R f a 7 G g d R r Y 5 q L / n w c D Z 2 P d b c 7 r 2 W t t f 9 G Q p Z i W E 9 J o j G + g d Z x 2 z f e f /  
+ T u B / o W j R q 9 L 2 m q 9 b c T g M 3 m P E u 8 c F q q y w e + L D d T D a y e 9 3 9 k r L 2 v c i S g a X f x 0 H w X g P Y E Z T F 5 h o h u b j  
+ d J s 3 8 4 D v t r j T Z A 9 x e V 8 o 2 W m + K a l 8 N 1 k y s n Q z 1 x X N 5 K y 7 p x n Z 4 K D p d G N D z C g / + R q R F E A R h q G w Q / t D  
+ l x A 6 D Q N A y D d g R H Y p j 6 F X V l d d d R d n J g p 1 n H i 6 g r o Y 1 m H 3 a f F 3 A d F x 5 c x D E v U u 1 l L O u 2 w 7 r 3 b 1 M 8 g 6  
+ H 5 R g 3 q I c h V q 4 T x 9 0 p C 7 6 W H Z / u E 6 z 4 v 1 H 9 d q 0 s c s O M q d l t 1 W P 0 d o 6 Y s F + K i 2 3 t + A a v V q 0 a t l u Y u t z  
+ 7 t b 7 o a W s N k I 8 c 3 R 3 Z c e q K U Y + B L H h T F 1 2 n y A W j 5 G 7 Y v o T p 4 a 2 H / N I / l 1 P 4 X X w I G D 5 c H R Z M R G X Z M O 3  
+ m d G j r 4 o 6 h 5 c Z H g I V 9 S N 9 K x N 3 + + c 9 l 5 + 6 i S g 6 D o P g 8 b Z / A 2 c Q O q D E Y W h z F Y M g v D S 3 f k D X 5 G O E U R 3 J  
+ f V z d H a 7 S F 1 Z H B M 4 f P V s 4 c u u Y d Z v o L t i y B q e i y 7 G P c H k J X 1 i R G P f x m 3 9 5 x x 2 j 0 l 0 L s Z H W 4 W h Z x 7 Q Z  
+ i f n U d L 0 m h Y j R I t a 5 0 m 8 a h d t a z y 0 H H a P f b y d m A W s f 2 6 q y j i x Q 9 g b 1 G h s O C s 9 u R l W d p 1 w Y b x n g H m 1 5  
+ r r s k 6 G Y K t N o 7 D 8 W 4 u D d C 7 M U r a f 3 o a 5 z d W Y 9 d Z c h P b / H r B j 6 m a 2 k M 6 D 1 q u x q W Q 6 s j O C 6 1 p 1 0 b S d S Q  
+ 4 e q 2 i I 5 v R t m T D w P L F D g O 5 n D 8 R h s G o Q A 2 D Q N g 9 E Q P A w X 4 N h B E c R h G z e n d a i Z 1 t e c K w q o d t w W 0 6 i h 9  
+ W Z S Q v e k F 2 L n u z X 3 B 4 O I b h i X d 2 s d D F O M e N q n S i D d 4 K z x 9 e M d n 1 N o h S C v N a m q M f 0 p 2 6 v a G y 6 o c f l O Z  
+ Y 9 w W l 2 m N m l 4 H E b s p 1 4 G j 4 j V o T 3 K G 5 L q y s o T e T a 6 s u t w + A / s Q a Q d H h Y 1 d R q n m p 6 o 4 K c H R 3 S 6 e T u H Z  
+ F + Y s Y 9 d Z b c 1 3 6 L v e + a x d 1 x + g 1 G G d L c G t r 7 d / B H e n 6 l J E 0 d / Y G D 4 O 5 9 X U O m P X O c g 9 p A Q B p H A S A 3 D Q  
+ N w 9 D 4 O A 0 D U N A 3 E E R h G E j e t L Z C N J c Z D Z W V j n / H O f C h 5 S 7 6 L I W h P 2 o y g d 1 b 7 d L W L 6 t Z z q x e N w c 7 h T +  
+ 3 b u a 4 H + z x 1 O J r e s e 9 i V 2 + W g B k I G p F x 6 o q i V L i i 3 a m j k 6 B N 1 7 u 3 s f a 6 1 d J i z o G d d Z 0 I 5 b B j e 1 l m n p  
+ S Z X C p I 3 S P H D q 6 l a j g r Z W x f B q d r h P h d J E U Q P v f D k W g h O L t Y i p x 4 0 h J n 6 Q m O G 6 d 0 d 2 3 U 9 p l s E a n u 9 n  
+ a d d m R r K o n g b 7 F K v d v D Y N h f R + Q 0 J 0 w 7 D 1 3 w 8 s Y O Q 3 9 p i x A G A d B J C 4 N A 5 c Q P w 2 D Y N w y D k Q c 2 E d v c N b  
+ H i m n Z d / d R v r U 4 t e b g Y V c 9 o + w u Z r e 3 a q J o A 1 v o K U Y + F f U i H O n n q j y I S h L F X b q q 1 2 x Z h c I u k L v v T g a  
+ Y 5 H x J c a C r n F I J s O A K w d u D u + i 7 W N V u Z 9 4 O t 9 0 O g c P v v U j E Q c K d L k e W b H G 2 V 7 N q 6 3 q 9 2 8 6 1 h 2 2 r e 7 z  
+ 6 v f f v H Y e 6 5 X H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x x A H g C H H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x 3  
+ H c d x 3 H c d x 3 H c d x 3 H c d l Q I H h x 3 H c d x 3 H c d x 3 H c d x 3 H c d x 3 H c d x w A / 8 O o G A A A B A P 3 / A A / w A Q J A 0 E Q V  
+ B k H Q h C U K Q t D E N Q 5 D 0 Q R F E k T R R F U W R d G E Z R p G 0 c R 1 H k f S B I U i S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M  
+ 0 0 T V N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F Q l D U R R V G U d S F J U p S 1 M U 1 T l P V B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F  
+ h W J Y 1 k W V Z l e A F A V h P 8 A U x W k Q R A X E Q A / E I P w / X A Q V 3 D 4 Q g + E A Q V 5 X l c V 0 X 1 f F 1 X I Q Q + X B d 2 A Y l c 1 /  
+ D 9 c l z Y V k G L X t d l 4 X Z h W N Y h e G J X l g 2 T Y N f 2 e Z t k G C X V d G X X F n 2 d Y 9 j m R a x h 1 7 Z Z i 2 m a d s 2 G Z J j W y a  
+ 5 q W R b d j 2 p a k Q Q 9 E N u B A Y l o l + X p e W G b V f m b c l c G r a Z i 3 I Y p f G Y Z J t n Q X w Q B D D 1 h g + E N 3 H b Y h 2 X D D 0  
+ R A 9 d N v m y d 9 7 F 0 X N k B C X N e 2 K Y 5 5 2 e D 9 4 1 3 a Z / W r b R 0 3 m a p y 3 C E B 2 X Q e B o 3 Z Y F g o M d F i l w E I P Y I a Z g  
+ W V g h 1 3 Q g N n H A a t 9 n G b k P 4 L X d 1 I c X k P h E D w Q o Y a 2 I G W c h 5 H U g B d 1 8 f R u 2 x j p p G o Z 2 P Y Y Z q P 2 l f l l 4  
+ O Z G J o c d R o o u g a P 4 F k B m Y x b p w W u b 9 t 4 J Z y H o n g + O 4 + Z B x H 1 Y y A 5 W i k Q 1 z X K S I P j e E n L k l p 3 z j 1 p 3 c  
+ c q T W 4 l 9 j Y 2 D y M 5 o g x t m I g h e 3 X d Z u 4 o l F 0 5 A f u S 2 U c 2 M W 1 c K E 1 9 X R x Z P X Y Q 5 6 b R f H G Z W h 5 R a F 2 K J Z  
+ N c 3 G a + b X K l m l J p b F h 2 Z g W A W d h p f W t j p 1 5 g k Z + m j Z i S J / X + Z 2 + a C d p y f 6 C 5 Q q l / 3 1 d 6 a W g c y y m V b m  
+ U 4 e s S D Z F n a d I n t V n 4 j k K n q r i 6 2 G 7 r 6 Q b A p u d a h r 9 q I N k O j 2 y s 6 d L Q e W 4 G 2 u a o I 8 l K a L n b N 2 m v k y C  
+ H x c G 2 X 7 d B f q r n K Z J 4 u e c 1 1 h 5 7 o m t D A H b l e w G c b 6 3 m A q d 2 7 g l L C q 8 b i U q 6 Z S Q p U k q u b o h R 9 b 8 m P C 3  
+ 1 q 2 T X h o h k 6 7 n X I 3 H a p 8 o 8 y u D s M a p r H n o u + 4 2 e y q q P w 1 z r b z z H p c j l 1 b a o 1 m q y a W p 4 H 0 T T 2 Z e F v 5 G  
+ x O + M M a T I a I l V z 8 / c 2 8 c q x e 9 7 S 1 q Y 7 r o S o n s 2 m 0 s P x 6 4 3 d d W P s O 0 j T X d a X Q q L l b D I b 0 a n 2 P b G N g + c  
+ q z N L Y a x L 5 s G X q / h B q I W m 1 j m V q O S 7 4 w 9 + W e 3 5 d l + Y p / m h f V u K T y J o B A 1 V 1 N B a 7 Q c J v V t a B j u 6 K c 2 9  
+ v d l q x w q e t 2 1 N e u H a N Q 2 X T L 4 u 6 u n z h a u 9 X u w Q Z r Z / k O o e e g u U 1 7 A s C g V z 4 G Y C / I / 1 W N 4 j 7 H s p Z b O s  
+ M g f r d 8 8 b q 9 4 v l q K Z h 6 z s L Y l / m 5 9 s / P W J h S / r T l S 3 t u b / t s c 1 L X m P g C 9 s 6 / N f V x f 3 F M 7 o a Y M C Y T M +  
+ e 3 W + q Y d G z p H o e i a H 8 D l p N e W R 3 a m m T c 9 2 K h m w 0 r W 9 4 + O A s D s q A a A Y W Z 3 I i 1 4 4 V X i t H F e P h P 3 5 v R J +  
+ Y S F 2 Q j V u a 3 w V e H F h v Z J n m f o H w y j q W Q o G b Z l v V r H u l b a 4 9 9 S W m O s h 3 p O q 6 2 K T 6 S 9 e X + X 3 + p 3 t 8 r v l  
+ j B q 9 p / o H o c 6 m o D c 9 g Y A l O p e K e 7 y n G g D k d a o B z u p w a n b 0 o f v 4 J i j l v k s X G J O l e n f A q y 9 u / p z + 9 N + L  
+ Y t i 1 v x n R w n m 6 h g b k O Y d m y I v 3 j n 6 s v q h M W v a e L D o R w 6 s c i L V 6 u G 4 c H o 6 C d y 5 K V Y 0 n u U H j m e 9 n F m e f  
+ K i X 1 2 6 B 5 H g 6 O e 3 9 5 F o K V Z c e X 5 N 6 q T R u 0 l / J d b b z c s X m z e J Y m d c X 9 l r h r 1 l d 5 Y u e 6 X H I o D I b r x / O q  
+ d 5 b M a u g H 4 8 9 x + w J W 5 i H b x h D s b y c 7 i s E / G A Y J 3 h 6 K 8 / b 6 K s c j J v 0 Y F 4 8 Z X v p r I e 3 q 7 o w J + L F 1 q c f M  
+ h f W 3 D 9 P i G U 5 D 1 Z 8 f h / o D j f n H c z i A 4 m y X c 3 D 1 S L c 2 u u R c f 2 r Q 9 7 g G P e D a D L X j 4 S 2 6 k z h 0 3 e m e v L x g  
+ N w / 8 9 O s s f x / A O 2 p 2 o N K q y 9 v 2 1 D 9 6 d 3 u b q u + K n b x n 2 j v 3 q z Z M 9 e W w c H i T h P R 5 H k c L 9 G C u E z L s b N x +  
+ w P l k X c 3 y p 2 E X D 5 b 6 P 2 r e 1 o d u / + e Y r n 8 L 6 5 a S s k g K b X 3 f 7 n q s m 6 T W Q f 3 O e N 5 H e N m o e O a g 3 O b n W p 3 w  
+ H J g u V 8 9 f O Y 5 a X 6 k 4 6 c W g s v Z T n J w Z B 4 8 Z r H O 5 f y 2 7 3 a 5 X u r z m P 5 M 5 1 r T f k 2 / B 3 u k e L 8 i 9 X c p H l W R p  
+ n 4 H a s E l e r M W m f q 9 o i T b G S f P Y X 5 r S q P j + v H a 4 o W p r z 7 y h I u e 6 W a T 1 2 q 9 n g S D + X m r h H f 4 T j 7 Z c y X H +  
+ X H r v 8 f u R p T b x s H J Z q m o D c P 3 + z h e j Y S + i i 7 I h J g K L e m L a 9 h Z 7 t 4 e 2 o f 6 5 + 4 q 4 z u 7 / c c D F v U s r m P b q  
+ W E N o w X J K G v u 3 a s n y S f N o T N X e 4 G 0 4 W c 9 x H G p z E s q k j Y G S 3 6 3 + z c i G m Q j X y N A y 2 r J J s 2 h P t x L t P l / b  
+ c p W l a V p W l a V p W l Y C B 4 l a V p W l a V p W l a V p W l a V p W l a V p W l Z c R 4 A i V p W l a V p W l a V p W A D / w A P g U A A A E A  
+ / / 8 A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I 0 k S V J k n S h K U q  
+ S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F R V J U 1 U V V V l X V  
+ h W V a V t X F d V 5 X 1 g W F Y l j W R X g B P 5 Y D + A F L 1 r E A P x C D 8 Q F y X N d B A E E P h B X J d x C D 5 c A / X l f x B D 9 b 1 x X d  
+ e V y X 9 e m D E F g m I X B d V u Y 9 d G E Z B l W O X 1 c W Q Y R l G W Z 1 i G M X 1 o V + a N g 2 S Z x n W b X x k m o a Z q 2 R X F p 2 B Z l g  
+ m J Z 9 j W a a t j V / b J c 2 b Y x m W O c B p 1 2 X h e 1 4 Z 5 e n H Y p t W G c t h 3 E X x z 3 Q X g P x D D 1 o H S c 4 Q Q 9 E N w H E Y J q m  
+ F c p y G T a Z e W 3 c N d W B E B x X U b l p X j X Z i 2 6 a p o X Y d 9 c 3 N c t 0 X y b J t V v c d x m u c F l W G b x l W 8 e l b m g a 5 6 W U  
+ g 9 j 4 Q b C E X Y b d 5 X e e R u G Z Y m F m v g R g Y B d 6 C o a g h 5 o d f p t m Y d V 1 4 l h u A 2 9 E I Q H c h N x Y Y h l r I Y i t 2 X 4 c  
+ l 5 3 x i h d H G d m K H 6 k C M F / c e A G r i N n p M g g Q w + b V + Q + E B 4 W 0 j 5 v 4 A Y e Q H 0 j + K n P k V 4 5 O h 5 j l u g u Q Z J b 9  
+ r 5 M g m a p K f C A 4 J a R v Y M j Z k Y 1 Z Z w 4 j Z x q W l f O L p f b S E a D c K h H q i 9 r 5 G h K Q W w g x 7 n A X d d o n f F m n 3 h 2 B  
+ J n o K f q Y m O R 3 l Z i n 4 N o h u G i k i O 2 x d F t H W j u N 6 Y o e h Y T h N 7 K s i O Q q V X u m 6 R b + V 4 F o 1 / Z Y d + v G d o q o q  
+ x r a a K s q 1 y X 8 e S b 7 N n W T W t q C F 4 f t J 5 5 2 n e S 6 p q V y J s e F n m 6 c 9 1 Z R Y C q b Y j 2 M J 4 n m j p z q h s 3 K o K l J G  
+ j e w p T f y u G + f 1 9 Z Y v N k L 1 v 6 8 I h m e 9 s B k O v o k s t i 2 2 p C l I g X C 8 Z g e O 9 a 8 s e / 3 Q w p h r h t 2 a p T e D D L 3 f  
+ a x 3 T Y K P r f c G i 5 9 s p k 4 V a K e M p s 2 c Z z Z d o 6 l s 6 W q a w t r M 1 y a R 6 a l L H c d v 3 A L i Y / E M i f n G H t p b L Z Z s m  
+ 8 c 0 v u P a 2 l z S s Z x K f 3 M 0 x z Y C j N 6 5 w v D C r o q + y 9 V l 6 2 3 S k R 7 b M 2 K 6 J 6 t e J Z m v l 6 d H y + R 6 L m v T a 4 t m m  
+ 7 R i 6 N o O z G O Z L t C t 5 w 3 y Z M r v q s L 0 o 3 Q t 1 v j R H i l W 7 7 J Z b V N O f Z 5 J G g K A Z e m C M 5 o X 6 1 5 y w e j J a s i r b  
+ O h n N s c x Z d b / 1 v m b B 7 K 6 M T 5 6 J H D p G q 8 V v L E n c t O r s 5 n f H M r u H R o i q O 2 f A 8 X i 5 6 o O 3 G f f K n o K n z M u r  
+ i / r q v l f E H I v P m 5 f g W l O z 6 P 5 O h + L p t n 1 P 4 u X 5 t w v l w D o p F o B h 6 d W 6 q + q Z T x v g 1 b b 4 g y X S n 4 k T B 9 H 3  
+ u n m R r P r / n 0 P b I 4 3 2 r / 4 u a d N 6 4 D A q e i X y 4 L e h r d + o e 6 q f 2 / u P Y 0 r l s F 0 D Y t C o z A 3 4 l z p d I w P 3 X z + d  
+ + 9 q i H W d n 2 S / J + X F k v 8 / X M 4 q y a k Y x 2 G 4 N Y 5 X 2 c U w X 1 c B w / Y P K 5 X 4 4 L e i 2 s h 4 2 2 M O 8 j h t j 2 O + c X v n F  
+ 5 5 a 2 5 4 3 8 6 N L a 3 6 C 3 0 r P Q H 6 m / 2 c j v 5 8 9 K j y w o 6 o o Q R C d f G t s 0 i H O 0 9 3 B d k l v B e W h v l c j j y f W E 0 L Q P  
+ D x n l O v 5 6 Q t W 6 K + s h 0 r U p U o h h I G 0 X p f 8 m T 1 e C q C f Y H q + U u Q 9 L i M I j i B 3 q 8 S a 2 t h v x M z 4 e C P E p 6 d F 2  
+ r P + X w 5 W A J Q f 6 4 h B E K L L D + e T N H 2 S W 4 h h z S s j + G 5 p 0 u D a t J l v V 8 / f j Q t s t T K r D l R k v e j X D t a 2 H Q 8 X 6  
+ f Q 7 d w / S e Y u V x X s 2 t z o 4 y e h P V p v z u C u e H I 1 g f w q h y H z X 1 t K F P S 4 i r 9 3 + G r L 9 7 z l Y 9 / l 8 O V 5 Z 3 H s 2 v  
+ 5 r m 6 r A 7 I 5 D q M q y r K l 0 N A s M q y r K s q y q G S w N D K s q j c A P / A f g U A A A E A / v 8 A D / A B A k D Q R B U G Q d C E J Q p C  
+ 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E  
+ 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R Z V m  
+ V 4 A U B W E / w B T I / x B E B c R B D 5 c F z X B c V 4 X E P x C D 9 e V 5 E F f Q / Y B f B A Y A P h D X 1 e h C D 5 i 2 E X 5 e l 1 Y l e 2 M Z  
+ J i x B Y A Q G C Y V l F + X s P 2 C Z h e G T Y R o F 0 Y B o G S Z d p m f X x n m i a R j W J Y p g W X b J r m i b V m W x a 9 t m O X l r l 2 b x  
+ t 2 g E B d G P b x c m r Z l d Q 9 E Q P V w b d x 2 / Y 5 d m e c B x m 6 Z l k 2 D Z x 0 n J Y B u X H d t o X R a d d 3 S a h y G z d 5 h W 0 X N r  
+ W q Z Z j 3 B d J w W a e 9 2 l 3 X Y Q Q 9 Y h f n 2 b 5 1 W t b 5 3 n X Y 5 m m b f J x 3 v X R g h C c 9 e H 7 d h u m C Y y E 2 j a x s n s Y p n H  
+ p Y 9 r n W e G H 2 w Z W G Y U i G E m x h h 0 Y Y h 9 4 Y o h p s 3 p b e D H n f N 2 G n Y 2 E 3 / Z 9 q o + f 9 p o W X W H Y / Z u Q 4 2 Z 6 N X J  
+ g p 5 p G b y E o + X t + X T d 1 0 2 9 Y G B I b k 2 Q I 2 g t q 4 I l u E Z C X + Q Z I i p + p X d G T p U g O P X v l h f X B f R 8 4 9 i N x W D i  
+ a T p q n N 3 1 y a y O J j k Z + 5 w i G Y m 1 Z p 6 V z Y V m H 3 l i H Y q l l n W k i 9 8 H t i O j n x h a b Y n Y 1 2 n y g y O m 5 a h o 4 T n x  
+ 9 Y 7 n 2 S q G X + d Z + o W f Z A p W G 4 8 a W X Y J q W u K 2 f S c 3 l c a a p c m R l 3 9 n e t 6 i f q q K w r O E Z 1 q a y X o Z G H H x n B n  
+ Y i Z B o a S b 1 m W 4 s W g o N p F i r a g i q 5 r r t l H b k u J W Q f W r Z y p q z I 7 f a m Y E i x l o 5 h m v 4 U s q M r S b + o l 8 q C Z Z  
+ r a + V Z h s u 4 q p v C g W v s S R o 0 j t 1 o H b u v 8 T i S l 7 5 v q L r 2 w O 3 7 O k A Q H U s j B b Y o a z c G e e 5 a f s i 3 Z H d m X 5 M  
+ a l y 1 w h e 3 3 W E O E J e d C m 6 r k l / a E l n I r B c u C b p d e 0 q I x G M b R n 5 6 o c b C j 7 u e N l a P m 6 e Z W n b K n k y d 2 H D 0  
+ j G H s i 2 M r z m 2 q r j 1 6 y p v m C Q c f s S c 8 l s B h Q 9 E K 1 3 t g h q I C n G u b k u a 9 Z C u 1 5 6 k f B 4 N b Y S p t t c a q m G 3 L  
+ V H r n K d Y t q q I M 6 n y G M l a f H 5 / p u + N C 2 i k L M 1 W b N P l m H s U j h 7 p V h v E G y h L H + n q 6 t s j z j Z a w 5 G 6 X i x V 6  
+ 8 X 7 C e 7 w j 3 q X f f f r Z L 4 O d 6 8 E L D O o t X V r 4 2 7 B t O Z G j c H g L w X 0 m r U f K 8 b W 1 w g / l 6 C z 2 U G b 5 f t K n 9 z X v  
+ M 7 l u J v e i J K N 7 D 6 p u 1 O V t g + J 6 7 0 3 u 9 8 R Y y U 6 x y p k 8 2 o f r 8 F k n C s d w K s 9 F y a F J N u X O Y a r v m K t u P d 5 N  
+ w C a P A g e e L F w W i r 1 7 W N 5 o j O m a H s e w u K l r K s C 7 m T Z J q j X I V s f r 4 3 Y v 5 N f 9 i e N f / 7 1 / w t Z t o i 5 q + / p x  
+ v i 9 c l W H r W 0 m l 6 j v W M X A 4 5 u 6 r f v c c y o e e M 4 1 z b K t a L / u 4 7 t q v k s v M a 4 g p 7 N A g D + e H q i A P 5 d 3 R + 1 e y  
+ z Z N 4 2 t d l 0 W + v U 8 a 9 3 g Y u 4 v V y D a 7 v 6 / d p C 9 Z w 2 1 + b r u b i X g G 9 k R 5 K R i D y f X / B p d i 1 W Y O Y b S l r 7 v b 1  
+ Z t 3 b 7 5 F 7 k P / + 0 H 7 H C z T y X I / V u + 2 v e / p E o x s d 3 2 / 5 8 O 6 + T e a 2 / X I x s 3 h r y 4 e g F 3 5 p s 7 l 1 q R 9 o 6 + d H  
+ F Y j f n m 5 r 7 s m d m 9 4 2 j n e Z 7 b T y P p y P m m 6 c q B e d i D z 4 v o d u 2 6 m N 5 O 3 k / 9 s H 2 + y a M d z X b B 2 7 m v q 4 f U t d  
+ i P e / H 6 i / + H w / y X e j X Z N m 7 H S 9 p s e N p N l C i r Q j f f M p l 3 l q H v 9 j M 9 7 b p 7 t p O 1 r u X L P c C + f G O + 2 j r 4 r p  
+ H 4 u j p G h d z + i M e + 7 j 1 a T e Z o e F y r r v g g d k Y A / e G o A i a h f p o q k X 8 4 p w K t 2 V o / 6 x j Y F / 3 G N c y d x u 9 m 2 b  
+ Z l x A g e N m 2 b Z t m 2 a y h 4 A j Z t m v o A P / A E w F A A A B A A A A A B A E B Q J A 0 E Q V B k H Q h C U K Q t D E N Q 5 D 0 Q R F E k T R  
+ R F U W R d G E Z R p G 0 c R 1 H k f S B I U i S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M 0 0 T V N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F  
+ Q l D U R R V G U d S F J U p S 1 M U 1 T l P V B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F h W J Y 1 k W V Z k o E A Q B B D 8 P x C D 4 Q  
+ V q D 5 b l w W l b Q / X U Q V r W l a R B W 9 e 1 / X U Q l 3 X x d 1 3 Y J g F / X 1 b l z X F d G A X o Q A / X B a 1 t X J b 2 U Z N f m I Z h i F  
+ x X N n G K X 5 e m S X t f V 0 Z R i 1 s Y J p G P Z d l m M Y 1 m 2 i W x j m R Y d s W B X d p m 2 Y N n W S X B c g / D 4 Q 2 q E B m m t Z l d F 2  
+ Z 1 f H H Y R r F / Z V t 3 L b t a l s W p a 3 V b x u H M Z F e W 6 X 4 P x D D 1 y X a Y l x 2 c X t 1 H O b 5 3 3 d e J 5 H q e 5 v G k a h v X b a  
+ V m n L d 1 i G / Z d k m F d 9 9 X B Z V c F 2 f t z V 5 c 5 o W n e x s X a a Z i m 9 d B m G o e x 9 m s e l z W r Y x 5 n 5 a t k 2 F b C C W N a O  
+ C o n Y R t m a e m G o P f p 4 x A d O H G S e E Q n G b V 7 X Z W 9 1 A 9 c R / W 3 d F g m m g i Q Y B Z B e H W X i F W D f t y 5 O k B / X z f y U  
+ 5 R k e U 4 e a 2 I 2 5 Z 6 D n q j N 7 5 A f W E 4 K l B g I I d J / 4 q l B 5 m h Z 8 P Y 2 f a V H M f t f Y x a p w 5 v j u Z X 8 b 9 9 3 d d W E Z  
+ 3 g 1 j p Y f y F o 4 l y g 4 Q b R m 5 G g 6 R H I d u a J f k V v p 7 g e M o T n u W 4 / c G X m W g K m 5 8 Y t r 5 + p W m J M a m c o F l a R K Y  
+ m l 9 J h p l + G B p 6 X q p n 6 d K M p K q n 4 m e o n t k l 3 m Q n 2 v o g h J n W g r t s p 2 q O N H K l K l q 4 m Z h 3 a d J q q a i J r q k f  
+ O d a U n J n r L Y l t I M h C n n Q e d h 4 F s y q q / t O 1 5 U q 6 l 7 q i G V b Y v a B 4 o n G T n z p C k K F r y g r C u 6 8 r T p x u a s o x  
+ o 7 q w y t p B t u d 2 f k a p r U t i / q k v O p r F k + 9 7 g p V t o 3 s R m Z a Y 1 l X j o j H q N c Y Q 8 O w e J q 0 n 2 D I f q V 3 r j u h z  
+ I R l 2 G 4 r u T A o J z m h M 6 i V o t E e W K 9 F p C 8 Z Q x y 1 m r y f H 1 q m + w p X l 2 Q 5 k q C y L G x S k 4 E t + k p k i L G q y t q M 2  
+ 7 f B t Z N v r L Y / x S O b 3 x f b 8 M b 2 h 3 W m i M d Y c a 3 N 1 c n S o A a x 8 L 0 d x + c j b O F N F b K O N A i T i J / g u 5 8 j 2 T W K C  
+ o G w 8 8 n 1 c o 6 i C q L O f S 0 e D p V m O b p + Z Z 0 g T K H y l Z 5 r u t L S a / w 6 3 m v r a 8 K 1 r P n 9 m 4 F w O n h 4 Q Y 9 q W H u z w  
+ e S r P 4 y L a 3 2 y W K A c f S W P r u b N H 7 q 4 n n 4 n p v M r 7 Y I Z 7 H f P M u i L K g u H N W l w q 5 P U z a i P I 1 J k O 8 j 6 s Y 3 8 B  
+ / u e 6 W O K o 6 2 7 d L m G I c b 6 S / d e s a 5 + k / a f t N r n 8 G p w D q L Z s P Y e s a n H L w m L w Z q + 3 n v G l v p W p 4 Z m b N r T M  
+ s y w + 1 Z 6 2 2 6 Y O m 3 C t C o b 3 p t 4 6 o X / 9 x r q E s v y W p u u k c y z / 5 K d r 2 T c Y r n 9 v i l e P a 4 k O w J 0 j 2 u b A k P / P  
+ L m D W 5 S t 5 9 3 V 8 u c 1 w E J 8 e V / f W b 2 l u T d P r d a 3 D 1 u m f L 4 v 0 v G 6 B r q E + P + P a c + K H P y S E v Y o P n 6 R o 1 / m p  
+ 4 b 2 v J b X y Y z z e y c C h L N 9 s m r j 5 W 2 6 p 7 A v L D t c 5 7 b v G m L x q 0 k i J p W w / n s w 4 T S 9 g x X T P P 4 v n L 8 1 n w d Q k  
+ 3 9 n 3 v m B o D g J t f q 2 H K a J 4 z x p m y e Q 8 S y / O N d o 7 D a E t r p 4 p 9 x 6 P R b v u + x i D 4 c B u v f a 0 y m a s R t m t N s d H  
+ n p I n G t J b x z t M t t f c J D p v o p I X p o Z 2 s X d L F 6 x p 2 D t 7 b b F r T M G p v m J p W o 3 h t o 0 u U s A x / B e K o B h b N 4 L O  
+ P k 4 L i / h v n 2 4 c q W 6 / h z f g 8 v 8 7 p 8 / 8 / O 6 h 0 K 5 o G p t v 9 5 f q m / x r f A P n + v x t K + 2 Q m v j 1 g 2 7 k O m 7 F w D K c  
+ p y n K c p y n K c p y n K c p y k Q A A / 8 A X w g A A A E A A g A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F  
+ 0 Y R l G k b R x H U e R 9 I E h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F  
+ F U Z R 1 I U l S l L U x T V O U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 L w t C o R B B E M R R B  
+ D 0 P w 7 D k Q B B D M P R K D t e x I D 0 N x A E g R w 7 D Q N Q 6 E I R x F E Q Q B D E I Q F 4 E A P m Q Z E P 2 R E F l h A Z Z j 2 Q D 4 Q W a Z  
+ g Q g / Z h n W i Z 9 k W a a M P 2 c Z B l m j Z B m G f Z l p G x a A P 2 r X h m W g b t m G r b d s G o Z 5 m m X a 5 s m V a d v 2 j c h q R B b R  
+ e H C b c Q m 0 X N x G n b Z t X G Z Y Q W e a Z m W v a h x W v c s P m m b l 2 X W b F n n a c t r 3 K e 1 1 3 A a 5 u W c e F p 3 G a 0 Q H d Z R r  
+ X N a p z 3 A a F k 3 a a M Q n q a p 1 m i f J 6 G j Z N p 4 F Z 1 t B D c U Q A 9 Z 9 n l v Z 1 k I V d J 2 2 Z g 1 s Y W b B 6 3 D e 1 n 2 k b l n n  
+ 9 i J s 3 m a m L W k D 5 t 4 d E I Q x E g U Q R G E E Q l y D w P g 9 D p t w w D k T n b E c S B A D Q P B J E w R A 3 D A N w 9 E M R h F E O O n N  
+ i R z n n i N w 3 D g 5 k 5 d f k P W P b + N 2 1 b p l I J h Z 6 G 5 c V p G i Z R 2 m 5 n B k Y P b 6 c Z y i W B 3 b h B w X 7 i J 7 H l m y J n f c  
+ q D X x Z S K X u f x o G P l + i 5 y f x v m 1 e q J n 4 m C k J 6 f 5 1 6 T b F u J x l 9 9 p c n e n K Z m x q H 3 e u A 5 7 d i e 2 q m W f H f Z F  
+ 6 n 5 f u A q V E I P a 0 D + A o 0 j B o n k Z V w 5 i e Z s m T m O g 5 7 f m M n Z Z C b 6 y i + A 2 S Z y n Q / h V l g + E O V W m E W N I 1 r k P  
+ g 2 D w R g 6 D c R F 1 E c S Q 8 D k P 2 D D w N g 2 D h g h E j Y Q r 1 j K D J X p C X a d a S q W w o Z 2 5 X d 5 e G y e d 8 6 g c J 4 J / a B v c  
+ B f b A 8 E s m X I q p Z x J n f i 1 H H r W + X Z j f B I y h B s n 0 i x s n a s B l Z 1 d Z u 3 4 s e W G w s m q s F w l m n d w F + 8 l s 1 u p q  
+ Z m Y 3 / w V x r J m + J 3 r i m G X I z 1 v X V y B l K o i B u 6 U o r O M E q K C 5 w d i Y H y i K j X A X h d I 0 n C v 2 0 b p 7 2 o f t 0 a H f  
+ 6 K t J d O Z 2 b n F 9 W V b d 0 Q + e S 9 L Y X J c W / D k O H S u E R Y 9 E k R A 8 D o Q x J E Z h Q 0 D s Q h J E I R J V c 2 J 5 c 0 L A 6 V 2 P  
+ S o s 2 V 3 o m x L P N M h X T N Y 1 z Z n u w K D G s p 3 E w / E O A n m r H b X 9 r N q 2 n r P o M l o P Z a i d K l u Y x j W m / z R r p v g f T  
+ H + d 9 9 8 r p h x I P y u Z s T s H J p W i 6 n v H 2 n c Y v a m C W X f i c d i w x w r M q f m s M w G o P T o m r m S w + / X t E P 2 I u Z O 3 H  
+ J s m J p f 6 b R H I c q s v C 9 r c K K 2 b t 5 2 y r S a G 1 7 j m j 4 6 N R E D u M Q 7 4 Q O w v E A T Y 9 E g R m A E I T B J X k M g 1 E A R x G  
+ j V / X I q G s + V w 2 e p c c P N a O c i + a x + D o p n i C C p + x V t c T y r l n 9 v 2 f n / 6 n q M M 8 a D f 5 t H T H p m b P Z c Z f S a x e  
+ n B e g + J x 4 N / n 6 Z g t R y H 9 v 3 P 3 v 7 z t v G 2 N / d D w W c s 2 / 7 P u t p H A v r 7 p + M A 7 Z m I C Y 5 v a F f l m I x 1 Z + m z b 3  
+ W 2 1 f F / u T 7 2 w d W p i M Y W 6 p b 2 Y l S N B F t U Q A 4 D m 5 g 0 E E R G I E s Q g 4 u I R x C D c N Q 3 D s R W K Y 6 V u / s S E 3 i 8 V 2  
+ H v y T V M L 2 P S G q r H 2 c 3 0 P C 9 W c N 0 t y i e C 2 z e L s c v 3 L Y v C m l m 9 P x / K m z 6 T S 2 v g X a X k e x o Z w q r o P p b z x c  
+ i g O J f d o t 6 X I w L Q 3 5 o n a 5 y v 3 I m 2 8 P x P I q i p 9 U e L 6 a x 6 1 8 K o b m V Y x t d p v t r t 9 3 k l V 8 n R d a u c O n 6 0 q l  
+ p f G d l v 1 t b B m D N t y Z q Y r z d u O x B 4 4 Q w 8 E E O r x E M N g 6 E Y P Q 9 Y M P l 3 E k R W F D Y O h B E i V I 6 + 3 N + f y r V u t w  
+ 1 / N D q e X K C 8 d u / Z 2 C f s 6 8 S Z 6 V 1 D Q m S 6 L V v D n b w 5 c x h q / n 7 5 5 2 1 n O a K q y B v q R a H F f M + n k p w 6 7 P d W w V  
+ v 8 i 9 v Z e R 9 x 7 Y l s G c + Q / V 8 5 z 5 K m v c p 9 x / U + H w P 5 c N 3 K 7 h L k X Z 8 a J / r D 6 N v 6 3 T q o P 1 C e 3 S g p w 8 9 e 6 o  
+ 8 Q p W W N u z t t K O D x e L z X i N X N E Y P d 0 D w P B A D w L w + E 8 P L s E o P Q 0 D 4 T B K E I M Q z v E R J T h x 2 P i v 6 / Y g z D K u  
+ R 8 b 2 9 T x X w L B z e I p d 8 Z k s 0 n + 1 8 t 5 G o 9 Z 6 3 n K D d 7 Q s r z r H 5 t n 7 w 2 + p G p 2 t 8 b 0 P M a + l N i 0 l e P Z 7 2 c r 9  
+ 7 e g m 8 5 a l Y k / y c 7 O z Z v I H b + a 8 g / 7 N u k 5 a d G Y j G L I S b / M o 6 g 9 5 N i q 1 2 2 P 2 t s 2 9 9 m o X Q 0 d z G 2 f q X f 5 Z  
+ K u 4 W a v j m x t y O x C D w Q d 7 E A R A 1 D k S Q 9 D 0 S x G D 0 N h B E g R Q 6 D Y N 1 3 E c R o 2 j p p q O + F 8 K H o u / c F / n 6 X i x j  
+ 4 t A y B t Z d i n Q 3 7 f q q n 5 j H w o L g e d 6 i n J t K O y q l 4 n 5 H K p c x / D e k x D H + o + j J r E q r A M V 2 7 q M k a / M + t e 9 0  
+ q O 2 9 9 O 9 6 i e m g d C o W q z y q n Q 5 X V v 5 i 5 9 v n 1 O e 6 U l e x n y t h 9 K C e 6 D P A 7 d t o A h O I t W q P m v 5 q K e G q D w Q b  
+ c c 2 O 3 S j Y P F z D X j W H 3 8 P h I X 8 O W J E U O g 0 D b h G K t m t M L n O I G v p T r a R r q s c 3 a 3 x m 2 n i + Y U Y 9 t Z z 7 i c 2 1  
+ 8 n l a W 0 e 9 / E f z M 6 m 1 x v f L f S f 9 n v 3 A X l a p s 6 x b y k c B 9 x z J + r J y H 9 m r N 8 X Z v F f c a 3 w / d w z Z 9 L p K X P M a  
+ q o 4 Q 8 O f b K p 6 X a S a 3 J J c b u B H D j G A K N 2 5 0 L 1 Z i x r L a O u d s 9 u O t j z / Y 8 F i L G I E 3 K W Y Q a q u 6 / f l c m a v P  
+ j o F D 0 P V 9 E I O A x E U S e E E j f w 2 E M T V / D E M g 7 v K 9 G N 3 T H O W q H r 7 B / P B Y T m b D e 4 b O x q E w z y f h w 2 s d D s 2 X  
+ G 2 c T 2 8 f a 2 + H 5 d C z Y x 5 D l K H z e B P 1 s R z I s m m L s U n P A t D s q z P q + l w 8 1 v e o d j m v c N x y r T H Q 7 f A a x s z D x  
+ V C u f p + n 6 f p + n 6 f p + n 5 l B 4 A i f p + n 6 f p + n 6 f p + n 6 f p + n 6 f p + n 6 f p + n 6 f m U A g e J + n 6 f p + n 6 f p + n 6 f m U  
+ A D / w e g g A A A E A A w A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I  
+ 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F  
+ R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 L w o C c S R J E 8 S B D E E O x B E A N w u D U R h B X o R w 2  
+ C o K w 0 E M S B E E E P g 8 D 4 S h Q E U Q h D E M Q B A E E P x A D 9 d m S Z F k A / E I P 2 a Z N l g + Z d k G Y Z V o G V Z F p m T Z R l m V Z  
+ N r G Y a d n m e a p o g + E A Q m S Z d s m U Z t o m U Z h d m i a 5 t m t Z t u n A a 5 d m b c B v X A c d m X D a g P m 8 b N v m q a Z q m g b 4  
+ Q V 2 a R v 2 Z Y Z u G n d x 2 m a b N 2 W i d x u W W Z J q X X e F 7 X L c d r G W d V v X i a 1 k n K a l z x C d Z 6 n o b 5 s X 9 f V s n O b p 4  
+ m 1 Z F q 2 1 f t / X c D 8 P m g d u E 3 O Z G A w + D 1 l 2 4 E E Q g + f B u 2 Z a h 2 3 k f 6 G m c e J p 3 B h t r Y R b U P Q / E M R G N b Y R x  
+ H E w S R E E k P V 1 D A L A z E A T W 2 E 4 P Q s C c L A + E k S h C D 0 O Q 6 E Q U B L E F j G v f u G 3 V f N y 5 V d e A X K c F 1 I I l l 2 2 c  
+ h W C n 4 l V k Y S b V q 5 f a N 8 o j i l 8 2 m f m C W Y d O A J l i R 7 2 u Z V o W U l t z 3 k f R + 2 i c W a H x a x r H 6 e N z G 0 e l 6 W k f  
+ m c X 2 a N v Z 8 Z O H a J h J z 2 o d N 7 H h o u f 4 a g m i h A m p 6 G e e e l 5 X c t m G l n W f p 0 m 9 m Y R h y C m r h 2 H H S h C p W Q h t  
+ l 5 q i Z w Z 2 a G B X z a W r I q e 5 k 4 Y s s O x D X s Q V z k k S x L E U R Q 9 q U N w v D O H A y E M U A 9 C s J Q x E E S B F Y Y P B A j a O  
+ B B j J 9 W 9 b x y J U c W f G z m O v X I i d z a o i h n X C r 1 3 2 6 p a f n 0 l 5 3 m y m O r G G w C b X G w B o X N i G a 1 2 g l q X A q 5 k x  
+ D n T B I A a 3 D 5 b q a K c B f m 9 r 1 Z 2 p X H g O i M R a h 1 H O d K p 8 U b h 5 Z 7 f F 1 o H n 0 P h D x Z 3 a H e h 5 5 g e 6 A X h f d / G x  
+ b B v 8 1 c x + 5 b s H B m q z O Y 4 S i O t X W c G g 9 Q e C q 8 x m r N J w a + n m Q z D M 6 B a O H o Z h 4 P B D u d c x E E o S h O E c R B A D  
+ x h g 2 D A N h G D s M x L E g N g o C k N o 5 Y U O w 8 E I S x N E Z j R C f q k 5 i o B y Z m v X V s x m i K n 3 o N 8 Y e w W 9 m v y K f n K b m  
+ K K P d 9 y Y M b Z 2 X v w z K s P d B 1 6 W b m I p X n z M L 6 1 j W p y p V 3 9 L f O p 2 b 0 C u K Q v i B s R w R 7 G b h 3 I + Y 8 e I 2 g D 1 t  
+ 6 a h / u Y B 0 m o H e 9 R w 9 R c e I 9 M 2 D H I g q W h c H v h 7 u p 2 O H p V i u 2 G q g 5 6 9 H Z v 6 8 u e y X v c 0 j L O v v u v b H n B 6 X  
+ M g w P 9 o D 0 P h G Y 9 j R E E g S R O E U R B F 4 U P Q v D E N B G E k O x G E 0 N w p C c M x D E k S B B D k N w + E t c R D b d q 8 K x 7 L P H  
+ x Z 4 L 3 l R / n W f 3 F m 7 x 5 2 q T x b A J j Z q E v d 0 n u 2 8 g b 3 o f 0 m K X A b y f Y K d m Y 8 t 5 S + N P i b F s P x W g r E 8 V + M d 2  
+ H q u l b K u p y p e d M m 6 L E 8 e y y k 8 i i K J u 9 e l 2 b F a H U + U Z 6 Y m t g L A e b b Z v 8 K i G s b 7 a V v J 9 y 7 Y q O 0 d 2 r 4 s l  
+ z W l D 1 t Y t E U Q 2 N D 8 R t 9 E 6 5 p + D c M g x D o R g 3 D p c Q w C U K w 8 E U S I d D 6 z h N E x e + L x X j / 9 l j L d E l 6 W K A 4 6 Z  
+ u e z d z f z Z m A 8 B b u l q S h O d P T 5 C v X g c a y N g 6 + p 9 I 7 K J 8 W p S 9 8 A e 1 6 J Z g W m + e 0 W j L v i n y W z 6 q w r G o d 4 9  
+ N x Z 2 c n z K W K A i J 2 4 Z p d s e i y T S q n n + p 5 / p N s n 9 r u D d I h 6 F n L f 1 n F z a Y P a x l a G X 2 9 r U G 0 5 7 / K h i d 0 H b  
+ 2 e p Q 9 D 0 R I y X M Q R M E h c Y y D u H Q 4 C 8 N B E D 8 M x G E o O A s C h g t y Z Q P A / 4 g R 4 c E b m e p 5 f Q t P n 3 8 2 8 d t o J p v  
+ v L e e q j 7 m S r r D N P m J 4 M O 5 T n u 9 n z Y Z 8 9 u G v D 2 J 2 4 S d 3 R 6 e 1 3 j 8 I 7 m x + w a Z 2 c n x C o 9 P Z l / b / e V 2 K s 8 H  
+ U M 8 / N q 5 9 b O Z G + b d n M 8 6 z v c z / O + 8 y 6 X N a X c L T X t d D 9 e T Z S C c s h 3 p 2 3 e u m G 2 a f 6 H O b f t q e z L 9 s z / P L  
+ H U 0 3 G 7 o Y Y P Q 9 E W M l z t Y S B O E U R B H D p t Q u C 4 N B E E w P B G E w O g r C Y M B B E k S B B D w O Q 8 E g T x J 4 y H N E 5 Z p 5  
+ d y i 8 K 8 n 2 F d a g p o P 7 p P u 7 J a e n e 2 m L s Y O 1 b s K G d q p + 7 i l 2 2 l 6 G y a y p u G m 2 i / U G w p L y 9 N e B 5 6 P 7 3 q o g  
+ 7 2 Y 3 l w F n n j n 3 l b 3 z G Y + 5 y v A L 8 c P n 2 z 2 S 9 p v v e p 2 w p + i M M j D C 4 e w z F / z Z r G n N b z L 2 z h p 9 a g d x / d M z  
+ b H o r i n 0 X 9 Z y L R A D 0 P h E Y V j 9 u E c T R J E b O w + 3 s M A 0 Y U N h K E w O g o C Z g h H E Y Q A 9 D 0 P R J E 4 S Y c E N / X 4 e h  
+ / 9 C s n 2 2 c r j D J m d P J 2 x 9 t + K s e 2 A 9 P Z q x H g m / t X l p P v e e e 6 y K f y 3 S 5 X p T 1 L 7 y u + N I 9 7 S o p p 7 s L / m W H  
+ 3 v 2 G d 9 A p T Y a L 7 v N K e n K e / e f h m e s 7 v n 8 u d j R N B a v 8 4 K 1 d 1 c q w u H m P 8 i y N k r v Y O i 7 u l M u 8 J n t k i J n e  
+ 4 m i 2 I e D s Q l 7 2 1 b x N E m 5 / P D 4 N w x D I R A + D M R h L D o L Q n D M Q t y E A P Y Z E k T R J b d c 8 4 5 R q 5 9 c 1 2 X Z 1 7 l 5 U  
+ 7 2 f c 8 9 u Z + 0 o z 9 M w p N s 6 s z y a / y n / 1 4 q / 1 v q a n 6 K X n n r J 5 u s q K q L s T 4 9 C y 2 j L 5 1 6 x I D z e V q b z b 3 2 d n  
+ 1 m X 9 0 z R N R e L F 6 O Z y F + e a / I e q Z 7 Z O 7 q q S 5 X g r S I Q b h t 7 1 e t 2 Y Q 7 m l 4 Q 8 X Q K n 7 u c n t 6 2 J 3 i 1 F p 4 v Z y  
+ 6 e K t E Q B F E n i B C E Y Q w 4 E E P A t C 8 O R J E U O e J D Q K A q 4 I S h H j s O g + E s T x H 4 y 0 Q / 8 / S f 2 8 P L e e y v A K I b a J  
+ G z x C C Y m l l 5 e k d r q m e Z f y X M 1 r C 4 r i n C / Q o p p n 9 o h / c C p 7 F q 8 8 f C Z m 1 D Q 2 z c W f c 0 e D C 5 v b F 1 6 F 0 1 4 N  
+ M m K x L 7 q D N n 4 x 1 s 5 9 p P J 7 E z Z 7 Z 4 C s V a T p O k 6 T p O k 6 T p M e A I p O k 6 T p O k 6 T p O k 6 T p O k 6 T p O k 6 T p N k A I  
+ H i k 6 T p O k 6 T p O k 6 T A D / w A e w g A A A E A + v 8 A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l  
+ G k b R x H U e R 9 I E h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R  
+ 1 I U l S l L U x T V O U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 L w O B Q P R I F I Q g / E Q Q R  
+ I E Q M w 5 E 8 S w / E g T R I C s F A i D J c x D E Y R Q + D 8 S R K E U Q R D E I Q B B D 9 k A + E E Q R A D 9 l h A Z p l 2 Z Z B m m S Z 9 l W Y  
+ Z J o G d Z B o A + X J l W X a B m m V Z Q Q W I Z 1 l m j Z x t G 0 Z t u W b Z Y P m n X J c m a b B m G n Z t w 2 z c N k B B a p o 2 W a J x G X b  
+ p k W 9 a F o 2 1 Z E P 1 y a 1 n G 7 d B k m W a p v X e Z 5 t X e D 8 Q 3 C a B x n M D 9 x m x b x r 3 K a R k W f E B w H Z b V j 3 k Z l k W Z D 9  
+ q X Y f R 4 m Y b d 0 G h f x p G e a d 8 3 Q a J t H l c 1 w 3 T f V 8 4 I c N j x A Y i E h D d 9 m 3 h E J 8 X s f K A 3 X a 5 7 H N a x s 4 F e 5 y  
+ G u h h x H L g x 8 2 x a x p H m b w P g 5 D w R h T E Q Q B K c o R g 2 D c S B I E M S x O E U K A b C g M A 6 Y U R B E D 4 P R F E w R x C E M Q 3  
+ J Z S J o J d e B I H b m X o U a a F H j a a K m 6 h i K W c e l y Z q h S H 5 b i x / V y f 9 r 3 A m F w 4 A b C H H Y e J r m 8 m l x X l o R r 5 p  
+ i R k h C Z S J Z + i 2 B X R o V / H b d p n a L i W B 3 I b d 6 Y n c F 9 X s Y 9 w m X f l 6 p z a W X J + b h 2 3 P j O E G 4 g 9 z 3 F h C s Y L i  
+ t m o f j V n 2 q o g P X K a t y W x e 2 N I P a u I Z 3 d q q n 9 i 6 t 4 l q q A 6 W n 9 t H h i E Q n 5 E E O Q 6 E U U R J D 4 R R E E c R Q 0 D E  
+ R h O c o S x Q E M G A Q C o P x G E E R L t E E R R I E d j m O g x r Y Q c y l 3 l q K x 6 l c W j p l d x 6 6 H p S n 4 F e K Y 6 q o q m I X b l 5  
+ c O r l t o T d H A 5 6 a J 7 M A w 9 w b E a e x 6 K m y Z 2 Z p a s L O s S C 4 A w C e r V w T K Y o b u M 4 s g q I s n y + A 6 P a l u 6 b i R + Y  
+ M i 1 p Z b n i B m l i 6 K W t a N y 4 D f 6 F 6 u c m p n 0 c e k J 6 q J n 2 o Z V q 2 V o p r X 3 b F 2 X 1 y V 1 q u b e t L H m z I K y i S k s e  
+ Z h i I m E N 2 A 8 D o P R K u c Q B D E Q S R C D E N x O E o P B F E 0 T g z B I G Q z v W 9 G Q E g S R F t S 1 G T n m s t m g H a n j g K D d F d  
+ 6 B 8 k o a M t P f U P d f z 7 G a e 5 X Z 6 X 1 V 3 3 X o m J t q z f W H q r 3 S 2 S n Z n H T q z R 6 W q n H K C n P G n R y R u t c g m / O n p 2  
+ n L K e v W n Z f O F 4 m p 9 j 2 R 6 D T q p 1 O v o m f + c Y L h h v + o e z b + V Z G e I O j L V J c Z v X s h Z 7 Q f m l 7 5 + z f R + W P 6 B t  
+ Z R r + k 2 r D x y g + z n o e j a m B 6 K b 1 y m 2 / u W W 9 b T 4 o I 1 + i 5 / x v G R B D 1 5 h C D 1 i A 6 D 8 T B Q 4 l j R C D Q P x K E Q Q x  
+ I E s Q w m B w K Q y D 6 7 1 0 D w Q B J E 0 R J Y 0 7 P 2 d x e k q n y f G W d n 7 B t f q Z 5 o h z q C a P z B 0 4 A b X U M z m G j t l f 2 k o D  
+ y z V + Q a W K / E Z d q b P b j A s l f x / I z a G + 6 o c b 0 s 1 7 W e N n + v 4 Y S z p 9 W y m G b K q s z C d l s x o a x c T S v a q y + 9 Q b  
+ e i + Z 4 + l O q i i H 3 c o G H 2 s 8 B + + 2 o v K H H y i X Z t 6 T H o y w p i I 0 4 4 Q A 7 D o P h P F B 2 L 0 E c O w v D 4 T 5 Z E k U B M C Y  
+ D A i k 6 W O M 3 Y S R I Y x j r J m H K K A b V k 8 d 2 l x o o v p u t E c i C K c s + r X y / x 7 9 I c j O 8 D c L 0 P s c 3 l 4 t p r P J b s B u  
+ J l b 2 K e 2 v i m 7 / m G H Z m g q w H 7 4 / 5 c / x V t W T q 2 p q o 8 b P 8 X s z I N Q 5 3 F 6 2 6 B + 2 s q C C 8 9 w + Z 7 I e S X d H c R y m  
+ s m r r o Y s V 9 X 2 d 3 T I Y 8 5 + 2 v + x 2 s J g G X X V l 9 1 a O n 6 I R A 6 B j X B D g P B J F A R g + E Q Q + L D E N R N E y U x M E 4 N g U  
+ B o M N 2 E I R R F 4 k S O M E S H 6 P 1 S Y Z b p x 6 X g s S + P D 0 T D + d o 7 7 N T r n n q Z d X a m d x e s Y d h / O n 8 r r w / Q v x y G 1 a  
+ z O n d / z I L N z f N M 6 e 7 2 m 4 q x 9 Y S 9 q q f a s n F d s 9 Z n N a 0 b G / W w / 1 n C y d r W p s l o X F q P Q n 8 o v m X d 8 v T d 2 b L  
+ 2 s 3 a x 2 3 N d O G n e w 5 v Y f j S j H 1 y C j 4 t d P p o H i S b n d g m j H j f X b R B D x 5 s M D w P A 8 E k U e J E K U A 2 D q 8 5 G E w Q  
+ w k B 0 K g x 3 8 R Z Y Y g R x M E Z 9 R E z f G t j o T I M O y S p I E + q M s j y a B 5 g v u m u Z c j t o J m r s H v s i D G w w F 2 9 X w / r 9  
+ T m r P 3 h c 5 9 P 3 d r m b 3 x P Z d d y q J 8 X l z y 3 d w y t P b v r R b M c T K 4 r w m h G e 5 3 M p g 9 u J a K z m m b 3 6 v H n E f x z u j  
+ o D b H h d + o K + 8 x s P 7 d i D q 3 6 t 2 r Q p v A 6 q q p o X Q c D 7 8 Z 1 c Q Q 9 D h b x R E a 7 B E 4 w M Q 1 E w S V 8 F E T w y B A G w x E  
+ C U B D E V k J U 4 x y h E 1 b M N H g n w 3 u x 5 w H W + q J a j s m s M o y e b Y N p v m d s l 9 1 P F Z P Y 2 2 p l 3 7 Q z 9 7 8 X 6 P C G 4 b 1  
+ q m s 5 B 3 u 2 z e j 5 5 o K k I K y p + 7 3 d t n d H y f R 9 X e F p q N w r P 8 h f 1 y M 3 m y i / N c S / / p s n C b P r b a 4 G 4 + G G S l l 9  
+ o R c 2 F H + r 7 k X y 1 S i + w 0 d + 9 s o 7 K Z b o z 7 4 A Z Y O A 9 E Y U B H D 4 R B D E i 4 A z E s T H m E 4 T w 5 B Q G A v X N j R F l k R x  
+ J E a V / 6 x h q q T 9 O l J s r H H m 4 m e k 5 4 5 7 w 7 / l 6 A H a v q q H V m 7 G p k q a v m Z n j 3 8 M x V q M u 6 P M Y J d 3 w 8 g r G z H b  
+ 5 2 s Y K m r A 6 e g i v u i 1 J 3 5 t i z y 8 Z c 7 2 t m i T U m 0 w y g H + 6 f I 3 8 l 6 d a e z n 2 n b x h p Z g r F 3 n A 6 O M m V D 3 b G 2 w  
+ 5 + 9 I g h / 4 t j O W q x 6 d / q + s z U H E v j J e P i E P 2 H e z c R A E 8 T w 8 u 9 f N 6 D 8 T B F E M S h O D w I Q d C s N b s E R j u g E o  
+ S x E l f G O R x j I n 6 l q M 4 t p i A I z w x 0 s R v j B 8 q i f U + Z s 7 M q e 8 7 E Y k Z 6 k q J o v E Y Q h / K J m d T J N s a G K h B 6 B u  
+ J j d h v f W 2 K k t H f H L 2 2 m X q 8 Y o z l 9 H p z Z W 4 q y Y G S e e e c P c 7 H p d 7 t 6 h A C k V 6 C o K g q C o K g p p H g C K C o K g q  
+ C o K g q C o K g q C o K g q C o I C B 4 o K g q C o K g q C m k A P / A A 0 J A A A B A P b / P 8 / w A Q J A 0 E Q V A 0 B Q Z C U K Q t D E N Q 5 D  
+ 0 Q R F E k T R R F U W R d G E Z R p G 0 c R 1 H k f S B H k A S F J E l S Z J 0 o S l K k r S x L U u S 9 C k j T B M 0 0 T V N k 3 T h O U 6 T t L k  
+ I T x P 1 A U F Q l D U R R V D T 5 R l J U p S 1 M U 1 T k V T J T 1 S V N V F V V Z T F I V d W l b V x X V e R x W V f W J Y 1 k W V P F h W Z a V q  
+ W t b E q W h b V w X F c l z R p b 1 0 X d e F a P 8 A V 4 A F d k s O E 6 Q 0 D 0 R A 7 D 4 Q B B E Y Q A 7 E 0 a x l E 8 W R f E g B T 5 C M O Q / E  
+ E P h G E U P x A E c R x D E B o m I Y g Q R A Z h o m Y D 8 P x C Z l o 2 i a Y Q A + E J n R A b R n W Z b E Q Q / b N t 2 d Z 0 Q 2 5 b V q G n b E  
+ P m x Y h t W 7 c R s W / c t p G 7 a N u H I a d x X U a l r G 7 E F u 2 0 d t p G 2 b J 2 x D a p p x C e F z n V E E P W v c V 1 W j D 5 m H a d h 2  
+ X l f B 0 G v e g Q n H a d u H x a d 4 2 H f x t G 0 c l q 2 t d F 4 W j c 1 0 W 4 b B u 3 H a p 3 n o b C E W r Y h 5 m r b w Q G h Z i B G p c V r G  
+ o b 9 3 2 m c p h 3 b d F 8 G s a V x G r f J 2 3 w g i F 3 2 e s Q X m d 2 K W l e C F n V b W G I l h S J Y G k F / X 9 d 1 / I K c l r 3 6 d K I h C  
+ g c P g 9 D w P A 0 D c O x F D s O 2 g h c T R k F 8 T x e G g Q z 8 P 0 K Q 4 D 1 r B C E R p x E E g R Y b i h s o J a 2 A X W c V x 4 l Z m G I d g  
+ F n Y Y g V p m 5 a S E G y g e H 6 E a Z 5 p 9 g p m Q / a G A X N a l y I L k O Q 4 I b e k n m e B 5 n R n F q I M e x q I n Y e I W H n t r q O a K  
+ p J 5 f J s 2 8 E G H G 1 h R q p / a + Q K 2 k 1 9 4 9 i + F X t c i F p M b a f o x d J t m u p K v o W b p 7 6 8 e y S n 4 h R 4 H u s i z 3 a c N 8  
+ X T q B u A + a F s o a i i J Y c e l 3 3 H n h 0 4 Z j t p I T q 1 y 4 o i 2 B r t e 1 0 3 p f C A 5 p D 8 P A + D 4 N w 0 D o R J S b Q R h E D g Q B  
+ Z G g W h T F 4 Z A 4 O s / A w k + j h F c E Q R E E Z r R D p i t 5 J q i y 6 o i y 1 n 4 d 2 s o R k p z 5 6 c S 3 p x n d x m t i O K 3 k s 6 M r R  
+ b B / M q e 5 2 5 p a W L 7 x o 2 m s j a p y s 1 h m n Z M r K k a + i C 7 a / b O D K B e n R r 0 f J y Z 7 Z 1 v Y i g W R 3 o y / R X V a 2 T X N r  
+ W y X y g Z 9 r i k 5 5 G m u a H 2 6 i K D X l Z j a t v h F t H 7 d q M Y e r e 5 s 4 s / N 9 c a W p H h n H P t v 2 m n 7 A 2 l 3 J 1 z R p 3 7 x 9  
+ z 5 K s p + m 6 0 y G n l j C L m t D 2 m m Z D 4 O w 0 D Q P 2 F 0 x i g 3 E g a B l F E V x g F k F j q B Q O N e E Z w R C E P s p P j a L u N c l 1  
+ N V a a j + F j a k o u k u i I u 2 m C r w i e 8 u B 3 S 9 9 6 s q w 3 4 2 y Q K f 5 e 6 r L d a i e O a L g 9 w f e 6 O I z C q 7 q k y A f d 1 P f L  
+ w j X 0 p B d i y + U i 5 w I W f 6 B t o n h i K k 0 X w Z I d r I q Q 0 6 6 H p 7 i I 3 a 3 v c I G 5 v g I 7 b R 6 6 c e y M X x 2 N 7 f c / H N 9 J  
+ j L x 8 4 o F 9 m u d 5 t H r j 5 t 7 u 3 Z t t 3 v W K 6 N s P T m q v W 4 h B D w Q B E D 8 P c 4 n / e Y o p D N J 4 8 p 3 L q D o P Q 6 D Y N 6 w D  
+ f o e 4 E U W B j F g U R i G U N z 1 A I L Q 6 f A Q x D E M P R B E c S Z P h y D 3 e n n w + L i B 4 a a k i x o x s d 1 J C i + q s y r / Q N e 5 x  
+ r I A 3 y S X O h 2 s u Q c X P q d o n O H x h K 7 r I o K E H k y P N 4 V i K v + H n 7 8 6 B 2 5 7 t M e r 3 P 4 z L 7 f 4 t P Y b R c a n X f 3 C J  
+ c i t P T t X q r O I e s m I I E n m 3 8 4 p F v 6 c i B v 7 i t C w u 5 m n G o L h R + 6 f s L 8 4 6 r t 7 N N r b I 4 6 z / u P p 0 5 y w 9 D k M w  
+ 3 k 8 O p p E U P g 6 F E Z h f F A X R m E 8 / T q C a 3 G H w J i G b k / t 4 j x r y d O 8 K 6 r q p + d / c 0 K L L j t B 7 e L 0 C f m w o T i 9 1  
+ t i k L z g p 9 u b d K m q c d 6 k / Z u X b m p 3 X 3 n 2 d r Y 7 Q u r a + L f t 2 W / 8 a M u X 3 u M t N + y 7 K d 3 q A v G i B z H D d + t n b e  
+ u 3 7 d e 6 T q q s K I f U g 7 U b I g j 9 K g k L m 3 D c l 4 4 f 5 G q u 9 j a n W I D 1 2 4 e f a J L S m h x X j c O k 4 g n 5 / a C z H x c 4 3 b  
+ O m d D 3 n g 2 D 0 Q w 8 5 o P x H E I O h F G M a B T F U Y h X B o 7 Q T D d o x E E V 5 h E E e T + 0 4 y 2 P Y i D f J C j 9 s H w 0 y D v j z S s  
+ n z e L g O 7 r K x a B i P i 6 y h + m t v j 2 O m u z i k 4 X 9 z h q a z T 8 X f b x q 3 j j 2 I H S 0 5 t f 3 e 7 h s g 8 i e X z s b b o T u T 3 P  
+ 4 n 7 T 4 M h 6 H d A 8 Z 1 n O t b i G u h i r q B 1 f S Y L t O A X B n W n 4 f n L E K y p K C J 8 3 + 9 X e g + 1 b t 0 O w r G f y f o E b y f 9 M  
+ E O + n + r O + p P r i H 7 I c h + 3 K 3 a r J y y 1 u w 9 D 4 O g 2 D U P R D D c P h I 7 c R B S G U W R S G I Z A 2 P U B g t D o P H b m p o h G E  
+ e N 2 h d z 8 c v p K n b H n a s s z s 6 0 d Q s h y s w 1 P 6 + B c x / K m o G f X U 7 x 8 f U d p 3 t 7 d 6 m 7 y k d 8 6 F e W 3 q y / j G r Y b V  
+ s / c Z j m r K r a s m j n u A v X 0 L L X 9 r O J a a r u Q q T g m s 6 p r v f 4 g i u e b m a y E I e k T N a T q q t X L b 5 3 t d u 3 w 4 + b z 9  
+ W t b f T a J q O e J 5 / h 3 4 N a r 5 s y z P J Y x j D 1 6 3 g j O G 8 D s N Q 1 D y W G E E A R R B D k R h k G M U x Y G c W w R O g F Q 5 8 E R B  
+ E b Q R e 2 o 7 X p 9 b F t 6 d r J t o n 8 Z y q y 4 u + q G k j G X p g y 8 O P h C 4 t P e W H / 4 z q d e U d f a J H / h 3 q w 9 x s 2 j p i C a h  
+ k i C r l g z k o F 4 t i J o d C H r K a P k n D i + I L z d L H H j n e w r C g + f n f 0 + f o J q G H v s z i q 4 S a 5 u o P d m 9 f X g + I Y 6 c  
+ N 3 G v p B r s 4 g 1 y K E 4 t v 5 + c j P o n r B v N D 0 6 B I x 0 2 z 8 o g j h p C 9 y E H d h B 3 f K b Z h 3 w D w O A 0 D u / w 7 d v F g 5 E Q  
+ Y R p F M V R h F s I z q A 4 N 9 p E L F s Y w J 2 5 0 d T e 4 a 1 6 x e E s h w + 8 p P Q H a v H M L C / y Q q 3 o p 3 8 w k T S X f d i R 7 V n 7 N  
+ M t z 7 + 5 J 0 C y r a b Z 6 3 t h + 4 7 R s p w t T 3 a t o n n r N c 0 g 1 6 K B 2 V v 9 B c e n L X t a n J y 5 h y n O c S i v c y 6 n 6 Z i P N 8  
+ 4 b 9 2 b n p D 8 q 7 a t w a q n K G 7 b h 5 y q Y g X l s u 9 W x 6 a 1 O G Z + c r 1 G 2 i e s n W j z 2 J y x 8 Q p o g 1 3 n 8 c D a 4 D l I O w 5  
+ D U O J r w R w Z v E M W B o F c U R k G A K T x A w M w 6 c D G G H E j A o o E O + r q s L L 7 q u q t m s f u k M g o X i I e D 8 P X b y K c o d 9  
+ L 8 X X r L k q N j r K J 1 u 7 n M 6 d + K 6 F d C n P c i X d K U c b K I 8 / O g X L y + 2 4 O 8 Z 0 r t i v N + G E C a M Q d + A q u u q 6 n t y W  
+ s n f 0 b Q H I n j I I I f F y 7 K d 5 7 q 0 g 3 I 3 I B Q b L O s 6 z r O s 6 z r O s 4 e A I s 6 z r O s 6 z r O s 6 z r O s 6 z r O s 6 z r O s 5 o  
+ g I H i z r O s 6 z r O s 6 z r O A D / w E o I A A A B A P n / P 8 / w A Q J A 0 E Q V B k H Q h C U K Q t D E N Q 5 D 0 Q R F E k T R R F U W R d G E  
+ Z R p G 0 c R 1 H k f S B I U i S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M 0 0 T V N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F Q l D U R R V G  
+ U d S F J U p S 1 M U 1 T l P V B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F h W J Y 1 k W V Z l e P 8 A V i A F A U w M M y w 2 D w P g 4 D  
+ 8 P x B E Q R A 8 E 4 a B h E k T h T D w G g d D M O g 8 D 0 O h D E Q P x C E E R R B D 8 Q B C E B k x B D 4 Q W T X Z k G X Z g Q G P Z t l W U Z p  
+ j 2 Z X Z o W X Z A Q G Q Z J k 2 p a x o W d E A P m d X Z o x C X V l G u a l p W l a l p 2 Y a t s 2 x E F n n B a B l 3 H a 5 m 2 S Z t s G L Z p r  
+ W c c k P X J a 1 q G Y D 8 Q 3 Q b d n 2 l D 5 i 3 E d B q W 2 c Q P X D b x k V 1 D 4 Q 1 1 c x r G i e 5 u 3 D d F m H m Z F s m Z Z F n H P b N n n  
+ b Z t t 2 v Z J u 2 9 a x p 2 a a p v W W b l / X 4 Y 9 w G y b N 4 3 V a x q 2 y d 5 j H 1 c M P m W f J l 2 W Z B m W X g J 4 X / b 1 p W + Z 2 H 3 o  
+ f 9 1 n j d a C 1 1 g I Q h D b Y P g 8 j c N w 2 D 5 h w 8 j N j B E E 8 Z B g E c U B V D U F A i X E P Q 7 D s Q B D Z c Q x F Z N j H N c J / I p c  
+ F u H 0 h y J 4 Q g V v I K f 1 o W 7 g K B m m m Z v 2 s l y J 3 b g d z G j b R v W P a 9 / J v f l s J a l M P 4 K g d s H T i h o 4 G b Z t G o b J  
+ 7 W + f h 2 a G e x u Y p a e L p z b x x K G n R 9 G v n O c o H c + h H o e W h 2 6 b 6 G m S o t 8 n 4 e d y Y K g S H p 5 b O n G L e G j W g n V 7  
+ m t g 5 w l 1 a q G n y Z Y P h C b Z w Z 7 E E Q o c b C X m d Z W g a S d Z 7 6 a n p z n x p K t W w E J e Q 9 j Y O Q 3 D o P w 6 D q w x C E d 5 R  
+ Z G Y V h J F I U w y B E I Q 2 D 0 P 2 G E S w n D k 9 k a D r S D m o d Z p 3 H b d z o l p e z 4 h c R u 4 n e F q H t d C + a y c + y a s g N 6 G 5  
+ r 2 e o E n h q 2 M w W q o g n h u 6 9 g C m H V o 9 0 K p v S p 5 V c m L 4 N s N / G y r + Z s I f N q I S s u d 6 M e J t H e o 5 q 1 2 p S / n C m  
+ V 1 a v n G I H E x 3 H W u m z P 2 8 p y k d C l y l q Y y O j n n f 2 x J a r z O H d c u c W g q 9 0 a R f m K G k y v Q Y I p t + 9 F 0 K Y G h 1 a  
+ T p T Z e 7 J L D i 6 w + D m P Q + E U R A 9 E c Z B l E w T R U E g I g S C s O g 9 D 0 P J P v C N L H v m K q H v t y H w e Z z K M Z 6 q 6 t z C y  
+ G q i F 7 H 7 v + w s m c a V c F 0 + I J U Z V l q D h J 1 H D n Z l B D h u + Z k f e z 9 U e 7 P a 4 4 / H G 4 1 3 s 4 j f u c 4 G 5 R s Y C 5 n o e  
+ N p a e H a h T O c d l S H 9 b l i f Z T w S x 3 6 7 / G c X q 9 3 u r 5 n G M R 1 3 q M u Z S K J q x X N G l o O s u U r i B a / z 9 u H q m 1 o o a  
+ r W b n W x C x 4 W Y y f I Z r d s K B x K x Y O i L + g + 4 M O w 4 X Q P A 3 D 2 T 5 P E c V x n F c R x V F A L g T C Q O A 7 3 K X G J l L j 7 S s  
+ B 1 K t s / n o J f L B 3 b l / K M I x j m H c 5 P R Z y i b 5 O c Y v 9 3 N n P 9 + w r b b L S 4 / 4 7 A i a r a t s i Y n R v R 9 O Z + O M L 1 c 1  
+ o v 1 g S / H a o + p r 2 m K I c k r X v 8 Y r a f d l b n U e 5 q H j G 4 9 3 k Y T 8 h n q 9 h d o 2 T o a V I v n K m K e n L o Z a v d 4 P A c 6 l  
+ c Q + P Z a Y y t 2 R A t Y P A 7 D d d A 8 4 N k R G a k T x l F s T B O F c P Q X B k M 2 G k u 7 2 S E N 2 Z U s O y G c q H o v t 9 a C P a p j s J  
+ f 9 d 4 m 6 + j C s x g W t I m s J 9 3 9 f + m H g 5 X j 3 U e h 2 c A g V 0 d T a m h r I Z P z v I 0 q L Y A Z x n 8 e o / N v I b j m 7 6 2 b 2 J v  
+ f i j X N q e Y o h l n x 4 l 8 u p X u v a r c O b i j F 1 d l p L 5 c 1 m a / + 9 z c G Z x n 4 J l r K H 3 f K I 9 t k 6 D J u / 5 k 4 Q X a 9 M S 1  
+ v G L 6 0 T J Y m d x 7 a + a n h A 9 D Y N 1 y 3 N k 9 2 D 4 R h h G Y T R M 3 4 J Q S C x h e F k 6 w q + c v n p 8 q x 8 8 G / R 4 K U r a X s B Z 7  
+ + 5 s f T S Y Q 9 Z 0 X O s D q q M p t 9 X 0 w Z n p U 8 j / n P q S r d i c X j q o 8 C o c z 7 C j W 4 9 2 + q o Z 3 K K t 9 L H p y i Z z n 0 o h 4  
+ G 5 w N + G T x C a O 4 2 b v 9 i f / w + o w J r p l q l 4 n X 9 K Y X b b i p s R o y c a 9 e a h m f h B o 7 H y J 9 r A l O H 8 w 2 Z z e g m y B K  
+ 5 6 1 s Y 7 k s N w 4 Y Y N 3 q E O T x G F U Z h X E k U x Q C 4 E w n D e S 4 3 d i w h E r 7 b J h v e W X g 1 x x r 4 0 X E q / l a W t B x L R Z a  
+ 0 j N I O f e B d O l 9 5 o D c i 9 4 d 8 9 n 3 A e 5 8 n w p b A r S d F 8 a 0 y 9 7 m j / 6 m n g f a 0 t D b H / s u f X Q K n s m + p f g e Z a p o  
+ 2 p 9 E x K w M G 5 j 6 u / h y Y Z t f 3 + p Z r V o 5 8 r 5 j 6 k 8 9 m c Q p h 9 d m / 2 + q W 1 t l X 4 9 7 O s / 8 G w m x t Y P A 3 D e 1 g 5 e U  
+ P 9 2 D w S R g G P f B W E c I A U C 3 g w / D s P 2 O Z G N K v 5 7 H P c v S Z 4 A x n 4 / X c n o B A D 1 w G v x b R W u + j H n O r T 4 t i l f K  
+ c t l V y H L l + p b A c X m 2 a x u c + M x 3 9 a r c 5 w L 3 n a 9 / i 9 F r X A 5 v / q w 0 B o 5 4 f 3 T n 5 s v Z 9 m 0 C s v S x 6 X 5 f 6 f B +  
+ b r a y 3 c h 7 v 7 I a P u v h i y y O e n G o P U h C m 6 + x h 7 K h d t / M m i u 9 3 2 9 T / X m / q M 4 7 n s P Q 4 D c O 9 y D x s R G Y o R B f  
+ G U U B K F Q T A n B M K g 4 j Y O m R u + v u l x d u e k b m b r 1 6 K W a h 5 B 3 6 L 2 b H Z u g S L 8 k p v 6 K w e P j K Y h 7 K 2 f s f A 8 G a  
+ a I M F 5 j J n N 0 q y r 3 c e q Z y i a w J v 0 G X 5 Z q q o J Z 2 a c Y J r O c P i 6 L I 6 D m z R Z X 9 f v o J Z X z Y V d + H N a 2 m t I c 7 /  
+ G 4 m v q m K B s C V v b x b W 5 w c j L 8 e f T M 2 v a L Z H g h 6 m G f h O V G 0 d k P 5 L Y c N g 7 D 4 O w 4 Z 2 1 G J F s Z x S E k V R N C Y F  
+ A q 3 M P g 6 y p n R G h h n b D / X y M W s j 9 H t 0 F z a R z j s H v f q r H z f / X 6 Q x x 5 4 v + 3 s G d s P C H v 4 r 8 n u Z 6 Y Y c h v 6 K  
+ R Z q q Y e v 2 w 9 I 9 T m r R 0 G X 6 B 6 D w O Y m X Y n I Z q q f X t J r + + d X 6 H 8 x h 3 P f x b + 2 u B c a a N o 2 j a N o 2 j a N o 0 e A I  
+ o 2 j a N o 2 j a N o 2 j a N o 2 j a N o 2 j a N o 1 k w I H i j a N o 2 j a N o 2 j a N A D / w B Y I A A A B A P n / P 8 / w A Q J A 0 E Q V B k H Q  
+ h C U K Q t D E N Q 5 D 0 Q R F E k T R R F U W R d G E Z R p G 0 c R 1 H k f S B I U i S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M 0 0 T V  
+ N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F Q l D U R R V G U d S F J U p S 1 M U 1 T l P V B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F h W J Y  
+ 1 k W V Z l e P 8 A V i A F A U w O A 5 Q 8 D 0 P Q 7 D 4 Q Q / E M Q w + E g Y R X E A R B D D w M g 3 D p h A 6 D w Q R D E A Q h C X Y Q B A E E Q W  
+ O E A P w / Y 8 Q V 1 Y 4 P 2 Q X V m m a Z E P w + E J n W i Z p k 2 S X Z k G V a Z j 2 n Z R r W R Z l p Q / E J k 2 N a Z t G r Z V j W f b B m G s  
+ Z J l W l b B w G e c N k m P b N x m d Z B t W 5 c N d m g b B w 2 V a F q m b Z 9 p m R d g Q G h a h n X N c h n 2 U a J i m 6 Z N p X H Y 1 y 2 w c  
+ F v 2 / Z R v H h e d v 3 b b p n m 1 D 5 4 X e Z l j W 0 f Z 2 X v g B y H H e h j m 2 e Z v 3 5 c h o n s Z e B h C D 5 1 G K d p 4 2 T f l j I H d C  
+ B m Q Z d w Y U h B w G W c t w X J a M P W 2 g x 5 3 T f 5 9 B D X Z c g 8 D 4 O w 6 a A O 4 n E F j B D E o X h W Y 8 R A 5 D A O I 2 D 4 O Q 5 b N t  
+ B E c 9 7 4 I b N 8 2 7 g Z 7 Y G c h / 3 0 a 5 4 W y a y T H Y e h m 2 1 b p m 3 o a G I W X d J t V 2 f l z I F d Z 6 X H h N 9 o r h p w I U f B q 4  
+ g n J s 2 q Y 6 a I F Z E P W 0 d 2 c X g a d n J l a p 5 n s b K F J 3 e S B 4 i l N 2 G p e W E W 4 k 2 T m T e R j 2 c Z Z 2 Z o a + h n G Y 2 Y m t  
+ e B 9 3 c a h 6 Y e o d k q E k 2 V l 1 h y e a m r C m Y d a m G G g c 1 w 6 E r l p q H f a C J Q d m X G 3 b q L o y j U O g + j J h 2 V E V l R U F  
+ 4 T W I E M O g w D Z h A 9 j R i H M a g Q 6 p o l 4 q Q e l d a v m 1 3 6 g u R 2 p 3 Z K E H s f y W X Q d K o o K l J m Z t a m v 3 M e C F 6 t a e  
+ / p p q e 9 Z 0 q i U X k o a W X l v Z p W k g K 9 W + k 2 r 2 u a h t r x w J 1 q t x W X 5 Y u 9 k a 7 m Z u W O f 5 6 m 8 l 2 e m 0 f s Q Q 9 h O o  
+ s S q P E H u h n F n 6 l S v s h s q O M 0 c a j 3 g x 2 9 c J l a 4 W Z y L C J S d + m Y b f V / H e g 5 r J P n u a Z 4 x q W X m p V 8 G 4 Y w P w  
+ 9 1 l c 4 2 D + R o G E Q P h F F w W x G E E R R B D I M w 3 D j X I Y h h p 4 N y 2 w W d i W I V 3 x F 5 9 D e q U 7 e c d m N 2 i q l 3 L d y I n 7  
+ i q i o e e 7 C m R b i E W p d K s X k a K m L s z 2 B b m 1 F 0 5 e o 6 o d N q a g u b n K A 7 A b t 7 X M q 9 v s 2 u + / u q v 6 q e f 4 9 l d w l  
+ F d s M c S H G x f J p K J w u C p c r + V X e m / w 8 w l 6 e Y s g S m 8 P Y / B o O Z 9 t I n 0 L P b u 0 O X m Y b T v L 3 a v n K U Z 5 8 P f 8 W  
+ 8 o N x R 8 O N j h 3 A 9 X F c 9 a D z X 2 L 2 c U B g E 8 P l / D M N A 4 D w O / u D x r F 4 w C U H C i q e Z p 3 p 1 o Q 0 Z p J b 6 i D J k m y d  
+ N 5 h l 9 9 1 4 u B s q 5 G 8 a l 0 m V d K w v n L 6 p B r m M v S a 6 s v a D K d m v d Y D i m n 5 k u a S s t m S r a q d + C H 7 6 W v a n f u a +  
+ m 4 R 9 a n 0 H m N 8 e V t r 2 p i Z H W q f L b D r 3 t o k c V v X h a H y Z 7 0 2 i K l r 2 / 3 O 6 a 9 u R o 2 F J P Z F i Q / D z W f 6 D 0 P r Z  
+ a Z e A + E s X R V E I R B E D w M Q 0 D s O f 6 D x i 4 T b B u K 9 f H f H e p j h K X f N 8 r 2 + X B u v u 7 2 6 G u 3 h 2 r j j K q e 4 d 8 r 2 f  
+ q 9 o L h v F 6 M f z A 9 H 5 h 3 I g f H R / b 6 B q 7 6 y 2 + J r s P 4 K R o 3 k Z k 8 B w G k p F t q X 5 z N Y E 7 b V I I 4 e C I a e y K Z 0 7 P  
+ x 8 B 6 R z 5 i m i D u V v b k W 2 f y I L 0 Z B o m Y E F h 2 L v b T 4 b r 2 l + 4 q q n 6 e k z y Y I q d 0 o Q a A P r Z X T 7 O 2 E Q P x E F o W  
+ x H 2 c Q A 0 D Q N w 5 / o O o 4 b S x u N v a G q g 0 C U I a p W I Y L d X y n u r H A p k 3 G 5 L w g n p o M Z S w 3 4 p H c p P l d q I p x R r e  
+ 8 c + h p r d x e W r d e B K l 8 z A O C q O 9 q b + b q r h 8 9 9 Z K k 6 B 4 M 4 D k W r u r d X x 9 q G 2 z v R 2 f i 9 / p K g r 2 U n b 0 r I G k  
+ p H r K n + B 0 3 Q 4 7 J 4 e 6 K Z 2 R Y m e r w Z p n M G p t 3 3 r 8 e 8 P D f G 3 u 5 D 5 c t Z Y Y P 4 z D 6 L m M E U T x e E 9 i h C D b + P 7 D  
+ 0 O Q 7 Z o Q l 4 a x 3 Y X 4 y 5 5 4 l 7 E + n e v g L + 0 f P r 2 m x u q d b b p M 6 m e 6 n 8 w N 0 8 U l C 5 5 K o f j n s g x s 2 c u d s q f x 3  
+ t 2 7 m e T 5 L 9 D x 7 + 6 t 2 W 2 l N r L t d X N Z Q x r M Z 4 8 r n 6 x + H p 9 C 9 z 3 2 t 4 T U 6 n 4 e B I M p 1 1 n b b b Q m u u V j I R g N i  
+ t H m f J / I n m C K d l f s 3 j d + 5 7 B q S l G K g 9 o A 9 D 6 2 Q 8 a D X 1 3 t 4 R B b F k R h C s 4 M g 0 k U P P 6 X e G M T g m p + z b q r M  
+ 6 l q 9 r w 3 x m p / z / 2 3 O v D p 2 8 + D I c H r S + J t o 7 3 L q 5 z j Y D k 9 8 e K 8 p / O E Z R w v K w h 4 q l 6 Z w t G a u F G X w y + v g  
+ g u w u l Z m r 3 b 3 x i s m p q 6 q p m W v X Q Y n g r E f v N d 8 5 G I W K 7 i Z m 6 v S Z d M d z W M F x X 1 G K e f v Y T v a a K n 7 X r 3 f y  
+ L i r D 0 9 i m n E N c m g D 9 h g 8 1 7 K m K E R i h Y F 4 R 1 + E I N w x Y P + r J E N i 8 n 9 + q I h 8 K m s 6 e j V M o 3 S w 8 j + a q / Q x e  
+ X n P l a 8 O c s P n M B x m 3 H C m K i r 3 l i a / c 7 r i W t w a g r m 5 H H W 8 n j f K K f u f M S d C m P P v D E u z 3 f C e k 8 7 U 8 J l e I  
+ 8 A + C D H f a P 5 u F k r h X e p R q + Q r H h J b p G V 5 W h O K v I r S d H b v j R W 2 0 p 7 e V l u C 3 O c J 3 5 N d K 3 g / + v + o R D o O 2  
+ S E U Q h D F Q X x J D / a A y D U O b J D x h G K Y s R L n h C v p q y G s a y b t m G Y c q l Z t 4 X e 3 5 b N m H 7 x p v N z l D q t y v 5 z W 6  
+ d 2 e c U c 9 6 7 t l 5 0 I s m d 0 8 l x z h W 2 Y r j / d n e v r x l / 3 N 6 b 2 X a F i G D J 5 n y 9 m r u q p s a z 2 7 Y D 3 y k b m c O E H o 7  
+ N k w s F S b Z t m 2 b Z t m 2 b Z t m 1 k h 4 A i b Z t m 2 b Z t m 2 b Z t m 2 b Z t m 2 b Z t m 2 b Z t m 2 b W S A g e J t m 2 b Z t m 2 b Z t m 2  
+ b W S A D / w A F A E A A A E A A A A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E  
+ h S J I 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O  
+ U 9 U F R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 M R A W 1 b l v X B c V y X N d F 1 X Z d 1 4 X l e l 7 X  
+ x f V + X 9 g G B Y J g 2 E Y V h m H Y h i W K Y t j G N Y 5 j 2 Q Z F k m T Z R l W W Z d m G Z Z p m 2 c Z 1 n m f a B o W i a N p G l a Z p 2 o a l  
+ q m r a x r W u a 9 s G x b J s 2 0 b V t m 3 b h u W 6 b t v G 9 b 5 v 3 A c F w n D c R x X G c d y H J c p y 3 M c 1 z n P d B 0 X J H g C H N A g e  
+ G b A D / w A U A Q A A A Q A A A A A Q B A U C Q N B E F Q Z B 0 I Q l C k L Q x D U O Q 9 E E R R J E 0 U R V F k X R h G U a R t H E d R 5 H 0 g S F  
+ I k j S R J U m S d K E p S p K 0 s S 1 L k v T B M U y T N N E 1 T Z N 0 4 T l O k 7 T x P U + T 9 Q F B U J Q 1 E U V R l H U h S V K U t T F N U 5 T  
+ 1 Q V F U l T V R V V W V d W F Z V p W 1 c V 1 X l f W B Y V i W N Z F e P 8 A V g A E / 0 x E B b V u W 9 c F x X J c 1 0 X V d l 3 X h e V 6 X t f F  
+ 9 X 5 f 2 A Y F g m D Y R h W G Y d i G J Y p i 2 M Y 1 j m P Z B k W S Z N l G V Z Z l 2 Y Z l m m b Z x n W e Z 9 o G h a J o 2 k a V p m n a h q W q  
+ a t r G t a 5 r 2 w b F s m z b R t W 2 b d u G 5 b p u 2 8 b 1 v m / c B w X C c N x H F c Z x 3 I c l y n L c x z X O c 9 0 H R c k e A I c 0 C B 4 Z  
+ s A P / A B Q B A A A B A A A A A B A E B Q J A 0 E Q V B k H Q h C U K Q t D E N Q 5 D 0 Q R F E k T R R F U W R d G E Z R p G 0 c R 1 H k f S B I U i  
+ S N J E l S Z J 0 o S l K k r S x L U u S 9 M E x T J M 0 0 T V N k 3 T h O U 6 T t P E 9 T 5 P 1 A U F Q l D U R R V G U d S F J U p S 1 M U 1 T l P V  
+ B U V S V N V F V V Z V 1 Y V l W l b V x X V e V 9 Y F h W J Y 1 k V 4 / w B W A A T / T E Q F t W 5 b 1 w X F c l z X R d V 2 X d e F 5 X p e 1 8 X 1  
+ f l / Y B g W C Y N h G F Y Z h 2 I Y l i m L Y x j W O Y 9 k G R Z J k 2 U Z V l m X Z h m W a Z t n G d Z 5 n 2 g a F o m j a R p W m a d q G p a p q  
+ 2 s a 1 r m v b B s W y b N t G 1 b Z t 2 4 b l u m 7 b x v W + b 9 w H B c J w 3 E c V x n H c h y X K c t z H N c 5 z 3 Q d F y R 4 A h z Q I H h m w  
+ A / 8 A F A E A A A E A A A A A E A Q F A k D Q R B U G Q d C E J Q p C 0 M Q 1 D k P R B E U S R N F E V R Z F 0 Y R l G k b R x H U e R 9 I E h S J I  
+ 0 k S V J k n S h K U q S t L E t S 5 L 0 w T F M k z T R N U 2 T d O E 5 T p O 0 8 T 1 P k / U B Q V C U N R F F U Z R 1 I U l S l L U x T V O U 9 U F  
+ R V J U 1 U V V V l X V h W V a V t X F d V 5 X 1 g W F Y l j W R X j / A F Y A B P 9 M R A W 1 b l v X B c V y X N d F 1 X Z d 1 4 X l e l 7 X x f V +  
+ X 9 g G B Y J g 2 E Y V h m H Y h i W K Y t j G N Y 5 j 2 Q Z F k m T Z R l W W Z d m G Z Z p m 2 c Z 1 n m f a B o W i a N p G l a Z p 2 o a l q m r a  
+ x r W u a 9 s G x b J s 2 0 b V t m 3 b h u W 6 b t v G 9 b 5 v 3 A c F w n D c R x X G c d y H J c p y 3 M c 1 z n P d B 0 X J H g C H N A g e G b A D  
+ / w A = < / p a r s e d w a v e f o r m s >  
+ 	 	 < r e p b e a t s   d a t a e n c o d i n g = " B a s e 6 4 " > < r e p b e a t   l e a d n a m e = " I "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 6 "   p e n d = " 2 1 4 "   q o n s e t = " 2 5 8 "   q e n d = " 2 9 6 "   t o n s e t = " 3 6 0 "   t e n d = " 4 7 8 " > D A A N A A 0 A D A A O A A 4 A D g A O A A 8 A D w A P A A 0 A D w A O A A 0 A D Q A N A A 0 A D A A M A A w A D A A L A A s A C w A M A A w A D A A N  
+ A A 0 A D g A N A A 0 A D Q A N A A 4 A D A A M A A s A C w A M A A w A D A A L A A o A C w A L A A w A D A A M A A s A C w A K A A s A C w A L A A o A  
+ C g A K A A o A C g A L A A s A C g A J A A k A C g A K A A o A C A A J A A k A C g A K A A k A C g A K A A g A C g A J A A g A C A A I A A k A C g A I  
+ A A g A B w A I A A g A C Q A I A A o A C A A H A A g A C A A I A A g A B w A H A A g A C A A I A A c A B w A H A A g A B w A H A A Y A C A A I A A c A  
+ B w A H A A c A B w A H A A c A B Q A G A A c A B w A H A A U A B g A H A A c A B g A G A A c A B g A H A A c A C A A H A A c A B g A H A A c A B g A H  
+ A A Y A B w A G A A c A C A A I A A c A B g A H A A c A C A A H A A g A C Q A I A A g A C Q A K A A s A C w A L A A o A C w A M A A w A D g A P A B I A  
+ F A A W A B k A G g A c A B 4 A I A A i A C Q A J g A o A C g A K A A p A C k A J g A m A C U A J g A l A C M A I g A h A C E A I A A f A B 8 A H Q A b  
+ A B s A G Q A Y A B Y A F A A T A A 8 A D Q A L A A k A C A A F A A U A B Q A F A A Q A A w A C A A M A A Q A A A A A A A A A A A P / / A A A B A P / /  
+ / v / + / / 7 / / v / + / / 3 / / v / / / / 7 / / v / / / / / / / / / / / / / / / v / / / w A A A A A A A P / / A A A A A A A A / / 8 A A A A A A A A A  
+ A A A A A w A E A A Q A B g A K A A 8 A F w A a A C I A L A A 2 A E A A T g B a A F 8 A X g B X A E c A O Q A x A C A A A w D o / 8 r / p v + F / 3 T /  
+ e P + K / 6 L / t v / J / 9 n / 6 P / z / / 7 / B w A M A A w A C g A K A A 0 A D g A N A A 0 A D Q A N A A 0 A D g A Q A B A A E Q A S A B I A E g A T  
+ A B Q A F A A V A B U A F Q A W A B c A F g A W A B Y A F w A Y A B k A G Q A a A B g A G Q A a A B o A G w A c A B 0 A H Q A g A C M A J Q A m A C g A  
+ K Q A o A C k A K Q A r A C o A K w A r A C w A K w A r A C 0 A L A A t A C 4 A L w A v A D A A M Q A z A D M A M w A 0 A D U A N w A 5 A D w A P g B A  
+ A E I A Q w B G A E c A S A B K A E w A T A B O A E 8 A U Q B S A F M A V Q B W A F g A W g B a A F 0 A X w B h A G Q A Z g B o A G o A b Q B v A H E A  
+ c w B 2 A H g A e g B 8 A H 0 A f g C A A I E A g w C G A I Y A i Q C K A I o A j Q C O A J A A k A C S A J M A l A C U A J Y A l g C W A J Y A l g C V  
+ A J U A l A C S A I 8 A j A C I A I U A g g B 9 A H o A d Q B w A G w A Z w B i A F 8 A W Q B T A E 8 A S Q B G A E M A P w A 6 A D Y A M g A v A C 0 A  
+ K g A l A C M A I g A f A B w A G w A a A B k A G A A Y A B c A F Q A V A B Y A F A A R A B A A D w A M A A w A C g A I A A g A B w A H A A g A C g A M  
+ A A 8 A E g A U A B U A F A A T A B Q A E g A Q A B A A D w A N A A 0 A C g A K A A k A C Q A K A A w A D A A N A A w A D A A N A A 0 A D g A O A A 4 A  
+ D g A N A A w A D Q A M A A w A C w A L A A w A D A A N A A 0 A D A A M A A w A D Q A N A A 0 A D Q A N A A 0 A D Q A N A A w A D A A N A A s A C w A M  
+ A A s A C w A M A A s A C w A K A A o A C g A L A A o A C w A K A A k A C Q A I A A g A C g A J A A k A C Q A I A A g A C A A I A A k A C A A J A A k A  
+ C Q A J A A k A C Q A K A A k A C Q A J A A c A B w A H A A k A B w A G A A c A B w A I A A c A B g A I A A c A B w A G A A c A B w A H A A g A B w A G  
+ A A g A A A A A A P / / / w / + / / 8 P / f / / D / / / / w / / / / 8 P / v / / D / 3 / / w / 7 / / 8 P + f / / D / b / / w / 1 / / 8 P 9 P / / D / T /  
+ / w / 1 / / 8 P 9 / / / D / f / / w / 3 / / 8 P 9 / / / D / X / / w / 0 / / 8 P 9 P / / D / T / / w / y / / 8 P 8 / / / D / T / / w / 1 / / 8 P 9 f / /  
+ D / P / / w / x / / 8 P 8 P / / D / H / / w / z / / 8 P 9 P / / D / T / / w / 2 / / 8 P 9 / / / D / b / / w / 1 / / 8 P 9 P / / D / P / / w / y / / 8 P  
+ 8 f / / D / H / / w / 0 / / 8 P 9 v / / D / b / / w / 3 / / 8 P 9 / / / D / X / / w / z / / 8 P 8 f / / D / H / / w / y / / 8 P 9 P / / D / f / / w / 4  
+ / / 8 P + P / / D / j / / w / 3 / / 8 P 9 f / / D / T / / w / z / / 8 P 8 / / / D / b / / w / 4 / / 8 P + f / / D / r / / w / 6 / / 8 P + P / / D / f /  
+ / w / 1 / / 8 P 9 P / / D / X / / w / 3 / / 8 P + P / / D / r / / w / 6 / / 8 P + v / / D / j / / w / 3 / / 8 P 9 f / / D / X / / w / 2 / / 8 P + P / /  
+ D / n / / w / 5 / / 8 P + v / / D / r / / w / 6 / / 8 P + P / / D / b / / w / 1 / / 8 P 9 v / / D / j / / w / 6 / / 8 P + / / / D / v / / w / 6 / / 8 P  
+ + f / / D / j / / w / 3 / / 8 P 9 / / / D / f / / w / 5 / / 8 P + / / / D / r / / w / 4 / / 8 P 9 v / / D / P / / w / v / / 8 P 6 v / / D + n / / w / s  
+ / / 8 P 8 v / / D / b / / w / 5 / / 8 P + v / / D / n / / w / 3 / / 8 P 9 v / / D / j / / w / 7 / / 8 P / f / / D / / / / w 8 B A A A A A g A A A A E A  
+ A A A A A A A A / / / / D / z / / w / 6 / / 8 P + v / / D / v / / w / 8 / / 8 P / v / / D / 7 / / w / + / / 8 P / f / / D / z / / w / 5 / / 8 P 9 / / /  
+ D / j / / w / 5 / / 8 P + v / / D / v / / w / 9 / / 8 P / f / / D / 3 / / w / 7 / / 8 P + f / / D / j / / w / 3 / / 8 P + f / / D / z / / w / + / / 8 P  
+ / v / / D / 7 / / w / 9 / / 8 P / P / / D / r / / w / 5 / / 8 P 9 / / / D / f / / w / 7 / / 8 P / f / / D / z / / w / 9 / / 8 P / f / / D / v / / w / 5  
+ / / 8 P + f / / D / j / / w / 5 / / 8 P + v / / D / 3 / / w / + / / 8 P / v / / D / 7 / / w / 8 / / 8 P + / / / D / v / / w / 6 / / 8 P + v / / D / z /  
+ / w / + / / 8 P / / / / D / 7 / / w / / / / 8 P / f / / D / r / / w / 5 / / 8 P + f / / D / r / / w / 8 / / 8 P / v / / D / 7 / / w / + / / 8 P / v / /  
+ D / z / / w / 5 / / 8 P + f / / D / r / / w / 6 / / 8 P / P / / D / 7 / / w / / / / 8 P A A A A A P 7 / / w / 7 / / 8 P + f / / D / n / / w / 6 / / 8 P  
+ + / / / D / 3 / / w / / / / 8 P A Q A A A A E A A A A A A A A A A A A A A P / / / w / / / / 8 P / / / / D / / / / w 8 A A A A A A A A A A P / / / w / 9  
+ / / 8 P / P / / D / n / / w / 1 / / 8 P 8 v / / D / H / / w / x / / 8 P 8 / / / D / f / / w / 6 / / 8 P + / / / D / r / / w / 3 / / 8 P 9 P / / D / H /  
+ / w / v / / 8 P 7 / / / D / P / / w / 3 / / 8 P + P / / D / n / / w / 7 / / 8 P + / / / D / j / / w / 0 / / 8 P 8 v / / D + / / / w / v / / 8 P 8 v / /  
+ D / P / / w / 0 / / 8 P 9 f / / D / X / / w / 0 / / 8 P 9 P / / D / T / / w / 0 / / 8 P 8 / / / D / T / / w / 2 / / 8 P 9 / / / D / j / / w / 4 / / 8 P  
+ + P / / D / f / / w / 2 / / 8 P 9 / / / D / n / / w / 8 / / 8 P / v / / D / 7 / / w / + / / 8 P / f / / D / v / / w / 6 / / 8 P + / / / D / z / / w / +  
+ / / 8 P A A A A A A A A A A A A A A A A A A A A A P / / / w / 9 / / 8 P / P / / D / z / / w / 8 / / 8 P / v / / D w A A A A A A A A A A A A A A A A E A  
+ A A D / / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " I I "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 7 0 "   p e n d = " 2 4 8 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 4 "   t o n s e t = " 3 4 8 "   t e n d = " 4 8 2 " > C g A K A A s A D Q A M A A 4 A D Q A M A A s A D A A L A A w A D Q A N A A 0 A D Q A L A A o A C Q A I A A c A C Q A L A A w A D A A M A A 0 A C w A K  
+ A A s A D A A M A A s A D A A N A A 4 A D g A M A A o A C Q A J A A o A C w A M A A w A C w A J A A g A C A A H A A g A C Q A L A A w A D Q A M A A w A  
+ C g A J A A k A C Q A L A A w A D A A M A A s A C w A L A A o A C Q A I A A k A C g A K A A s A C w A K A A g A B Q A G A A Y A B g A H A A k A C g A L  
+ A A k A C A A H A A c A B g A H A A g A C A A J A A o A C Q A I A A c A B w A G A A Y A C A A J A A k A C Q A I A A g A B w A G A A U A B g A I A A k A  
+ C Q A I A A g A C A A H A A Y A B Q A F A A Y A B w A H A A c A B g A G A A Y A B Q A F A A Q A B g A H A A g A C Q A I A A c A B g A E A A Q A B Q A F  
+ A A Y A C A A I A A g A B w A G A A U A B Q A F A A g A C Q A K A A 0 A D Q A M A A s A D A A N A B A A E Q A R A B I A E A A O A A s A C A A G A A c A  
+ C A A K A A w A D Q A O A B A A E Q A T A B Q A F Q A X A B c A G Q A b A B s A G Q A X A B U A F Q A V A B Q A F A A R A A 4 A D A A J A A g A B g A F  
+ A A U A B w A I A A g A B g A F A A E A / / / 7 / / n / + f / 5 / / r / + / / 9 / / 3 / / f / 8 / / v / + v / 6 / / z / / v / 9 / / 7 / / v / + / / 7 /  
+ + / / 6 / / v / + / / 8 / / 3 / / / 8 A A A A A A A D + / / 3 / / f / / / / / / A A A C A A I A A g A B A A A A A A A A A A A A A Q A C A A Q A A w A B  
+ A P z / 8 / / r / + D / 2 v / e / + f / 9 P 8 C A B k A O A B X A H g A q A D k A C M B Y Q G j A e E B H g J S A k U C 2 Q F U A e k A l A B Q A B U A  
+ 1 v + e / 3 7 / d f + H / 6 7 / 0 / / 0 / w o A E g A W A B Y A F g A Y A B g A F w A W A B Y A G A A a A B o A G Q A X A B U A F Q A V A B U A G A A a  
+ A B w A H Q A b A B o A G g A Y A B s A H A A c A B 4 A H w A e A B 4 A H g A f A B 0 A H Q A f A C I A J A A l A C c A K Q A p A C o A K w A u A C 8 A  
+ M Q A y A D M A N Q A 1 A D Q A M g A x A D E A M g A 1 A D Y A O A A 5 A D o A O w A 9 A D 4 A P w B A A E M A R g B H A E s A T A B M A E 8 A U A B S  
+ A F U A W A B c A F 8 A Y Q B i A G I A Z A B k A G Q A a A B s A G 8 A c w B 0 A H Q A d w B 4 A H o A f Q C A A I Y A i w C P A J I A l A C W A J g A  
+ m w C f A K M A q Q C u A L I A t A C 1 A L c A u g C 9 A M A A x g D K A M 4 A 0 Q D T A N U A 1 A D W A N k A 3 A D e A O A A 4 w D k A O Y A 5 g D l  
+ A O U A 5 A D j A O M A 4 g D f A N w A 1 w D S A M o A w w C 8 A L Y A s Q C s A K c A o A C W A I w A g Q B 4 A H E A a w B n A G I A X A B V A E 4 A  
+ R g A 9 A D c A M w A w A C 0 A K g A o A C Q A H w A d A B o A G Q A Y A B Y A F g A U A B E A D w A M A A s A B w A G A A M A A g A D A A U A C A A L  
+ A A 0 A D g A P A A 8 A D w A P A A 4 A E A A O A A w A C g A K A A g A B w A E A A M A B A A F A A c A C Q A L A A s A C Q A I A A k A C g A K A A w A  
+ D A A N A A w A C w A L A A k A C A A I A A g A C w A N A A 0 A D Q A N A A w A C g A K A A s A C g A L A A w A C w A L A A o A C w A K A A k A C Q A I  
+ A A o A C w A L A A s A C g A J A A g A C A A H A A g A C A A J A A k A C g A I A A c A B w A H A A Y A B w A I A A g A C A A I A A g A B Q A D A A I A  
+ B A A F A A Y A C A A H A A g A C A A G A A U A B Q A G A A c A C A A I A A k A C Q A J A A c A B g A F A A Y A B w A I A A g A C Q A K A A o A C A A G  
+ A A Y A / v / / D / 7 / / w / / / / 8 P A A A A A A A A A A A A A A A A A A A A A A A A A A D + / / 8 P / f / / D / z / / w / 9 / / 8 P / / / / D w A A  
+ A A A A A A A A A A A A A A A A A A D / / / 8 P / v / / D / 7 / / w / 9 / / 8 P / f / / D / 7 / / w 8 A A A A A A Q A A A A E A A A A A A A A A A A A A  
+ A P 7 / / w / 9 / / 8 P / f / / D / 3 / / w / + / / 8 P A A A A A A A A A A A A A A A A A A A A A P 3 / / w / 8 / / 8 P / P / / D / v / / w / 8 / / 8 P  
+ / f / / D w A A A A A A A A A A A A A A A P / / / w / 9 / / 8 P / P / / D / v / / w / 7 / / 8 P / P / / D / 3 / / w / / / / 8 P A A A A A A A A A A A A  
+ A A A A / / / / D / 3 / / w / 8 / / 8 P / P / / D / z / / w / + / / 8 P A A A A A P / / / w / / / / 8 P / / / / D / 3 / / w / 8 / / 8 P + / / / D / v /  
+ / w / 7 / / 8 P / f / / D / 7 / / w / / / / 8 P / / / / D / / / / w / 9 / / 8 P + / / / D / v / / w / 6 / / 8 P + v / / D / z / / w / + / / 8 P / / / /  
+ D / / / / w / / / / 8 P / v / / D / z / / w / 6 / / 8 P + f / / D / r / / w / 8 / / 8 P / f / / D / 7 / / w / / / / 8 P / / / / D / 7 / / w / 9 / / 8 P  
+ / f / / D / 7 / / w / / / / 8 P A Q A A A A I A A A A C A A A A A g A A A A A A A A D 9 / / 8 P + f / / D / f / / w / 2 / / 8 P 9 f / / D / P / / w / z  
+ / / 8 P 9 P / / D / X / / w / 2 / / 8 P 9 v / / D / X / / w / 0 / / 8 P 8 / / / D / H / / w / x / / 8 P 8 v / / D / P / / w / 0 / / 8 P 9 P / / D / P /  
+ / w / z / / 8 P 9 f / / D / b / / w / 2 / / 8 P 9 f / / D / P / / w / x / / 8 P 7 / / / D + / / / w / v / / 8 P 7 v / / D + / / / w / v / / 8 P 8 P / /  
+ D / P / / w / 2 / / 8 P 9 v / / D / T / / w / z / / 8 P 8 v / / D / H / / w / x / / 8 P 8 / / / D / T / / w / 1 / / 8 P 9 / / / D / j / / w / 5 / / 8 P  
+ + f / / D / j / / w / 4 / / 8 P 9 / / / D / b / / w / 3 / / 8 P + v / / D / z / / w / 8 / / 8 P / P / / D / v / / w / 6 / / 8 P + P / / D / j / / w / 3  
+ / / 8 P + P / / D / v / / w / 9 / / 8 P / v / / D / 7 / / w / + / / 8 P / f / / D / v / / w / 7 / / 8 P + / / / D / v / / w / 8 / / 8 P / v / / D / / /  
+ / w / / / / 8 P / / / / D / 3 / / w / 7 / / 8 P + v / / D / v / / w / 7 / / 8 P / f / / D / / / / w 8 A A A A A A A A A A P 7 / / w / 9 / / 8 P + v / /  
+ D / X / / w / v / / 8 P 6 f / / D + b / / w / o / / 8 P 6 v / / D + v / / w / v / / 8 P 9 f / / D / 7 / / w 8 I A A A A E g A A A C E A A A A 4 A A A A  
+ V Q A A A H E A A A C R A A A A u A A A A N 0 A A A A B A Q A A E w E A A P k A A A D H A A A A l w A A A H U A A A B j A A A A V A A A A D w A A A A Z  
+ A A A A 9 / / / D + H / / w / c / / 8 P 5 f / / D / b / / w 8 C A A A A D A A A A A 0 A A A A I A A A A A w A A A A E A A A A C A A A A A w A A A A Q A  
+ A A A F A A A A B g A A A A c A A A A H A A A A B Q A A A A M A A A A A A A A A / / / / D / / / / w 8 A A A A A A A A A A A I A A A A C A A A A A w A A  
+ A A E A A A A A A A A A / / / / D / / / / w / / / / 8 P A A A A A A A A A A A D A A A A A w A A A A M A A A A D A A A A A g A A A A E A A A A A A A A A  
+ / / / / D w A A A A A D A A A A B Q A A A A U A A A A F A A A A B Q A A A A Q A A A A D A A A A A g A A A A I A A A A C A A A A B A A A A A Y A A A A G  
+ A A A A B g A A A A Y A A A A E A A A A A g A A A A E A A A A C A A A A A w A A A A Q A A A A G A A A A B w A A A A c A A A A H A A A A B g A A A A Q A  
+ A A A E A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " I I I "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 5 0 "   p e n d = " 2 3 0 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 4 "   t o n s e t = " 3 2 8 "   t e n d = " 4 7 6 " > / f / 9 / / 3 / / v / + / / 7 / / v / + / / z / + / / 8 / / z / / P / 9 / / / / / / / + / / 3 / / f / 8 / / v / / P / + / / / / A A A A A A A A / / / +  
+ / / / / / f / + / / 7 / / v 8 A A P / / A A D / / / 7 / / v / / / / 7 / / / / / / / 3 / / f / 8 / / z / / P / 9 / / 7 / / v / + / / / / / / 8 A A A A A  
+ A A A A A P / / / / / / / w A A A A A A A A A A A A A A A A A A / / / + / / / / / / / / / w A A / v / / / / 7 / / f / + / / 7 / / / 8 A A P / / A A A A  
+ A P / / / / / 9 / / / / / / / / / / / / / / / / / w A A / / / / / / / / / / / + / / / / / / 8 A A P / / A A A A A A A A A A A A A P / / / / 8 A A A A A  
+ A A A A A A E A A A D / / / / / / / / / / / / / A A D / / w A A A A D / / / / / / / / / / / 7 / A A D / / w A A A A A A A P / / / v / + / / 7 / / f / /  
+ / / / / / v 8 A A A A A / / / + / / 7 / / / / / / w A A A Q A B A A I A A w A C A A Q A A w A D A A M A B A A E A A M A A g D / / / z / + f / 3 / / X /  
+ 9 P / z / / L / 8 f / x / / H / 8 P / w / / H / 8 P / u / + / / 8 P / w / / H / 8 P / w / / D / 7 / / w / / D / 7 / / t / + v / 6 / / o / + f / 5 / / n  
+ / + n / 6 / / u / + / / 8 P / x / / D / 7 / / u / + / / 8 P / x / / T / 9 v / 4 / / n / + f / 5 / / j / + P / 6 / / r / / P / 9 / / 3 / / / / + / / 3 /  
+ / f / 9 / / 3 / / v 8 A A A A A A A A A A A A A A A A A A P / / A A A A A A A A A A A B A A E A A A A A A A A A A A A A A A A A A Q A C A A I A A Q A A  
+ A P f / 7 f / h / 9 X / 0 / / W / 9 n / 4 / / v / w E A F g A q A E Y A b w C g A N k A F w F j A a 8 B 9 g E k A g A C n Q E / A f o A 0 A C 1 A I o A  
+ S A A G A N X / v / / J / + H / + / 8 N A B M A D g A I A A Y A C g A M A A o A C g A J A A g A C w A L A A o A C A A F A A Q A A g A C A A M A B A A F  
+ A A U A B Q A E A A Q A A w A D A A I A A w A E A A U A B Q A F A A U A B A A D A A M A A w A E A A U A B g A H A A g A C A A I A A Y A B g A H A A Y A  
+ B g A H A A g A C g A I A A c A B g A G A A U A B g A I A A g A C Q A J A A o A C w A N A A 0 A D g A N A A 8 A E A A R A B I A E g A S A B I A E w A R  
+ A B M A E g A U A B Q A F A A V A B U A F g A W A B U A F w A Y A B k A G w A b A B w A H Q A d A B w A H Q A e A C A A I g A k A C Y A J g A m A C Y A  
+ J w A o A C o A L A A v A D E A M w A 0 A D U A N w A 4 A D s A P A A 9 A D 8 A Q Q B D A E Q A R A B D A E U A R g B I A E k A S w B M A E 0 A T g B O  
+ A E 4 A T Q B P A F A A U Q B S A F E A U A B P A E w A S Q B I A E Y A R Q B E A E I A P w A 9 A D k A N A A v A C s A K A A m A C U A I w A g A B 4 A  
+ G Q A V A B E A D w A N A A w A D A A K A A k A B g A E A A E A / / 8 A A P / / / / 8 A A P / / / v / / / / 3 / / f / 8 / / z / / P / 7 / / z / / f / 8  
+ / / z / + v / 6 / / r / + f / 5 / / n / + v / 7 / / r / + / / 8 / / v / + / / 6 / / n / + v / 7 / / z / / f / 9 / / 3 / / P / 7 / / r / + / / 7 / / 3 /  
+ / f / + / / / / / v / 9 / / 3 / / f / 9 / / 3 / / v / / / / / / A A A A A P / / / f / 7 / / 3 / / f / 8 / / 3 / / f / + / / 7 / / v / 9 / / z / / P / 9  
+ / / 3 / / v / + / / / / / / / / / / 3 / / v / 8 / / z / / v / + / / / / / / / / / w A A / v / + / / 3 / / P / / / / / / / / 8 A A P / / / f / 6 / / n /  
+ + v / 7 / / z / / v / + / / 7 / / f / 9 / / 3 / / v / / / / / / A A A A A A A A A A A A A A A A / / / / / / 7 / / / 8 A A A E A A A A A A A A A A A D /  
+ / / / / B A A A A A Y A A A A H A A A A B w A A A A Y A A A A C A A A A / / / / D / 3 / / w / 7 / / 8 P + f / / D / j / / w / 5 / / 8 P + P / / D / n /  
+ / w / 6 / / 8 P + f / / D / n / / w / 5 / / 8 P + P / / D / f / / w / 2 / / 8 P 9 / / / D / j / / w / 6 / / 8 P + v / / D / n / / w / 4 / / 8 P + P / /  
+ D / r / / w / 7 / / 8 P + f / / D / j / / w / 2 / / 8 P 9 f / / D / P / / w / y / / 8 P 8 f / / D / L / / w / z / / 8 P 9 f / / D / j / / w / 7 / / 8 P  
+ + / / / D / n / / w / 4 / / 8 P 9 / / / D / X / / w / 2 / / 8 P 9 / / / D / j / / w / 6 / / 8 P / P / / D / 3 / / w / + / / 8 P / v / / D / z / / w / 8  
+ / / 8 P + / / / D / v / / w / 9 / / 8 P / / / / D w A A A A A B A A A A A Q A A A A A A A A A A A A A A A A A A A P / / / w / / / / 8 P / / / / D w A A  
+ A A A B A A A A A g A A A A I A A A A C A A A A A A A A A P / / / w / + / / 8 P / v / / D / / / / w 8 A A A A A A g A A A A M A A A A D A A A A A g A A  
+ A A A A A A A A A A A A / / / / D / / / / w 8 A A A A A A g A A A A M A A A A D A A A A A w A A A A E A A A D 9 / / 8 P 9 / / / D / D / / w / p / / 8 P  
+ 6 P / / D + z / / w / w / / 8 P 8 / / / D / j / / w / / / / 8 P C A A A A B E A A A A e A A A A M g A A A E s A A A B n A A A A h g A A A K s A A A D R  
+ A A A A 9 w A A A B Q B A A A I A Q A A 2 Q A A A K c A A A C A A A A A a w A A A F 4 A A A B K A A A A L A A A A A g A A A D t / / 8 P 4 P / / D + T /  
+ / w / w / / 8 P / P / / D w Y A A A A M A A A A C w A A A A Y A A A A E A A A A B A A A A A U A A A A F A A A A B A A A A A Q A A A A F A A A A B g A A  
+ A A Y A A A A G A A A A B Q A A A A Q A A A A C A A A A A A A A A A A A A A A A A A A A A g A A A A M A A A A D A A A A A w A A A A M A A A A D A A A A  
+ A Q A A A A A A A A A A A A A A A A A A A A I A A A A E A A A A B A A A A A Q A A A A D A A A A A g A A A A I A A A A A A A A A A A A A A A A A A A A C  
+ A A A A B A A A A A Q A A A A F A A A A B A A A A A M A A A A B A A A A A A A A A A A A A A A A A A A A A g A A A A Q A A A A F A A A A B g A A A A Y A  
+ A A A E A A A A A w A A A A I A A A A C A A A A A g A A A A M A A A A F A A A A B Q A A A A Y A A A A H A A A A B Q A A A A M A A A A C A A A A A w A A  
+ A A Q A A A A G A A A A C A A A A A k A A A A K A A A A C g A A A A c A A A A F A A A A B Q A A A A U A A A A G A A A A C A A A A A o A A A A L A A A A  
+ C w A A A A o A A A A J A A A A C Q A A A A k A A A A J A A A A C g A A A A w A A A A N A A A A D w A A A A 8 A A A A P A A A A D g A A A A w A A A A M  
+ A A A A D Q A A A A 0 A A A A Q A A A A E g A A A B M A A A A U A A A A F A A A A B Q A A A A T A A A A F A A A A B Q A A A A V A A A A G A A A A B o A  
+ A A A b A A A A H A A A A B w A A A A b A A A A G g A A A B o A A A A a A A A A G w A A A B w A A A A f A A A A I A A A A C E A A A A h A A A A I Q A A  
+ A B 8 A A A A g A A A A I Q A A A C I A A A A j A A A A J Q A A A C Y A A A A o A A A A K A A A A C c A A A A l A A A A J A A A A C Q A A A A l A A A A  
+ K A A A A C o A A A A q A A A A K g A A A C k A A A A m A A A A I w A A A C M A A A A h A A A A I A A A A C E A A A A i A A A A I g A A A C E A A A A f  
+ A A A A H Q A A A B g A A A A W A A A A F A A A A B M A A A A T A A A A E w A A A B I A A A A Q A A A A D g A A A A w A A A A I A A A A B g A A A A U A  
+ A A A F A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " a V R "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 7 0 "   p e n d = " 2 1 6 "   q o n s e t = " 2 5 2 "   q e n d = " 2 9 4 "   t o n s e t = " 3 6 2 "   t e n d = " 4 8 0 " > 9 P / 1 / / X / 9 f / z / / P / 8 / / 0 / / L / 8 / / z / / T / 8 / / z / / T / 9 P / 1 / / X / 9 / / 2 / / f / 9 v / 2 / / X / 9 v / 1 / / X / 9 P / 1  
+ / / T / 9 P / 0 / / T / 9 P / 0 / / T / 9 P / 1 / / b / 9 v / 2 / / X / 9 f / 2 / / b / 9 / / 3 / / b / 9 v / 2 / / f / 9 v / 1 / / X / 9 f / 1 / / X /  
+ 9 v / 3 / / f / 9 v / 2 / / b / 9 v / 2 / / b / 9 v / 2 / / X / 9 / / 4 / / f / 9 / / 3 / / b / 9 / / 3 / / j / + P / 3 / / n / + f / 5 / / f / + P / 4  
+ / / n / + f / 5 / / n / + f / 5 / / n / + P / 5 / / j / + P / 5 / / j / + f / 6 / / r / + P / 5 / / n / + / / 4 / / j / + v / 6 / / r / + f / 5 / / j /  
+ + f / 6 / / n / + f / 6 / / v / / P / 7 / / r / + f / 7 / / r / + / / 6 / / r / + / / 8 / / v / + / / 6 / / n / + f / 5 / / r / + / / 7 / / r / + / / 6  
+ / / v / + v / 5 / / j / + f / 5 / / v / + / / 5 / / j / + f / 4 / / b / 9 / / 3 / / f / 9 v / 1 / / T / 8 v / z / / P / 9 P / 0 / / X / 9 f / 1 / / T /  
+ 8 v / x / + / / 7 f / r / + r / 6 P / m / + T / 5 P / h / + L / 4 f / f / + D / 4 v / j / + P / 4 v / j / + X / 5 / / o / + n / 6 / / t / + 7 / 7 / / x  
+ / / D / 8 P / x / / P / 9 P / 2 / / j / + / / + / w A A A g A B A A E A A Q A A A A A A A A A C A A I A A g A C A A I A A g A D A A M A A g A B A A I A  
+ B A A F A A Q A B A A D A A M A A g A B A A E A A g A C A A I A A Q A C A A E A A Q A A A A A A A A A B A A E A A A A A A A A A A Q A A A A A A A A A A  
+ A A M A B Q A K A A 4 A E A A L A A Q A / P / w / 9 7 / y f + z / 5 z / f P 9 X / z b / F v / 3 / u L + y / 6 8 / t / + K / 9 3 / 7 f / 7 v 8 d A E c A  
+ Z g B 2 A H U A a w B T A D g A H w A I A P v / 8 v / u / / D / 7 / / w / + / / 7 v / v / + / / 7 f / t / + 7 / 7 v / v / + 3 / 7 f / s / + z / 7 P / r  
+ / + n / 6 v / p / + n / 6 f / p / + j / 6 P / n / + b / 5 v / m / + b / 5 f / l / + b / 5 v / k / + L / 4 f / g / 9 7 / 3 f / d / 9 r / 2 P / Y / 9 X /  
+ 1 P / T / 9 P / 0 f / Q / 9 L / 0 / / S / 9 L / 0 v / R / 8 / / z / / N / 8 z / y / / L / 8 n / y P / H / 8 b / x f / D / 8 H / v v + 9 / 7 z / u f + 3  
+ / 7 b / s / + w / 6 3 / r P + q / 6 n / q f + o / 6 f / o / + h / 5 / / n f + c / 5 r / m P + X / 5 X / k v + P / 4 z / i P + F / 4 P / g P 9 + / 3 z /  
+ e f 9 2 / 3 L / b / 9 r / 2 j / a P 9 m / 2 T / Y f 9 e / 1 z / W P 9 X / 1 X / U v 9 R / 0 / / T v 9 M / 0 r / S f 9 I / 0 b / R f 9 E / 0 P / Q v 9 D  
+ / 0 P / R P 9 F / 0 f / S v 9 N / 1 H / V f 9 a / 2 H / Z v 9 r / 3 H / d f 9 6 / 3 / / h / + O / 5 b / m / + i / 6 f / q / + y / 7 b / u / / A / 8 T /  
+ y f / R / 9 X / 1 v / a / 9 3 / 3 / / h / + P / 5 f / m / + j / 6 f / r / + v / 7 P / v / / H / 8 f / 0 / / b / 9 / / 5 / / v / / P / 7 / / r / 9 / / 2  
+ / / P / 8 f / w / + / / 7 v / v / + / / 8 P / x / / P / 9 P / 1 / / b / + P / 5 / / v / + / / 5 / / f / 9 v / 1 / / X / 9 f / 0 / / T / 9 P / 0 / / X /  
+ 9 f / 0 / / X / 9 P / 1 / / X / 9 v / 4 / / b / 9 f / 0 / / T / 9 P / 0 / / T / 9 P / 0 / / T / 9 P / 0 / / X / 9 P / 1 / / b / 9 v / 1 / / X / 9 v / 3  
+ / / b / 9 / / 2 / / b / 9 v / 3 / / j / 9 / / 3 / / j / 9 v / 2 / / f / 9 / / 5 / / j / + P / 5 / / n / + P / 5 / / n / + P / 4 / / j / + f / 7 / / r /  
+ + / / 6 / / n / + P / 5 / / j / + P / 5 / / r / + v / 6 / / r / + v / 6 / / n / + P / 4 / / n / + f / 6 / / r / + f / 5 / / r / + f / 4 / / n / + v / 6  
+ / / r / E Q A A A B w A A A A s A A A A Q g A A A F g A A A B 0 A A A A m Q A A A M M A A A D q A A A A C w E A A B I B A A D p A A A A s A A A A I Y A  
+ A A B t A A A A Y Q A A A F g A A A B C A A A A J A A A A A o A A A D 0 / / 8 P 5 v / / D + X / / w / s / / 8 P 9 / / / D w A A A A A G A A A A B A A A  
+ A A A A A A A A A A A A A Q A A A A Q A A A A F A A A A B A A A A A I A A A A B A A A A A A A A A A A A A A A B A A A A A g A A A A E A A A A B A A A A  
+ A A A A A A A A A A D + / / 8 P / f / / D / 3 / / w / + / / 8 P A A A A A A I A A A A C A A A A A g A A A A I A A A A A A A A A / f / / D / z / / w / 9  
+ / / 8 P / v / / D w A A A A A B A A A A A g A A A A E A A A A B A A A A A Q A A A A A A A A A A A A A A A A A A A A A A A A A C A A A A B A A A A A Q A  
+ A A A E A A A A B A A A A A M A A A A C A A A A A A A A A A A A A A A B A A A A A w A A A A Q A A A A F A A A A B g A A A A U A A A A D A A A A A g A A  
+ A A M A A A A D A A A A A g A A A A M A A A A F A A A A B w A A A A g A A A A I A A A A B w A A A A Q A A A A D A A A A A g A A A A Q A A A A G A A A A  
+ C A A A A A k A A A A K A A A A C Q A A A A c A A A A G A A A A B g A A A A U A A A A G A A A A C A A A A A k A A A A K A A A A C w A A A A o A A A A J  
+ A A A A C Q A A A A g A A A A I A A A A C g A A A A w A A A A P A A A A E A A A A B E A A A A Q A A A A D w A A A A 4 A A A A O A A A A D Q A A A A 4 A  
+ A A A R A A A A E w A A A B Q A A A A V A A A A F g A A A B U A A A A U A A A A F A A A A B Q A A A A V A A A A F w A A A B o A A A A d A A A A H g A A  
+ A B 4 A A A A d A A A A H A A A A B w A A A A c A A A A H Q A A A B 8 A A A A g A A A A I g A A A C M A A A A j A A A A I g A A A C E A A A A h A A A A  
+ I Q A A A C E A A A A k A A A A J g A A A C c A A A A o A A A A J w A A A C Y A A A A k A A A A I w A A A C M A A A A j A A A A J A A A A C U A A A A m  
+ A A A A J g A A A C U A A A A h A A A A H w A A A B 4 A A A A c A A A A G g A A A B o A A A A a A A A A G g A A A B g A A A A W A A A A F A A A A B E A  
+ A A A O A A A A D Q A A A A s A A A A L A A A A D A A A A A s A A A A K A A A A C Q A A A A Y A A A A E A A A A A g A A A A A A A A A A A A A A A A A A  
+ A A E A A A A C A A A A A g A A A A E A A A A A A A A A / v / / D / 7 / / w / 9 / / 8 P / f / / D / 7 / / w / / / / 8 P A A A A A A A A A A D / / / 8 P  
+ / f / / D / v / / w / 7 / / 8 P + / / / D / v / / w / 9 / / 8 P / / / / D / / / / w / / / / 8 P / / / / D / 3 / / w / 8 / / 8 P / P / / D / v / / w / 6  
+ / / 8 P / P / / D / 7 / / w / / / / 8 P A A A A A A A A A A D / / / 8 P / f / / D / z / / w / 8 / / 8 P / f / / D / / / / w 8 A A A A A A Q A A A A E A  
+ A A A A A A A A A A A A A P 7 / / w / 9 / / 8 P / f / / D / 7 / / w 8 A A A A A A A A A A A I A A A A B A A A A A Q A A A A A A A A D / / / 8 P / v / /  
+ D / 7 / / w / + / / 8 P A A A A A A E A A A A C A A A A A Q A A A A A A A A A A A A A A / v / / D / 3 / / w / 8 / / 8 P / P / / D / 7 / / w 8 A A A A A  
+ A A A A A A A A A A A A A A A A / / / / D / / / / w / / / / 8 P / v / / D / 7 / / w 8 A A A A A A A A A A A A A A A A A A A A A A A A A A P / / / w / 9  
+ / / 8 P / P / / D / 3 / / w / 9 / / 8 P / v / / D / / / / w 8 A A A A A A A A A A A A A A A D + / / 8 P / f / / D / z / / w / 8 / / 8 P / f / / D / 7 /  
+ / w / / / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " a V L "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 4 "   p e n d = " 2 2 8 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 0 "   t o n s e t = " 3 4 0 "   t e n d = " 4 5 4 " > C Q A I A A g A C A A I A A g A C A A I A A o A C g A K A A k A C Q A I A A g A B w A H A A g A C A A H A A g A C A A H A A c A B g A G A A c A B w A G  
+ A A g A C Q A I A A g A B w A G A A c A B g A H A A Y A B g A H A A c A B w A G A A Y A B w A I A A g A C A A H A A g A B w A G A A Y A B g A E A A Q A  
+ B Q A F A A Y A B Q A F A A U A B Q A F A A U A B Q A F A A U A B Q A G A A Y A B g A F A A U A B g A G A A U A B g A G A A Y A B Q A F A A U A B Q A F  
+ A A Q A B A A F A A Y A B Q A G A A U A B Q A E A A Q A B Q A E A A Q A B Q A F A A U A A w A E A A Q A A w A E A A U A B A A E A A Q A B Q A E A A Q A  
+ B A A E A A Q A B A A E A A M A B A A E A A Q A B A A D A A M A A w A E A A Q A B A A E A A U A B A A D A A M A B A A E A A U A B A A F A A U A B Q A E  
+ A A Q A B A A D A A Q A B A A G A A Q A B A A F A A Q A B A A D A A I A A g A C A A M A A w A D A A M A A w A D A A M A B Q A H A A k A C w A N A A 4 A  
+ E A A S A B M A F A A V A B c A G A A Z A B s A H Q A d A B w A H A A c A B w A H A A a A B w A H A A b A B k A G g A b A B s A G g A b A B s A H A A a  
+ A B g A F w A V A B M A E g A R A B A A D w A N A A w A C w A K A A g A B w A G A A U A B A A F A A Q A B Q A D A A M A A g A B A A E A A Q A B A A E A  
+ A A A B A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A  
+ A A U A D A A T A B c A G Q A a A B s A G Q A U A A 8 A C g A F A P 3 / 7 f / Y / 7 7 / n f 9 x / 0 P / G v 8 H / x r / P f 9 c / 2 v / a f 9 s / 3 z /  
+ o / / O / + z / / f / + / / n / 9 / / 1 / / f / A A A C A A E A A A D / / w E A B A A D A A M A A Q A A A A I A A w A E A A U A B w A I A A g A B w A G  
+ A A g A B w A I A A k A C A A K A A o A C g A K A A k A C Q A J A A k A C g A K A A o A C g A K A A k A C Q A K A A o A C w A M A A 0 A D g A O A B A A  
+ E Q A Q A A 8 A E A A Q A B E A E g A S A B M A E g A R A B E A E Q A R A B E A E Q A R A B E A E Q A S A B E A E Q A Q A B E A E Q A S A B M A F Q A X  
+ A B Y A F w A Y A B k A G Q A Z A B o A G g A b A B w A H A A b A B 0 A H Q A c A B 0 A H g A e A B 8 A I A A h A C E A I Q A i A C I A I w A j A C M A  
+ J Q A l A C Y A J g A m A C Y A J Q A k A C U A J Q A l A C Y A J Q A l A C U A J A A l A C U A J g A m A C Y A J Q A m A C Y A J Q A k A C M A I g A j  
+ A C M A I w A h A B 4 A H Q A b A B k A G A A X A B Y A F Q A T A B I A E A A O A A 4 A D A A K A A s A C w A M A A w A C g A J A A k A C A A H A A g A  
+ C A A H A A g A C A A I A A g A C A A I A A g A C A A K A A o A C w A L A A w A C g A J A A k A C A A H A A c A B g A G A A Y A B g A G A A c A C A A J  
+ A A o A C w A O A A 0 A D Q A O A A 0 A D Q A L A A s A C Q A I A A k A C A A I A A k A C A A I A A c A B w A I A A g A C A A J A A o A C Q A J A A k A  
+ C A A I A A g A C A A I A A c A B w A H A A g A B w A H A A c A B g A H A A c A C A A H A A g A C Q A I A A k A B w A G A A Y A C A A H A A g A C A A I  
+ A A c A B g A H A A Y A B Q A G A A Y A B g A H A A Y A B g A G A A Y A B g A G A A U A B Q A G A A U A B g A F A A Q A B Q A F A A U A B g A H A A c A  
+ C A A H A A c A B g A H A A Q A B Q A F A A U A B Q A F A A U A B A A E A A M A B A A E A A Q A B A A F A A U A A w A D A A Q A B A A D A A M A B A A E  
+ A A U A E g A A A B I A A A A Q A A A A E A A A A B A A A A A R A A A A E w A A A B U A A A A Y A A A A G Q A A A B k A A A A Y A A A A F w A A A B c A  
+ A A A X A A A A G Q A A A B s A A A A d A A A A H w A A A C A A A A A g A A A A H w A A A B 0 A A A A d A A A A H g A A A B 8 A A A A h A A A A I w A A  
+ A C Q A A A A l A A A A J Q A A A C M A A A A i A A A A I g A A A C I A A A A j A A A A J Q A A A C c A A A A n A A A A J w A A A C Y A A A A k A A A A  
+ I Q A A A C A A A A A f A A A A H g A A A B 8 A A A A f A A A A H g A A A B 0 A A A A b A A A A G A A A A B Q A A A A R A A A A D w A A A A 4 A A A A P  
+ A A A A D w A A A A 4 A A A A N A A A A C w A A A A g A A A A E A A A A A w A A A A I A A A A B A A A A A g A A A A I A A A A B A A A A A A A A A A A A  
+ A A D + / / 8 P / P / / D / v / / w / 7 / / 8 P + / / / D / z / / w / 9 / / 8 P / P / / D / z / / w / 7 / / 8 P + f / / D / j / / w / 3 / / 8 P 9 / / /  
+ D / j / / w / 6 / / 8 P + / / / D / z / / w / 8 / / 8 P / P / / D / r / / w / 5 / / 8 P 9 / / / D / b / / w / 2 / / 8 P 9 / / / D / n / / w / 6 / / 8 P  
+ + v / / D / v / / w / 6 / / 8 P 9 / / / D / b / / w / 2 / / 8 P 9 / / / D / n / / w / 6 / / 8 P + / / / D / r / / w / 6 / / 8 P + f / / D / j / / w / 4  
+ / / 8 P 9 / / / D / j / / w / 6 / / 8 P / P / / D / 3 / / w / 9 / / 8 P / f / / D / v / / w / 5 / / 8 P + P / / D / j / / w / 3 / / 8 P + f / / D / v /  
+ / w / 8 / / 8 P / f / / D / 3 / / w / 8 / / 8 P + v / / D / n / / w / 4 / / 8 P + P / / D / n / / w / 6 / / 8 P + / / / D / z / / w / 8 / / 8 P + v / /  
+ D / n / / w / 4 / / 8 P + P / / D / j / / w / 6 / / 8 P / P / / D / 3 / / w / 8 / / 8 P / P / / D / r / / w / 5 / / 8 P + P / / D / j / / w / 4 / / 8 P  
+ + v / / D / z / / w / 8 / / 8 P + / / / D / v / / w / 6 / / 8 P + f / / D / n / / w / 6 / / 8 P + f / / D / n / / w / 7 / / 8 P / P / / D / z / / w / 8  
+ / / 8 P + / / / D / n / / w / 4 / / 8 P + P / / D / j / / w / 6 / / 8 P / P / / D / z / / w / 8 / / 8 P / P / / D / v / / w / 5 / / 8 P + P / / D / j /  
+ / w / 5 / / 8 P + v / / D / z / / w / 9 / / 8 P / v / / D / 3 / / w / 8 / / 8 P + v / / D / r / / w / 6 / / 8 P + / / / D / z / / w / 9 / / 8 P / v / /  
+ D / 7 / / w / / / / 8 P / f / / D / r / / w / 5 / / 8 P + f / / D / n / / w / 7 / / 8 P / f / / D / 7 / / w / + / / 8 P / f / / D / v / / w / 6 / / 8 P  
+ + v / / D / n / / w / 5 / / 8 P + / / / D / 3 / / w / + / / 8 P / f / / D / 3 / / w / 8 / / 8 P + v / / D / n / / w / 5 / / 8 P + v / / D / z / / w / 9  
+ / / 8 P / v / / D / 7 / / w / + / / 8 P / P / / D / v / / w / 6 / / 8 P + v / / D / r / / w / 8 / / 8 P / f / / D / 7 / / w / + / / 8 P / f / / D / z /  
+ / w / 6 / / 8 P + f / / D / n / / w / 5 / / 8 P + / / / D / 3 / / w / / / / 8 P A A A A A A A A A A D / / / 8 P / v / / D / 7 / / w / / / / 8 P A A A A  
+ A A A A A A A B A A A A A A A A A P / / / w / 9 / / 8 P + v / / D / f / / w / 0 / / 8 P 8 f / / D / H / / w / z / / 8 P 9 f / / D / f / / w / 5 / / 8 P  
+ + f / / D / f / / w / 0 / / 8 P 8 v / / D / D / / w / v / / 8 P 8 f / / D / X / / w / 3 / / 8 P 9 / / / D / j / / w / 4 / / 8 P 9 / / / D / T / / w / x  
+ / / 8 P 7 v / / D + 7 / / w / v / / 8 P 8 P / / D / H / / w / y / / 8 P 8 f / / D / D / / w / w / / 8 P 8 v / / D / P / / w / 0 / / 8 P 9 f / / D / T /  
+ / w / 0 / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " a V F "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 2 "   p e n d = " 2 4 2 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 4 "   t o n s e t = " 3 4 6 "   t e n d = " 4 8 2 " > A w A E A A Q A B A A E A A Q A B A A D A A Q A A w A E A A Q A B A A E A A Q A B A A E A A M A A g A B A A E A A g A D A A Q A B Q A F A A U A B A A E  
+ A A Q A B A A D A A Q A B A A F A A Y A B Q A F A A M A A w A C A A M A B Q A E A A Q A A w A B A A E A A g A D A A M A B A A E A A U A B A A G A A U A  
+ B g A E A A M A A w A F A A Y A B g A F A A Q A B Q A F A A U A A w A D A A Q A B A A D A A Q A B A A D A A M A A g A C A A E A A g A D A A Q A B Q A E  
+ A A M A A g A C A A I A A Q A D A A M A A w A E A A Q A A w A D A A I A A g A B A A I A A w A D A A M A B A A E A A M A A w A C A A I A A g A D A A Q A  
+ B A A E A A M A A w A B A A E A A Q A B A A E A A w A D A A M A A g A B A A E A A g A A A A E A A g A C A A M A A w A D A A I A A A A B A A E A A Q A B  
+ A A I A A g A C A A M A A g A C A A E A A g A D A A Q A B A A F A A c A B w A I A A c A C A A J A A o A C Q A K A A k A B w A F A A E A A A D / / / 7 /  
+ / v / / / w A A A A A A A A E A A A A B A A I A A g A D A A M A B A A F A A Q A B A A D A A I A A Q A B A A A A A A D / / / 3 / + / / 5 / / f / 9 v / 2  
+ / / f / + v / 6 / / v / + v / 5 / / j / 9 P / 0 / / T / 9 P / 1 / / f / + f / 6 / / r / + / / 6 / / n / + f / 6 / / v / / P / 8 / / 7 / / f / 9 / / z /  
+ / P / 7 / / z / / f / + / / / / A A A A A A A A / / / / / / / / / v / + / w A A A A A B A A I A A Q A A A A A A A A A A A A A A A Q A C A A I A A Q D 9  
+ / / b / 7 f / i / 9 f / 1 / / c / + P / 7 v / / / x Q A M Q B K A G w A n A D V A B A B U A G X A d w B H Q I 9 A g Y C k g E n A d c A n w B x A D s A  
+ / P / E / 6 L / n P + w / 9 L / 8 f 8 H A B I A E Q A Q A A 4 A D w A R A B A A D w A O A A 8 A E g A S A B E A D w A N A A w A D A A L A A 0 A D g A P  
+ A B A A D w A P A A 8 A D g A O A A 8 A D w A R A B I A E Q A R A B A A E Q A Q A B A A E Q A T A B Q A F g A W A B c A G A A X A B g A G Q A Z A B s A  
+ H A A d A B 0 A H Q A d A B s A G w A b A B o A H A A e A B 8 A I A A h A C I A I w A k A C Q A J g A o A C k A K w A t A C 0 A L g A v A D A A M Q A y  
+ A D M A N g A 4 A D k A O w A 7 A D w A P Q A 9 A D 4 A Q A B C A E U A R g B H A E g A S Q B K A E s A T Q B Q A F Q A V w B a A F w A X Q B e A F 8 A  
+ Y g B j A G c A b A B w A H I A c w B 1 A H Y A e A B 7 A H 4 A g g C F A I c A i Q C K A I w A j Q C N A J A A k Q C T A J U A l g C Y A J k A m Q C a  
+ A J k A m Q C Z A J k A m A C X A J U A k g C O A I k A h A C A A H w A e g B 3 A H I A b A B m A F 8 A W A B R A E w A S Q B F A E I A P Q A 4 A D Q A  
+ L Q A m A C I A I A A d A B w A G g A X A B M A E g A P A A 0 A D A A K A A o A C Q A I A A c A B Q A F A A Q A A Q A B A P / / / v / / / w E A A g A E  
+ A A M A A w A E A A Q A A w A C A A Q A B A A D A A M A A Q A B A A A A A A D / / / / / / / 8 A A A E A A g A D A A I A A g A B A A E A A Q A D A A Q A  
+ A w A E A A Q A A w A D A A I A A w A D A A I A B A A F A A U A B Q A F A A Q A A g A D A A M A A w A D A A M A A w A D A A M A A w A C A A I A A g A C  
+ A A M A A w A E A A Q A B A A C A A I A A g A B A A I A A w A D A A Q A A w A C A A I A A g A C A A I A A g A D A A I A A g A C A A I A A A D / / / / /  
+ / / 8 A A A A A A Q A C A A M A A g A B A A E A A Q A C A A I A A g A E A A Q A B Q A F A A M A A g A B A A I A A w A E A A M A B A A F A A Q A A g A B  
+ A A E A + f / / D / n / / w / 5 / / 8 P + f / / D / v / / w / 9 / / 8 P / / / / D / / / / w / + / / 8 P / P / / D / n / / w / 4 / / 8 P + f / / D / v /  
+ / w / 9 / / 8 P / v / / D / 7 / / w / + / / 8 P / / / / D / 3 / / w / 6 / / 8 P + P / / D / j / / w / 5 / / 8 P + / / / D / z / / w / 9 / / 8 P / v / /  
+ D / 3 / / w / 7 / / 8 P + f / / D / n / / w / 5 / / 8 P + P / / D / r / / w / 8 / / 8 P / f / / D / 3 / / w / 9 / / 8 P + / / / D / n / / w / 4 / / 8 P  
+ + P / / D / j / / w / 6 / / 8 P / f / / D / 7 / / w / / / / 8 P / / / / D / 3 / / w / 7 / / 8 P + v / / D / r / / w / 6 / / 8 P / P / / D / 3 / / w / 9  
+ / / 8 P / v / / D / 7 / / w / 8 / / 8 P + v / / D / n / / w / 5 / / 8 P + v / / D / z / / w / + / / 8 P / / / / D / / / / w / / / / 8 P / P / / D / r /  
+ / w / 6 / / 8 P + / / / D / v / / w / 8 / / 8 P / v / / D / / / / w / / / / 8 P / / / / D / 3 / / w / 8 / / 8 P / P / / D / v / / w / 7 / / 8 P / f / /  
+ D / / / / w 8 A A A A A A A A A A A A A A A D / / / 8 P / v / / D / 3 / / w / 8 / / 8 P / P / / D / / / / w 8 A A A A A A A A A A A A A A A A A A A A A  
+ / / / / D / 7 / / w / 8 / / 8 P / P / / D / z / / w / 9 / / 8 P A A A A A A A A A A A A A A A A A A A A A A A A A A D 9 / / 8 P + / / / D / v / / w / 8  
+ / / 8 P / f / / D w A A A A A A A A A A A A A A A A A A A A D / / / 8 P / v / / D / 3 / / w / 9 / / 8 P / f / / D / / / / w 8 B A A A A A g A A A A I A  
+ A A A B A A A A A Q A A A A A A A A D + / / 8 P / v / / D / 7 / / w / / / / 8 P A A A A A A I A A A A C A A A A A Q A A A A I A A A A B A A A A A A A A  
+ A A E A A A A C A A A A A w A A A A M A A A A E A A A A B g A A A A Y A A A A E A A A A A Q A A A P / / / w / 9 / / 8 P / P / / D / 3 / / w / 9 / / 8 P  
+ / P / / D / r / / w / 5 / / 8 P 9 / / / D / b / / w / 3 / / 8 P + P / / D / n / / w / 6 / / 8 P + / / / D / r / / w / 4 / / 8 P 9 v / / D / X / / w / 1  
+ / / 8 P 9 f / / D / X / / w / 3 / / 8 P + / / / D / 3 / / w / 8 / / 8 P + f / / D / b / / w / y / / 8 P 7 / / / D + / / / w / v / / 8 P 8 f / / D / T /  
+ / w / 3 / / 8 P + f / / D / v / / w / 5 / / 8 P 9 v / / D / T / / w / 0 / / 8 P 9 f / / D / b / / w / 5 / / 8 P / P / / D / 3 / / w / 8 / / 8 P / P / /  
+ D / v / / w / 5 / / 8 P + P / / D / n / / w / 6 / / 8 P / P / / D / 7 / / w / / / / 8 P A A A A A A A A A A D / / / 8 P / P / / D / v / / w / 9 / / 8 P  
+ / / / / D w A A A A A A A A A A A Q A A A A E A A A A B A A A A A A A A A P / / / w / / / / 8 P / / / / D / / / / w 8 A A A A A A g A A A A I A A A A B  
+ A A A A A Q A A A A A A A A D + / / 8 P / v / / D / / / / w 8 A A A A A A A A A A A I A A A A D A A A A A w A A A A Q A A A A C A A A A A A A A A P 7 /  
+ / w / 6 / / 8 P 9 v / / D / H / / w / t / / 8 P 6 v / / D + v / / w / t / / 8 P 7 / / / D / T / / w / + / / 8 P C A A A A B M A A A A f A A A A M Q A A  
+ A E o A A A B l A A A A g w A A A K c A A A D N A A A A 8 g A A A B A B A A A O A Q A A 4 A A A A K s A A A C J A A A A d A A A A G k A A A B b A A A A  
+ P w A A A B w A A A A B A A A A 7 P / / D + T / / w / p / / 8 P 9 f / / D w A A A A A I A A A A C g A A A A U A A A A A A A A A A A A A A A E A A A A E  
+ A A A A B w A A A A k A A A A I A A A A B Q A A A A Q A A A A C A A A A A Q A A A A A A A A A A A A A A A Q A A A A M A A A A D A A A A A w A A A A M A  
+ A A A C A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 1 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 6 "   p e n d = " 2 1 0 "   q o n s e t = " 2 5 4 "   q e n d = " 2 9 8 "   t o n s e t = " 3 0 8 "   t e n d = " 4 7 2 " > C A A H A A c A B w A I A A c A B w A H A A g A C A A J A A g A C A A I A A g A B w A H A A c A B w A G A A Y A B g A F A A Y A B g A G A A Y A B g A G  
+ A A U A B g A F A A U A B Q A E A A Q A B A A E A A Q A B A A E A A Q A B A A E A A M A B A A F A A Q A B A A E A A Q A A w A D A A M A A w A C A A M A  
+ A w A D A A M A A w A D A A I A A g A C A A I A A Q A C A A I A A g A C A A M A A w A D A A E A A Q A B A A E A A g A B A A I A A w A B A A E A A g A B  
+ A A E A A g A C A A I A A g A C A A I A A Q A B A A I A A Q A B A A E A A A A A A A A A A Q A B A A E A A A A B A A E A A A A A A A A A A Q A A A A A A  
+ A A A A A A A A A Q A A A A A A A A A B A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A  
+ A A A A A A A A A P / / / / 8 A A A A A A A A A A P / / A A A A A P / / A A A A A P / / / / 8 A A P / / / / / / / / / / / / / / / w E A A Q A D A A Q A  
+ B Q A G A A Y A B g A F A A U A B Q A G A A c A C A A H A A Y A A w A A A P 3 / + / / 6 / / j / 9 / / 2 / / T / 8 v / x / / D / 8 P / y / / P / 8 / / 0  
+ / / T / 9 f / 2 / / f / + P / 5 / / n / + v / 6 / / r / / P / 8 / / z / / P / 8 / / z / / f / 9 / / 3 / / f / 9 / / 7 / / v / + / / 3 / / f / 9 / / 7 /  
+ / v / / / w A A / / 8 A A P / / A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A E A B A A J  
+ A A 4 A E w A e A C s A N A A 1 A D E A K w A l A B w A C A D x / 9 X / s P + M / 2 z / T f 8 6 / z T / L P 8 j / z D / R v 9 N / 1 r / b v 9 x / 2 f /  
+ Z P 9 v / 3 b / a / 9 T / 0 f / U v 9 y / 6 H / y / / m / / j / A g A L A B E A E w A U A B Q A E w A T A B Q A F A A W A B c A G A A Y A B g A G A A Z  
+ A B k A G Q A Z A B k A G Q A Y A B g A G Q A Y A B g A G A A Y A B c A G A A Y A B g A F w A Y A B c A F w A Y A B g A F w A Z A B g A G Q A Z A B o A  
+ G Q A Y A B g A G A A Y A B c A G A A X A B c A F g A W A B U A F A A T A B I A E g A R A B E A E A A P A A 8 A D g A O A A 4 A D A A N A A s A C g A L  
+ A A o A C Q A J A A g A B g A F A A Q A A w A C A A A A A A D / / / 3 / + / / 5 / / j / 9 / / 2 / / X / 8 / / y / / D / 7 v / t / + z / 6 f / p / + f /  
+ 5 f / j / + D / 3 / / e / 9 r / 2 P / W / 9 X / 0 / / S / 9 D / z / / M / 8 r / y P / H / 8 b / x f / E / 8 P / w v + / / 7 7 / v P + 7 / 7 v / u / + 7  
+ / 7 z / v P + 8 / 7 3 / v / / C / 8 P / x v / J / 8 z / z / / R / 9 T / 1 / / a / 9 3 / 4 P / h / + X / 6 P / q / + 3 / 8 P / x / / P / 9 v / 2 / / n /  
+ + v / 8 / / 7 / / / 8 A A A A A A Q A B A A I A A w A E A A U A B g A H A A c A C A A H A A g A C A A I A A g A B w A H A A c A C A A H A A g A C Q A K  
+ A A o A C g A L A A s A C w A L A A s A C w A K A A o A C Q A I A A g A B w A H A A c A C A A H A A k A C A A I A A g A C A A I A A k A C g A J A A k A  
+ C A A I A A c A B w A G A A Y A B g A G A A c A B g A G A A Y A B Q A E A A U A B Q A E A A U A B Q A E A A U A B A A E A A U A B Q A F A A Q A B Q A F  
+ A A Q A B A A E A A Q A B A A D A A M A A w A D A A M A A g A C A A I A A g A C A A M A A w A D A A M A A g A D A A I A A Q A C A A I A A g A D A A Q A  
+ B A A D A A M A A g A B A A E A A g A B A A E A A Q A C A A E A A Q A B A A E A A Q A A A A A A A A A B A A E A A Q A B A A A A A A A A A A A A A A A A  
+ A A A A A A A A A A E A A A A D A A A A B A A A A A U A A A A F A A A A B Q A A A A Q A A A A C A A A A A Q A A A A I A A A A C A A A A B A A A A A U A  
+ A A A G A A A A B w A A A A g A A A A I A A A A B g A A A A Y A A A A G A A A A B w A A A A g A A A A J A A A A B w A A A A U A A A A D A A A A A g A A  
+ A A A A A A D + / / 8 P + / / / D / r / / w / 8 / / 8 P / v / / D / / / / w 8 A A A A A A A A A A A A A A A D 9 / / 8 P + / / / D / j / / w / 3 / / 8 P  
+ + v / / D / 3 / / w / + / / 8 P / / / / D w A A A A A A A A A A A A A A A P / / / w / 7 / / 8 P + f / / D / j / / w / 4 / / 8 P + f / / D / r / / w / 7  
+ / / 8 P + v / / D / n / / w / 6 / / 8 P + / / / D / 3 / / w / 9 / / 8 P / P / / D / 3 / / w / + / / 8 P / v / / D / 3 / / w / 9 / / 8 P / f / / D / 3 /  
+ / w / 9 / / 8 P / v / / D w A A A A A C A A A A B A A A A A Q A A A A B A A A A A A A A A A A A A A A A A A A A A A A A A A I A A A A E A A A A B Q A A  
+ A A Y A A A A H A A A A B g A A A A M A A A A B A A A A A Q A A A A I A A A A E A A A A B Q A A A A Y A A A A H A A A A B w A A A A U A A A A E A A A A  
+ A w A A A A I A A A A D A A A A B A A A A A Y A A A A H A A A A B w A A A A Y A A A A F A A A A A w A A A A I A A A A C A A A A A g A A A A Q A A A A E  
+ A A A A A g A A A P / / / w / 5 / / 8 P 8 v / / D + z / / w / r / / 8 P 6 / / / D + 7 / / w / 2 / / 8 P A A A A A A 0 A A A A Z A A A A I g A A A C 8 A  
+ A A B E A A A A X Q A A A H k A A A C c A A A A x g A A A O 4 A A A A S A Q A A I g E A A A I B A A D G A A A A l A A A A H M A A A B i A A A A V g A A  
+ A E E A A A A k A A A A C A A A A P P / / w / n / / 8 P 6 P / / D / H / / w / 9 / / 8 P B Q A A A A w A A A A M A A A A C A A A A A g A A A A K A A A A  
+ C w A A A A s A A A A K A A A A C Q A A A A k A A A A I A A A A C Q A A A A o A A A A L A A A A C w A A A A o A A A A I A A A A B g A A A A U A A A A F  
+ A A A A B Q A A A A Y A A A A I A A A A C Q A A A A o A A A A K A A A A C A A A A A Y A A A A G A A A A B g A A A A Y A A A A I A A A A C g A A A A o A  
+ A A A L A A A A C w A A A A k A A A A H A A A A B g A A A A Y A A A A H A A A A C Q A A A A o A A A A K A A A A C g A A A A k A A A A I A A A A B w A A  
+ A A c A A A A H A A A A B w A A A A g A A A A K A A A A C w A A A A w A A A A L A A A A C g A A A A g A A A A I A A A A C A A A A A k A A A A K A A A A  
+ D A A A A A 0 A A A A O A A A A D w A A A A 4 A A A A M A A A A C w A A A A o A A A A K A A A A D A A A A A 4 A A A A Q A A A A E A A A A B A A A A A P  
+ A A A A D Q A A A A 0 A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A J C Q / / 8 A A D 8 G g R U A A P 7 / / w / / / / 8 P / / / / D / / /  
+ / w / + / / 8 P + / / / D / r / / w / 6 / / 8 P + v / / D / z / / w / 9 / / 8 P + / / / D / n / / w / 3 / / 8 P 9 v / / D / f / / w / 3 / / 8 P 9 / / /  
+ D / j / / w / 6 / / 8 P + / / / D / n / / w / 3 / / 8 P 9 / / / D / f / / w / 2 / / 8 P 9 v / / D / f / / w / 4 / / 8 P + P / / D / j / / w / 2 / / 8 P  
+ 9 f / / D / P / / w / y / / 8 P 8 f / / D / D / / w / x / / 8 P 8 f / / D / D / / w / w / / 8 P 8 P / / D + 7 / / w / s / / 8 P 7 P / / D + r / / w / q  
+ / / 8 P 6 / / / D + v / / w / p / / 8 P 6 v / / D + 3 / / w / t / / 8 P 6 / / / D + n / / w / o / / 8 P 6 P / / D + n / / w / p / / 8 P 5 / / / D + n /  
+ / w / q / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 2 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 6 "   p e n d = " 1 9 8 "   q o n s e t = " 2 5 4 "   q e n d = " 2 9 8 "   t o n s e t = " 3 3 8 "   t e n d = " 4 8 2 " > J Q A l A C Q A J A A k A C M A I w A j A C I A I g A i A C I A I g A h A C A A H w A g A B 8 A H w A e A B 4 A H g A d A B 0 A G w A b A B w A G w A b  
+ A B o A G g A a A B k A G Q A X A B c A F g A W A B Y A F g A V A B U A F Q A W A B Q A E w A U A B I A E w A R A B I A E Q A R A B A A D w A P A A 8 A  
+ D w A P A A 4 A D g A O A A 4 A D Q A N A A 0 A D A A N A A w A D A A L A A s A C w A K A A o A C Q A K A A o A C g A K A A k A C A A I A A g A C A A I  
+ A A g A B w A H A A g A C A A I A A c A C A A H A A c A B w A H A A c A B w A G A A c A B w A G A A Y A B g A G A A Y A B g A G A A Y A B g A F A A Y A  
+ B Q A F A A U A B g A F A A U A B Q A F A A U A B Q A E A A Q A B Q A E A A Q A B A A F A A M A B A A D A A M A B A A E A A Q A B A A E A A Q A B A A E  
+ A A M A A w A D A A I A A w A D A A M A B A A D A A Q A B A A E A A M A A g A C A A I A A w A D A A M A A w A D A A M A A w A F A A U A C A A K A A 0 A  
+ E Q A T A B U A F w A Y A B s A H w A j A C c A L A A u A C 4 A L Q A r A C k A J g A h A B 4 A G w A X A B M A D g A K A A Y A B Q A E A A Q A A w A E  
+ A A Q A A w A E A A M A A Q A B A A A A A A D / / / / / / / / / / / 7 / / / / + / / 3 / / f / 9 / / 7 / / f / + / / 7 / / v / 9 / / 3 / / f / 9 / / 3 /  
+ / f / 9 / / 3 / / f / 9 / / z / / f / 8 / / z / / f / 9 / / 3 / / f / 9 / / 7 / / f / + / / 7 / / / / / / / / / / / 8 A A A A A A A A C A A M A B g A P  
+ A B o A J w A 7 A F U A Z w B w A H U A d Q B 0 A G 0 A V w A u A O r / l P 8 z / 8 r + a v 4 N / r T 9 d P 1 S / U f 9 N f 0 d / R v 9 E f 3 v / N f 8  
+ 6 P w p / Y b 9 3 v 0 p / m z + r f 7 3 / k j / m P / W / / r / C g A a A C g A M g A 4 A D s A P A A 9 A D 4 A Q Q B H A E w A U w B X A F c A W A B X  
+ A F o A X A B g A G U A a A B q A G s A a Q B p A G s A b A B t A G 8 A b w B x A H E A c Q B y A H Q A d A B 3 A H k A e g B 9 A H 8 A g A C B A I I A  
+ g w C F A I c A i A C L A I w A j g C R A J E A l A C W A J c A m g C c A J 4 A o Q C j A K Y A q Q C q A K 0 A r w C x A L U A u A C 7 A M A A w w D G  
+ A M g A y g D N A M 8 A 0 g D W A N o A 3 A D e A O A A 4 g D l A O g A 6 g D s A O 8 A 8 g D 1 A P k A / A D / A A A B A w E F A Q g B C g E N A Q 8 B  
+ E g E U A R U B F w E Y A R k B G g E a A R w B H g E d A R 8 B H w E e A R 8 B H w E g A S A B I Q E i A S E B I g E i A S I B I A E g A R 4 B H Q E c  
+ A R k B F w E V A R E B D A E H A Q I B + w D 1 A O 8 A 6 Q D i A N s A 0 w D K A M A A u A C w A K g A o Q C Z A J A A i A C A A H g A c A B p A G Q A  
+ X w B Z A F U A U A B K A E Y A Q g B A A D 0 A O g A 5 A D c A N Q A y A D E A L g A t A C w A K w A q A C k A K Q A p A C g A K A A o A C g A K A A o  
+ A C g A K Q A p A C k A K Q A p A C g A K A A n A C Y A J Q A k A C U A J A A k A C Q A J A A k A C Q A I w A j A C M A I w A j A C M A J A A k A C M A  
+ I w A h A C E A I A A g A B 8 A H g A e A B w A H Q A b A B s A G w A a A B o A G Q A Y A B g A G A A W A B Y A F Q A U A B Q A F A A T A B M A E w A U  
+ A B I A E g A R A B E A E A A P A A 8 A D w A O A A 4 A D Q A N A A 0 A D A A M A A w A C w A M A A s A C w A L A A s A C g A K A A o A C g A K A A o A  
+ C g A K A A k A C Q A J A A g A C A A H A A g A B w A H A A g A B w A H A A Y A B w A G A A Y A B g A G A A c A B w A H A A c A B w A H A A Y A B g A G  
+ A A Y A 9 P / / D / X / / w / 1 / / 8 P 8 / / / D / P / / w / 1 / / 8 P + P / / D / r / / w / 6 / / 8 P + / / / D / v / / w / 7 / / 8 P / P / / D / 3 /  
+ / w / + / / 8 P / / / / D / / / / w / + / / 8 P / P / / D / / / / w 8 B A A A A A g A A A A I A A A A D A A A A B Q A A A A Y A A A A G A A A A B g A A  
+ A A Q A A A A F A A A A B A A A A A M A A A A D A A A A B Q A A A A Y A A A A H A A A A C A A A A A g A A A A H A A A A B g A A A A Y A A A A F A A A A  
+ B g A A A A Y A A A A I A A A A C Q A A A A o A A A A J A A A A C A A A A A c A A A A F A A A A B g A A A A c A A A A H A A A A B w A A A A g A A A A H  
+ A A A A B g A A A A c A A A A I A A A A B g A A A A U A A A A F A A A A B g A A A A c A A A A J A A A A C Q A A A A g A A A A H A A A A B Q A A A A U A  
+ A A A F A A A A B g A A A A g A A A A J A A A A C w A A A A 0 A A A A Q A A A A E Q A A A A 8 A A A A J A A A A A g A A A P z / / w / 0 / / 8 P 6 f / /  
+ D 9 7 / / w / T / / 8 P x P / / D 7 D / / w + f / / 8 P j / / / D 4 H / / w 9 2 / / 8 P a / / / D 2 f / / w + A / / 8 P r P / / D 8 / / / w / q / / 8 P  
+ A A A A A B Q A A A A k A A A A M Q A A A D o A A A A + A A A A P A A A A D Q A A A A m A A A A G A A A A A 4 A A A A F A A A A / v / / D / v / / w / 9  
+ / / 8 P A A A A A A A A A A D + / / 8 P / f / / D / v / / w / 6 / / 8 P + / / / D / z / / w / 8 / / 8 P + / / / D / v / / w / 7 / / 8 P + / / / D / r /  
+ / w / 4 / / 8 P + P / / D / n / / w / 4 / / 8 P 9 / / / D / j / / w / 5 / / 8 P + v / / D / n / / w / 4 / / 8 P 9 v / / D / X / / w / 1 / / 8 P 9 f / /  
+ D / X / / w / 1 / / 8 P 9 v / / D / f / / w / 4 / / 8 P 9 / / / D / X / / w / 0 / / 8 P 8 / / / D / P / / w / z / / 8 P 8 / / / D / P / / w / y / / 8 P  
+ 8 f / / D / L / / w / x / / 8 P 7 / / / D + 7 / / w / u / / 8 P 6 / / / D + v / / w / t / / 8 P 7 / / / D + / / / w / u / / 8 P 7 P / / D + v / / w / p  
+ / / 8 P 6 P / / D + f / / w / o / / 8 P 6 f / / D + r / / w / p / / 8 P 6 f / / D + j / / w / m / / 8 P 5 P / / D + P / / w / k / / 8 P 4 / / / D + T /  
+ / w / l / / 8 P 4 / / / D + H / / w / f / / 8 P 3 / / / D 9 3 / / w / a / / 8 P 2 v / / D 9 r / / w / a / / 8 P 2 v / / D 9 n / / w / Z / / 8 P 1 / / /  
+ D 9 b / / w / U / / 8 P 0 f / / D 9 H / / w / T / / 8 P 0 / / / D 9 L / / w / R / / 8 P 0 P / / D 8 7 / / w / M / / 8 P y v / / D 8 f / / w / G / / 8 P  
+ x f / / D 8 X / / w / F / / 8 P x P / / D 8 L / / w + / / / 8 P v P / / D 7 r / / w + 6 / / 8 P u v / / D 7 j / / w + 3 / / 8 P t / / / D 7 j / / w + 3  
+ / / 8 P t f / / D 7 P / / w + y / / 8 P s f / / D 6 / / / w + w / / 8 P s P / / D 6 / / / w + v / / 8 P r f / / D 6 v / / w + o / / 8 P p / / / D 6 j /  
+ / w + p / / 8 P q v / / D 6 v / / w + s / / 8 P r P / / D 6 z / / w + t / / 8 P r / / / D 7 D / / w + y / / 8 P t P / / D 7 b / / w + 6 / / 8 P v v / /  
+ D 8 H / / w / E / / 8 P x f / / D 8 f / / w / L / / 8 P z v / / D 9 H / / w / U / / 8 P 1 / / / D 9 r / / w / e / / 8 P 4 P / / D + H / / w / j / / 8 P  
+ 5 P / / D + b / / w / o / / 8 P 6 / / / D + / / / w / y / / 8 P 8 / / / D / T / / w / 0 / / 8 P 8 / / / D / H / / w / 0 / / 8 P 9 / / / D / j / / w / 6  
+ / / 8 P / f / / D / / / / w 8 A A A A A A A A A A A A A A A A A A A A A A Q A A A A E A A A A A A A A A A A A A A A A A A A A A A A A A / / / / D / 3 /  
+ / w / 7 / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 3 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 4 "   p e n d = " 2 0 8 "   q o n s e t = " 2 5 4 "   q e n d = " 2 9 8 "   t o n s e t = " 3 4 2 "   t e n d = " 4 8 4 " > K w A p A C o A K Q A p A C g A K A A n A C c A J w A n A C c A J g A l A C Q A I w A j A C Q A I w A j A C M A I g A i A C E A I A A f A B 4 A H w A e  
+ A B 4 A H Q A d A B s A G g A Z A B k A G g A Y A B k A G A A Y A B c A F w A W A B U A F A A U A B Q A E w A T A B I A E A A Q A B A A D w A O A A 4 A  
+ D g A N A A 0 A D Q A O A A w A D Q A M A A s A C w A M A A s A C w A L A A s A C w A J A A k A C A A J A A k A C A A J A A g A C A A H A A c A B g A G  
+ A A Y A B w A G A A c A B w A H A A Y A B w A G A A Y A B w A G A A Y A B g A G A A c A B g A G A A U A B g A F A A Y A B g A G A A U A B A A E A A Q A  
+ B Q A E A A Q A B A A E A A U A B Q A F A A U A B Q A F A A Q A B A A F A A Q A B A A E A A M A A w A D A A Q A A w A D A A Q A B A A E A A Q A B A A D  
+ A A Q A A w A D A A M A A w A D A A M A B A A E A A Q A B A A E A A M A A w A E A A Q A B A A G A A U A B Q A D A A Q A B A A E A A U A B g A H A A k A  
+ C w A N A A 4 A E Q A T A B Y A G g A e A C I A J g A o A C c A J w A l A C I A H w A d A B o A G A A W A B M A D w A L A A g A B w A G A A U A B Q A F  
+ A A U A B Q A D A A M A A A A A A P / / / f / 9 / / 3 / / P / 7 / / v / / P / 8 / / v / / P / 8 / / 3 / / P / 8 / / z / / f / 8 / / v / + / / 7 / / z /  
+ + / / 7 / / z / / P / 8 / / z / / P / 8 / / z / / P / 8 / / z / / P / 9 / / 3 / / f / + / / 7 / / / / + / / / / A A A A A A A A A Q A B A A E A A g A F  
+ A A s A E g A c A C g A M w A 4 A D w A Q Q B I A F w A e g C M A I A A Y w B J A C U A 9 / + + / 3 z / U P 8 9 / x r / 4 f 6 o / m L + B f 6 P / S X 9  
+ C / 0 / / Z f 9 9 v 1 N / p 7 + 6 P 4 p / 2 r / q / / g / w I A F Q A k A C 8 A N Q A 5 A D 0 A Q A B D A E Y A S A B L A E 8 A U w B X A F o A W w B d  
+ A F 8 A Y A B i A G Y A a Q B r A G 0 A b g B v A H A A c Q B y A H M A d w B 5 A H o A e w B 9 A H 8 A g A C C A I U A i A C K A I 4 A k A C S A J Q A  
+ l Q C W A J o A n A C f A K M A p Q C o A K o A q w C t A K 8 A s A C 0 A L c A u w C + A M E A x A D H A M o A z Q D Q A N M A 1 w D a A N 8 A 4 w D m  
+ A O k A 7 A D v A P M A 9 g D 6 A P 8 A A w E G A Q k B D Q E R A R Q B F w E c A S A B I w E p A S 0 B M A E 1 A T k B P A F B A U U B S Q F N A V E B  
+ V Q F Z A V w B X w F j A W Y B a A F r A W 4 B c Q F 0 A X Y B e A F 6 A X w B f Q F / A Y I B h A G G A Y k B i g G L A Y w B j Q G M A Y w B j A G L  
+ A Y o B h w G C A X 0 B d g F u A W c B X Q F U A U s B Q A E 1 A S k B H A E Q A Q Q B 9 g D r A O A A 1 A D I A L 0 A s A C m A J w A l A C K A I E A  
+ e Q B w A G k A Z A B d A F k A U w B O A E o A R Q B D A E E A P w A 9 A D o A O A A 1 A D M A M Q A w A C 8 A L w A u A C 4 A L g A u A C 0 A L Q A t  
+ A C 0 A L g A u A C 4 A L g A u A C 4 A L g A t A C w A L A A s A C s A K w A r A C o A K w A q A C o A K g A o A C g A K A A o A C g A K A A n A C c A  
+ J w A m A C Q A J A A j A C M A I g A h A C A A H w A e A B 4 A H Q A d A B w A H A A b A B o A G g A Z A B g A G A A W A B Y A F g A W A B Y A F A A V  
+ A B Q A E w A S A B E A E A A Q A A 8 A D w A P A A 4 A D Q A N A A w A C w A L A A w A D A A L A A s A C w A K A A k A C Q A K A A k A C Q A J A A k A  
+ C Q A J A A g A C A A H A A c A C A A G A A Y A B w A H A A Y A B g A F A A U A B Q A F A A U A B Q A G A A U A B Q A G A A Y A B g A G A A U A B Q A F  
+ A A U A / v / / D / 7 / / w / / / / 8 P / v / / D / 3 / / w / + / / 8 P / / / / D / 3 / / w / 7 / / 8 P / P / / D / 3 / / w / 9 / / 8 P / v / / D / 7 /  
+ / w / + / / 8 P / f / / D / z / / w / 7 / / 8 P + v / / D / n / / w / 5 / / 8 P + f / / D / n / / w / 7 / / 8 P / f / / D / v / / w / 5 / / 8 P + P / /  
+ D / f / / w / 4 / / 8 P + f / / D / n / / w / 4 / / 8 P + P / / D / n / / w / 7 / / 8 P + f / / D / b / / w / 1 / / 8 P 9 P / / D / T / / w / 0 / / 8 P  
+ 9 f / / D / X / / w / 0 / / 8 P 8 v / / D / D / / w / u / / 8 P 7 f / / D + 3 / / w / t / / 8 P 7 v / / D + / / / w / v / / 8 P 7 v / / D + 3 / / w / t  
+ / / 8 P 7 P / / D + z / / w / s / / 8 P 6 / / / D + v / / w / s / / 8 P 7 P / / D + r / / w / q / / 8 P 6 f / / D + j / / w / m / / 8 P 5 P / / D + T /  
+ / w / m / / 8 P 5 / / / D + b / / w / k / / 8 P 4 / / / D + D / / w / e / / 8 P 3 P / / D 9 v / / w / b / / 8 P 3 P / / D 9 z / / w / c / / 8 P 3 P / /  
+ D 9 v / / w / Y / / 8 P 1 v / / D 9 X / / w / V / / 8 P 1 P / / D 9 T / / w / U / / 8 P 0 / / / D 9 L / / w / P / / 8 P z f / / D 8 v / / w / I / / 8 P  
+ x v / / D 8 b / / w / F / / 8 P x P / / D 8 T / / w / D / / 8 P w P / / D 7 / / / w + 9 / / 8 P u v / / D 7 j / / w + 4 / / 8 P u f / / D 7 f / / w + 1  
+ / / 8 P t P / / D 7 T / / w + y / / 8 P s f / / D 6 / / / w + t / / 8 P r P / / D 6 z / / w + s / / 8 P r P / / D 6 v / / w + q / / 8 P q v / / D 6 f /  
+ / w + m / / 8 P p f / / D 6 T / / w + l / / 8 P q P / / D 6 n / / w + p / / 8 P q v / / D 6 r / / w + p / / 8 P q v / / D 6 3 / / w + w / / 8 P s / / /  
+ D 7 b / / w + 6 / / 8 P v f / / D 7 / / / w / C / / 8 P x P / / D 8 b / / w / J / / 8 P z P / / D 8 / / / w / T / / 8 P 2 P / / D 9 r / / w / d / / 8 P  
+ 3 / / / D + H / / w / k / / 8 P 5 v / / D + j / / w / r / / 8 P 7 v / / D / H / / w / y / / 8 P 8 / / / D / X / / w / 2 / / 8 P 9 v / / D / f / / w / 5  
+ / / 8 P + / / / D / z / / w / 9 / / 8 P / v / / D / 7 / / w / 8 / / 8 P + / / / D / z / / w / + / / 8 P A A A A A A I A A A A E A A A A B Q A A A A Y A  
+ A A A F A A A A B A A A A A M A A A A B A A A A A A A A A A A A A A A A A A A A A A A A A P / / / w / / / / 8 P / / / / D / 7 / / w / 9 / / 8 P / f / /  
+ D w A A A A A A A A A A A Q A A A A I A A A A D A A A A B A A A A A U A A A A E A A A A A Q A A A A A A A A A A A A A A A Q A A A A E A A A A D A A A A  
+ A w A A A A I A A A A B A A A A A Q A A A A A A A A A A A A A A A A A A A A E A A A A C A A A A A g A A A A E A A A A D A A A A B Q A A A A Q A A A A C  
+ A A A A A Q A A A A E A A A A A A A A A A A A A A A E A A A A C A A A A A Q A A A A E A A A A B A A A A A A A A A P / / / w / / / / 8 P A A A A A A E A  
+ A A A C A A A A A g A A A A I A A A A C A A A A A Q A A A A A A A A D / / / 8 P A A A A A A A A A A A A A A A A A g A A A A Q A A A A D A A A A A g A A  
+ A A I A A A A B A A A A A A A A A A A A A A A A A A A A A A A A A A I A A A A D A A A A A w A A A A I A A A A A A A A A A A A A A A A A A A A A A A A A  
+ A A A A A A E A A A A C A A A A A w A A A A M A A A A D A A A A A g A A A A E A A A A A A A A A A A A A A A E A A A A B A A A A A w A A A A U A A A A E  
+ A A A A B A A A A A Q A A A A D A A A A A Q A A A A E A A A A D A A A A A w A A A A M A A A A D A A A A B Q A A A A U A A A A E A A A A A w A A A A M A  
+ A A A C A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 4 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 6 8 "   p e n d = " 2 1 4 "   q o n s e t = " 2 5 8 "   q e n d = " 2 9 8 "   t o n s e t = " 3 3 4 "   t e n d = " 4 8 2 " > H A A a A B o A G Q A Z A B g A G A A Z A B g A G A A Z A B g A G A A Z A B c A F g A W A B Y A F g A W A B U A F A A U A B M A E w A T A B M A E g A S  
+ A B I A E g A Q A A 8 A D w A P A A 8 A E A A Q A A 8 A E A A Q A A 4 A D g A O A A 4 A D g A O A A 0 A D A A M A A s A C w A K A A k A C A A I A A g A  
+ B w A G A A Y A B Q A F A A U A B Q A G A A U A B g A H A A Y A B g A G A A U A B A A E A A U A B Q A F A A U A B Q A F A A U A B Q A D A A Q A A w A D  
+ A A I A A g A C A A M A B A A F A A Q A B A A F A A Q A B Q A E A A Q A B A A D A A M A A w A D A A M A A g A D A A M A A g A C A A I A A Q A C A A I A  
+ A g A C A A M A A w A D A A I A A w A C A A M A B A A E A A M A A w A D A A M A A g A B A A E A A Q A B A A I A A w A D A A M A B Q A E A A Q A A w A C  
+ A A I A A g A C A A I A A g A C A A I A A w A D A A M A A g A D A A I A A w A D A A Q A B A A E A A U A B Q A E A A U A B Q A E A A M A B A A E A A Y A  
+ C A A K A A 0 A D g A R A B M A F g A a A B 0 A H g A g A B 8 A H Q A d A B o A G Q A X A B U A F Q A U A B I A E A A O A A w A C w A J A A k A B w A H  
+ A A c A B w A G A A U A A w A B A P / / / v / + / / 7 / / v / 9 / / 3 / / f / 8 / / v / + / / 8 / / z / / f / 9 / / / / / v / 8 / / z / / f / 8 / / 3 /  
+ / f / 8 / / z / / P / 7 / / v / / P / 8 / / z / / P / 8 / / z / + / / 8 / / 3 / / f / 9 / / 7 / / / / / / / / / A A A A A P / / / / 8 A A A A A A A D /  
+ / / / / / / / + / / v / + P / 3 / / j / / P 8 N A D U A c g C 0 A O 8 A N Q F 9 A b 4 B / Q E z A m s C r A L S A q 8 C S g K / A f 0 A 9 P / V / i n +  
+ G f 5 K / o f + w P 7 5 / j L / Y v + N / 7 f / 3 v / 9 / w s A F Q A d A C A A I Q A j A C Q A J w A p A C k A K w A r A C w A L w A x A D I A N Q A 2  
+ A D c A O A A 5 A D s A P A A + A E A A Q Q B C A E M A R A B E A E c A S Q B L A E 0 A T g B P A F A A U Q B S A F Q A V g B Z A F s A X g B f A G E A  
+ Y g B k A G Y A a A B r A G 0 A b g B x A H I A d A B 2 A H k A e w B 9 A I A A g w C F A I c A i w C O A J E A l Q C X A J o A n g C h A K U A q Q C t  
+ A L A A s w C 2 A L k A v g D D A M g A z Q D R A N U A 2 g D e A O M A 5 w D r A O 8 A 9 A D 6 A P 8 A B A E K A R A B F g E b A S E B J Q E r A T E B  
+ N w E 9 A U M B S Q F P A V Q B W g F f A W Q B a Q F u A X M B e A F 8 A Y E B h Q G L A Z E B l Q G Z A Z 0 B o A G j A a Y B q A G r A a 0 B r g G u  
+ A a 0 B q g G l A a A B m A G O A Y Q B e Q F t A W I B V g F I A T s B K w E c A Q 0 B / g D x A O Q A 1 w D K A L 4 A s Q C m A J o A j w C F A H 0 A  
+ d Q B t A G M A X Q B V A E 8 A S g B G A E I A P w A 7 A D k A N w A 0 A D M A M Q A u A C 0 A K g A n A C U A J Q A k A C M A I w A i A C A A I A A g  
+ A C E A I A A i A C I A I Q A i A C E A I A A f A B 4 A H Q A d A B w A H A A b A B s A G w A a A B k A G Q A Y A B c A G A A Y A B g A G Q A Z A B g A  
+ G A A X A B Y A F g A W A B U A F A A T A B M A E w A T A B I A E Q A Q A B A A D w A Q A B A A D w A N A A 0 A D Q A M A A 0 A D g A N A A w A D Q A N  
+ A A 0 A D A A L A A o A C Q A J A A k A C A A I A A c A B w A H A A Y A B g A F A A Q A B A A G A A U A B Q A E A A Q A B g A F A A U A B g A G A A Y A  
+ B g A F A A U A B Q A E A A U A B A A F A A Q A B Q A E A A M A A Q A A A A A A A A A A A A I A B A A E A A Q A B Q A E A A Q A B A A D A A M A A g A D  
+ A A Q A 6 f / / D + n / / w / n / / 8 P 5 f / / D + T / / w / i / / 8 P 3 / / / D 9 7 / / w / f / / 8 P 3 / / / D 9 7 / / w / g / / 8 P 3 / / / D 9 7 /  
+ / w / c / / 8 P 2 v / / D 9 j / / w / W / / 8 P 1 v / / D 9 f / / w / X / / 8 P 1 v / / D 9 T / / w / R / / 8 P z / / / D 8 3 / / w / M / / 8 P y / / /  
+ D 8 r / / w / J / / 8 P y P / / D 8 f / / w / G / / 8 P x f / / D 8 L / / w / A / / 8 P v v / / D 7 3 / / w + 9 / / 8 P v f / / D 7 z / / w + 6 / / 8 P  
+ t / / / D 7 b / / w + 1 / / 8 P t f / / D 7 P / / w + x / / 8 P s P / / D 6 / / / w + w / / 8 P r / / / D 6 / / / w + u / / 8 P r f / / D 6 v / / w + r  
+ / / 8 P q v / / D 6 r / / w + q / / 8 P q v / / D 6 z / / w + s / / 8 P r P / / D 6 z / / w + s / / 8 P r f / / D 6 / / / w + x / / 8 P t P / / D 7 f /  
+ / w + 5 / / 8 P u / / / D 7 3 / / w + / / / 8 P w P / / D 8 P / / w / I / / 8 P z P / / D 9 D / / w / U / / 8 P 2 P / / D 9 z / / w / e / / 8 P 3 / / /  
+ D + L / / w / k / / 8 P 5 f / / D + f / / w / p / / 8 P 8 P / / D / T / / w / 2 / / 8 P + P / / D / n / / w / 4 / / 8 P + P / / D / n / / w / 5 / / 8 P  
+ + v / / D / z / / w / + / / 8 P / v / / D / 7 / / w / / / / 8 P / / / / D / / / / w 8 A A A A A A g A A A A Q A A A A F A A A A B w A A A A k A A A A J  
+ A A A A B w A A A A U A A A A D A A A A A g A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A E A  
+ A A A D A A A A B Q A A A A Y A A A A I A A A A C g A A A A g A A A A G A A A A B Q A A A A Q A A A A E A A A A A w A A A A M A A A A E A A A A B Q A A  
+ A A U A A A A E A A A A A w A A A A E A A A A A A A A A A Q A A A A M A A A A E A A A A B A A A A A U A A A A F A A A A B Q A A A A Q A A A A C A A A A  
+ A A A A A A E A A A A C A A A A B A A A A A M A A A A C A A A A A g A A A A I A A A A B A A A A A A A A A A E A A A A C A A A A A w A A A A Q A A A A E  
+ A A A A B A A A A A Q A A A A E A A A A A w A A A A M A A A A E A A A A A g A A A A I A A A A E A A A A B g A A A A Y A A A A G A A A A B Q A A A A U A  
+ A A A E A A A A B A A A A A Q A A A A E A A A A B Q A A A A Y A A A A G A A A A B g A A A A Q A A A A E A A A A B A A A A A Y A A A A H A A A A C A A A  
+ A A k A A A A L A A A A D g A A A A 4 A A A A M A A A A C Q A A A A c A A A A F A A A A B g A A A A Y A A A A G A A A A B g A A A A Y A A A A F A A A A  
+ B A A A A A M A A A A C A A A A A g A A A A I A A A A C A A A A A w A A A A Q A A A A E A A A A A w A A A A M A A A A C A A A A A w A A A A M A A A A C  
+ A A A A A g A A A A M A A A A D A A A A B Q A A A A Y A A A A G A A A A B Q A A A A M A A A A C A A A A A g A A A A I A A A A E A A A A B Q A A A A Q A  
+ A A A F A A A A B g A A A A Y A A A A E A A A A A w A A A A M A A A A E A A A A B A A A A A Y A A A A H A A A A B g A A A A U A A A A F A A A A B Q A A  
+ A A Q A A A A E A A A A A w A A A A Q A A A A G A A A A C A A A A A g A A A A H A A A A B w A A A A U A A A A E A A A A B A A A A A Q A A A A F A A A A  
+ B w A A A A g A A A A I A A A A B w A A A A U A A A A F A A A A B g A A A A U A A A A E A A A A B Q A A A A g A A A A J A A A A C A A A A A c A A A A H  
+ A A A A B g A A A A U A A A A F A A A A B g A A A A U A A A A F A A A A B g A A A A Y A A A A H A A A A B w A A A A U A A A A F A A A A B g A A A A Y A  
+ A A A H A A A A < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 5 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 7 2 "   p e n d = " 2 1 6 "   q o n s e t = " 2 5 4 "   q e n d = " 2 9 6 "   t o n s e t = " 3 7 0 "   t e n d = " 4 8 6 " > C g A J A A g A C A A H A A g A B w A H A A c A B w A H A A c A C A A H A A c A B g A G A A Y A B g A G A A Y A B g A G A A U A B g A G A A U A B g A G  
+ A A Y A B Q A F A A U A B A A F A A U A B Q A F A A U A B g A G A A Y A B Q A F A A U A B Q A F A A U A B Q A E A A U A A w A D A A I A A Q A B A A E A  
+ A Q A A A A E A A A A B A A E A A Q A A A A A A A Q A D A A I A A g A C A A I A A Q A A A A E A A Q A B A A E A A A A B A A E A A Q A B A A E A A A A A  
+ A A A A A Q A B A A E A A Q A C A A E A A g A B A A I A A Q A B A A E A A A A B A A E A A Q A B A A E A A Q A C A A I A A g A B A A I A A Q A C A A E A  
+ A A A C A A I A A g A C A A I A A w A C A A I A A w A C A A I A A g A D A A I A A g A C A A I A A g A C A A I A A w A D A A M A A w A E A A Q A B A A D  
+ A A I A A g A C A A M A A w A C A A I A A w A D A A M A A w A D A A Q A B A A E A A Q A B Q A F A A Y A B Q A E A A Q A B A A E A A M A B A A F A A Q A  
+ B w A I A A k A C g A M A A 8 A E Q A U A B U A F w A Y A B g A F w A X A B c A F w A U A B Q A F A A U A B M A E Q A R A B A A D w A O A A 4 A D g A O  
+ A A 4 A D Q A M A A o A C A A G A A Q A A w A C A A E A A A A A A P 7 / / / / + / / 7 / / v / + / / 7 / / v / / / w A A A A D / / / 7 / / v / / / / 7 /  
+ / / / / / / / / / v / + / / 3 / / f / 9 / / 7 / / v / + / / / / / / 8 A A P / / / / / / / / / / A A A A A A A A A A A A A A A A A A A A A A A A / v / 8  
+ / / j / 9 P / s / + D / 1 / / S / 9 L / 2 P / n / w c A O Q B y A L E A / g B Q A Z 8 B 7 g E y A n M C t A L b A r s C X g L p A V c B n A D l / 3 n /  
+ W P 9 X / 2 H / b / + E / 6 D / u v / R / + b / + f 8 F A A 0 A E Q A T A B Q A E w A T A B Q A F Q A V A B Q A F A A V A B U A F g A X A B c A G A A Z  
+ A B k A G g A b A B w A H g A f A B 8 A I A A h A C E A I Q A i A C M A J Q A m A C c A K A A o A C o A K g A s A C 0 A L g A w A D E A M w A 1 A D Y A  
+ N w A 3 A D k A O g A 8 A D 0 A P g B A A E E A Q g B D A E Q A R Q B F A E g A S g B L A E 4 A T w B R A F M A V Q B X A F g A W w B e A G E A Z A B l  
+ A G k A a w B t A G 8 A c g B 2 A H o A f Q B / A I I A h A C H A I o A j Q C R A J Q A m Q C e A K I A p Q C p A K 0 A s g C 3 A L s A w Q D G A M o A  
+ z w D T A N g A 3 g D i A O c A 7 Q D w A P U A + Q D + A A I B B g E K A Q 4 B E g E W A R s B H g E i A S Y B K Q E s A S 8 B M A E y A T M B N Q E 1  
+ A T U B N A E x A S w B J g E f A R Y B D g E G A f 0 A 9 Q D s A O I A 1 w D K A M A A t Q C q A K I A m A C Q A I Y A e w B z A G o A Y g B c A F Y A  
+ U A B J A E M A P g A 6 A D Q A M Q A u A C o A K A A m A C M A I Q A e A B 0 A G w A Z A B g A F g A T A B M A E Q A Q A B A A D w A O A A 4 A D g A O  
+ A A 4 A D w A P A A 8 A D w A P A A 4 A D g A N A A w A C w A L A A s A C g A L A A s A C g A K A A o A C Q A K A A o A C g A K A A s A C w A M A A s A  
+ C w A L A A o A C g A K A A o A C Q A J A A o A C Q A J A A g A C A A I A A c A C A A I A A g A C Q A H A A g A B w A H A A c A B w A H A A c A B w A I  
+ A A c A B w A H A A Y A B g A G A A Y A B Q A G A A U A B A A F A A Q A B A A E A A Q A B A A E A A Q A A w A D A A M A A w A E A A Q A B Q A F A A Y A  
+ B Q A F A A U A B A A E A A Q A B A A D A A I A A w A D A A M A A g A B A A E A A g A C A A I A A w A E A A U A B A A E A A Q A B A A E A A Q A A w A E  
+ A A Q A 1 P / / D 9 f / / w / Z / / 8 P 2 / / / D 9 3 / / w / g / / 8 P 4 / / / D + b / / w / r / / 8 P 7 v / / D / D / / w / x / / 8 P 8 v / / D / L /  
+ / w / 0 / / 8 P 9 f / / D / b / / w / 5 / / 8 P + / / / D / z / / w / 9 / / 8 P / v / / D / / / / w / / / / 8 P / / / / D / / / / w 8 B A A A A B Q A A  
+ A A Y A A A A G A A A A B g A A A A Y A A A A F A A A A A w A A A A E A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A  
+ A A A A A A A A A A A A A A A A A Q A A A A E A A A A D A A A A B Q A A A A U A A A A F A A A A B Q A A A A M A A A A C A A A A A g A A A A I A A A A D  
+ A A A A A w A A A A M A A A A D A A A A A w A A A A E A A A A A A A A A A A A A A A E A A A A B A A A A A Q A A A A E A A A A C A A A A B A A A A A Q A  
+ A A A C A A A A A Q A A A A A A A A A A A A A A A A A A A A I A A A A D A A A A A w A A A A M A A A A E A A A A A w A A A A M A A A A D A A A A A g A A  
+ A A M A A A A D A A A A A w A A A A Q A A A A G A A A A B g A A A A U A A A A E A A A A B A A A A A Q A A A A E A A A A B A A A A A U A A A A G A A A A  
+ B w A A A A Y A A A A G A A A A B Q A A A A Q A A A A F A A A A B g A A A A Q A A A A F A A A A C A A A A A k A A A A H A A A A B g A A A A Y A A A A H  
+ A A A A B g A A A A Y A A A A G A A A A B g A A A A Y A A A A H A A A A C A A A A A c A A A A F A A A A B A A A A A U A A A A G A A A A B g A A A A Y A  
+ A A A H A A A A B w A A A A c A A A A H A A A A B w A A A A c A A A A G A A A A B A A A A A Y A A A A H A A A A B w A A A A Y A A A A I A A A A C A A A  
+ A A c A A A A F A A A A B A A A A A U A A A A F A A A A B g A A A A c A A A A F A A A A B g A A A A c A A A A H A A A A B Q A A A A Y A A A A G A A A A  
+ B g A A A A c A A A A I A A A A C A A A A A k A A A A J A A A A C A A A A A c A A A A G A A A A B g A A A A g A A A A J A A A A C A A A A A k A A A A K  
+ A A A A C g A A A A g A A A A H A A A A B g A A A A Y A A A A H A A A A C A A A A A g A A A A H A A A A B w A A A A g A A A A J A A A A B w A A A A Y A  
+ A A A G A A A A B w A A A A c A A A A H A A A A B Q A A A A U A A A A E A A A A A w A A A A I A A A A B A A A A A w A A A A U A A A A H A A A A C A A A  
+ A A k A A A A H A A A A B g A A A A Q A A A A D A A A A A g A A A A E A A A A A A A A A / / / / D / 3 / / w / 8 / / 8 P / f / / D / 7 / / w / 9 / / 8 P  
+ / P / / D / v / / w / 6 / / 8 P + f / / D / r / / w / 8 / / 8 P / P / / D / v / / w / 8 / / 8 P / v / / D w A A A A A A A A A A A A A A A P / / / w 8 A  
+ A A A A A g A A A A I A A A A B A A A A A A A A A A A A A A A A A A A A A Q A A A A M A A A A G A A A A B w A A A A k A A A A L A A A A C g A A A A o A  
+ A A A K A A A A C g A A A A k A A A A I A A A A C A A A A A o A A A A L A A A A C w A A A A s A A A A L A A A A C g A A A A o A A A A K A A A A C Q A A  
+ A A o A A A A K A A A A C g A A A A w A A A A N A A A A D Q A A A A w A A A A L A A A A C g A A A A k A A A A K A A A A C g A A A A o A A A A L A A A A  
+ C w A A A A s A A A A K A A A A C A A A A A c A A A A H A A A A C A A A A A k A A A A J A A A A C g A A A A o A A A A J A A A A C Q A A A A g A A A A I  
+ A A A A B w A A A A c A A A A J A A A A C w A A A A 0 A A A A O A A A A E A A A A B A A A A A O A A A A C w A A A A c A A A A D A A A A / v / / D / X /  
+ / w / q / / 8 P < / r e p b e a t > < r e p b e a t   l e a d n a m e = " V 6 "   d u r a t i o n = " 1 2 0 0 "   p o n s e t = " 1 7 0 "   p e n d = " 2 1 6 "   q o n s e t = " 2 5 6 "   q e n d = " 2 9 6 "   t o n s e t = " 3 6 8 "   t e n d = " 4 8 6 " > A g A D A A I A A Q A B A A I A A Q A B A A I A A g A C A A I A A g A C A A I A A Q A B A A E A A Q A B A A E A A Q A B A A E A A Q A B A A E A A Q A C  
+ A A I A A g A C A A E A A Q A C A A A A A Q A B A A E A A Q A B A A E A A g A C A A I A A g A D A A M A A w A C A A I A A g A B A A A A A A A A A A A A  
+ A A A A A A A A A A A A A A A A A A D / / / / / A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A Q A B A A E A A Q A B A A A A A A A A  
+ A A A A A A A B A A I A A Q A C A A I A A Q A B A A E A A Q A B A A E A A Q A B A A A A A A A A A A E A A Q A A A A E A A Q A C A A I A A Q A B A A E A  
+ A Q A B A A E A A Q A B A A E A A Q A B A A E A A g A B A A A A A Q A B A A I A A Q A B A A E A A Q A B A A E A A Q A C A A I A A g A C A A I A A g A C  
+ A A I A A g A B A A I A A g A C A A I A A w A D A A I A A g A D A A M A A w A D A A Q A B A A F A A U A A w A D A A M A A w A C A A I A A Q A C A A I A  
+ A w A D A A Q A B Q A H A A g A C g A N A A 4 A E A A Q A B A A D w A Q A B E A E Q A Q A B E A E Q A Q A B A A D g A N A A w A C w A K A A s A D A A L  
+ A A s A C w A L A A k A B w A F A A I A A g A B A A A A A A A A A P / / / / / 9 / / 3 / / v / + / / 7 / / / / / / / / / A A D / / / 7 / / v / / / / 7 /  
+ / / / + / / / / / v / + / / / / / f / + / / 7 / / v / + / / 7 / / / / / / / / / / v / / / / 7 / / / / / / / / / / / 8 A A A A A / / / / / w A A / v / 6  
+ / / f / 8 / / s / + L / 2 f / V / 9 X / 2 f / j / / b / F Q A 6 A G E A l A D M A A M B O w F w A Z 8 B 0 Q H 5 A f M B t g F k A R I B u A B a A B Y A  
+ 7 P / R / 8 b / w f / C / 9 D / 3 / / q / / f / A A A H A A w A D A A N A A w A C w A L A A o A C w A L A A o A C g A K A A o A C w A L A A s A C w A L  
+ A A w A D A A N A A 4 A D g A P A A 8 A D w A Q A B A A E A A Q A B E A E g A U A B Q A F Q A W A B U A F g A X A B g A G A A Y A B o A G g A c A B w A  
+ H Q A e A B 4 A H w A f A C A A I g A j A C Q A J Q A l A C U A J g A n A C g A K Q A q A C s A L A A t A C 4 A L w A v A D A A M g A z A D U A O A A 6  
+ A D w A P Q A + A D 8 A Q A B D A E Y A S A B J A E s A T Q B P A F A A U g B U A F c A W Q B c A G A A Y g B l A G c A a g B t A H A A c w B 3 A H o A  
+ f w C B A I Q A i A C L A I 8 A k Q C U A J g A n A C f A K I A o w C m A K g A q g C t A L E A t A C 3 A L o A v A C 9 A L 4 A w A D C A M M A w w D F  
+ A M U A x Q D E A M E A v g C 5 A L Q A s A C p A K U A n w C a A J Q A j A C F A H 0 A d g B v A G o A Z Q B e A F g A U Q B L A E U A P w A 6 A D c A  
+ M w A v A C s A J w A j A B 8 A H A A b A B k A G A A W A B U A E g A R A B A A D g A N A A w A C g A J A A g A B w A G A A Y A B Q A E A A Q A B A A E  
+ A A Q A B A A F A A U A B g A H A A Y A B Q A F A A Q A A w A D A A I A A g A D A A Q A A w A D A A M A A g A D A A M A B A A E A A U A B Q A F A A U A  
+ B Q A F A A Q A B A A E A A U A B A A E A A Q A A w A E A A Q A A w A E A A Q A A w A E A A Q A B A A D A A M A A w A D A A M A A w A D A A M A B A A E  
+ A A Q A A w A D A A M A A g A C A A I A A g A C A A I A A g A C A A I A A g A C A A E A A g A C A A I A A g A C A A I A A g A D A A M A A w A E A A U A  
+ B Q A E A A Q A A w A D A A M A A g A C A A I A A g A D A A I A A g A B A A E A A A A A A A A A A g A D A A I A A g A C A A E A A g A C A A I A A g A C  
+ A A I A A g A A A A E A A A A A A A A A A A A A A A E A A A A C A A A A A w A A A A M A A A A D A A A A A w A A A A M A A A A C A A A A A w A A A A I A  
+ A A A C A A A A A g A A A A Q A A A A E A A A A B Q A A A A Q A A A A D A A A A A g A A A A I A A A A C A A A A A g A A A A M A A A A D A A A A A w A A  
+ A A M A A A A C A A A A A A A A A A E A A A A C A A A A A g A A A A A A A A A A A A A A A g A A A A Q A A A A F A A A A B A A A A A M A A A A D A A A A  
+ A g A A A A I A A A A D A A A A B A A A A A Q A A A A E A A A A B A A A A A U A A A A E A A A A A w A A A A M A A A A D A A A A A w A A A A M A A A A E  
+ A A A A B A A A A A Q A A A A E A A A A A w A A A A I A A A A B A A A A A Q A A A A A A A A A A A A A A A w A A A A Y A A A A G A A A A B A A A A A I A  
+ A A A B A A A A A Q A A A A A A A A A A A A A A A A A A A A Q A A A A G A A A A B Q A A A A Q A A A A D A A A A A g A A A A E A A A A B A A A A A Q A A  
+ A A I A A A A D A A A A A g A A A A E A A A A A A A A A / / / / D / 7 / / w / + / / 8 P / f / / D / / / / w 8 A A A A A A Q A A A A A A A A A A A A A A  
+ A A A A A P / / / w / / / / 8 P / v / / D / 3 / / w / 8 / / 8 P + v / / D / j / / w / 3 / / 8 P 9 / / / D / f / / w / 4 / / 8 P 9 / / / D / X / / w / 0  
+ / / 8 P 9 P / / D / b / / w / 1 / / 8 P 8 / / / D / T / / w / 3 / / 8 P + P / / D / j / / w / 6 / / 8 P + v / / D / n / / w / 7 / / 8 P / f / / D / 3 /  
+ / w / 9 / / 8 P / f / / D / z / / w / 7 / / 8 P / P / / D / 7 / / w 8 A A A A A A g A A A A Q A A A A F A A A A B g A A A A Y A A A A G A A A A B g A A  
+ A A Y A A A A G A A A A B g A A A A c A A A A H A A A A C A A A A A g A A A A G A A A A B g A A A A c A A A A H A A A A B g A A A A c A A A A I A A A A  
+ C Q A A A A k A A A A J A A A A C Q A A A A g A A A A H A A A A B w A A A A Y A A A A G A A A A B w A A A A k A A A A K A A A A C Q A A A A g A A A A I  
+ A A A A C A A A A A c A A A A H A A A A B w A A A A c A A A A I A A A A C g A A A A o A A A A J A A A A C A A A A A Y A A A A F A A A A B g A A A A c A  
+ A A A I A A A A C g A A A A w A A A A O A A A A D g A A A A o A A A A G A A A A A g A A A P 7 / / w / 3 / / 8 P 7 P / / D + L / / w / Y / / 8 P y P / /  
+ D 7 X / / w + j / / 8 P k f / / D 4 D / / w 9 2 / / 8 P a / / / D 2 L / / w 9 u / / 8 P l P / / D 7 z / / w / d / / 8 P + f / / D x E A A A A n A A A A  
+ N w A A A D 8 A A A B A A A A A O w A A A D E A A A A h A A A A E w A A A A g A A A A B A A A A / v / / D / 3 / / w / 9 / / 8 P / v / / D / 7 / / w / +  
+ / / 8 P A A A A A A A A A A A A A A A A / v / / D / z / / w / 8 / / 8 P / v / / D / / / / w 8 A A A A A / / / / D / / / / w / / / / 8 P / f / / D / v /  
+ / w / 7 / / 8 P + / / / D / z / / w / 9 / / 8 P / f / / D / 3 / / w / 8 / / 8 P + / / / D / v / / w / 7 / / 8 P + / / / D / r / / w / 6 / / 8 P + / / /  
+ D / 3 / / w / 9 / / 8 P / P / / D / v / / w / 4 / / 8 P 9 / / / D / b / / w / 1 / / 8 P 9 f / / D / X / / w / z / / 8 P 8 / / / D / P / / w / y / / 8 P  
+ 8 f / / D / H / / w / w / / 8 P 7 v / / D + 7 / / w / x / / 8 P 8 / / / D / P / / w / y / / 8 P 8 v / / D / D / / w / v / / 8 P 7 / / / D + 7 / / w / t  
+ / / 8 P 7 f / / D + / / / w / v / / 8 P 7 v / / D + 3 / / w / r / / 8 P 6 f / / D + n / / w / o / / 8 P 5 / / / D + b / / w / l / / 8 P 5 f / / D + X /  
+ / w / k / / 8 P < / r e p b e a t > < / r e p b e a t s >  
+ 	 < / w a v e f o r m s >  
+ < / r e s t i n g e c g d a t a >  
+ 
\ No newline at end of file
diff --git a/test/rexml/formatter/test_default.rb b/test/rexml/formatter/test_default.rb
new file mode 100644
index 0000000..b5b1317
--- /dev/null
+++ b/test/rexml/formatter/test_default.rb
@@ -0,0 +1,19 @@
+require_relative "../rexml_test_utils"
+
+module REXMLTests
+  class DefaultFormatterTest < Test::Unit::TestCase
+    def format(node)
+      formatter = REXML::Formatters::Default.new
+      output = ""
+      formatter.write(node, output)
+      output
+    end
+
+    class InstructionTest < self
+      def test_content_nil
+        instruction = REXML::Instruction.new("target")
+        assert_equal("<?target?>", format(instruction))
+      end
+    end
+  end
+end
diff --git a/test/rexml/functions/test_base.rb b/test/rexml/functions/test_base.rb
new file mode 100644
index 0000000..74dc1a3
--- /dev/null
+++ b/test/rexml/functions/test_base.rb
@@ -0,0 +1,261 @@
+# frozen_string_literal: false
+require "test/unit/testcase"
+
+require "rexml/document"
+
+# TODO: Split me
+module REXMLTests
+  class FunctionsTester < Test::Unit::TestCase
+    include REXML
+
+    def setup
+      super
+      REXML::Functions.context = nil
+    end
+
+    def test_functions
+      # trivial text() test
+      # confuse-a-function
+      source = "<a>more <b id='1'/><b id='2'>dumb</b><b id='3'/><c/> text</a>"
+      doc = Document.new source
+      res = ""
+      XPath::each(doc.root, "text()") {|val| res << val.to_s}
+      assert_equal "more  text", res
+
+      res = XPath::first(doc.root, "b[last()]")
+      assert_equal '3', res.attributes['id']
+      res = XPath::first(doc.root, "b[position()=2]")
+      assert_equal '2', res.attributes['id']
+      res = XPath::first(doc.root, "*[name()='c']")
+      assert_equal "c", res.name
+    end
+
+    # Contributed by Mike Stok
+    def test_starts_with
+      source = <<-EOF
+        <foo>
+        <a href="mailto:a@b.c">a@b.c</a>
+        <a href="http://www.foo.com">http://www.foo.com</a>
+        </foo>
+      EOF
+      doc = Document.new source
+      mailtos = doc.elements.to_a("//a[starts-with(@href, 'mailto:')]")
+      assert_equal 1, mailtos.size
+      assert_equal "mailto:a@b.c", mailtos[0].attributes['href']
+
+      ailtos = doc.elements.to_a("//a[starts-with(@href, 'ailto:')]")
+      assert_equal 0, ailtos.size
+    end
+
+    def test_string_length
+      doc = Document.new <<-EOF
+        <AAA>
+        <Q/>
+        <SSSS/>
+        <BB/>
+        <CCC/>
+        <DDDDDDDD/>
+        <EEEE/>
+        </AAA>
+      EOF
+      assert doc, "create doc"
+
+      set = doc.elements.to_a("//*[string-length(name()) = 3]")
+      assert_equal 2, set.size, "nodes with names length = 3"
+
+      set = doc.elements.to_a("//*[string-length(name()) < 3]")
+      assert_equal 2, set.size, "nodes with names length < 3"
+
+      set = doc.elements.to_a("//*[string-length(name()) > 3]")
+      assert_equal 3, set.size, "nodes with names length > 3"
+    end
+
+    # Test provided by Mike Stok
+    def test_contains
+      source = <<-EOF
+        <foo>
+        <a href="mailto:a@b.c">a@b.c</a>
+        <a href="http://www.foo.com">http://www.foo.com</a>
+        </foo>
+      EOF
+      doc = Document.new source
+
+      [['o', 2], ['foo', 1], ['bar', 0]].each { |test|
+        search, expected = test
+        set = doc.elements.to_a("//a[contains(@href, '#{search}')]")
+        assert_equal expected, set.size
+      }
+    end
+
+    # Mike Stok and Sean Russell
+    def test_substring
+      # examples from http://www.w3.org/TR/xpath#function-substring
+      doc = Document.new('<test string="12345" />')
+
+      #puts XPath.first(d, 'node()[0 + 1]')
+      #d = Document.new("<a b='1'/>")
+      #puts XPath.first(d, 'a[0 mod 0]')
+      [ [1.5, 2.6, '234'],
+        [0, 3, '12'],
+        [0, '0 div 0', ''],
+        [1, '0 div 0', ''],
+        ['-42', '1 div 0', '12345'],
+                          ['-1 div 0', '1 div 0', '']
+      ].each { |start, length, expected|
+        set = doc.elements.to_a("//test[substring(@string, #{start}, #{length}) = '#{expected}']")
+        assert_equal 1, set.size, "#{start}, #{length}, '#{expected}'"
+      }
+    end
+
+    def test_substring_angrez
+      testString = REXML::Functions::substring_after("helloworld","hello")
+      assert_equal( 'world', testString )
+    end
+
+    def test_translate
+      source = <<-EOF
+      <doc>
+      <case name='w3c one' result='BAr' />        <!-- w3c -->
+      <case name='w3c two' result='AAA' />        <!-- w3c -->
+      <case name='alchemy' result="gold" />   <!-- mike -->
+      <case name='vbxml one' result='A Space Odyssey' />
+      <case name='vbxml two' result='AbCdEf' />
+      </doc>
+      EOF
+
+      doc = Document.new(source)
+
+      [ ['bar', 'abc', 'ABC', 'w3c one'],
+        ['--aaa--','abc-','ABC', 'w3c two'],
+        ['lead', 'dear language', 'doll groover', 'alchemy'],
+        ['A Space Odissei', 'i', 'y', 'vbxml one'],
+        ['abcdefg', 'aceg', 'ACE', 'vbxml two'],
+      ].each { |arg1, arg2, arg3, name|
+        translate = "translate('#{arg1}', '#{arg2}', '#{arg3}')"
+        set = doc.elements.to_a("//case[@result = #{translate}]")
+        assert_equal 1, set.size, translate
+        assert_equal name, set[0].attributes['name']
+      }
+    end
+
+    def test_name
+      d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
+      assert_equal 1, d.root.elements.to_a('*[name() = "b"]').size
+      assert_equal 1, d.elements.to_a('//*[name() = "x:b"]').size
+    end
+
+    def test_local_name
+      d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
+      assert_equal 2, d.root.elements.to_a('*[local_name() = "b"]').size
+      assert_equal 2, d.elements.to_a('//*[local_name() = "b"]').size
+    end
+
+    def test_substring2
+      doc = Document.new('<test string="12345" />')
+      assert_equal(1,doc.elements.to_a("//test[substring(@string,2)='2345']").size)
+    end
+
+    # Submitted by Kouhei
+    def test_floor_ceiling_round
+      source = "<a><b id='1'/><b id='2'/><b id='3'/></a>"
+      doc = REXML::Document.new(source)
+
+      id_1 = doc.elements["/a/b[@id='1']"]
+      id_2 = doc.elements["/a/b[@id='2']"]
+      id_3 = doc.elements["/a/b[@id='3']"]
+
+      good = {
+        "floor" => [[], [id_1], [id_2], [id_3]],
+        "ceiling" => [[id_1], [id_2], [id_3], []],
+        "round" => [[id_1], [id_2], [id_3], []]
+      }
+      good.each do |key, value|
+        (0..3).each do |i|
+          xpath = "//b[number(@id) = #{key}(#{i+0.5})]"
+          assert_equal(value[i], REXML::XPath.match(doc, xpath))
+        end
+      end
+
+      good["round"] = [[], [id_1], [id_2], [id_3]]
+      good.each do |key, value|
+        (0..3).each do |i|
+          xpath = "//b[number(@id) = #{key}(#{i+0.4})]"
+          assert_equal(value[i], REXML::XPath.match(doc, xpath))
+        end
+      end
+    end
+
+    # Submitted by Kou
+    def test_lang
+      d = Document.new(<<-XML)
+      <a xml:lang="en">
+      <b xml:lang="ja">
+      <c xml:lang="fr"/>
+      <d/>
+      <e xml:lang="ja-JP"/>
+      <f xml:lang="en-US"/>
+      </b>
+      </a>
+      XML
+
+      assert_equal(1, d.elements.to_a("//*[lang('fr')]").size)
+      assert_equal(3, d.elements.to_a("//*[lang('ja')]").size)
+      assert_equal(2, d.elements.to_a("//*[lang('en')]").size)
+      assert_equal(1, d.elements.to_a("//*[lang('en-us')]").size)
+
+      d = Document.new(<<-XML)
+      <root>
+      <para xml:lang="en"/>
+      <div xml:lang="en"><para/></div>
+      <para xml:lang="EN"/>
+      <para xml:lang="en-us"/>
+      </root>
+      XML
+
+      assert_equal(5, d.elements.to_a("//*[lang('en')]").size)
+    end
+
+    def test_ticket_60
+      document = REXML::Document.new("<a><b>A</b><b>1</b></a>")
+      assert_equal( "A", REXML::XPath.first(document, '//b[.="A"]').text )
+      assert_equal( "1", REXML::XPath.first(document, '//b[.="1"]').text )
+    end
+
+    def test_normalize_space
+      source = "<a><!--COMMENT A--><b><!-- COMMENT A --></b></a>"
+      doc = REXML::Document.new(source)
+      predicate = "string(.)=normalize_space('\nCOMMENT    \n A \n\n ')"
+      m = REXML::XPath.match(doc, "//comment()[#{predicate}]")
+      assert_equal( [REXML::Comment.new("COMMENT A")], m )
+    end
+
+    def test_string_nil_without_context
+      doc = REXML::Document.new(<<-XML)
+      <?xml version="1.0" encoding="UTF-8"?>
+      <root>
+      <foo bar="baz"/>
+      <foo bar=""/>
+      </root>
+      XML
+
+      assert_equal([doc.root.elements[2]],
+                   REXML::XPath.match(doc,
+                                      "//foo[@bar=$n]",
+                                      nil,
+                                      {"n" => nil}))
+    end
+
+    def test_unregistered_method
+      doc = Document.new("<root/>")
+      assert_nil(XPath::first(doc.root, "to_s()"))
+    end
+
+    def test_nonexistent_function
+      doc = Document.new("<root><nonexistent/></root>")
+      # TODO: Maybe, this is not XPath spec behavior.
+      # This behavior must be reconsidered.
+      assert_equal(doc.root.elements[1],
+                   XPath::first(doc.root, "nonexistent()"))
+    end
+  end
+end
diff --git a/test/rexml/functions/test_boolean.rb b/test/rexml/functions/test_boolean.rb
new file mode 100644
index 0000000..b3e2117
--- /dev/null
+++ b/test/rexml/functions/test_boolean.rb
@@ -0,0 +1,75 @@
+# frozen_string_literal: false
+
+require "test/unit"
+require "rexml/document"
+require "rexml/functions"
+
+module REXMLTests
+  class TestFunctionsBoolean < Test::Unit::TestCase
+    def setup
+      REXML::Functions.context = nil
+    end
+
+    def test_true
+      assert_equal(true, REXML::Functions.boolean(true))
+    end
+
+    def test_false
+      assert_equal(false, REXML::Functions.boolean(false))
+    end
+
+    def test_integer_true
+      assert_equal(true, REXML::Functions.boolean(1))
+    end
+
+    def test_integer_positive_zero
+      assert_equal(false, REXML::Functions.boolean(0))
+    end
+
+    def test_integer_negative_zero
+      assert_equal(false, REXML::Functions.boolean(-0))
+    end
+
+    def test_float_true
+      assert_equal(true, REXML::Functions.boolean(1.1))
+    end
+
+    def test_float_positive_zero
+      assert_equal(false, REXML::Functions.boolean(-0.0))
+    end
+
+    def test_float_negative_zero
+      assert_equal(false, REXML::Functions.boolean(-0.0))
+    end
+
+    def test_float_nan
+      assert_equal(false, REXML::Functions.boolean(Float::NAN))
+    end
+
+    def test_string_true
+      assert_equal(true, REXML::Functions.boolean("content"))
+    end
+
+    def test_string_empty
+      assert_equal(false, REXML::Functions.boolean(""))
+    end
+
+    def test_node_set_true
+      root = REXML::Document.new("<root/>").root
+      assert_equal(true, REXML::Functions.boolean([root]))
+    end
+
+    def test_node_set_empty
+      assert_equal(false, REXML::Functions.boolean([]))
+    end
+
+    def test_nil
+      assert_equal(false, REXML::Functions.boolean(nil))
+    end
+
+    def test_context
+      REXML::Functions.context = {node: true}
+      assert_equal(true, REXML::Functions.boolean())
+    end
+  end
+end
diff --git a/test/rexml/functions/test_local_name.rb b/test/rexml/functions/test_local_name.rb
new file mode 100644
index 0000000..97c9e74
--- /dev/null
+++ b/test/rexml/functions/test_local_name.rb
@@ -0,0 +1,44 @@
+# frozen_string_literal: false
+
+require "test/unit"
+require "rexml/document"
+require "rexml/functions"
+
+module REXMLTests
+  class TestFunctionsLocalName < Test::Unit::TestCase
+    def setup
+      REXML::Functions.context = nil
+    end
+
+    def test_one
+      document = REXML::Document.new(<<-XML)
+<root xmlns:x="http://example.com/x/">
+  <x:child/>
+</root>
+      XML
+      node_set = document.root.children
+      assert_equal("child", REXML::Functions.local_name(node_set))
+    end
+
+    def test_multiple
+      document = REXML::Document.new(<<-XML)
+<root xmlns:x="http://example.com/x/">
+  <x:child1/>
+  <x:child2/>
+</root>
+      XML
+      node_set = document.root.children
+      assert_equal("child1", REXML::Functions.local_name(node_set))
+    end
+
+    def test_nonexistent
+      assert_equal("", REXML::Functions.local_name([]))
+    end
+
+    def test_context
+      document = REXML::Document.new("<root/>")
+      REXML::Functions.context = {node: document.root}
+      assert_equal("root", REXML::Functions.local_name())
+    end
+  end
+end
diff --git a/test/rexml/functions/test_number.rb b/test/rexml/functions/test_number.rb
new file mode 100644
index 0000000..16e6357
--- /dev/null
+++ b/test/rexml/functions/test_number.rb
@@ -0,0 +1,38 @@
+# frozen_string_literal: false
+
+require "test/unit"
+require "rexml/document"
+require "rexml/functions"
+
+module REXMLTests
+  class TestFunctionsNumber < Test::Unit::TestCase
+    def setup
+      REXML::Functions.context = nil
+    end
+
+    def test_true
+      assert_equal(1, REXML::Functions.number(true))
+    end
+
+    def test_false
+      assert_equal(0, REXML::Functions.number(false))
+    end
+
+    def test_numeric
+      assert_equal(29, REXML::Functions.number(29))
+    end
+
+    def test_string_integer
+      assert_equal(100, REXML::Functions.number("100"))
+    end
+
+    def test_string_float
+      assert_equal(-9.13, REXML::Functions.number("-9.13"))
+    end
+
+    def test_node_set
+      root = REXML::Document.new("<root>100</root>").root
+      assert_equal(100, REXML::Functions.number([root]))
+    end
+  end
+end
diff --git a/test/rexml/listener.rb b/test/rexml/listener.rb
index a89205f..6bede03 100644
--- a/test/rexml/listener.rb
+++ b/test/rexml/listener.rb
@@ -1,50 +1,51 @@
+# frozen_string_literal: false
 class Listener
-	attr_reader :ts, :te
-	attr_reader :normalize
-	def initialize
-		@ts = false
-		@te = false
-	end
-	def tag_start name, attrs
-		@ts = true if name=="subsection" and attrs["title"]=="Namespaces"
-	end
-	def tag_end name
-		@te = true if name=="documentation"
-	end
-	def text text
-		@normalize = text
-		#text.tr! "\n", ' '
-		#puts "text #{text[0..10]}..."
-	end
-	def instruction name, instruction
-		#puts "instruction"
-	end
-	def comment comment
-		#puts "comment #{comment[0..10]}..."
-	end
-	def doctype name, pub_sys, long_name, uri
-		#puts "doctype #{name}"
-	end
-	def attlistdecl content
-		#puts "attlistdecl"
-	end
-	def elementdecl content
-		#puts "elementdecl"
-	end
-	def entitydecl content
-		#puts "entitydecl"
-	end
-	def notationdecl content
-		#puts "notationdecl"
-	end
-	def entity content
-		#puts "entity"
-	end
-	def cdata content
-		#puts "cdata"
-	end
-	def xmldecl version, encoding, standalone
-		#puts "xmldecl #{version}"
-	end
+  attr_reader :ts, :te
+  attr_reader :normalize
+  def initialize
+    @ts = false
+    @te = false
+  end
+  def tag_start name, attrs
+    @ts = true if name=="subsection" and attrs["title"]=="Namespaces"
+  end
+  def tag_end name
+    @te = true if name=="documentation"
+  end
+  def text text
+    @normalize = text
+    #text.tr! "\n", ' '
+    #puts "text #{text[0..10]}..."
+  end
+  def instruction name, instruction
+    #puts "instruction"
+  end
+  def comment comment
+    #puts "comment #{comment[0..10]}..."
+  end
+  def doctype name, pub_sys, long_name, uri
+    #puts "doctype #{name}"
+  end
+  def attlistdecl content
+    #puts "attlistdecl"
+  end
+  def elementdecl content
+    #puts "elementdecl"
+  end
+  def entitydecl content
+    #puts "entitydecl"
+  end
+  def notationdecl content
+    #puts "notationdecl"
+  end
+  def entity content
+    #puts "entity"
+  end
+  def cdata content
+    #puts "cdata"
+  end
+  def xmldecl version, encoding, standalone
+    #puts "xmldecl #{version}"
+  end
 end
 
diff --git a/test/rexml/parse/test_document_type_declaration.rb b/test/rexml/parse/test_document_type_declaration.rb
index c55a283..5571390 100644
--- a/test/rexml/parse/test_document_type_declaration.rb
+++ b/test/rexml/parse/test_document_type_declaration.rb
@@ -1,14 +1,16 @@
+# frozen_string_literal: false
 require "test/unit"
 require "rexml/document"
 
-class TestParseDocumentTypeDeclaration < Test::Unit::TestCase
-  private
+module REXMLTests
+  class TestParseDocumentTypeDeclaration < Test::Unit::TestCase
+    private
     def parse(doctype)
       REXML::Document.new(<<-XML).doctype
 #{doctype}
 <r/>
-    XML
-  end
+      XML
+    end
 
     class TestName < self
       def test_valid
@@ -184,35 +186,35 @@ x'>  <r/>
           end
         end
       end
-  end
+    end
 
-  class TestMixed < self
-    def test_entity_element
-      doctype = parse(<<-INTERNAL_SUBSET)
+    class TestMixed < self
+      def test_entity_element
+        doctype = parse(<<-INTERNAL_SUBSET)
 <!ENTITY entity-name "entity content">
 <!ELEMENT element-name EMPTY>
-      INTERNAL_SUBSET
-      assert_equal([REXML::Entity, REXML::ElementDecl],
-                   doctype.children.collect(&:class))
-    end
+        INTERNAL_SUBSET
+        assert_equal([REXML::Entity, REXML::ElementDecl],
+                     doctype.children.collect(&:class))
+      end
 
-    def test_attlist_entity
-      doctype = parse(<<-INTERNAL_SUBSET)
+      def test_attlist_entity
+        doctype = parse(<<-INTERNAL_SUBSET)
 <!ATTLIST attribute-list-name attribute-name CDATA #REQUIRED>
 <!ENTITY entity-name "entity content">
-      INTERNAL_SUBSET
-      assert_equal([REXML::AttlistDecl, REXML::Entity],
-                   doctype.children.collect(&:class))
-    end
+        INTERNAL_SUBSET
+        assert_equal([REXML::AttlistDecl, REXML::Entity],
+                     doctype.children.collect(&:class))
+      end
 
-    def test_notation_attlist
-      doctype = parse(<<-INTERNAL_SUBSET)
+      def test_notation_attlist
+        doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION notation-name SYSTEM "system-literal">
 <!ATTLIST attribute-list-name attribute-name CDATA #REQUIRED>
-      INTERNAL_SUBSET
-      assert_equal([REXML::NotationDecl, REXML::AttlistDecl],
-                   doctype.children.collect(&:class))
-    end
+        INTERNAL_SUBSET
+        assert_equal([REXML::NotationDecl, REXML::AttlistDecl],
+                     doctype.children.collect(&:class))
+      end
 
       private
       def parse(internal_subset)
@@ -222,5 +224,6 @@ x'>  <r/>
 ]>
         DOCTYPE
       end
+    end
   end
 end
diff --git a/test/rexml/parse/test_element.rb b/test/rexml/parse/test_element.rb
index e8dce4b..9f172a2 100644
--- a/test/rexml/parse/test_element.rb
+++ b/test/rexml/parse/test_element.rb
@@ -41,7 +41,7 @@ Last 80 unconsumed characters:
         assert_equal(<<-DETAIL.chomp, exception.to_s)
 Invalid attribute name: <:a="">
 Line: 1
-Position: 13
+Position: 9
 Last 80 unconsumed characters:
 
         DETAIL
diff --git a/test/rexml/parse/test_notation_declaration.rb b/test/rexml/parse/test_notation_declaration.rb
index 6191a71..19a0536 100644
--- a/test/rexml/parse/test_notation_declaration.rb
+++ b/test/rexml/parse/test_notation_declaration.rb
@@ -1,27 +1,29 @@
+# frozen_string_literal: false
 require 'test/unit'
 require 'rexml/document'
 
-class TestParseNotationDeclaration < Test::Unit::TestCase
-  private
-  def xml(internal_subset)
-    <<-XML
+module REXMLTests
+  class TestParseNotationDeclaration < Test::Unit::TestCase
+    private
+    def xml(internal_subset)
+      <<-XML
 <!DOCTYPE r SYSTEM "urn:x-henrikmartensson:test" [
 #{internal_subset}
 ]>
 <r/>
-    XML
-  end
-
-  def parse(internal_subset)
-    REXML::Document.new(xml(internal_subset)).doctype
-  end
+      XML
+    end
 
-  class TestCommon < self
-    def test_name
-      doctype = parse("<!NOTATION name PUBLIC 'urn:public-id'>")
-      assert_equal("name", doctype.notation("name").name)
+    def parse(internal_subset)
+      REXML::Document.new(xml(internal_subset)).doctype
     end
 
+    class TestCommon < self
+      def test_name
+        doctype = parse("<!NOTATION name PUBLIC 'urn:public-id'>")
+        assert_equal("name", doctype.notation("name").name)
+      end
+
       def test_no_name
         exception = assert_raise(REXML::ParseException) do
           parse(<<-INTERNAL_SUBSET)
@@ -81,10 +83,10 @@ Last 80 unconsumed characters:
  INVALID>  ]> <r/> 
         DETAIL
       end
-  end
+    end
 
-  class TestExternalID < self
-    class TestSystem < self
+    class TestExternalID < self
+      class TestSystem < self
         def test_no_literal
           exception = assert_raise(REXML::ParseException) do
             parse(<<-INTERNAL_SUBSET)
@@ -115,23 +117,23 @@ x'>  ]> <r/>
           DETAIL
         end
 
-      def test_single_quote
-        doctype = parse(<<-INTERNAL_SUBSET)
+        def test_single_quote
+          doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION name SYSTEM 'system-literal'>
-        INTERNAL_SUBSET
-        assert_equal("system-literal", doctype.notation("name").system)
-      end
+          INTERNAL_SUBSET
+          assert_equal("system-literal", doctype.notation("name").system)
+        end
 
-      def test_double_quote
-        doctype = parse(<<-INTERNAL_SUBSET)
+        def test_double_quote
+          doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION name SYSTEM "system-literal">
-        INTERNAL_SUBSET
-        assert_equal("system-literal", doctype.notation("name").system)
+          INTERNAL_SUBSET
+          assert_equal("system-literal", doctype.notation("name").system)
+        end
       end
-    end
 
-    class TestPublic < self
-      class TestPublicIDLiteral < self
+      class TestPublic < self
+        class TestPublicIDLiteral < self
           def test_content_double_quote
             exception = assert_raise(REXML::ParseException) do
               parse(<<-INTERNAL_SUBSET)
@@ -147,22 +149,22 @@ Last 80 unconsumed characters:
             DETAIL
           end
 
-        def test_single_quote
-          doctype = parse(<<-INTERNAL_SUBSET)
+          def test_single_quote
+            doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION name PUBLIC 'public-id-literal' "system-literal">
-          INTERNAL_SUBSET
-          assert_equal("public-id-literal", doctype.notation("name").public)
-        end
+            INTERNAL_SUBSET
+            assert_equal("public-id-literal", doctype.notation("name").public)
+          end
 
-        def test_double_quote
-          doctype = parse(<<-INTERNAL_SUBSET)
+          def test_double_quote
+            doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION name PUBLIC "public-id-literal" "system-literal">
-          INTERNAL_SUBSET
-          assert_equal("public-id-literal", doctype.notation("name").public)
+            INTERNAL_SUBSET
+            assert_equal("public-id-literal", doctype.notation("name").public)
+          end
         end
-      end
 
-      class TestSystemLiteral < self
+        class TestSystemLiteral < self
           def test_garbage_after_literal
             exception = assert_raise(REXML::ParseException) do
               parse(<<-INTERNAL_SUBSET)
@@ -178,39 +180,40 @@ x'>  ]> <r/>
            DETAIL
           end
 
-        def test_single_quote
-          doctype = parse(<<-INTERNAL_SUBSET)
+          def test_single_quote
+            doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION name PUBLIC "public-id-literal" 'system-literal'>
-          INTERNAL_SUBSET
-          assert_equal("system-literal", doctype.notation("name").system)
-        end
+            INTERNAL_SUBSET
+            assert_equal("system-literal", doctype.notation("name").system)
+          end
 
-        def test_double_quote
-          doctype = parse(<<-INTERNAL_SUBSET)
+          def test_double_quote
+            doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION name PUBLIC "public-id-literal" "system-literal">
-          INTERNAL_SUBSET
-          assert_equal("system-literal", doctype.notation("name").system)
+            INTERNAL_SUBSET
+            assert_equal("system-literal", doctype.notation("name").system)
+          end
         end
       end
-    end
 
-    class TestMixed < self
-      def test_system_public
-        doctype = parse(<<-INTERNAL_SUBSET)
+      class TestMixed < self
+        def test_system_public
+          doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION system-name SYSTEM "system-literal">
 <!NOTATION public-name PUBLIC "public-id-literal" 'system-literal'>
-        INTERNAL_SUBSET
-        assert_equal(["system-name", "public-name"],
-                     doctype.notations.collect(&:name))
-      end
+          INTERNAL_SUBSET
+          assert_equal(["system-name", "public-name"],
+                       doctype.notations.collect(&:name))
+        end
 
-      def test_public_system
-        doctype = parse(<<-INTERNAL_SUBSET)
+        def test_public_system
+          doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION public-name PUBLIC "public-id-literal" 'system-literal'>
 <!NOTATION system-name SYSTEM "system-literal">
-        INTERNAL_SUBSET
-        assert_equal(["public-name", "system-name"],
-                     doctype.notations.collect(&:name))
+          INTERNAL_SUBSET
+          assert_equal(["public-name", "system-name"],
+                       doctype.notations.collect(&:name))
+        end
       end
     end
 
diff --git a/test/rexml/parse/test_processing_instruction.rb b/test/rexml/parse/test_processing_instruction.rb
new file mode 100644
index 0000000..f0c0c24
--- /dev/null
+++ b/test/rexml/parse/test_processing_instruction.rb
@@ -0,0 +1,44 @@
+require "test/unit"
+require "rexml/document"
+
+module REXMLTests
+  class TestParseProcessinInstruction < Test::Unit::TestCase
+    def parse(xml)
+      REXML::Document.new(xml)
+    end
+
+    class TestInvalid < self
+      def test_no_name
+        exception = assert_raise(REXML::ParseException) do
+          parse("<??>")
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Invalid processing instruction node
+Line: 1
+Position: 4
+Last 80 unconsumed characters:
+<??>
+        DETAIL
+      end
+
+      def test_garbage_text
+        # TODO: This should be parse error.
+        # Create test/parse/test_document.rb or something and move this to it.
+        doc = parse(<<-XML)
+x<?x y
+<!--?><?x -->?>
+<r/>
+        XML
+        pi = doc.children[1]
+        assert_equal([
+                       "x",
+                       "y\n<!--",
+                     ],
+                     [
+                       pi.target,
+                       pi.content,
+                     ])
+      end
+    end
+  end
+end
diff --git a/test/rexml/parser/test_sax2.rb b/test/rexml/parser/test_sax2.rb
index f836c06..91d135f 100644
--- a/test/rexml/parser/test_sax2.rb
+++ b/test/rexml/parser/test_sax2.rb
@@ -1,7 +1,9 @@
+# frozen_string_literal: false
 require "test/unit"
 require "rexml/parsers/sax2parser"
 require "rexml/sax2listener"
 
+module REXMLTests
 class TestSAX2Parser < Test::Unit::TestCase
   class TestDocumentTypeDeclaration < self
     private
@@ -198,3 +200,4 @@ class TestSAX2Parser < Test::Unit::TestCase
     end
   end
 end
+end
diff --git a/test/rexml/parser/test_stream.rb b/test/rexml/parser/test_stream.rb
new file mode 100644
index 0000000..c315833
--- /dev/null
+++ b/test/rexml/parser/test_stream.rb
@@ -0,0 +1,32 @@
+require "test/unit"
+require "rexml/document"
+require "rexml/streamlistener"
+
+module REXMLTests
+  class TestStreamParser < Test::Unit::TestCase
+    class NullListener
+      include REXML::StreamListener
+    end
+
+    class TestInvalid < self
+      def test_no_end_tag
+        xml = "<root><sub>"
+        exception = assert_raise(REXML::ParseException) do
+          parse(xml)
+        end
+        assert_equal(<<-MESSAGE, exception.to_s)
+Missing end tag for '/root/sub'
+Line: 1
+Position: #{xml.bytesize}
+Last 80 unconsumed characters:
+        MESSAGE
+      end
+
+      private
+      def parse(xml, listener=nil)
+        listener ||= NullListener.new
+        REXML::Document.parse_stream(xml, listener)
+      end
+    end
+  end
+end
diff --git a/test/rexml/parser/test_tree.rb b/test/rexml/parser/test_tree.rb
index 5f53a01..8a5d9d1 100644
--- a/test/rexml/parser/test_tree.rb
+++ b/test/rexml/parser/test_tree.rb
@@ -1,7 +1,9 @@
+# frozen_string_literal: false
 require "test/unit"
 require "rexml/document"
 require "rexml/parsers/treeparser"
 
+module REXMLTests
 class TestTreeParser < Test::Unit::TestCase
   class TestInvalid < self
     def test_unmatched_close_tag
@@ -38,3 +40,4 @@ Last 80 unconsumed characters:
     end
   end
 end
+end
diff --git a/test/rexml/parser/test_ultra_light.rb b/test/rexml/parser/test_ultra_light.rb
index 809ef5c..44fd1d1 100644
--- a/test/rexml/parser/test_ultra_light.rb
+++ b/test/rexml/parser/test_ultra_light.rb
@@ -1,6 +1,8 @@
+# frozen_string_literal: false
 require "test/unit"
 require "rexml/parsers/ultralightparser"
 
+module REXMLTests
 class TestUltraLightParser < Test::Unit::TestCase
   class TestDocumentTypeDeclaration < self
     def test_entity_declaration
@@ -52,7 +54,7 @@ class TestUltraLightParser < Test::Unit::TestCase
         normalized_doctype[1] = normalized_parent
         normalized_doctype
       when :start_element
-        tag, parent, name, attributes, *children = child
+        tag, _parent, name, attributes, *children = child
         normalized_parent = :parent
         normalized_children = children.collect do |sub_child|
           normalize_child(sub_child)
@@ -64,3 +66,4 @@ class TestUltraLightParser < Test::Unit::TestCase
     end
   end
 end
+end
diff --git a/test/rexml/rexml_test_utils.rb b/test/rexml/rexml_test_utils.rb
index 57fe65c..8bb002c 100644
--- a/test/rexml/rexml_test_utils.rb
+++ b/test/rexml/rexml_test_utils.rb
@@ -1,4 +1,8 @@
-require 'test/unit'
+# frozen_string_literal: false
+
+require "test/unit"
+require "rexml/document"
+
 module REXMLTestUtils
   def fixture_path(*components)
     File.join(File.dirname(__FILE__), "data", *components)
diff --git a/test/rexml/test_attribute.rb b/test/rexml/test_attribute.rb
new file mode 100644
index 0000000..5175bd4
--- /dev/null
+++ b/test/rexml/test_attribute.rb
@@ -0,0 +1,14 @@
+require_relative "rexml_test_utils"
+
+module REXMLTests
+  class AttributeTest < Test::Unit::TestCase
+    def test_empty_prefix
+      error = assert_raise(ArgumentError) do
+        REXML::Attribute.new(":x")
+      end
+      assert_equal("name must be " +
+                   "\#{PREFIX}:\#{LOCAL_NAME} or \#{LOCAL_NAME}: <\":x\">",
+                   error.message)
+    end
+  end
+end
diff --git a/test/rexml/test_attributes.rb b/test/rexml/test_attributes.rb
index f9c0987..d6f566b 100644
--- a/test/rexml/test_attributes.rb
+++ b/test/rexml/test_attributes.rb
@@ -1,203 +1,205 @@
+# frozen_string_literal: false
 require 'test/unit/testcase'
 require 'rexml/document'
 
-class AttributesTester < Test::Unit::TestCase
-  include REXML
-  def test_accessor
-    doc = Document.new("<a xmlns:foo='a' xmlns:bar='b' foo:att='1' bar:att='2' att='3'/>")
-    assert_equal '3', doc.root.attributes['att']
-    assert_equal '2', doc.root.attributes['bar:att']
-    doc.root.attributes['att'] = 5
-    assert_equal '5', doc.root.attributes['att']
-  end
-
-  def test_each_attribute
-    doc = Document.new('<a x="1" y="2"/>')
-    doc.root.attributes.each_attribute {|attr|
-      if attr.expanded_name == 'x'
-        assert_equal '1', attr.value
-      elsif attr.expanded_name == 'y'
-        assert_equal '2', attr.value
-      else
-        assert_fail "No such attribute!!"
-      end
-    }
-  end
+module REXMLTests
+  class AttributesTester < Test::Unit::TestCase
+    include REXML
+    def test_accessor
+      doc = Document.new("<a xmlns:foo='a' xmlns:bar='b' foo:att='1' bar:att='2' att='3'/>")
+      assert_equal '3', doc.root.attributes['att']
+      assert_equal '2', doc.root.attributes['bar:att']
+      doc.root.attributes['att'] = 5
+      assert_equal '5', doc.root.attributes['att']
+    end
 
-  def test_each
-    doc = Document.new('<a x="1" y="2"/>')
-    doc.root.attributes.each {|name, value|
-      if name == 'x'
-        assert_equal '1', value
-      elsif name == 'y'
-        assert_equal '2', value
-      else
-        assert_fail "No such attribute!!"
-      end
-    }
-  end
+    def test_each_attribute
+      doc = Document.new('<a x="1" y="2"/>')
+      doc.root.attributes.each_attribute {|attr|
+        if attr.expanded_name == 'x'
+          assert_equal '1', attr.value
+        elsif attr.expanded_name == 'y'
+          assert_equal '2', attr.value
+        else
+          assert_fail "No such attribute!!"
+        end
+      }
+    end
 
-  def test_get_attribute
-    doc = Document.new('<a xmlns:x="a" x:foo="1" foo="2" bar="3"/>')
-    assert_equal '2', doc.root.attributes.get_attribute("foo").value
-    assert_equal '1', doc.root.attributes.get_attribute("x:foo").value
-  end
+    def test_each
+      doc = Document.new('<a x="1" y="2"/>')
+      doc.root.attributes.each {|name, value|
+        if name == 'x'
+          assert_equal '1', value
+        elsif name == 'y'
+          assert_equal '2', value
+        else
+          assert_fail "No such attribute!!"
+        end
+      }
+    end
 
-  def test_size
-    doc = Document.new("<a xmlns:foo='a' x='1' y='2' foo:x='3'/>")
-    assert_equal 4, doc.root.attributes.length
-  end
+    def test_get_attribute
+      doc = Document.new('<a xmlns:x="a" x:foo="1" foo="2" bar="3"/>')
+      assert_equal '2', doc.root.attributes.get_attribute("foo").value
+      assert_equal '1', doc.root.attributes.get_attribute("x:foo").value
+    end
 
-  def test_setter
-    doc = Document.new("<a xmlns:x='a' x:foo='1' foo='3'/>")
-    doc.root.attributes['y:foo'] = '2'
-    assert_equal '2', doc.root.attributes['y:foo']
-    doc.root.attributes['foo'] = '4'
-    assert_equal '4', doc.root.attributes['foo']
-    doc.root.attributes['x:foo'] = nil
-    assert_equal 3, doc.root.attributes.size
-  end
+    def test_size
+      doc = Document.new("<a xmlns:foo='a' x='1' y='2' foo:x='3'/>")
+      assert_equal 4, doc.root.attributes.length
+    end
 
-  def test_delete
-    doc = Document.new("<a xmlns:y='a' xmlns:x='b' xmlns:z='c' y:foo='0' x:foo='1' foo='3' z:foo='4'/>")
-    doc.root.attributes.delete 'foo'
-    assert_equal 6, doc.root.attributes.size
-    assert_equal '1', doc.root.attributes['x:foo']
+    def test_setter
+      doc = Document.new("<a xmlns:x='a' x:foo='1' foo='3'/>")
+      doc.root.attributes['y:foo'] = '2'
+      assert_equal '2', doc.root.attributes['y:foo']
+      doc.root.attributes['foo'] = '4'
+      assert_equal '4', doc.root.attributes['foo']
+      doc.root.attributes['x:foo'] = nil
+      assert_equal 3, doc.root.attributes.size
+    end
 
-    doc.root.attributes.delete 'x:foo'
-    assert_equal 5, doc.root.attributes.size
+    def test_delete
+      doc = Document.new("<a xmlns:y='a' xmlns:x='b' xmlns:z='c' y:foo='0' x:foo='1' foo='3' z:foo='4'/>")
+      doc.root.attributes.delete 'foo'
+      assert_equal 6, doc.root.attributes.size
+      assert_equal '1', doc.root.attributes['x:foo']
 
-    attr = doc.root.attributes.get_attribute('y:foo')
-    doc.root.attributes.delete attr
-    assert_equal 4, doc.root.attributes.size
+      doc.root.attributes.delete 'x:foo'
+      assert_equal 5, doc.root.attributes.size
 
-    assert_equal '4', doc.root.attributes['z:foo']
-  end
+      attr = doc.root.attributes.get_attribute('y:foo')
+      doc.root.attributes.delete attr
+      assert_equal 4, doc.root.attributes.size
 
-  def test_prefixes
-    doc = Document.new("<a xmlns='foo' xmlns:x='bar' xmlns:y='twee' z='glorp' x:k='gru'/>")
-    prefixes = doc.root.attributes.prefixes
-    assert_equal 2, prefixes.size
-    assert_equal 0, (prefixes - ['x', 'y']).size
-  end
+      assert_equal '4', doc.root.attributes['z:foo']
+    end
 
-  # Contributed by Mike Stok
-  def test_values_with_apostrophes
-    doc = Document.new(%q#<tag h1="1'2'" h2='1"2'/>#)
-    s = doc.to_s
-    assert(s =~ /h1='1&apos;2&apos;'/)
-    assert(s =~ /h2='1"2'/)
-  end
+    def test_prefixes
+      doc = Document.new("<a xmlns='foo' xmlns:x='bar' xmlns:y='twee' z='glorp' x:k='gru'/>")
+      prefixes = doc.root.attributes.prefixes
+      assert_equal 2, prefixes.size
+      assert_equal 0, (prefixes - ['x', 'y']).size
+    end
 
-  # Submitted by Kou
-  def test_namespace_conflict
-    assert_raise( ParseException,
-                  "Declaring two attributes with the same namespace should be an error" ) do
-      REXML::Document.new <<-XML
-      <x xmlns:n1="http://www.w3.org"
-         xmlns:n2="http://www.w3.org" >
-        <bad n1:a="1"  n2:a="2" />
-      </x>
-      XML
+    # Contributed by Mike Stok
+    def test_values_with_apostrophes
+      doc = Document.new(%q#<tag h1="1'2'" h2='1"2'/>#)
+      s = doc.to_s
+      assert(s =~ /h1='1&apos;2&apos;'/)
+      assert(s =~ /h2='1"2'/)
     end
 
-    REXML::Document.new("<a xmlns:a='a' xmlns:b='a'></a>")
-  end
+    # Submitted by Kou
+    def test_namespace_conflict
+      assert_raise( ParseException,
+                    "Declaring two attributes with the same namespace should be an error" ) do
+        REXML::Document.new <<-XML
+        <x xmlns:n1="http://www.w3.org"
+           xmlns:n2="http://www.w3.org" >
+          <bad n1:a="1"  n2:a="2" />
+        </x>
+        XML
+      end
 
-  # Submitted by Kou
-  def test_attribute_deletion
-    e = REXML::Element.new
-    e.add_namespace("a", "http://a/")
-    e.add_namespace("b", "http://b/")
-    e.add_attributes({"c" => "cc", "a:c" => "cC", "b:c" => "CC"})
+      REXML::Document.new("<a xmlns:a='a' xmlns:b='a'></a>")
+    end
 
-    e.attributes.delete("c")
-    assert_nil(e.attributes.get_attribute("c"))
+    # Submitted by Kou
+    def test_attribute_deletion
+      e = REXML::Element.new
+      e.add_namespace("a", "http://a/")
+      e.add_namespace("b", "http://b/")
+      e.add_attributes({"c" => "cc", "a:c" => "cC", "b:c" => "CC"})
 
-    before_size = e.attributes.size
-    e.attributes.delete("c")
-    assert_nil(e.attributes.get_attribute("c"))
-    assert_equal(before_size, e.attributes.size)
+      e.attributes.delete("c")
+      assert_nil(e.attributes.get_attribute("c"))
 
-    e.attributes.delete(e.attributes.get_attribute("a:c"))
-    assert_nil(e.attributes.get_attribute("a:c"))
+      before_size = e.attributes.size
+      e.attributes.delete("c")
+      assert_nil(e.attributes.get_attribute("c"))
+      assert_equal(before_size, e.attributes.size)
 
-    e.attributes.delete("b:c")
-    assert_nil(e.attributes.get_attribute("b:c"))
+      e.attributes.delete(e.attributes.get_attribute("a:c"))
+      assert_nil(e.attributes.get_attribute("a:c"))
 
-    before_size = e.attributes.size
-    e.attributes.delete(e.attributes.get_attribute("b:c"))
-    assert_nil(e.attributes.get_attribute("b:c"))
-    assert_equal(before_size, e.attributes.size)
+      e.attributes.delete("b:c")
+      assert_nil(e.attributes.get_attribute("b:c"))
 
-    before_size = e.attributes.size
-    e.attributes.delete("c")
-    assert_nil(e.attributes.get_attribute("c"))
-    assert_equal(before_size, e.attributes.size)
+      before_size = e.attributes.size
+      e.attributes.delete(e.attributes.get_attribute("b:c"))
+      assert_nil(e.attributes.get_attribute("b:c"))
+      assert_equal(before_size, e.attributes.size)
 
-    e.add_attribute("c", "cc")
+      before_size = e.attributes.size
+      e.attributes.delete("c")
+      assert_nil(e.attributes.get_attribute("c"))
+      assert_equal(before_size, e.attributes.size)
 
-    e.attributes.delete(e.attributes.get_attribute("c"))
-    assert_nil(e.attributes.get_attribute("c"))
-  end
+      e.add_attribute("c", "cc")
 
-  # Submitted by Kou
-  def test_element_usage
-    attr = Attribute.new("name", "value")
-    elem = Element.new("elem")
-    a = Attribute.new(attr, elem)
-    assert_equal(elem, a.element)
-  end
+      e.attributes.delete(e.attributes.get_attribute("c"))
+      assert_nil(e.attributes.get_attribute("c"))
+    end
 
-  def attr_test(attr_name,attr_value)
-    a1 = REXML::Attribute.new(attr_name,attr_value)
+    # Submitted by Kou
+    def test_element_usage
+      attr = Attribute.new("name", "value")
+      elem = Element.new("elem")
+      a = Attribute.new(attr, elem)
+      assert_equal(elem, a.element)
+    end
 
-    s1 = a1.value
-    s2 = a1.value
+    def attr_test(attr_name,attr_value)
+      a1 = REXML::Attribute.new(attr_name,attr_value)
 
-    #p s1
-    #p s2
-    assert_equal(s1,s2)
+      s1 = a1.value
+      s2 = a1.value
 
-    a2 = REXML::Attribute.new(attr_name,attr_value)
+      #p s1
+      #p s2
+      assert_equal(s1,s2)
 
-    a2.to_s        # NB invocation of to_s
-    s1 = a2.value
-    s2 = a2.value
+      a2 = REXML::Attribute.new(attr_name,attr_value)
 
-    #p s1
-    #p s2
-    assert_equal(s1,s2)
-  end
+      a2.to_s        # NB invocation of to_s
+      s1 = a2.value
+      s2 = a2.value
 
-  def test_amp_attributes
-    attr_test('name','value with &amp; ampersand only')
-  end
+      #p s1
+      #p s2
+      assert_equal(s1,s2)
+    end
 
-  def test_amp_and_lf_attributes
-    attr_test('name','value with LF &#x000a; &amp; ampersand')
-  end
+    def test_amp_attributes
+      attr_test('name','value with &amp; ampersand only')
+    end
 
-  def test_quoting
-    d = Document.new(%q{<a x='1' y="2"/>})
-    assert_equal( %q{<a x='1' y='2'/>}, d.to_s )
-    d.root.context[:attribute_quote] = :quote
-    assert_equal( %q{<a x="1" y="2"/>}, d.to_s )
+    def test_amp_and_lf_attributes
+      attr_test('name','value with LF &#x000a; &amp; ampersand')
+    end
 
-    d = Document.new(%q{<a x='1' y="2"><b z='3'/></a>})
-    assert_equal( %q{<a x='1' y='2'><b z='3'/></a>}, d.to_s )
-    d.root.context[:attribute_quote] = :quote
-    assert_equal( %q{<a x="1" y="2"><b z="3"/></a>}, d.to_s )
-  end
+    def test_quoting
+      d = Document.new(%q{<a x='1' y="2"/>})
+      assert_equal( %q{<a x='1' y='2'/>}, d.to_s )
+      d.root.context[:attribute_quote] = :quote
+      assert_equal( %q{<a x="1" y="2"/>}, d.to_s )
 
-  def test_ticket_127
-    doc = Document.new
-    doc.add_element 'a', { 'v' => 'x & y' }
-    assert doc.to_s.index(';')
-  end
+      d = Document.new(%q{<a x='1' y="2"><b z='3'/></a>})
+      assert_equal( %q{<a x='1' y='2'><b z='3'/></a>}, d.to_s )
+      d.root.context[:attribute_quote] = :quote
+      assert_equal( %q{<a x="1" y="2"><b z="3"/></a>}, d.to_s )
+    end
+
+    def test_ticket_127
+      doc = Document.new
+      doc.add_element 'a', { 'v' => 'x & y' }
+      assert doc.to_s.index(';')
+    end
 
-  def test_to_a_with_namespaces
-    document = Document.new(<<-XML)
+    def test_to_a_with_namespaces
+      document = Document.new(<<-XML)
 <root
   xmlns:ns1="http://example.org/ns1"
   xmlns:ns2="http://example.org/ns2">
@@ -208,13 +210,14 @@ class AttributesTester < Test::Unit::TestCase
     other-attribute="other-value"/>
 </root>
 XML
-    child = document.root.elements["child"]
-    assert_equal([
-                   "attribute='no-ns'",
-                   "ns1:attribute='ns1'",
-                   "ns2:attribute='ns2'",
-                   "other-attribute='other-value'",
-                 ],
-                 child.attributes.to_a.collect(&:to_string).sort)
+      child = document.root.elements["child"]
+      assert_equal([
+                     "attribute='no-ns'",
+                     "ns1:attribute='ns1'",
+                     "ns2:attribute='ns2'",
+                     "other-attribute='other-value'",
+                   ],
+                   child.attributes.to_a.collect(&:to_string).sort)
+    end
   end
 end
diff --git a/test/rexml/test_attributes_mixin.rb b/test/rexml/test_attributes_mixin.rb
index f0659eb..3a9f54e 100644
--- a/test/rexml/test_attributes_mixin.rb
+++ b/test/rexml/test_attributes_mixin.rb
@@ -1,29 +1,32 @@
+# frozen_string_literal: false
 require 'test/unit'
 require 'rexml/document'
 
-class TestAttributes < Test::Unit::TestCase
-  def setup
-    @ns_a = "urn:x-test:a"
-    @ns_b = "urn:x-test:b"
-    element_string = <<-"XMLEND"
-    <test xmlns:a="#{@ns_a}"
-          xmlns:b="#{@ns_b}"
-          a = "1"
-          b = '2'
-          a:c = "3"
-          a:d = '4'
-          a:e = "5"
-          b:f = "6"/>
-    XMLEND
-    @attributes = REXML::Document.new(element_string).root.attributes
-  end
+module REXMLTests
+  class TestAttributes < Test::Unit::TestCase
+    def setup
+      @ns_a = "urn:x-test:a"
+      @ns_b = "urn:x-test:b"
+      element_string = <<-"XMLEND"
+      <test xmlns:a="#{@ns_a}"
+            xmlns:b="#{@ns_b}"
+            a = "1"
+            b = '2'
+            a:c = "3"
+            a:d = '4'
+            a:e = "5"
+            b:f = "6"/>
+      XMLEND
+      @attributes = REXML::Document.new(element_string).root.attributes
+    end
 
-  def test_get_attribute_ns
-    assert_equal("1", @attributes.get_attribute_ns("", "a").value)
-    assert_equal("2", @attributes.get_attribute_ns("", "b").value)
-    assert_equal("3", @attributes.get_attribute_ns(@ns_a, "c").value)
-    assert_equal("4", @attributes.get_attribute_ns(@ns_a, "d").value)
-    assert_equal("5", @attributes.get_attribute_ns(@ns_a, "e").value)
-    assert_equal("6", @attributes.get_attribute_ns(@ns_b, "f").value)
+    def test_get_attribute_ns
+      assert_equal("1", @attributes.get_attribute_ns("", "a").value)
+      assert_equal("2", @attributes.get_attribute_ns("", "b").value)
+      assert_equal("3", @attributes.get_attribute_ns(@ns_a, "c").value)
+      assert_equal("4", @attributes.get_attribute_ns(@ns_a, "d").value)
+      assert_equal("5", @attributes.get_attribute_ns(@ns_a, "e").value)
+      assert_equal("6", @attributes.get_attribute_ns(@ns_b, "f").value)
+    end
   end
 end
diff --git a/test/rexml/test_changing_encoding.rb b/test/rexml/test_changing_encoding.rb
index fdcc075..a2dc072 100644
--- a/test/rexml/test_changing_encoding.rb
+++ b/test/rexml/test_changing_encoding.rb
@@ -1,43 +1,45 @@
 # -*- coding: utf-8 -*-
+# frozen_string_literal: false
 
 require 'rexml/encoding'
 
+module REXMLTests
+  class ChangingEncodings < Test::Unit::TestCase
+    def initialize a
+      @u = '   '
+      @e = @u.encode("EUC-JP")
+      @f = Foo.new
+      super
+    end
 
-class ChangingEncodings < Test::Unit::TestCase
-  def initialize a
-    @u = '   '
-    @e = @u.encode("EUC-JP")
-    @f = Foo.new
-    super
-  end
+    class Foo
+      include REXML::Encoding
+    end
 
-  class Foo
-    include REXML::Encoding
-  end
+    # Note that these tests must be executed in order for the third one to
+    # actually test anything.
+    def test_0_euc
+      @f.encoding = 'EUC-JP'
+      assert_equal( @u, @f.decode(@e) )
+      # This doesn't happen anymore, for some reason
+      #assert_raise( Iconv::IllegalSequence, "Decoding unicode should fail" ) {
+      #  @f.decode(@u) == @u
+      #}
+    end
 
-  # Note that these tests must be executed in order for the third one to
-  # actually test anything.
-  def test_0_euc
-    @f.encoding = 'EUC-JP'
-    assert_equal( @u, @f.decode(@e) )
-    # This doesn't happen anymore, for some reason
-    #assert_raises( Iconv::IllegalSequence, "Decoding unicode should fail" ) {
-    #  @f.decode(@u) == @u
-    #}
-  end
-
-  def test_1_utf
-    @f.encoding = 'UTF-8'
-    assert_not_equal( @u, @f.decode( @e ) )
-    assert_equal( @u, @f.decode( @u ) )
-  end
+    def test_1_utf
+      @f.encoding = 'UTF-8'
+      assert_not_equal( @u, @f.decode( @e ) )
+      assert_equal( @u, @f.decode( @u ) )
+    end
 
-  def test_2_euc
-    @f.encoding = 'EUC-JP'
-    assert_equal( @u, @f.decode(@e) )
-    # This doesn't happen anymore, for some reason
-    #assert_raises( Iconv::IllegalSequence, "Decoding unicode should fail" ) {
-    #  @f.decode(@u) == @u
-    #}
+    def test_2_euc
+      @f.encoding = 'EUC-JP'
+      assert_equal( @u, @f.decode(@e) )
+      # This doesn't happen anymore, for some reason
+      #assert_raise( Iconv::IllegalSequence, "Decoding unicode should fail" ) {
+      #  @f.decode(@u) == @u
+      #}
+    end
   end
 end
diff --git a/test/rexml/test_comment.rb b/test/rexml/test_comment.rb
index ebe3eea..0af2f5c 100644
--- a/test/rexml/test_comment.rb
+++ b/test/rexml/test_comment.rb
@@ -1,8 +1,9 @@
+# frozen_string_literal: false
 require "test/unit/testcase"
 
 require 'rexml/document'
 
-module REXMLTest
+module REXMLTests
   class CommentTester < Test::Unit::TestCase
     # Bug #5278
     def test_hyphen_end_line_in_doctype
diff --git a/test/rexml/test_contrib.rb b/test/rexml/test_contrib.rb
index d97b5a7..8462b3c 100644
--- a/test/rexml/test_contrib.rb
+++ b/test/rexml/test_contrib.rb
@@ -1,4 +1,5 @@
 # coding: binary
+# frozen_string_literal: false
 
 require_relative "rexml_test_utils"
 
@@ -6,11 +7,12 @@ require "rexml/document"
 require "rexml/parseexception"
 require "rexml/formatters/default"
 
-class ContribTester < Test::Unit::TestCase
-  include REXMLTestUtils
-  include REXML
+module REXMLTests
+  class ContribTester < Test::Unit::TestCase
+    include REXMLTestUtils
+    include REXML
 
-  XML_STRING_01 = <<DELIMITER
+    XML_STRING_01 = <<DELIMITER
 <?xml version="1.0" encoding="UTF-8"?>
 <biblio>
   <entry type="Book">
@@ -31,7 +33,7 @@ class ContribTester < Test::Unit::TestCase
 </biblio>
 DELIMITER
 
-  XML_STRING_02 = <<DELIMITER
+    XML_STRING_02 = <<DELIMITER
 <biblio>
   <entry type="Book">
     <language>english</language>
@@ -51,205 +53,205 @@ DELIMITER
 </biblio>
 DELIMITER
 
-  # Tobias Reif <tobiasreif@pinkjuice.com>
-  def test_bad_doctype_Tobias
-    source = <<-EOF
-     <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN"
-        "http://www.w3.org/TR/SVG/DTD/svg10.dtd"
-       [
-       <!-- <!ENTITY % fast-slow "0 0  .5 1">-->
-       <!--<!ENTITY % slow-fast ".5 0  1 1">-->
-       <!ENTITY hover_ani
-        '<animateTransform attributeName="transform"
-         type="scale" restart="whenNotActive" values="1;0.96"
-         dur="0.5s" calcMode="spline" keySplines="0 0  .5 1"
-         fill="freeze" begin="mouseover"/>
-         <animateTransform  attributeName="transform"
-         type="scale" restart="whenNotActive" values="0.96;1"
-         dur="0.5s" calcMode="spline" keySplines=".5 0  1 1"
-         fill="freeze" begin="mouseover+0.5s"/>'
+    # Tobias Reif <tobiasreif@pinkjuice.com>
+    def test_bad_doctype_Tobias
+      source = <<-EOF
+       <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN"
+          "http://www.w3.org/TR/SVG/DTD/svg10.dtd"
+         [
+         <!-- <!ENTITY % fast-slow "0 0  .5 1">-->
+         <!--<!ENTITY % slow-fast ".5 0  1 1">-->
+         <!ENTITY hover_ani
+          '<animateTransform attributeName="transform"
+           type="scale" restart="whenNotActive" values="1;0.96"
+           dur="0.5s" calcMode="spline" keySplines="0 0  .5 1"
+           fill="freeze" begin="mouseover"/>
+           <animateTransform  attributeName="transform"
+           type="scale" restart="whenNotActive" values="0.96;1"
+           dur="0.5s" calcMode="spline" keySplines=".5 0  1 1"
+           fill="freeze" begin="mouseover+0.5s"/>'
+         >
+         ]
        >
-       ]
-     >
-    EOF
-    doc = REXML::Document.new source
-    doc.write(out="")
-    assert(out[/>\'>/] != nil, "Couldn't find >'>")
-    assert(out[/\]>/] != nil, "Couldn't find ]>")
-  end
+      EOF
+      doc = REXML::Document.new source
+      doc.write(out="")
+      assert(out[/>\'>/] != nil, "Couldn't find >'>")
+      assert(out[/\]>/] != nil, "Couldn't find ]>")
+    end
 
-  # Peter Verhage
-  def test_namespace_Peter
-    source = <<-EOF
-    <?xml version="1.0"?>
-    <config:myprog-config xmlns:config="http://someurl/program/version">
-    <!-- main options -->
-      <config:main>
-        <config:parameter name="name"  value="value"/>
-      </config:main>
-    </config:myprog-config>
-    EOF
-    doc = REXML::Document.new source
-    assert_equal "myprog-config", doc.root.name
-    count = 0
-    REXML::XPath.each(doc, "x:myprog-config/x:main/x:parameter",
-      {"x"=>"http://someurl/program/version"}) { |element|
-        assert_equal "name", element.attributes["name"]
-      count += 1;
-    }
-    assert_equal 1, count
-    assert_equal "myprog-config", doc.elements["config:myprog-config"].name
-  end
+    # Peter Verhage
+    def test_namespace_Peter
+      source = <<-EOF
+      <?xml version="1.0"?>
+      <config:myprog-config xmlns:config="http://someurl/program/version">
+      <!-- main options -->
+        <config:main>
+          <config:parameter name="name"  value="value"/>
+        </config:main>
+      </config:myprog-config>
+      EOF
+      doc = REXML::Document.new source
+      assert_equal "myprog-config", doc.root.name
+      count = 0
+      REXML::XPath.each(doc, "x:myprog-config/x:main/x:parameter",
+        {"x"=>"http://someurl/program/version"}) { |element|
+          assert_equal "name", element.attributes["name"]
+        count += 1;
+      }
+      assert_equal 1, count
+      assert_equal "myprog-config", doc.elements["config:myprog-config"].name
+    end
 
-  # Tobias Reif <tobiasreif@pinkjuice.com>
-  def test_complex_xpath_Tobias
-    source = <<-EOF
-    <root>
-      <foo>
-        <bar style="baz"/>
-        <blah style="baz"/>
-        <blam style="baz"/>
-      </foo>
-      <wax>
-        <fudge>
-          <noodle/>
-        </fudge>
-      </wax>
-    </root>
-    EOF
-    # elements that have child elements
-    #  but not grandchildren
-    #  and not children that don't have a style attribute
-    #  and not children that have a unique style attribute
-    complex_path = "*[* "+
-      "and not(*/node()) "+
-      "and not(*[not(@style)]) "+
-      "and not(*/@style != */@style)]"
-    doc = REXML::Document.new source
-    results = REXML::XPath.match( doc.root, complex_path )
-    assert(results)
-    assert_equal 1, results.size
-    assert_equal "foo", results[0].name
-  end
+    # Tobias Reif <tobiasreif@pinkjuice.com>
+    def test_complex_xpath_Tobias
+      source = <<-EOF
+      <root>
+        <foo>
+          <bar style="baz"/>
+          <blah style="baz"/>
+          <blam style="baz"/>
+        </foo>
+        <wax>
+          <fudge>
+            <noodle/>
+          </fudge>
+        </wax>
+      </root>
+      EOF
+      # elements that have child elements
+      #  but not grandchildren
+      #  and not children that don't have a style attribute
+      #  and not children that have a unique style attribute
+      complex_path = "*[* "+
+        "and not(*/node()) "+
+        "and not(*[not(@style)]) "+
+        "and not(*/@style != */@style)]"
+      doc = REXML::Document.new source
+      results = REXML::XPath.match( doc.root, complex_path )
+      assert(results)
+      assert_equal 1, results.size
+      assert_equal "foo", results[0].name
+    end
 
-  # "Chris Morris" <chrismo@charter.net>
-  def test_extra_newline_on_read_Chris
-    text = 'test text'
-    e = REXML::Element.new('Test')
-    e.add_text(text)
-    REXML::Formatters::Default.new.write(e,out="")
+    # "Chris Morris" <chrismo@charter.net>
+    def test_extra_newline_on_read_Chris
+      text = 'test text'
+      e = REXML::Element.new('Test')
+      e.add_text(text)
+      REXML::Formatters::Default.new.write(e,out="")
 
-    doc = REXML::Document.new(out)
-    outtext = doc.root.text
+      doc = REXML::Document.new(out)
+      outtext = doc.root.text
 
-    assert_equal(text, outtext)
-  end
+      assert_equal(text, outtext)
+    end
 
-  # Tobias Reif <tobiasreif@pinkjuice.com>
-  def test_other_xpath_Tobias
-    schema = <<-DELIM
-    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
-      elementFormDefault="qualified">
-      <xs:element name="rect">
-        <xs:complexType>
-          <xs:attribute name="width" type="xs:byte" use="required"/>
-          <xs:attribute name="height" type="xs:byte" use="required"/>
-        </xs:complexType>
-      </xs:element>
-      <xs:element name="svg">
-        <xs:complexType>
-          <xs:sequence>
-            <xs:element ref="rect"/>
-          </xs:sequence>
-        </xs:complexType>
-      </xs:element>
-    </xs:schema>
-    DELIM
-
-    doc = REXML::Document.new schema
-
-    result = REXML::XPath.first(doc.root, 'xs:element[descendant::xs:element[@ref]]')
-    assert result
-    assert_equal "svg", result.attributes['name']
-    result = REXML::XPath.first(doc, 'element[descendant::element[@ref]]')
-    assert_nil result
-  end
+    # Tobias Reif <tobiasreif@pinkjuice.com>
+    def test_other_xpath_Tobias
+      schema = <<-DELIM
+      <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
+        elementFormDefault="qualified">
+        <xs:element name="rect">
+          <xs:complexType>
+            <xs:attribute name="width" type="xs:byte" use="required"/>
+            <xs:attribute name="height" type="xs:byte" use="required"/>
+          </xs:complexType>
+        </xs:element>
+        <xs:element name="svg">
+          <xs:complexType>
+            <xs:sequence>
+              <xs:element ref="rect"/>
+            </xs:sequence>
+          </xs:complexType>
+        </xs:element>
+      </xs:schema>
+      DELIM
+
+      doc = REXML::Document.new schema
+
+      result = REXML::XPath.first(doc.root, 'xs:element[descendant::xs:element[@ref]]')
+      assert result
+      assert_equal "svg", result.attributes['name']
+      result = REXML::XPath.first(doc, 'element[descendant::element[@ref]]')
+      assert_nil result
+    end
 
-  #this first test succeeds, to check if stuff is set up correctly
-  def test_xpath_01_TobiasReif
-    doc = Document.new XML_STRING_01.dup
-    desired_result = Document.new '<author>Thomas, David; Hunt, Andrew</author>'
-    xpath = '//author'
-    result = XPath.first(doc, xpath)
-    assert_equal desired_result.to_s, result.to_s
-  end
+    #this first test succeeds, to check if stuff is set up correctly
+    def test_xpath_01_TobiasReif
+      doc = Document.new XML_STRING_01.dup
+      desired_result = Document.new '<author>Thomas, David; Hunt, Andrew</author>'
+      xpath = '//author'
+      result = XPath.first(doc, xpath)
+      assert_equal desired_result.to_s, result.to_s
+    end
 
-  def test_xpath_whitespace_TobiasReif
-    # same as above, with whitespace in XPath
-    doc = Document.new(XML_STRING_01.dup)
-    desired_result = Document.new('<author>Thomas, David; Hunt, Andrew</author>')
-    xpath = "\/\/author\n \n"
-    result = XPath.first(doc, xpath)
-    failure_message = "\n[[[TR: AFAIK, whitespace should be allowed]]]\n"
-    assert_equal(desired_result.to_s, result.to_s, failure_message)
-  end
+    def test_xpath_whitespace_TobiasReif
+      # same as above, with whitespace in XPath
+      doc = Document.new(XML_STRING_01.dup)
+      desired_result = Document.new('<author>Thomas, David; Hunt, Andrew</author>')
+      xpath = "\/\/author\n \n"
+      result = XPath.first(doc, xpath)
+      failure_message = "\n[[[TR: AFAIK, whitespace should be allowed]]]\n"
+      assert_equal(desired_result.to_s, result.to_s, failure_message)
+    end
 
-  def test_xpath_02_TobiasReif
-    doc = Document.new XML_STRING_01.dup
-    desired_result = Document.new '<author>Thomas, David; Hunt, Andrew</author>'
-    # Could that quirky
-    #  Programmer',&quot;'&quot;,'s
-    # be handled automatically, somehow?
-    # Or is there a simpler way? (the below XPath should match the author element above,
-    # AFAIK; I tested it inside an XSLT)
-    xpath = %q{/biblio/entry[
-    title/text()=concat('Programming Ruby. The Pragmatic Programmer',"'",'s Guide')
-    and
-    year='2000'
-    ]/author}
-    result = XPath.first(doc, xpath)
-    failure_message = "\nHow to handle the apos inside the string inside the XPath?\nXPath = #{xpath}\n"
-    assert_equal desired_result.to_s, result.to_s, failure_message
-  end
+    def test_xpath_02_TobiasReif
+      doc = Document.new XML_STRING_01.dup
+      desired_result = Document.new '<author>Thomas, David; Hunt, Andrew</author>'
+      # Could that quirky
+      #  Programmer',&quot;'&quot;,'s
+      # be handled automatically, somehow?
+      # Or is there a simpler way? (the below XPath should match the author element above,
+      # AFAIK; I tested it inside an XSLT)
+      xpath = %q{/biblio/entry[
+      title/text()=concat('Programming Ruby. The Pragmatic Programmer',"'",'s Guide')
+      and
+      year='2000'
+      ]/author}
+      result = XPath.first(doc, xpath)
+      failure_message = "\nHow to handle the apos inside the string inside the XPath?\nXPath = #{xpath}\n"
+      assert_equal desired_result.to_s, result.to_s, failure_message
+    end
 
-  def test_xpath_03_TobiasReif
-    doc = Document.new XML_STRING_02.dup
-    desired_result_string = "<entry type='Book'>
+    def test_xpath_03_TobiasReif
+      doc = Document.new XML_STRING_02.dup
+      desired_result_string = "<entry type='Book'>
     <language>english</language>
     <publisher>Addison-Wesley</publisher>
     <title>Programming Ruby. The Pragmatic Programmer's Guide</title>
     <type>Book</type>
     <year>2000</year>
   </entry>"
-    Document.new desired_result_string
-    xpath = "/biblio/entry[not(author)]"
-    result = XPath.first(doc, xpath)
-    assert_equal desired_result_string, result.to_s
-  end
-
-  def test_umlaut
-    koln_iso = "K\xf6ln"
-    koln_utf = "K\xc3\xb6ln"
-    source_iso = "<?xml version='1.0' encoding='ISO-8859-1'?><test>#{koln_iso}</test>"
-    source_utf = "<?xml version='1.0' encoding='UTF-8'?><test>#{koln_utf}</test>"
-
-    if String.method_defined? :encode
-      koln_iso.force_encoding('iso-8859-1')
-      koln_utf.force_encoding('utf-8')
-      source_iso.force_encoding('iso-8859-1')
-      source_utf.force_encoding('utf-8')
+      Document.new desired_result_string
+      xpath = "/biblio/entry[not(author)]"
+      result = XPath.first(doc, xpath)
+      assert_equal desired_result_string, result.to_s
     end
 
-    doc = REXML::Document.new(source_iso)
-    assert_equal('ISO-8859-1', doc.xml_decl.encoding)
-    assert_equal(koln_utf, doc.root.text)
-    doc.write(out="")
-    assert_equal(source_iso, out )
-    doc.xml_decl.encoding = 'UTF-8'
-    doc.write(out="")
-    assert_equal(source_utf, out)
+    def test_umlaut
+      koln_iso = "K\xf6ln"
+      koln_utf = "K\xc3\xb6ln"
+      source_iso = "<?xml version='1.0' encoding='ISO-8859-1'?><test>#{koln_iso}</test>"
+      source_utf = "<?xml version='1.0' encoding='UTF-8'?><test>#{koln_utf}</test>"
+
+      if String.method_defined? :encode
+        koln_iso.force_encoding('iso-8859-1')
+        koln_utf.force_encoding('utf-8')
+        source_iso.force_encoding('iso-8859-1')
+        source_utf.force_encoding('utf-8')
+      end
+
+      doc = REXML::Document.new(source_iso)
+      assert_equal('ISO-8859-1', doc.xml_decl.encoding)
+      assert_equal(koln_utf, doc.root.text)
+      doc.write(out="")
+      assert_equal(source_iso, out )
+      doc.xml_decl.encoding = 'UTF-8'
+      doc.write(out="")
+      assert_equal(source_utf, out)
 
-    doc = Document.new <<-EOF
+      doc = Document.new <<-EOF
 <?xml version="1.0" encoding="ISO-8859-1"?>
 <intranet>
 <position><aktuell datum="01-10-11">Technik</aktuell></position>
@@ -265,254 +267,255 @@ Die Technik ist das R\xFCckgrat der meisten Gesch\xFCftsprozesse bei Home of the
 </nebenspalte>
 </intranet>
 EOF
-    tn = XPath.first(doc, "//nebenspalte/text()[2]")
-    expected_iso = "N\xFCtzliches von Flashern f\xFCr Flasher."
-    expected_utf = expected_iso.unpack('C*').pack('U*')
-    expected_iso.force_encoding(::Encoding::ISO_8859_1)
-    expected_utf.force_encoding(::Encoding::UTF_8)
-    assert_equal(expected_utf, tn.to_s.strip)
-    f = REXML::Formatters::Default.new
-    f.write( tn, Output.new(o = "", "ISO-8859-1") )
-    assert_equal(expected_iso, o.strip)
-
-    doc = Document.new File.new(fixture_path('xmlfile-bug.xml'))
-    tn = XPath.first(doc, "//nebenspalte/text()[2]")
-    assert_equal(expected_utf, tn.to_s.strip)
-    f.write( tn, Output.new(o = "", "ISO-8859-1") )
-    assert_equal(expected_iso, o.strip)
-  end
-
-  def test_element_cloning_namespace_Chris
-    aDoc = REXML::Document.new '<h1 tpl:content="title" xmlns:tpl="1">Dummy title</h1>'
+      tn = XPath.first(doc, "//nebenspalte/text()[2]")
+      expected_iso = "N\xFCtzliches von Flashern f\xFCr Flasher."
+      expected_utf = expected_iso.unpack('C*').pack('U*')
+      expected_iso.force_encoding(::Encoding::ISO_8859_1)
+      expected_utf.force_encoding(::Encoding::UTF_8)
+      assert_equal(expected_utf, tn.to_s.strip)
+      f = REXML::Formatters::Default.new
+      f.write( tn, Output.new(o = "", "ISO-8859-1") )
+      assert_equal(expected_iso, o.strip)
+
+      doc = File.open(fixture_path('xmlfile-bug.xml')) {|file| Document.new file }
+      tn = XPath.first(doc, "//nebenspalte/text()[2]")
+      assert_equal(expected_utf, tn.to_s.strip)
+      f.write( tn, Output.new(o = "", "ISO-8859-1") )
+      assert_equal(expected_iso, o.strip)
+    end
 
-    anElement = anElement = aDoc.elements[1]
-    elementAttrPrefix = anElement.attributes.get_attribute('content').prefix
+    def test_element_cloning_namespace_Chris
+      aDoc = REXML::Document.new '<h1 tpl:content="title" xmlns:tpl="1">Dummy title</h1>'
 
-    aClone = anElement.clone
-    cloneAttrPrefix = aClone.attributes.get_attribute('content').prefix
+      anElement = anElement = aDoc.elements[1]
+      elementAttrPrefix = anElement.attributes.get_attribute('content').prefix
 
-    assert_equal( elementAttrPrefix , cloneAttrPrefix )
-  end
+      aClone = anElement.clone
+      cloneAttrPrefix = aClone.attributes.get_attribute('content').prefix
 
-  def test_namespaces_in_attlist_tobias
-    in_string = File.open(fixture_path('foo.xml'), 'r') do |file|
-       file.read
+      assert_equal( elementAttrPrefix , cloneAttrPrefix )
     end
 
-    doc = Document.new in_string
+    def test_namespaces_in_attlist_tobias
+      in_string = File.open(fixture_path('foo.xml'), 'r') do |file|
+         file.read
+      end
 
-    assert_nil XPath.first(doc,'//leg')
-    assert_equal 'http://www.foo.com/human', doc.root.elements[1].namespace
-    assert_equal 'human leg',
-      XPath.first(doc, '//x:leg/text()', {'x'=>'http://www.foo.com/human'}).to_s
-  end
+      doc = Document.new in_string
 
-  #  Alun ap Rhisiart
-  def test_less_than_in_element_content
-    source = File.new(fixture_path('ProductionSupport.xml'))
-    h = Hash.new
-    doc = REXML::Document.new source
-    doc.elements.each("//CommonError") { |el|
-      h[el.elements['Key'].text] = 'okay'
-    }
-    assert(h.include?('MotorInsuranceContract(Object)>>#error:'))
-  end
+      assert_nil XPath.first(doc,'//leg')
+      assert_equal 'http://www.foo.com/human', doc.root.elements[1].namespace
+      assert_equal 'human leg',
+        XPath.first(doc, '//x:leg/text()', {'x'=>'http://www.foo.com/human'}).to_s
+    end
 
-  # XPaths provided by Thomas Sawyer
-  def test_various_xpath
-    #@doc = REXML::Document.new('<r a="1"><p><c b="2"/></p></r>')
-    doc = REXML::Document.new('<r a="1"><p><c b="2">3</c></p></r>')
-
-    [['/r', REXML::Element],
-     ['/r/p/c', REXML::Element],
-     ['/r/attribute::a', Attribute],
-     ['/r/@a', Attribute],
-     ['/r/attribute::*', Attribute],
-     ['/r/@*', Attribute],
-     ['/r/p/c/attribute::b', Attribute],
-     ['/r/p/c/@b', Attribute],
-     ['/r/p/c/attribute::*', Attribute],
-     ['/r/p/c/@*', Attribute],
-     ['//c/attribute::b', Attribute],
-     ['//c/@b', Attribute],
-     ['//c/attribute::*', Attribute],
-     ['//c/@*', Attribute],
-     ['.//node()', REXML::Node ],
-     ['.//node()[@a]', REXML::Element ],
-     ['.//node()[@a="1"]', REXML::Element ],
-     ['.//node()[@b]', REXML::Element ], # no show, why?
-     ['.//node()[@b="2"]', REXML::Element ]
-    ].each do |xpath,kind|
-      begin
-        REXML::XPath.each( doc, xpath ) do |what|
-          assert_kind_of( kind, what, "\n\nWrong type (#{what.class}) returned for #{xpath} (expected #{kind.name})\n\n" )
-        end
-      rescue Exception
-        puts "PATH WAS: #{xpath}"
-        raise
+    #  Alun ap Rhisiart
+    def test_less_than_in_element_content
+      doc = File.open(fixture_path('ProductionSupport.xml')) do |source|
+        REXML::Document.new source
       end
+      h = Hash.new
+      doc.elements.each("//CommonError") { |el|
+        h[el.elements['Key'].text] = 'okay'
+      }
+      assert(h.include?('MotorInsuranceContract(Object)>>#error:'))
     end
 
-    [
-     ['/r', 'attribute::a', Attribute ],
-     ['/r', '@a', Attribute ],
-     ['/r', 'attribute::*', Attribute ],
-     ['/r', '@*', Attribute ],
-     ['/r/p/c', 'attribute::b', Attribute ],
-     ['/r/p/c', '@b', Attribute ],
-     ['/r/p/c', 'attribute::*', Attribute ],
-     ['/r/p/c', '@*', Attribute ]
-    ].each do |nodepath, xpath, kind|
-      begin
-        context = REXML::XPath.first(doc, nodepath)
-        REXML::XPath.each( context, xpath ) do |what|
-          assert_kind_of kind, what, "Wrong type (#{what.class}) returned for #{xpath} (expected #{kind.name})\n"
+    # XPaths provided by Thomas Sawyer
+    def test_various_xpath
+      #@doc = REXML::Document.new('<r a="1"><p><c b="2"/></p></r>')
+      doc = REXML::Document.new('<r a="1"><p><c b="2">3</c></p></r>')
+
+      [['/r', REXML::Element],
+       ['/r/p/c', REXML::Element],
+       ['/r/attribute::a', Attribute],
+       ['/r/@a', Attribute],
+       ['/r/attribute::*', Attribute],
+       ['/r/@*', Attribute],
+       ['/r/p/c/attribute::b', Attribute],
+       ['/r/p/c/@b', Attribute],
+       ['/r/p/c/attribute::*', Attribute],
+       ['/r/p/c/@*', Attribute],
+       ['//c/attribute::b', Attribute],
+       ['//c/@b', Attribute],
+       ['//c/attribute::*', Attribute],
+       ['//c/@*', Attribute],
+       ['.//node()', REXML::Node ],
+       ['.//node()[@a]', REXML::Element ],
+       ['.//node()[@a="1"]', REXML::Element ],
+       ['.//node()[@b]', REXML::Element ], # no show, why?
+       ['.//node()[@b="2"]', REXML::Element ]
+      ].each do |xpath,kind|
+        begin
+          REXML::XPath.each( doc, xpath ) do |what|
+            assert_kind_of( kind, what, "\n\nWrong type (#{what.class}) returned for #{xpath} (expected #{kind.name})\n\n" )
+          end
+        rescue Exception
+          puts "PATH WAS: #{xpath}"
+          raise
         end
-      rescue Exception
-        puts "PATH WAS: #{xpath}"
-        raise
       end
-    end
-  end
 
-  def test_entities_Holden_Glova
-    document = <<-EOL
-    <?xml version="1.0" encoding="UTF-8"?>
-    <!DOCTYPE rubynet [
-    <!ENTITY rbconfig.MAJOR "1">
-    <!ENTITY rbconfig.MINOR "7">
-    <!ENTITY rbconfig.TEENY "2">
-    <!ENTITY rbconfig.ruby_version "&rbconfig.MAJOR;.&rbconfig.MINOR;">
-    <!ENTITY rbconfig.arch "i386-freebsd5">
-    <!ENTITY rbconfig.prefix "/usr/local">
-    <!ENTITY rbconfig.libdir "&rbconfig.prefix;/lib">
-    <!ENTITY rbconfig.includedir "&rbconfig.prefix;/include">
-    <!ENTITY rbconfig.sitedir "&rbconfig.prefix;/lib/ruby/site_ruby">
-    <!ENTITY rbconfig.sitelibdir "&rbconfig.sitedir;/&rbconfig.ruby_version;">
-    <!ENTITY rbconfig.sitearchdir "&rbconfig.sitelibdir;/&rbconfig.arch;">
-    ]>
-    <rubynet>
-      <pkg version="version1.0">
-        <files>
-          <file>
-            <filename>uga.rb</filename>
-            <mode>0444</mode>
-            <path>&rbconfig.libdir;/rexml</path>
-            <content encoding="xml">... the file here</content>
-          </file>
-          <file>
-            <filename>booga.h</filename>
-            <mode>0444</mode>
-            <path>&rbconfig.includedir;</path>
-            <content encoding="xml">... the file here</content>
-          </file>
-          <file>
-            <filename>foo.so</filename>
-            <mode>0555</mode>
-            <path>&rbconfig.sitearchdir;/rexml</path>
-            <content encoding="mime64">Li4uIHRoZSBmaWxlIGhlcmU=\n</content>
-          </file>
-        </files>
-      </pkg>
-    </rubynet>
-    EOL
-
-    file_xpath = '/rubynet/pkg/files/file'
-
-    root = REXML::Document.new(document)
-
-    root.elements.each(file_xpath) do |metadata|
-      text = metadata.elements['path'].get_text.value
-      assert text !~ /&rbconfig/, "'#{text}' failed"
+      [
+       ['/r', 'attribute::a', Attribute ],
+       ['/r', '@a', Attribute ],
+       ['/r', 'attribute::*', Attribute ],
+       ['/r', '@*', Attribute ],
+       ['/r/p/c', 'attribute::b', Attribute ],
+       ['/r/p/c', '@b', Attribute ],
+       ['/r/p/c', 'attribute::*', Attribute ],
+       ['/r/p/c', '@*', Attribute ]
+      ].each do |nodepath, xpath, kind|
+        begin
+          context = REXML::XPath.first(doc, nodepath)
+          REXML::XPath.each( context, xpath ) do |what|
+            assert_kind_of kind, what, "Wrong type (#{what.class}) returned for #{xpath} (expected #{kind.name})\n"
+          end
+        rescue Exception
+          puts "PATH WAS: #{xpath}"
+          raise
+        end
+      end
     end
 
-    #Error occurred in test_package_file_opens(TC_PackageInstall):
-    # ArgumentError:
-    #illegal access mode &rbconfig.prefix;/lib/rexml
-    #
-    #[synack@Evergreen] src $ ruby --version
-    #ruby 1.6.7 (2002-03-01) [i686-linux-gnu]
-    #
-    #It looks like it expanded the first entity, but didn't reparse it for more
-    #entities. possible bug - or have I mucked this up?
-  end
+    def test_entities_Holden_Glova
+      document = <<-EOL
+      <?xml version="1.0" encoding="UTF-8"?>
+      <!DOCTYPE rubynet [
+      <!ENTITY rbconfig.MAJOR "1">
+      <!ENTITY rbconfig.MINOR "7">
+      <!ENTITY rbconfig.TEENY "2">
+      <!ENTITY rbconfig.ruby_version "&rbconfig.MAJOR;.&rbconfig.MINOR;">
+      <!ENTITY rbconfig.arch "i386-freebsd5">
+      <!ENTITY rbconfig.prefix "/usr/local">
+      <!ENTITY rbconfig.libdir "&rbconfig.prefix;/lib">
+      <!ENTITY rbconfig.includedir "&rbconfig.prefix;/include">
+      <!ENTITY rbconfig.sitedir "&rbconfig.prefix;/lib/ruby/site_ruby">
+      <!ENTITY rbconfig.sitelibdir "&rbconfig.sitedir;/&rbconfig.ruby_version;">
+      <!ENTITY rbconfig.sitearchdir "&rbconfig.sitelibdir;/&rbconfig.arch;">
+      ]>
+      <rubynet>
+        <pkg version="version1.0">
+          <files>
+            <file>
+              <filename>uga.rb</filename>
+              <mode>0444</mode>
+              <path>&rbconfig.libdir;/rexml</path>
+              <content encoding="xml">... the file here</content>
+            </file>
+            <file>
+              <filename>booga.h</filename>
+              <mode>0444</mode>
+              <path>&rbconfig.includedir;</path>
+              <content encoding="xml">... the file here</content>
+            </file>
+            <file>
+              <filename>foo.so</filename>
+              <mode>0555</mode>
+              <path>&rbconfig.sitearchdir;/rexml</path>
+              <content encoding="mime64">Li4uIHRoZSBmaWxlIGhlcmU=\n</content>
+            </file>
+          </files>
+        </pkg>
+      </rubynet>
+      EOL
+
+      file_xpath = '/rubynet/pkg/files/file'
+
+      root = REXML::Document.new(document)
+
+      root.elements.each(file_xpath) do |metadata|
+        text = metadata.elements['path'].get_text.value
+        assert text !~ /&rbconfig/, "'#{text}' failed"
+      end
 
-  def test_whitespace_after_xml_decl
-    Document.new <<EOL
+      #Error occurred in test_package_file_opens(TC_PackageInstall):
+      # ArgumentError:
+      #illegal access mode &rbconfig.prefix;/lib/rexml
+      #
+      #[synack@Evergreen] src $ ruby --version
+      #ruby 1.6.7 (2002-03-01) [i686-linux-gnu]
+      #
+      #It looks like it expanded the first entity, but didn't reparse it for more
+      #entities. possible bug - or have I mucked this up?
+    end
+
+    def test_whitespace_after_xml_decl
+      Document.new <<EOL
 <?xml version='1.0'?>
   <blo>
     <wak>
     </wak>
 </blo>
 EOL
-  end
+    end
 
-  def test_external_entity
-    xp = '//channel/title'
+    def test_external_entity
+      xp = '//channel/title'
 
-    %w{working.rss broken.rss}.each do |path|
-      File.open(File.join(fixture_path(path))) do |file|
-        doc = REXML::Document.new file.readlines.join('')
+      %w{working.rss broken.rss}.each do |path|
+        File.open(File.join(fixture_path(path))) do |file|
+          doc = REXML::Document.new file.readlines.join('')
 
-        # check to make sure everything is kosher
-        assert_equal( doc.root.class, REXML::Element )
-        assert_equal( doc.root.elements.class, REXML::Elements )
+          # check to make sure everything is kosher
+          assert_equal( doc.root.class, REXML::Element )
+          assert_equal( doc.root.elements.class, REXML::Elements )
 
-        # get the title of the feed
-        assert( doc.root.elements[xp].kind_of?( REXML::Element ) )
+          # get the title of the feed
+          assert( doc.root.elements[xp].kind_of?( REXML::Element ) )
+        end
       end
     end
-  end
 
-  def test_maintain_dtd
-    src = %q{<?xml version="1.0" encoding="UTF-8"?>
+    def test_maintain_dtd
+      src = %q{<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE ivattacks SYSTEM "../../ivacm.dtd" [
 <!ENTITY % extern-packages SYSTEM "../../ivpackages.dtd">
 <!ENTITY % extern-packages SYSTEM "../../common-declarations.dtd">
 %extern-packages;
 %extern-common;
 ]>}
-    doc = Document.new( src )
-    doc.write( out="" )
-    src = src.tr('"', "'")
-    out = out.tr('"', "'")
-    assert_equal( src, out )
-  end
+      doc = Document.new( src )
+      doc.write( out="" )
+      src = src.tr('"', "'")
+      out = out.tr('"', "'")
+      assert_equal( src, out )
+    end
 
-  def test_text_nodes_nomatch
-    source = "<root><child>test</child></root>"
-    d = REXML::Document.new( source )
-    r = REXML::XPath.match( d, %q{/root/child[text()="no-test"]} )
-    assert_equal( 0, r.size )
-  end
+    def test_text_nodes_nomatch
+      source = "<root><child>test</child></root>"
+      d = REXML::Document.new( source )
+      r = REXML::XPath.match( d, %q{/root/child[text()="no-test"]} )
+      assert_equal( 0, r.size )
+    end
 
-  def test_raw_Terje_Elde
-    f = REXML::Formatters::Default.new
-    txt = 'abc&#248;def'
-    a = Text.new( txt,false,nil,true )
-    f.write(a,out="")
-    assert_equal( txt, out )
-
-    txt = '<sean><russell>abc&#248;def</russell></sean>'
-    a = Document.new( txt, { :raw => ["russell"] } )
-    f.write(a,out="")
-    assert_equal( txt, out )
-  end
+    def test_raw_Terje_Elde
+      f = REXML::Formatters::Default.new
+      txt = 'abc&#248;def'
+      a = Text.new( txt,false,nil,true )
+      f.write(a,out="")
+      assert_equal( txt, out )
+
+      txt = '<sean><russell>abc&#248;def</russell></sean>'
+      a = Document.new( txt, { :raw => ["russell"] } )
+      f.write(a,out="")
+      assert_equal( txt, out )
+    end
 
-  def test_indenting_error
-    a=Element.new("test1")
-    b=Element.new("test2")
-    c=Element.new("test3")
-    b << c
-    a << b
+    def test_indenting_error
+      a=Element.new("test1")
+      b=Element.new("test2")
+      c=Element.new("test3")
+      b << c
+      a << b
 
-    REXML::Formatters::Pretty.new.write(a,"")
-  end
+      REXML::Formatters::Pretty.new.write(a,"")
+    end
 
-  def test_pos
-    require 'tempfile'
-    Tempfile.create("tidal") {|testfile|
-      testdata = %Q{<calibration>
+    def test_pos
+      require 'tempfile'
+      Tempfile.create("tidal") {|testfile|
+        testdata = %Q{<calibration>
 <section name="parameters">
 <param name="barpress">760</param>
 <param name="hertz">50</param>
@@ -520,62 +523,63 @@ EOL
 </calibration>
 }
 
-      testfile.puts testdata
-      testfile.rewind
-      assert_nothing_raised do
-        REXML::Document.new(testfile)
-      end
-    }
-  end
+        testfile.puts testdata
+        testfile.rewind
+        assert_nothing_raised do
+          REXML::Document.new(testfile)
+        end
+      }
+    end
 
-  def test_deep_clone
-    a = Document.new( '<?xml version="1.0"?><!DOCTYPE html PUBLIC
-    "-//W3C//DTD
-    XHTML 1.0 Transitional//EN"
-    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html
-    xmlns="http:///www.w3.org/1999/xhtml"></html>' )
-    b = a.deep_clone
-    assert_equal a.to_s, b.to_s
-  end
+    def test_deep_clone
+      a = Document.new( '<?xml version="1.0"?><!DOCTYPE html PUBLIC
+      "-//W3C//DTD
+      XHTML 1.0 Transitional//EN"
+      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html
+      xmlns="http:///www.w3.org/1999/xhtml"></html>' )
+      b = a.deep_clone
+      assert_equal a.to_s, b.to_s
+    end
 
-  def test_double_escaping
-    data = '<title>AT&amp;T</title>'
-    xml = "<description><![CDATA[#{data}]]></description>"
+    def test_double_escaping
+      data = '<title>AT&amp;T</title>'
+      xml = "<description><![CDATA[#{data}]]></description>"
 
-    doc = REXML::Document.new(xml)
-    description = doc.find {|e| e.name=="description"}
-    assert_equal data, description.text
-  end
+      doc = REXML::Document.new(xml)
+      description = doc.find {|e| e.name=="description"}
+      assert_equal data, description.text
+    end
 
-  def test_ticket_12
-    cfg = "<element><anotherelement><child1>a</child1><child2>b</child2></anotherelement></element>"
+    def test_ticket_12
+      cfg = "<element><anotherelement><child1>a</child1><child2>b</child2></anotherelement></element>"
 
-    config = REXML::Document.new( cfg )
+      config = REXML::Document.new( cfg )
 
-    assert_equal( "a", config.elements[ "//child1" ].text )
-  end
+      assert_equal( "a", config.elements[ "//child1" ].text )
+    end
 
 =begin
- # This is a silly test, and is low priority
- def test_namespace_serialization_tobi_reif
-   doc = Document.new '<doc xmlns:b="http://www.foo.foo">
- <b:p/>
-</doc>'
-   ns = 'http://www.foo.foo'
-   ns_declaration={'f'=>ns}
-   returned = XPath.match(doc,'//f:p',ns_declaration)
-   # passes:
-   assert( (returned[0].namespace==ns), 'namespace should be '+ns)
-   serialized = returned.to_s
-   serialized_and_parsed = Document.new(serialized)
-   puts 'serialized: '+serialized
-     # ... currently brings <b:p/>
-     # prefix b is undeclared (!)
-   assert( (serialized_and_parsed.namespace==ns),
-     'namespace should still be '+ns.inspect+
-     ' and not '+serialized_and_parsed.namespace.inspect)
-   # ... currently results in a failure:
-   # 'namespace should still be "http://www.foo.foo" and not ""'
- end
+    # This is a silly test, and is low priority
+    def test_namespace_serialization_tobi_reif
+      doc = Document.new '<doc xmlns:b="http://www.foo.foo">
+    <b:p/>
+   </doc>'
+      ns = 'http://www.foo.foo'
+      ns_declaration={'f'=>ns}
+      returned = XPath.match(doc,'//f:p',ns_declaration)
+      # passes:
+      assert( (returned[0].namespace==ns), 'namespace should be '+ns)
+      serialized = returned.to_s
+      serialized_and_parsed = Document.new(serialized)
+      puts 'serialized: '+serialized
+        # ... currently brings <b:p/>
+        # prefix b is undeclared (!)
+      assert( (serialized_and_parsed.namespace==ns),
+        'namespace should still be '+ns.inspect+
+        ' and not '+serialized_and_parsed.namespace.inspect)
+      # ... currently results in a failure:
+      # 'namespace should still be "http://www.foo.foo" and not ""'
+    end
 =end
+  end
 end
diff --git a/test/rexml/test_core.rb b/test/rexml/test_core.rb
index 02930e5..26e5ecd 100644
--- a/test/rexml/test_core.rb
+++ b/test/rexml/test_core.rb
@@ -1,4 +1,5 @@
-# coding: utf-8
+# -*- coding: utf-8 -*-
+# frozen_string_literal: false
 
 require_relative "rexml_test_utils"
 
@@ -11,1165 +12,1217 @@ require "rexml/undefinednamespaceexception"
 
 require_relative "listener"
 
-class Tester < Test::Unit::TestCase
-  include REXMLTestUtils
-  include REXML
-  def setup
-    @xsa_source = <<-EOL
-      <?xml version="1.0"?>
-      <?xsl stylesheet="blah.xsl"?>
-      <!-- The first line tests the XMLDecl, the second tests PI.
-      The next line tests DocType. This line tests comments. -->
-      <!DOCTYPE xsa PUBLIC
-        "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML"
-        "http://www.garshol.priv.no/download/xsa/xsa.dtd">
-
-      <xsa>
-        <vendor id="blah">
-          <name>Lars Marius Garshol</name>
-          <email>larsga@garshol.priv.no</email>
-          <url>http://www.stud.ifi.uio.no/~lmariusg/</url>
-        </vendor>
-      </xsa>
-    EOL
-  end
+module REXMLTests
+  class Tester < Test::Unit::TestCase
+    include REXMLTestUtils
+    include REXML
+    def setup
+      @xsa_source = <<-EOL
+        <?xml version="1.0"?>
+        <?xsl stylesheet="blah.xsl"?>
+        <!-- The first line tests the XMLDecl, the second tests PI.
+        The next line tests DocType. This line tests comments. -->
+        <!DOCTYPE xsa PUBLIC
+          "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML"
+          "http://www.garshol.priv.no/download/xsa/xsa.dtd">
+
+        <xsa>
+          <vendor id="blah">
+            <name>Lars Marius Garshol</name>
+            <email>larsga@garshol.priv.no</email>
+            <url>http://www.stud.ifi.uio.no/~lmariusg/</url>
+          </vendor>
+        </xsa>
+      EOL
+    end
 
-  def test_bad_markup
-    [
-      "<pkg='version'> foo </pkg>",
-      '<0/>',
-      '<a>&</a>',
-      '<a>&a</a>',
-#      '<a>&a;</a>', # FIXME
-      '<a a="<"/>',
-      '<a 3="<"/>',
-      '<a a="1" a="2"/>',
-      '<a><!-- -- --></a>',
-      '<a><!-- ---></a>',
-      '<a>&#x00;</a>',
-      '<a>&#0;</a>',
-      "<a a='&#0;' />",
-      "<a>\f</a>",
-      "<a a='\f' />",
-      "<a>\000</a>",
+    def test_bad_markup
+      [
+        "<pkg='version'> foo </pkg>",
+        '<0/>',
+        '<a>&</a>',
+        '<a>&a</a>',
+#        '<a>&a;</a>', # FIXME
+        '<a a="<"/>',
+        '<a 3="<"/>',
+        '<a a="1" a="2"/>',
+        '<a><!-- -- --></a>',
+        '<a><!-- ---></a>',
+        '<a>&#x00;</a>',
+        '<a>&#0;</a>',
+        "<a a='&#0;' />",
+        "<a>\f</a>",
+        "<a a='\f' />",
+        "<a>\000</a>",
 # FIXME      '<a' + [65535].pack('U') + ' />',
-      '<a>&#xfffe;</a>',
-      '<a>&#65535;</a>',
+        '<a>&#xfffe;</a>',
+        '<a>&#65535;</a>',
 # FIXME      '<a' + [0x0371].pack('U') + ' />',
 # FIXME      '<a a' + [0x0371].pack('U') + '="" />',
-    ].each do |src|
-      assert_raise( ParseException, %Q{Parse #{src.inspect} should have failed!} ) do
-        Document.new(src)
+      ].each do |src|
+        assert_raise( ParseException, %Q{Parse #{src.inspect} should have failed!} ) do
+          Document.new(src)
+        end
       end
     end
-  end
 
-  def test_attribute
-    # Testing constructors
-    #a = Attribute.new "hello", "dolly"
-    #b = Attribute.new a
-    #d = Document.new( "<a hello='dolly' href='blah'/>" )
-    #c = d[0].attributes.get_attribute( "hello" )
-
-    #assert_equal a, b
-    #for attr in [ a, b, c]
-    #  assert_equal "hello", attr.name
-    #  assert_equal "dolly", attr.value
-    #end
-
-    # This because of a reported bug in attribute handling in 1.0a8
-    source = '<a att="A">blah</a>'
-    doc = Document.new source
-    doc.elements.each do |a|
-      a.attributes['att'] << 'B'
-      assert_equal "AB", a.attributes['att']
-      a.attributes['att'] = 'C'
-      assert_equal "C", a.attributes['att']
-    end
-
-    # Bryan Murphy <murphybryanp@yahoo.com>
-    text = "this is a {target[@name='test']/@value} test"
-    source = <<-EOL
-    <?xml version="1.0"?>
-    <doc search="#{text}"/>
-    EOL
-
-    xml  = Document.new source
-    value = xml.root.attributes["search"]
-    assert_equal text, value.to_s
-
-    e = Element.new "test"
-    e.add_attributes({ "name1" => "test1", "name4" => "test4" })
-    e.add_attributes([["name3","test3"], ["name2","test2"]])
-    assert_equal "test1", e.attributes["name1"]
-    assert_equal "test2", e.attributes["name2"]
-    assert_equal "test3", e.attributes["name3"]
-    assert_equal "test4", e.attributes["name4"]
-
-    # ensure that the attributes come out in sorted order
-    assert_equal %w(<test
-      name1='test1'
-      name2='test2'
-      name3='test3'
-      name4='test4'/>).join(' '), e.to_s
-  end
+    def test_attribute
+      # Testing constructors
+      #a = Attribute.new "hello", "dolly"
+      #b = Attribute.new a
+      #d = Document.new( "<a hello='dolly' href='blah'/>" )
+      #c = d[0].attributes.get_attribute( "hello" )
+
+      #assert_equal a, b
+      #for attr in [ a, b, c]
+      #  assert_equal "hello", attr.name
+      #  assert_equal "dolly", attr.value
+      #end
+
+      # This because of a reported bug in attribute handling in 1.0a8
+      source = '<a att="A">blah</a>'
+      doc = Document.new source
+      doc.elements.each do |a|
+        a.attributes['att'] << 'B'
+        assert_equal "AB", a.attributes['att']
+        a.attributes['att'] = 'C'
+        assert_equal "C", a.attributes['att']
+      end
 
-  def test_cdata
-    test = "The quick brown fox jumped
-      & < & < \" '
-    over the lazy dog."
+      # Bryan Murphy <murphybryanp@yahoo.com>
+      text = "this is a {target[@name='test']/@value} test"
+      source = <<-EOL
+      <?xml version="1.0"?>
+      <doc search="#{text}"/>
+      EOL
+
+      xml  = Document.new source
+      value = xml.root.attributes["search"]
+      assert_equal text, value.to_s
+
+      e = Element.new "test"
+      e.add_attributes({ "name1" => "test1", "name4" => "test4" })
+      e.add_attributes([["name3","test3"], ["name2","test2"]])
+      assert_equal "test1", e.attributes["name1"]
+      assert_equal "test2", e.attributes["name2"]
+      assert_equal "test3", e.attributes["name3"]
+      assert_equal "test4", e.attributes["name4"]
+
+      # ensure that the attributes come out in sorted order
+      assert_equal %w(<test
+        name1='test1'
+        name2='test2'
+        name3='test3'
+        name4='test4'/>).join(' '), e.to_s
+    end
 
-    source = "<a><![CDATA[#{test}]]></a>"
-    d = REXML::Document.new( source )
+    def test_attribute_namespace_conflict
+      # https://www.w3.org/TR/xml-names/#uniqAttrs
+      message = <<-MESSAGE
+Duplicate attribute "a"
+Line: 4
+Position: 140
+Last 80 unconsumed characters:
+      MESSAGE
+      assert_raise_with_message(REXML::ParseException, message) do
+        Document.new(<<-XML)
+<!-- http://www.w3.org is bound to n1 and n2 -->
+<x xmlns:n1="http://www.w3.org"
+   xmlns:n2="http://www.w3.org" >
+  <bad a="1"     a="2" />
+  <bad n1:a="1"  n2:a="2" />
+</x>
+        XML
+      end
+    end
 
-    # Test constructors
-    cdata = d[0][0]
-    assert_equal test, cdata.value
-  end
+    def test_attribute_default_namespace
+      # https://www.w3.org/TR/xml-names/#uniqAttrs
+      document = Document.new(<<-XML)
+<!-- http://www.w3.org is bound to n1 and is the default -->
+<x xmlns:n1="http://www.w3.org"
+   xmlns="http://www.w3.org" >
+  <good a="1"     b="2" />
+  <good a="1"     n1:a="2" />
+</x>
+      XML
+      attributes = document.root.elements.collect do |element|
+        element.attributes.each_attribute.collect do |attribute|
+          [attribute.prefix, attribute.namespace, attribute.name]
+        end
+      end
+      assert_equal([
+                     [
+                       ["", "", "a"],
+                       ["", "", "b"],
+                     ],
+                     [
+                       ["", "", "a"],
+                       ["n1", "http://www.w3.org", "a"],
+                     ],
+                   ],
+                   attributes)
+    end
 
-  def test_comment
-    string = "This is a new comment!"
-    source = "<!--#{string}-->"
-    comment = Comment.new string
-    REXML::Formatters::Default.new.write( comment, out = "" )
-    assert_equal(source, out)
-
-    comment2 = Comment.new comment
-    assert_equal(comment, comment2)
-
-    assert_raise(ParseException) {
-      REXML::Document.new("<d><!- foo --></d>")
-    }
-    assert_raise(ParseException) {
-      REXML::Document.new("<d><!-- foo -></d>")
-    }
-  end
+    def test_cdata
+      test = "The quick brown fox jumped
+        & < & < \" '
+      over the lazy dog."
 
-  def test_whitespace
-    doc = Document.new "<root-element><first-element/></root-element>"
-    assert_equal 1, doc.root.size
-    assert_equal 1, doc.root.elements.size
-    doc = Document.new "<root-element>
-    <first-element/>
-    </root-element>"
-    assert_equal 3, doc.root.size
-    assert_equal 1, doc.root.elements.size
-
-    text = "  This is   text
-    with a lot of   whitespace   "
-    source = "<a>#{text}<b>#{text}</b><c>#{text}</c>#{text}</a>"
-
-    doc = Document.new( source, {
-      :respect_whitespace => %w{ a c }
-    } )
-    assert_equal text, doc.elements["//c"].text
-    string = ""
-    doc.root.each { |n| string << n.to_s if n.kind_of? Text }
-    assert_equal text+text, string
-
-    string ="   lots   of    blank
-    space"
-    doc.root.add_element("d").add_element("c").text = string
-    doc.root.add_element("e").text = string
-    assert_equal string, doc.elements["/a/d/c"].text
-    assert string != doc.elements["/a/e"].text, "Text wasn't properly compressed"
-
-    doc = Document.new source, { :respect_whitespace => :all }
-    doc.root.add_element("d").text = string
-    assert_equal text, doc.root.text
-    nxt = ""
-    doc.root.each { |n| nxt << n.to_s if n.kind_of? Text }
-    assert_equal text+text, nxt
-    assert_equal text, doc.root.elements["b"].text
-    assert_equal text, doc.root.elements["c"].text
-    assert_equal string, doc.root.elements["d"].text
-  end
+      source = "<a><![CDATA[#{test}]]></a>"
+      d = REXML::Document.new( source )
 
-  # This isn't complete.  We need to check declarations and comments
-  def test_doctype
-    string = "something"
-    correct = "<!DOCTYPE something>"
-    doc = DocType.new(string)
-    assert_equal(string, doc.name)
-    doc.write(out="")
-    assert_equal(correct, out)
-
-    doc2 = DocType.new(doc)
-    assert_equal(doc.name, doc2.name)
-    assert_equal(doc.external_id, doc2.external_id)
-
-    correct = '<!DOCTYPE xsa PUBLIC "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML" "http://www.garshol.priv.no/download/xsa/xsa.dtd">'
-
-    one_line_source = '<!DOCTYPE xsa PUBLIC "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML" "http://www.garshol.priv.no/download/xsa/xsa.dtd"><a/>'
-    doc = Document.new( one_line_source )
-    doc = doc[0]
-    assert(doc)
-    doc.write(test="")
-    assert_equal(correct, test)
-
-    multi_line_source = '<!DOCTYPE xsa PUBLIC
-    "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML"
-    "http://www.garshol.priv.no/download/xsa/xsa.dtd">
-    <a/>'
-    d = Document.new( multi_line_source )
-    doc = d[0]
-    assert(doc)
-    doc.write(test="")
-    assert_equal(correct, test)
-
-    odd_space_source = '  <!DOCTYPE
-    xsa      PUBLIC                 "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML"
-    "http://www.garshol.priv.no/download/xsa/xsa.dtd">   <a/>'
-    d = Document.new( odd_space_source )
-    dt = d.doctype
-    dt.write(test="")
-    assert_equal(correct, test)
-
-    # OK, the BIG doctype test, numba wun
-    docin = File.new(fixture_path("doctype_test.xml"))
-    doc = Document.new(docin)
-    doc.write(test="")
-    assert_equal(31, doc.doctype.size)
-  end
+      # Test constructors
+      cdata = d[0][0]
+      assert_equal test, cdata.value
+    end
 
-  def test_document
-    # Testing cloning
-    source = "<element/>"
-    doc = Document.new source
+    def test_comment
+      string = "This is a new comment!"
+      source = "<!--#{string}-->"
+      comment = Comment.new string
+      REXML::Formatters::Default.new.write( comment, out = "" )
+      assert_equal(source, out)
+
+      comment2 = Comment.new comment
+      assert_equal(comment, comment2)
+
+      assert_raise(ParseException) {
+        REXML::Document.new("<d><!- foo --></d>")
+      }
+      assert_raise(ParseException) {
+        REXML::Document.new("<d><!-- foo -></d>")
+      }
+    end
 
-    # Testing Root
-    assert_equal doc.root.name.to_s, "element"
+    def test_whitespace
+      doc = Document.new "<root-element><first-element/></root-element>"
+      assert_equal 1, doc.root.size
+      assert_equal 1, doc.root.elements.size
+      doc = Document.new "<root-element>
+      <first-element/>
+      </root-element>"
+      assert_equal 3, doc.root.size
+      assert_equal 1, doc.root.elements.size
+
+      text = "  This is   text
+      with a lot of   whitespace   "
+      source = "<a>#{text}<b>#{text}</b><c>#{text}</c>#{text}</a>"
+
+      doc = Document.new( source, {
+        :respect_whitespace => %w{ a c }
+      } )
+      assert_equal text, doc.elements["//c"].text
+      string = ""
+      doc.root.each { |n| string << n.to_s if n.kind_of? Text }
+      assert_equal text+text, string
+
+      string ="   lots   of    blank
+      space"
+      doc.root.add_element("d").add_element("c").text = string
+      doc.root.add_element("e").text = string
+      assert_equal string, doc.elements["/a/d/c"].text
+      assert string != doc.elements["/a/e"].text, "Text wasn't properly compressed"
+
+      doc = Document.new source, { :respect_whitespace => :all }
+      doc.root.add_element("d").text = string
+      assert_equal text, doc.root.text
+      nxt = ""
+      doc.root.each { |n| nxt << n.to_s if n.kind_of? Text }
+      assert_equal text+text, nxt
+      assert_equal text, doc.root.elements["b"].text
+      assert_equal text, doc.root.elements["c"].text
+      assert_equal string, doc.root.elements["d"].text
+    end
 
-    # Testing String source
-    source = @xsa_source
-    doc = Document.new source
-    assert_instance_of XMLDecl, doc.xml_decl
-    assert_instance_of DocType, doc.doctype
-    assert_equal doc.version, "1.0"
+    # This isn't complete.  We need to check declarations and comments
+    def test_doctype
+      string = "something"
+      correct = "<!DOCTYPE something>"
+      doc = DocType.new(string)
+      assert_equal(string, doc.name)
+      doc.write(out="")
+      assert_equal(correct, out)
+
+      doc2 = DocType.new(doc)
+      assert_equal(doc.name, doc2.name)
+      assert_equal(doc.external_id, doc2.external_id)
+
+      correct = '<!DOCTYPE xsa PUBLIC "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML" "http://www.garshol.priv.no/download/xsa/xsa.dtd">'
+
+      one_line_source = '<!DOCTYPE xsa PUBLIC "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML" "http://www.garshol.priv.no/download/xsa/xsa.dtd"><a/>'
+      doc = Document.new( one_line_source )
+      doc = doc[0]
+      assert(doc)
+      doc.write(test="")
+      assert_equal(correct, test)
+
+      multi_line_source = '<!DOCTYPE xsa PUBLIC
+      "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML"
+      "http://www.garshol.priv.no/download/xsa/xsa.dtd">
+      <a/>'
+      d = Document.new( multi_line_source )
+      doc = d[0]
+      assert(doc)
+      doc.write(test="")
+      assert_equal(correct, test)
+
+      odd_space_source = '  <!DOCTYPE
+      xsa      PUBLIC                 "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML"
+      "http://www.garshol.priv.no/download/xsa/xsa.dtd">   <a/>'
+      d = Document.new( odd_space_source )
+      dt = d.doctype
+      dt.write(test="")
+      assert_equal(correct, test)
+
+      # OK, the BIG doctype test, numba wun
+      doc = File.open(fixture_path("doctype_test.xml")) do |docin|
+        Document.new(docin)
+      end
+      doc.write(test="")
+      assert_equal(31, doc.doctype.size)
+    end
 
-    source = File.new(fixture_path("dash.xml"))
-    doc = Document.new source
-    assert_equal "content-2", doc.elements["//content-2"].name
-  end
+    def test_document
+      # Testing cloning
+      source = "<element/>"
+      doc = Document.new source
 
-  def test_instruction
-    target = "use"
-    content = "ruby"
-    source = "<?#{target} #{content}?>"
+      # Testing Root
+      assert_equal doc.root.name.to_s, "element"
 
-    instruction = Instruction.new target, content
-    instruction2 = Instruction.new instruction
-    assert_equal(instruction, instruction2)
-    REXML::Formatters::Default.new.write( instruction, out = "" )
-    assert_equal(source, out)
+      # Testing String source
+      source = @xsa_source
+      doc = Document.new source
+      assert_instance_of XMLDecl, doc.xml_decl
+      assert_instance_of DocType, doc.doctype
+      assert_equal doc.version, "1.0"
 
-    d = Document.new( source )
-    instruction2 = d[0]
-    assert_equal(instruction.to_s, instruction2.to_s)
+      doc = File.open(fixture_path("dash.xml")) {|s| Document.new s }
+      assert_equal "content-2", doc.elements["//content-2"].name
+    end
 
-    assert_raise(ParseException) {
-      REXML::Document.new("<d><?foo bar></d>")
-    }
-  end
+    def test_instruction
+      target = "use"
+      content = "ruby"
+      source = "<?#{target} #{content}?>"
 
-  def test_parent
-    parent = Parent.new
-    begin
-      parent << "Something"
-    rescue Exception
-      parent << Comment.new("Some comment")
-      assert parent.size == 1, "size of parent should be 1"
-    else
-      assert_fail "should have gotten an exception trying to add a "+ "String to a Parent"
-    end
-
-    source = "<a><one/><three/><five/></a>"
-    doc = Document.new source
-    three = doc.root.elements["three"]
-    doc.root.insert_before( three, Element.new("two") )
-    nxt = doc.root.elements["one"]
-    string = ""
-    while nxt
-      string << nxt.name
-      nxt = nxt.next_sibling
-    end
-    assert_equal "onetwothreefive", string
-
-
-    doc.root.insert_after( three, Element.new("four") )
-    string = ""
-    doc.root.each { |element| string << element.name }
-    assert_equal "onetwothreefourfive", string
-
-    string = ""
-    nxt = doc.root.elements["five"]
-    while nxt
-      string << nxt.name
-      nxt = nxt.previous_sibling
-    end
-    assert_equal "fivefourthreetwoone", string
-
-    doc.insert_after "//two", Element.new("two-and-half")
-    string = doc.root.elements.collect {|x| x.name}.join
-    assert_equal "onetwotwo-and-halfthreefourfive", string
-    doc.elements["/a/five"].insert_before "../four", Element.new("three-and-half")
-    string = doc.root.elements.collect {|x| x.name}.join
-    assert_equal "onetwotwo-and-halfthreethree-and-halffourfive", string
-
-    doc.elements["/a/five"].previous_sibling = Element.new("four-and-half")
-    string = doc.root.elements.collect {|x| x.name}.join
-    assert_equal "onetwotwo-and-halfthreethree-and-halffourfour-and-halffive", string
-    doc.elements["/a/one"].next_sibling = Element.new("one-and-half")
-    string = doc.root.elements.collect {|x| x.name}.join
-    assert_equal "oneone-and-halftwotwo-and-halfthreethree-and-halffourfour-and-halffive", string
-
-    doc = Document.new "<a><one/><three/></a>"
-    doc.root[1,0] = Element.new "two"
-    string = ""
-    doc.root.each { |el| string << el.name }
-    assert_equal "onetwothree", string
-  end
+      instruction = Instruction.new target, content
+      instruction2 = Instruction.new instruction
+      assert_equal(instruction, instruction2)
+      REXML::Formatters::Default.new.write( instruction, out = "" )
+      assert_equal(source, out)
 
-  # The Source classes are tested extensively throughout the test suite
-  def test_source
-    # Testing string source
-    source = @xsa_source
-    doc = Document.new source
-    assert_equal doc.root.name.to_s, "xsa"
+      d = Document.new( source )
+      instruction2 = d[0]
+      assert_equal(instruction.to_s, instruction2.to_s)
 
-    # Testing IO source
-    doc = Document.new File.new(fixture_path("project.xml"))
-    assert_equal doc.root.name.to_s, "Project"
-  end
+      assert_raise(ParseException) {
+        REXML::Document.new("<d><?foo bar></d>")
+      }
+    end
 
-  def test_text
-    f = REXML::Formatters::Default.new
-    string = "Some text"
-    text = Text.new(string)
-    assert_equal(string, text.to_s)
-    text2 = Text.new(text)
-    assert_equal(text, text2)
-    #testing substitution
-    string = "0 < ( 1 & 1 )"
-    correct = "0 &lt; ( 1 &amp; 1 )"
-    text = Text.new(string, true)
-    f.write(text,out="")
-    assert_equal(correct, out)
-
-    string = "Cats &amp; dogs"
-    text = Text.new(string, false, nil, true)
-    assert_equal(string, text.to_s)
-
-    string2 = "<a>#{string}</a>"
-    doc = Document.new( string2, {
-      :raw => %w{ a b }
-    } )
-    f.write(doc,out="")
-    assert_equal(string2, out)
-    b = doc.root.add_element( "b" )
-    b.text = string
-    assert_equal(string, b.get_text.to_s)
-
-    c = doc.root.add_element("c")
-    c.text = string
-    assert_equal("Cats &amp;amp; dogs", c.get_text.to_s)
-
-    # test all
-    string = "<a>&amp;<b>&lt;</b><c>&gt;<d>&quot;</d></c></a>"
-    doc = Document.new(string, { :raw => :all })
-    assert_equal( "&amp;", doc.elements["/a"][0].to_s )
-    assert_equal( "&", doc.elements["/a"].text )
-    assert_equal( "&lt;", doc.elements["/a/b"][0].to_s )
-    assert_equal( "<", doc.elements["/a/b"].text )
-    assert_equal( "&gt;", doc.elements["/a/c"][0].to_s )
-    assert_equal( ">", doc.elements["/a/c"].text )
-    assert_equal( '&quot;', doc.elements["//d"][0].to_s )
-    assert_equal( '"', doc.elements["//d"].text )
-
-    # test some other stuff
-    doc = Document.new('<a><b/></a>')
-    doc.root.text = 'Sean'
-    assert_equal( '<a><b/>Sean</a>', doc.to_s )
-    doc.root.text = 'Elliott'
-    assert_equal( '<a><b/>Elliott</a>', doc.to_s )
-    doc.root.add_element( 'c' )
-    assert_equal( '<a><b/>Elliott<c/></a>', doc.to_s )
-    doc.root.text = 'Russell'
-    assert_equal( '<a><b/>Russell<c/></a>', doc.to_s )
-    doc.root.text = nil
-    assert_equal( '<a><b/><c/></a>', doc.to_s )
-  end
+    def test_parent
+      parent = Parent.new
+      begin
+        parent << "Something"
+      rescue Exception
+        parent << Comment.new("Some comment")
+        assert parent.size == 1, "size of parent should be 1"
+      else
+        assert_fail "should have gotten an exception trying to add a "+ "String to a Parent"
+      end
 
-  def test_text_frozen
-    string = "Frozen".freeze
-    text = Text.new(string)
-    assert_equal(string, text.to_s)
-  end
+      source = "<a><one/><three/><five/></a>"
+      doc = Document.new source
+      three = doc.root.elements["three"]
+      doc.root.insert_before( three, Element.new("two") )
+      nxt = doc.root.elements["one"]
+      string = ""
+      while nxt
+        string << nxt.name
+        nxt = nxt.next_sibling
+      end
+      assert_equal "onetwothreefive", string
 
-  def test_xmldecl
-    source = "<?xml version='1.0'?>"
-    # test args
-    # test no args
-    decl2 = XMLDecl.new
-    assert_equal source, decl2.to_s
-    # test XMLDecl
-    decl2 = XMLDecl.new "1.0"
-    assert_equal source, decl2.to_s
-  end
 
-  def test_xmldecl_utf_16be_encoding_name
-    assert_equal("<?xml version='1.0' encoding='UTF-16'?>",
-                 XMLDecl.new("1.0", "UTF-16").to_s)
-  end
+      doc.root.insert_after( three, Element.new("four") )
+      string = ""
+      doc.root.each { |element| string << element.name }
+      assert_equal "onetwothreefourfive", string
 
-  def each_test( element, xpath, num_children )
-    count = 0
-    element.each_element( xpath ) { |child|
-      count += 1
-      yield child if block_given?
-    }
-    assert_equal num_children, count
-  end
+      string = ""
+      nxt = doc.root.elements["five"]
+      while nxt
+        string << nxt.name
+        nxt = nxt.previous_sibling
+      end
+      assert_equal "fivefourthreetwoone", string
+
+      doc.insert_after "//two", Element.new("two-and-half")
+      string = doc.root.elements.collect {|x| x.name}.join
+      assert_equal "onetwotwo-and-halfthreefourfive", string
+      doc.elements["/a/five"].insert_before "../four", Element.new("three-and-half")
+      string = doc.root.elements.collect {|x| x.name}.join
+      assert_equal "onetwotwo-and-halfthreethree-and-halffourfive", string
+
+      doc.elements["/a/five"].previous_sibling = Element.new("four-and-half")
+      string = doc.root.elements.collect {|x| x.name}.join
+      assert_equal "onetwotwo-and-halfthreethree-and-halffourfour-and-halffive", string
+      doc.elements["/a/one"].next_sibling = Element.new("one-and-half")
+      string = doc.root.elements.collect {|x| x.name}.join
+      assert_equal "oneone-and-halftwotwo-and-halfthreethree-and-halffourfour-and-halffive", string
+
+      doc = Document.new "<a><one/><three/></a>"
+      doc.root[1,0] = Element.new "two"
+      string = ""
+      doc.root.each { |el| string << el.name }
+      assert_equal "onetwothree", string
+    end
 
-  # This is the biggest test, as the number of permutations of xpath are
-  # enormous.
-  def test_element_access
-    # Testing each_element
-    doc = Document.new File.new(fixture_path("project.xml"))
-
-    each_test( doc, "/", 1 ) { |child|
-      assert_equal doc.name, child.name
-    }
-    each_test(doc, ".", 1) { |child| assert_equal doc, child }
-    each_test(doc.root, "..", 1) { |child| assert_equal doc, child }
-    each_test(doc.root, "*", 5)
-    each_test(doc, "Project/Datasets", 1) { |child|
-      assert_equal "Datasets", child.name
-    }
-    each_test(doc, "Project/Datasets/link", 2 )
-    each_test(doc.root, "/Project/Description", 1) {|child|
-      assert_equal "Description", child.name
-    }
-    each_test(doc.root, "./Description",1 ) { |child|
-      assert_equal "Description",child.name
-    }
-    each_test(doc.root, "../Project",1 ) { |child|
-      assert_equal doc.root, child
-    }
-    #each_test(doc,".../link",2) {|child| assert_equal "link",child.name.to_s}
-
-    # test get_element
-    first = doc.elements[ "Project" ]
-    assert_equal doc.root, first
-    second = doc.elements[ "Project" ].elements[1]
-    third = doc.elements[ "Project/Creator" ]
-    assert_equal second, third
-    fourth = doc.elements[ "Project/Datasets/link[@idref='18']" ]
-    assert_equal "Test data 1", fourth.attributes["name"]
-
-    # Testing each_predicate
-    each_test( doc, "Project/Datasets/link[@idref='18']", 1 ) { |child|
-      assert_equal "Test data 1", child.attributes["name"]
-    }
-
-    # testing next/previous_element
-    creator = doc.elements["//Creator"]
-    lm = creator.next_element
-    assert_equal "LastModifier", lm.name
-    assert_equal "Creator", lm.previous_element.name
-  end
+    # The Source classes are tested extensively throughout the test suite
+    def test_source
+      # Testing string source
+      source = @xsa_source
+      doc = Document.new source
+      assert_equal doc.root.name.to_s, "xsa"
 
-  def test_child
-    sean = Element.new "Sean"
-    rubbell = Element.new "Rubbell"
-    elliott = sean.add_element "Elliott"
-    sean << rubbell
-    assert_equal elliott, rubbell.previous_sibling
-    assert_equal rubbell, elliott.next_sibling
-
-    russell = Element.new "Russell"
-    rubbell.replace_with russell
-    assert_equal elliott, russell.previous_sibling
-    assert_equal russell, elliott.next_sibling
-
-    assert_nil russell.document
-    assert_equal sean, russell.root
-  end
+      # Testing IO source
+      doc = File.open(fixture_path("project.xml")) {|f| Document.new f }
+      assert_equal doc.root.name.to_s, "Project"
+    end
 
-  # Most of this class is tested elsewhere.  Here are the methods which
-  # aren't used in any other class
-  def test_element
-    sean = Element.new "Sean"
-    string = "1) He's a great guy!"
-    sean.text = string
-    russell = Element.new "Russell"
-    sean << russell
-
-    russell.attributes["email"] = "ser@germane-software.com"
-    assert_equal russell.attributes["email"], "ser@germane-software.com"
-    russell.attributes["webpage"] = "http://www.germane-software.com/~ser"
-
-    assert sean.has_text?, "element should have text"
-    assert_equal sean.text, string
-    assert sean.has_elements?, "element should have one element"
-    string = "2) What a stud!"
-    sean.add_text string
-    sean.text = "3) Super programmer!"
-    sean.text = nil
-    assert sean.has_text?, "element should still have text"
-    assert_equal sean.text, string
-
-    russell.delete_attribute "email"
-    assert_nil russell.attributes["email"]
-    russell.attributes.delete "webpage"
-    assert !russell.has_attributes?, "element should have no attributes"
-  end
+    def test_text
+      f = REXML::Formatters::Default.new
+      string = "Some text"
+      text = Text.new(string)
+      assert_equal(string, text.to_s)
+      text2 = Text.new(text)
+      assert_equal(text, text2)
+      #testing substitution
+      string = "0 < ( 1 & 1 )"
+      correct = "0 &lt; ( 1 &amp; 1 )"
+      text = Text.new(string, true)
+      f.write(text,out="")
+      assert_equal(correct, out)
+
+      string = "Cats &amp; dogs"
+      text = Text.new(string, false, nil, true)
+      assert_equal(string, text.to_s)
+
+      string2 = "<a>#{string}</a>"
+      doc = Document.new( string2, {
+        :raw => %w{ a b }
+      } )
+      f.write(doc,out="")
+      assert_equal(string2, out)
+      b = doc.root.add_element( "b" )
+      b.text = string
+      assert_equal(string, b.get_text.to_s)
+
+      c = doc.root.add_element("c")
+      c.text = string
+      assert_equal("Cats &amp;amp; dogs", c.get_text.to_s)
+
+      # test all
+      string = "<a>&amp;<b>&lt;</b><c>&gt;<d>&quot;</d></c></a>"
+      doc = Document.new(string, { :raw => :all })
+      assert_equal( "&amp;", doc.elements["/a"][0].to_s )
+      assert_equal( "&", doc.elements["/a"].text )
+      assert_equal( "&lt;", doc.elements["/a/b"][0].to_s )
+      assert_equal( "<", doc.elements["/a/b"].text )
+      assert_equal( "&gt;", doc.elements["/a/c"][0].to_s )
+      assert_equal( ">", doc.elements["/a/c"].text )
+      assert_equal( '&quot;', doc.elements["//d"][0].to_s )
+      assert_equal( '"', doc.elements["//d"].text )
+
+      # test some other stuff
+      doc = Document.new('<a><b/></a>')
+      doc.root.text = 'Sean'
+      assert_equal( '<a><b/>Sean</a>', doc.to_s )
+      doc.root.text = 'Elliott'
+      assert_equal( '<a><b/>Elliott</a>', doc.to_s )
+      doc.root.add_element( 'c' )
+      assert_equal( '<a><b/>Elliott<c/></a>', doc.to_s )
+      doc.root.text = 'Russell'
+      assert_equal( '<a><b/>Russell<c/></a>', doc.to_s )
+      doc.root.text = nil
+      assert_equal( '<a><b/><c/></a>', doc.to_s )
+    end
 
-  def test_no_format
-    source = "<a><b><c>blah</c><d/></b></a>"
-    out = ""
-    doc = Document.new( source )
-    doc.write(out)
-    assert_equal(source, out)
-  end
+    def test_text_frozen
+      string = "Frozen".freeze
+      text = Text.new(string)
+      assert_equal(string, text.to_s)
+    end
 
-  def test_namespace
-    source = <<-EOF
-    <x xmlns:foo="http://www.bar.com/schema">
-    </x>
-    EOF
-    doc = Document.new(source)
-    assert_equal("http://www.bar.com/schema", doc.root.namespace( "foo" ))
-    source = <<-EOF
-    <!-- bar namespace is "someuri" -->
-    <foo:bar xmlns="default" xmlns:foo="someuri">
-    <!-- a namespace is "default" -->
-    <a/>
-    <!-- foo:b namespace is "someuri" -->
-    <foo:b>
-    <!-- c namespace is "default" -->
-    <c/>
-    </foo:b>
-    <!-- d namespace is "notdefault" -->
-    <d xmlns="notdefault">
-    <!-- e namespace is "notdefault" -->
-    <e/>
-    <f xmlns="">
-    <g/>
-    </f>
-    </d>
-    </foo:bar>
-    EOF
-    doc = Document.new source
-    assert_equal "someuri", doc.root.namespace
-    assert_equal "default", doc.root.elements[1].namespace
-    assert_equal "someuri", doc.root.elements[2].namespace
-    assert_equal "notdefault", doc.root.elements[ 3 ].namespace
-
-    # Testing namespaces in attributes
-    source = <<-EOF
-    <a xmlns:b="uri">
-    <b b:a="x" a="y"/>
-    <c xmlns="foo">
-    </c>
-    </a>
-    EOF
-    doc = Document.new source
-    b = doc.root.elements["b"]
-    assert_equal "x", b.attributes["b:a"]
-    assert_equal "y", b.attributes["a"]
-
-    doc = Document.new
-    doc.add_element "sean:blah"
-    doc.root.text = "Some text"
-    out = ""
-    doc.write(out)
-    assert_equal "<sean:blah>Some text</sean:blah>", out
-  end
+    def test_xmldecl
+      source = "<?xml version='1.0'?>"
+      # test args
+      # test no args
+      decl2 = XMLDecl.new
+      assert_equal source, decl2.to_s
+      # test XMLDecl
+      decl2 = XMLDecl.new "1.0"
+      assert_equal source, decl2.to_s
+    end
 
+    def test_xmldecl_utf_16be_encoding_name
+      assert_equal("<?xml version='1.0' encoding='UTF-16'?>",
+                   XMLDecl.new("1.0", "UTF-16").to_s)
+    end
 
-  def test_add_namespace
-    e = Element.new 'a'
-    e.add_namespace 'someuri'
-    e.add_namespace 'foo', 'otheruri'
-    e.add_namespace 'xmlns:bar', 'thirduri'
-    assert_equal 'someuri', e.attributes['xmlns']
-    assert_equal 'otheruri', e.attributes['xmlns:foo']
-    assert_equal 'thirduri', e.attributes['xmlns:bar']
-  end
+    def each_test( element, xpath, num_children )
+      count = 0
+      element.each_element( xpath ) { |child|
+        count += 1
+        yield child if block_given?
+      }
+      assert_equal num_children, count
+    end
 
+    # This is the biggest test, as the number of permutations of xpath are
+    # enormous.
+    def test_element_access
+      # Testing each_element
+      doc = File.open(fixture_path("project.xml")) {|f| Document.new f }
+
+      each_test( doc, "/", 1 ) { |child|
+        assert_equal doc.name, child.name
+      }
+      each_test(doc, ".", 1) { |child| assert_equal doc, child }
+      each_test(doc.root, "..", 1) { |child| assert_equal doc, child }
+      each_test(doc.root, "*", 5)
+      each_test(doc, "Project/Datasets", 1) { |child|
+        assert_equal "Datasets", child.name
+      }
+      each_test(doc, "Project/Datasets/link", 2 )
+      each_test(doc.root, "/Project/Description", 1) {|child|
+        assert_equal "Description", child.name
+      }
+      each_test(doc.root, "./Description",1 ) { |child|
+        assert_equal "Description",child.name
+      }
+      each_test(doc.root, "../Project",1 ) { |child|
+        assert_equal doc.root, child
+      }
+      #each_test(doc,".../link",2) {|child| assert_equal "link",child.name.to_s}
+
+      # test get_element
+      first = doc.elements[ "Project" ]
+      assert_equal doc.root, first
+      second = doc.elements[ "Project" ].elements[1]
+      third = doc.elements[ "Project/Creator" ]
+      assert_equal second, third
+      fourth = doc.elements[ "Project/Datasets/link[@idref='18']" ]
+      assert_equal "Test data 1", fourth.attributes["name"]
+
+      # Testing each_predicate
+      each_test( doc, "Project/Datasets/link[@idref='18']", 1 ) { |child|
+        assert_equal "Test data 1", child.attributes["name"]
+      }
+
+      # testing next/previous_element
+      creator = doc.elements["//Creator"]
+      lm = creator.next_element
+      assert_equal "LastModifier", lm.name
+      assert_equal "Creator", lm.previous_element.name
+    end
 
-  def test_big_documentation
-    f = File.new(fixture_path("documentation.xml"))
-    d = Document.new f
-    assert_equal "Sean Russell", d.elements["documentation/head/author"].text.tr("\n\t", " ").squeeze(" ")
-    out = ""
-    d.write out
-  end
+    def test_child
+      sean = Element.new "Sean"
+      rubbell = Element.new "Rubbell"
+      elliott = sean.add_element "Elliott"
+      sean << rubbell
+      assert_equal elliott, rubbell.previous_sibling
+      assert_equal rubbell, elliott.next_sibling
+
+      russell = Element.new "Russell"
+      rubbell.replace_with russell
+      assert_equal elliott, russell.previous_sibling
+      assert_equal russell, elliott.next_sibling
+
+      assert_nil russell.document
+      assert_equal sean, russell.root
+    end
 
-  def test_tutorial
-    doc = Document.new File.new(fixture_path("tutorial.xml"))
-    out = ""
-    doc.write out
-  end
+    # Most of this class is tested elsewhere.  Here are the methods which
+    # aren't used in any other class
+    def test_element
+      sean = Element.new "Sean"
+      string = "1) He's a great guy!"
+      sean.text = string
+      russell = Element.new "Russell"
+      sean << russell
+
+      russell.attributes["email"] = "ser@germane-software.com"
+      assert_equal russell.attributes["email"], "ser@germane-software.com"
+      russell.attributes["webpage"] = "http://www.germane-software.com/~ser"
+
+      assert sean.has_text?, "element should have text"
+      assert_equal sean.text, string
+      assert sean.has_elements?, "element should have one element"
+      string = "2) What a stud!"
+      sean.add_text string
+      sean.text = "3) Super programmer!"
+      sean.text = nil
+      assert sean.has_text?, "element should still have text"
+      assert_equal sean.text, string
+
+      russell.delete_attribute "email"
+      assert_nil russell.attributes["email"]
+      russell.attributes.delete "webpage"
+      assert !russell.has_attributes?, "element should have no attributes"
+    end
 
-  def test_stream
-    c = Listener.new
-    Document.parse_stream( File.new(fixture_path("documentation.xml")), c )
-    assert(c.ts, "Stream parsing apparantly didn't parse the whole file")
-    assert(c.te, "Stream parsing dropped end tag for documentation")
+    def test_no_format
+      source = "<a><b><c>blah</c><d/></b></a>"
+      out = ""
+      doc = Document.new( source )
+      doc.write(out)
+      assert_equal(source, out)
+    end
 
-    Document.parse_stream("<a.b> <c/> </a.b>", c)
+    def test_namespace
+      source = <<-EOF
+      <x xmlns:foo="http://www.bar.com/schema">
+      </x>
+      EOF
+      doc = Document.new(source)
+      assert_equal("http://www.bar.com/schema", doc.root.namespace( "foo" ))
+      source = <<-EOF
+      <!-- bar namespace is "someuri" -->
+      <foo:bar xmlns="default" xmlns:foo="someuri">
+      <!-- a namespace is "default" -->
+      <a/>
+      <!-- foo:b namespace is "someuri" -->
+      <foo:b>
+      <!-- c namespace is "default" -->
+      <c/>
+      </foo:b>
+      <!-- d namespace is "notdefault" -->
+      <d xmlns="notdefault">
+      <!-- e namespace is "notdefault" -->
+      <e/>
+      <f xmlns="">
+      <g/>
+      </f>
+      </d>
+      </foo:bar>
+      EOF
+      doc = Document.new source
+      assert_equal "someuri", doc.root.namespace
+      assert_equal "default", doc.root.elements[1].namespace
+      assert_equal "someuri", doc.root.elements[2].namespace
+      assert_equal "notdefault", doc.root.elements[ 3 ].namespace
+
+      # Testing namespaces in attributes
+      source = <<-EOF
+      <a xmlns:b="uri">
+      <b b:a="x" a="y"/>
+      <c xmlns="foo">
+      </c>
+      </a>
+      EOF
+      doc = Document.new source
+      b = doc.root.elements["b"]
+      assert_equal "x", b.attributes["b:a"]
+      assert_equal "y", b.attributes["a"]
+
+      doc = Document.new
+      doc.add_element "sean:blah"
+      doc.root.text = "Some text"
+      out = ""
+      doc.write(out)
+      assert_equal "<sean:blah>Some text</sean:blah>", out
+    end
 
-    Document.parse_stream("<a>&lt;&gt;&amp;</a>", c)
-    assert_equal('<>&', c.normalize)
-  end
 
-  def test_line
-    Document.new File.new(fixture_path("bad.xml"))
-    assert_fail "There should have been an error"
-  rescue Exception
-    # We should get here
-    assert($!.line == 5, "Should have been an error on line 5, "+
-      "but was reported as being on line #{$!.line}" )
-  end
+    def test_add_namespace
+      e = Element.new 'a'
+      e.add_namespace 'someuri'
+      e.add_namespace 'foo', 'otheruri'
+      e.add_namespace 'xmlns:bar', 'thirduri'
+      assert_equal 'someuri', e.attributes['xmlns']
+      assert_equal 'otheruri', e.attributes['xmlns:foo']
+      assert_equal 'thirduri', e.attributes['xmlns:bar']
+    end
 
-  def test_substitution
-    val = "a'b\"c"
-    el = Element.new("a")
-    el.attributes["x"] = val
-    REXML::Formatters::Default.new.write(el, out="")
 
-    nel = Document.new( out)
-    assert_equal( val, nel.root.attributes["x"] )
-  end
+    def test_big_documentation
+      d = File.open(fixture_path("documentation.xml")) {|f| Document.new f }
+      assert_equal "Sean Russell", d.elements["documentation/head/author"].text.tr("\n\t", " ").squeeze(" ")
+      out = ""
+      d.write out
+    end
 
-  def test_exception
-    source = SourceFactory.create_from "<a/>"
-    p = ParseException.new( "dummy message", source )
-    begin
-      raise "dummy"
-    rescue Exception
-      p.continued_exception = $!
+    def test_tutorial
+      doc = File.open(fixture_path("tutorial.xml")) {|f| Document.new f }
+      out = ""
+      doc.write out
     end
-  end
 
-  def test_bad_content
-    in_gt = '<root-el>content>content</root-el>'
-    in_lt = '<root-el>content<content</root-el>'
+    def test_stream
+      c = Listener.new
+      File.open(fixture_path("documentation.xml")) do |f|
+        Document.parse_stream( f, c )
+      end
+      assert(c.ts, "Stream parsing apparently didn't parse the whole file")
+      assert(c.te, "Stream parsing dropped end tag for documentation")
+
+      Document.parse_stream("<a.b> <c/> </a.b>", c)
 
-    # This is OK
-    tree_gt = Document.new in_gt
-    assert_equal "content>content", tree_gt.elements[1].text
-    # This isn't
-    begin
-      Document.new in_lt
-      assert_fail "Should have gotten a parse error"
-    rescue ParseException
+      Document.parse_stream("<a>&lt;&gt;&amp;</a>", c)
+      assert_equal('<>&', c.normalize)
     end
-  end
 
-  def test_iso_8859_1_output_function
-    out = ""
-    output = Output.new( out )
-    koln_iso_8859_1 = "K\xF6ln"
-    koln_utf8 = "K\xc3\xb6ln"
-    source = Source.new( koln_iso_8859_1, 'iso-8859-1' )
-    results = source.scan(/.*/)[0]
-    koln_utf8.force_encoding('UTF-8') if koln_utf8.respond_to?(:force_encoding)
-    assert_equal koln_utf8, results
-    output << results
-    if koln_iso_8859_1.respond_to?(:force_encoding)
-      koln_iso_8859_1.force_encoding('ISO-8859-1')
-    end
-    assert_equal koln_iso_8859_1, out
-  end
+    def test_line
+      f = File.new(fixture_path("bad.xml"))
+      Document.new f
+      assert_fail "There should have been an error"
+    rescue Exception
+      # We should get here
+      assert($!.line == 5, "Should have been an error on line 5, "+
+        "but was reported as being on line #{$!.line}" )
+    ensure
+      f.close if f
+    end
 
-  def test_attributes_each
-    doc = Document.new("<a xmlns:a='foo'><b x='1' y='2' z='3' a:x='4'/></a>")
-    count = 0
-    doc.root.elements[1].attributes.each {|k,v| count += 1 }
-    assert_equal 4, count
-  end
+    def test_substitution
+      val = "a'b\"c"
+      el = Element.new("a")
+      el.attributes["x"] = val
+      REXML::Formatters::Default.new.write(el, out="")
 
-  def test_delete_namespace
-    doc = Document.new "<a xmlns='1' xmlns:x='2'/>"
-    doc.root.delete_namespace
-    doc.root.delete_namespace 'x'
-    assert_equal "<a/>", doc.to_s
-  end
+      nel = Document.new( out)
+      assert_equal( val, nel.root.attributes["x"] )
+    end
 
-  def test_each_element_with_attribute
-    doc = Document.new "<a><b id='1'/><c id='2'/><d id='1'/><e/></a>"
-    arry = []
-    block = proc { |e|
-      assert arry.include?(e.name)
-      arry.delete e.name
-    }
-    # Yields b, c, d
-    arry = %w{b c d}
-    doc.root.each_element_with_attribute( 'id', &block )
-    assert_equal 0, arry.size
-    # Yields b, d
-    arry = %w{b d}
-    doc.root.each_element_with_attribute( 'id', '1', &block )
-    assert_equal 0, arry.size
-    # Yields b
-    arry = ['b']
-    doc.root.each_element_with_attribute( 'id', '1', 1, &block )
-    assert_equal 0, arry.size
-    # Yields d
-    arry = ['d']
-    doc.root.each_element_with_attribute( 'id', '1', 0, 'd', &block )
-    assert_equal 0, arry.size
-  end
-  def test_each_element_with_text
-    doc = Document.new '<a><b>b</b><c>b</c><d>d</d><e/></a>'
-    arry = []
-    block = proc { |e|
-      assert arry.include?(e.name)
-      arry.delete e.name
-    }
-    # Yields b, c, d
-    arry = %w{b c d}
-    doc.root.each_element_with_text(&block)
-    assert_equal 0, arry.size
-    # Yields b, d
-    arry = %w{b c}
-    doc.root.each_element_with_text( 'b', &block )
-    assert_equal 0, arry.size
-    # Yields b
-    arry = ['b']
-    doc.root.each_element_with_text( 'b', 1, &block )
-    assert_equal 0, arry.size
-    # Yields d
-    arry = ['d']
-    doc.root.each_element_with_text( nil, 0, 'd', &block )
-    assert_equal 0, arry.size
-  end
+    def test_exception
+      source = SourceFactory.create_from "<a/>"
+      p = ParseException.new( "dummy message", source )
+      begin
+        raise "dummy"
+      rescue Exception
+        p.continued_exception = $!
+      end
+    end
 
-  def test_element_parse_stream
-    s = Source.new( "<a>some text</a>" )
-    l = Listener.new
-    class << l
-      def tag_start name, attributes
-        raise "Didn't find proper tag name" unless 'a'==name
+    def test_bad_content
+      in_gt = '<root-el>content>content</root-el>'
+      in_lt = '<root-el>content<content</root-el>'
+
+      # This is OK
+      tree_gt = Document.new in_gt
+      assert_equal "content>content", tree_gt.elements[1].text
+      # This isn't
+      begin
+        Document.new in_lt
+        assert_fail "Should have gotten a parse error"
+      rescue ParseException
       end
     end
 
-    Document::parse_stream(s, l)
-  end
+    def test_iso_8859_1_output_function
+      out = ""
+      output = Output.new( out )
+      koln_iso_8859_1 = "K\xF6ln"
+      koln_utf8 = "K\xc3\xb6ln"
+      source = Source.new( koln_iso_8859_1, 'iso-8859-1' )
+      results = source.scan(/.*/)[0]
+      koln_utf8.force_encoding('UTF-8') if koln_utf8.respond_to?(:force_encoding)
+      assert_equal koln_utf8, results
+      output << results
+      if koln_iso_8859_1.respond_to?(:force_encoding)
+        koln_iso_8859_1.force_encoding('ISO-8859-1')
+      end
+      assert_equal koln_iso_8859_1, out
+    end
 
-  def test_deep_clone
-    a = Document.new( '<?xml version="1"?><a x="y"><b>text</b>text<c><d><e>text</e></d></c></a>' )
-    b = a.deep_clone
-    assert_equal a.to_s, b.to_s
+    def test_attributes_each
+      doc = Document.new("<a xmlns:a='foo'><b x='1' y='2' z='3' a:x='4'/></a>")
+      count = 0
+      doc.root.elements[1].attributes.each {|k,v| count += 1 }
+      assert_equal 4, count
+    end
 
-    a = Document.new( '<a>some &lt; text <b> more &gt; text </b> &gt; </a>' )
-    b = a.deep_clone
-    assert_equal a.to_s, b.to_s
-    c = Document.new( b.to_s )
-    assert_equal a.to_s, c.to_s
-  end
+    def test_delete_namespace
+      doc = Document.new "<a xmlns='1' xmlns:x='2'/>"
+      doc.root.delete_namespace
+      doc.root.delete_namespace 'x'
+      assert_equal "<a/>", doc.to_s
+    end
 
-  def test_whitespace_before_root
-    a = <<EOL
+    def test_each_element_with_attribute
+      doc = Document.new "<a><b id='1'/><c id='2'/><d id='1'/><e/></a>"
+      arry = []
+      block = proc { |e|
+        assert arry.include?(e.name)
+        arry.delete e.name
+      }
+      # Yields b, c, d
+      arry = %w{b c d}
+      doc.root.each_element_with_attribute( 'id', &block )
+      assert_equal 0, arry.size
+      # Yields b, d
+      arry = %w{b d}
+      doc.root.each_element_with_attribute( 'id', '1', &block )
+      assert_equal 0, arry.size
+      # Yields b
+      arry = ['b']
+      doc.root.each_element_with_attribute( 'id', '1', 1, &block )
+      assert_equal 0, arry.size
+      # Yields d
+      arry = ['d']
+      doc.root.each_element_with_attribute( 'id', '1', 0, 'd', &block )
+      assert_equal 0, arry.size
+    end
+    def test_each_element_with_text
+      doc = Document.new '<a><b>b</b><c>b</c><d>d</d><e/></a>'
+      arry = []
+      block = proc { |e|
+        assert arry.include?(e.name)
+        arry.delete e.name
+      }
+      # Yields b, c, d
+      arry = %w{b c d}
+      doc.root.each_element_with_text(&block)
+      assert_equal 0, arry.size
+      # Yields b, d
+      arry = %w{b c}
+      doc.root.each_element_with_text( 'b', &block )
+      assert_equal 0, arry.size
+      # Yields b
+      arry = ['b']
+      doc.root.each_element_with_text( 'b', 1, &block )
+      assert_equal 0, arry.size
+      # Yields d
+      arry = ['d']
+      doc.root.each_element_with_text( nil, 0, 'd', &block )
+      assert_equal 0, arry.size
+    end
+
+    def test_element_parse_stream
+      s = Source.new( "<a>some text</a>" )
+      l = Listener.new
+      class << l
+        def tag_start name, attributes
+          raise "Didn't find proper tag name" unless 'a'==name
+        end
+      end
+
+      Document::parse_stream(s, l)
+    end
+
+    def test_deep_clone
+      a = Document.new( '<?xml version="1"?><a x="y"><b>text</b>text<c><d><e>text</e></d></c></a>' )
+      b = a.deep_clone
+      assert_equal a.to_s, b.to_s
+
+      a = Document.new( '<a>some &lt; text <b> more &gt; text </b> &gt; </a>' )
+      b = a.deep_clone
+      assert_equal a.to_s, b.to_s
+      c = Document.new( b.to_s )
+      assert_equal a.to_s, c.to_s
+    end
+
+    def test_whitespace_before_root
+      a = <<EOL
 <?xml version='1.0'?>
   <blo>
     <wak>
     </wak>
   </blo>
 EOL
-    d = Document.new(a)
-    b = ""
-    d.write( b )
-    assert_equal a,b
-  end
+      d = Document.new(a)
+      b = ""
+      d.write( b )
+      assert_equal a,b
+    end
 
-  def test_entities
-    a = Document.new( '<a>&#101;&#x65;&#252;</a>' )
-    assert_equal('ee'.force_encoding("UTF-8"), a.root.text)
-  end
+    def test_entities
+      a = Document.new( '<a>&#101;&#x65;&#252;</a>' )
+      assert_equal('ee'.force_encoding("UTF-8"), a.root.text)
+    end
 
-  def test_element_decl
-    element_decl = Source.new("<!DOCTYPE foo [
+    def test_element_decl
+      element_decl = Source.new("<!DOCTYPE foo [
 <!ELEMENT bar (#PCDATA)>
 ]>")
-    doc = Document.new( element_decl )
-    d = doc[0]
-    assert_equal("<!ELEMENT bar (#PCDATA)>", d.to_s.split(/\n/)[1].strip)
-  end
+      doc = Document.new( element_decl )
+      d = doc[0]
+      assert_equal("<!ELEMENT bar (#PCDATA)>", d.to_s.split(/\n/)[1].strip)
+    end
 
-  def test_attlist_decl
-    doc = Document.new <<-EOL
-    <!DOCTYPE blah [
-    <!ATTLIST blah
-      xmlns    CDATA    "foo">
-    <!ATTLIST a
-      bar          CDATA "gobble"
-      xmlns:one    CDATA  "two"
-    >
-    ]>
-    <a xmlns:three='xxx' three='yyy'><one:b/><three:c/></a>
-    EOL
-    assert_equal 'gobble', doc.root.attributes['bar']
-    assert_equal 'xxx', doc.root.elements[2].namespace
-    assert_equal 'two', doc.root.elements[1].namespace
-    assert_equal 'foo', doc.root.namespace
-
-    doc = Document.new <<-EOL
-    <?xml version="1.0"?>
-    <!DOCTYPE schema SYSTEM "XMLSchema.dtd" [
-    <!ENTITY % p ''>
-    <!ENTITY % s ''>
-    <!ATTLIST schema
-      xmlns:svg CDATA #FIXED "http://www.w3.org/2000/svg"
-      xmlns:xlink CDATA #FIXED "http://www.w3.org/1999/xlink"
-      xmlns:xml CDATA #FIXED "http://www.w3.org/XML/1998/namespace"
-    >]>
-    <schema/>
-    EOL
-    prefixes = doc.root.prefixes.sort
-    correct = ['svg', 'xlink', 'xml']
-    assert_equal correct, prefixes
-  end
+    def test_attlist_decl
+      doc = Document.new <<-EOL
+      <!DOCTYPE blah [
+      <!ATTLIST blah
+        xmlns    CDATA    "foo">
+      <!ATTLIST a
+        bar          CDATA "gobble"
+        xmlns:one    CDATA  "two"
+      >
+      ]>
+      <a xmlns:three='xxx' three='yyy'><one:b/><three:c/></a>
+      EOL
+      assert_equal 'gobble', doc.root.attributes['bar']
+      assert_equal 'xxx', doc.root.elements[2].namespace
+      assert_equal 'two', doc.root.elements[1].namespace
+      assert_equal 'foo', doc.root.namespace
+
+      doc = Document.new <<-EOL
+      <?xml version="1.0"?>
+      <!DOCTYPE schema SYSTEM "XMLSchema.dtd" [
+      <!ENTITY % p ''>
+      <!ENTITY % s ''>
+      <!ATTLIST schema
+        xmlns:svg CDATA #FIXED "http://www.w3.org/2000/svg"
+        xmlns:xlink CDATA #FIXED "http://www.w3.org/1999/xlink"
+        xmlns:xml CDATA #FIXED "http://www.w3.org/XML/1998/namespace"
+      >]>
+      <schema/>
+      EOL
+      prefixes = doc.root.prefixes.sort
+      correct = ['svg', 'xlink', 'xml']
+      assert_equal correct, prefixes
+    end
 
-  def test_attlist_write
-    file=File.new(fixture_path("foo.xml"))
-    doc=Document.new file
-    out = ''
-    doc.write(out)
-  end
+    def test_attlist_write
+      doc = File.open(fixture_path("foo.xml")) {|file| Document.new file }
+      out = ''
+      doc.write(out)
+    end
 
-  def test_more_namespaces
-    assert_raise( REXML::UndefinedNamespaceException,
-                   %Q{Should have gotten an Undefined Namespace error} )  {
-      Document.new("<r><p><n:c/></p></r>")
-    }
-    doc2 = Document.new("<r xmlns:n='1'><p><n:c/></p></r>")
-    es = XPath.match(doc2, '//c')
-    assert_equal 0, es.size
-    es = XPath.match(doc2, '//n:c')
-    assert_equal 1, es.size
-    doc2.root.add_namespace('m', '2')
-    doc2.root.add_element("m:o")
-    es = XPath.match(doc2, './/o')
-    assert_equal 0, es.size
-    es = XPath.match(doc2, '//n:c')
-    assert_equal 1, es.size
-  end
+    def test_more_namespaces
+      assert_raise( REXML::UndefinedNamespaceException,
+                     %Q{Should have gotten an Undefined Namespace error} )  {
+        Document.new("<r><p><n:c/></p></r>")
+      }
+      doc2 = Document.new("<r xmlns:n='1'><p><n:c/></p></r>")
+      es = XPath.match(doc2, '//c')
+      assert_equal 0, es.size
+      es = XPath.match(doc2, '//n:c')
+      assert_equal 1, es.size
+      doc2.root.add_namespace('m', '2')
+      doc2.root.add_element("m:o")
+      es = XPath.match(doc2, './/o')
+      assert_equal 0, es.size
+      es = XPath.match(doc2, '//n:c')
+      assert_equal 1, es.size
+    end
 
-  def test_ticket_51
-    doc = REXML::Document.new <<-EOL
-      <test xmlns='1' xmlns:x='1'>
-         <a>X</a>
-         <x:a>Y</x:a>
-
-         <b xmlns='2'>
-           <a>Z</a>
-         </b>
-      </test>
-    EOL
-
-    # The most common case.  People not caring about the namespaces much.
-    assert_equal( "XY", XPath.match( doc, "/test/a/text()" ).join )
-    assert_equal( "XY", XPath.match( doc, "/test/x:a/text()" ).join )
-    # Surprising?  I don't think so, if you believe my definition of the "common case"
-    assert_equal( "XYZ", XPath.match( doc, "//a/text()" ).join )
-
-    # These are the uncommon cases.  Namespaces are actually important, so we define our own
-    # mappings, and pass them in.
-    assert_equal( "XY", XPath.match( doc, "/f:test/f:a/text()", { "f" => "1" } ).join )
-    # The namespaces are defined, and override the original mappings
-    assert_equal( "", XPath.match( doc, "/test/a/text()", { "f" => "1" } ).join )
-    assert_equal( "", XPath.match( doc, "/x:test/x:a/text()", { "f" => "1" } ).join )
-    assert_equal( "", XPath.match( doc, "//a/text()", { "f" => "1" } ).join )
-  end
+    def test_ticket_51
+      doc = REXML::Document.new <<-EOL
+        <test xmlns='1' xmlns:x='1'>
+           <a>X</a>
+           <x:a>Y</x:a>
+
+           <b xmlns='2'>
+             <a>Z</a>
+           </b>
+        </test>
+      EOL
+
+      # The most common case.  People not caring about the namespaces much.
+      assert_equal( "XY", XPath.match( doc, "/*:test/*:a/text()" ).join )
+      assert_equal( "XY", XPath.match( doc, "/*:test/x:a/text()" ).join )
+      # Surprising?  I don't think so, if you believe my definition of the "common case"
+      assert_equal( "XYZ", XPath.match( doc, "//*:a/text()" ).join )
+
+      # These are the uncommon cases.  Namespaces are actually important, so we define our own
+      # mappings, and pass them in.
+      assert_equal( "XY", XPath.match( doc, "/f:test/f:a/text()", { "f" => "1" } ).join )
+      # The namespaces are defined, and override the original mappings
+      assert_equal( "XY", XPath.match( doc, "/*:test/*:a/text()", { "f" => "1" } ).join )
+      assert_equal( "", XPath.match( doc, "/x:test/x:a/text()", { "f" => "1" } ).join )
+      assert_equal( "XYZ", XPath.match( doc, "//*:a/text()", { "f" => "1" } ).join )
+    end
 
-  def test_processing_instruction
-    d = Document.new("<a><?foo bar?><?foo2 bar2?><b><?foo3 bar3?></b><?foo4 bar4?></a>")
-    assert_equal 4, XPath.match(d, '//processing-instruction()' ).size
-    match = XPath.match(d, "//processing-instruction('foo3')" )
-    assert_equal 1, match.size
-    assert_equal 'bar3', match[0].content
-  end
+    def test_processing_instruction
+      d = Document.new("<a><?foo bar?><?foo2 bar2?><b><?foo3 bar3?></b><?foo4 bar4?></a>")
+      assert_equal 4, XPath.match(d, '//processing-instruction()' ).size
+      match = XPath.match(d, "//processing-instruction('foo3')" )
+      assert_equal 1, match.size
+      assert_equal 'bar3', match[0].content
+    end
 
-  def test_oses_with_bad_EOLs
-    Document.new("\n\n\n<?xml version='1.0'?>\n\n\n<a/>\n\n")
-  end
+    def test_oses_with_bad_EOLs
+      Document.new("\n\n\n<?xml version='1.0'?>\n\n\n<a/>\n\n")
+    end
 
-  # Contributed (with patch to fix bug) by Kouhei
-  def test_ignore_whitespace
-    source = "<a> <b/> abc <![CDATA[def]]>  </a>"
+    # Contributed (with patch to fix bug) by Kouhei
+    def test_ignore_whitespace
+      source = "<a> <b/> abc <![CDATA[def]]>  </a>"
 
-    context_all = {:ignore_whitespace_nodes => :all}
-    context_a = {:ignore_whitespace_nodes => %(a)}
-    context_b = {:ignore_whitespace_nodes => %(b)}
+      context_all = {:ignore_whitespace_nodes => :all}
+      context_a = {:ignore_whitespace_nodes => %(a)}
+      context_b = {:ignore_whitespace_nodes => %(b)}
 
-    tests = [[[" abc ", "def"], context_all],
-             [[" abc ", "def"], context_a],
-             [[" ", " abc ", "def", "  "], context_b]]
+      tests = [[[" abc ", "def"], context_all],
+               [[" abc ", "def"], context_a],
+               [[" ", " abc ", "def", "  "], context_b]]
 
-    tests.each do |test|
-      assert_equal(test[0], Document.new(source, test[1]).root.texts.collect{|x|
-        x.to_s})
+      tests.each do |test|
+        assert_equal(test[0], Document.new(source, test[1]).root.texts.collect{|x|
+          x.to_s})
+      end
     end
-  end
 
-  def test_0xD_in_preface
-    doc = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\x0D<opml version=\"1.0\">\x0D</opml>"
-    doc = Document.new doc
-  end
+    def test_0xD_in_preface
+      doc = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\x0D<opml version=\"1.0\">\x0D</opml>"
+      doc = Document.new doc
+    end
 
-  def test_hyphens_in_doctype
-    doc = REXML::Document.new <<-EOQ
-     <?xml version="1.0"?>
-     <!DOCTYPE a-b-c>
-     <a-b-c>
-       <a/>
-     </a-b-c>
-    EOQ
+    def test_hyphens_in_doctype
+      doc = REXML::Document.new <<-EOQ
+       <?xml version="1.0"?>
+       <!DOCTYPE a-b-c>
+       <a-b-c>
+         <a/>
+       </a-b-c>
+      EOQ
 
-    assert_equal('a-b-c', doc.doctype.name)
-  end
+      assert_equal('a-b-c', doc.doctype.name)
+    end
 
-  def test_accents
-    docs = [
-      %Q{<?xml version="1.0" encoding="ISO-8859-1"?>
+    def test_accents
+      docs = [
+        %Q{<?xml version="1.0" encoding="ISO-8859-1"?>
 <gnuPod>
 <files>
   <file id="57"  artist="Coralie Cl\357\277\275ent" />
 </files>
 </gnuPod>},
-      '<?xml version="1.0" encoding="ISO-8859-1"?>
+        '<?xml version="1.0" encoding="ISO-8859-1"?>
 <gnuPod>
 <files>
     <file id="71"  album="Astrakan Caf" />
 </files>
 </gnuPod>',
-      %Q{<?xml version="1.0" encoding="ISO-8859-1"?>
+        %Q{<?xml version="1.0" encoding="ISO-8859-1"?>
 <gnuPod>
 <files>
     <file id="71"  album="Astrakan Caf\357\277\275eria" />
 </files>
 </gnuPod>},
-      %Q{<?xml version="1.0" encoding="ISO-8859-1"?>
+        %Q{<?xml version="1.0" encoding="ISO-8859-1"?>
 <gnuPod>
 <files>
     <file id="71"  album="Astrakan Caf\357\277\275" />
 </files>
 </gnuPod>} ]
-    docs.each_with_index { |d,i|
-      begin
-        REXML::Document.new(d)
-      rescue
-        puts "#{i} => #{docs[i]}"
-        raise
-      end
-    }
-  end
+      docs.each_with_index { |d,i|
+        begin
+          REXML::Document.new(d)
+        rescue
+          puts "#{i} => #{docs[i]}"
+          raise
+        end
+      }
+    end
 
-  def test_replace_text
-    e = REXML::Element.new( "a" )
-    e.add_text( "foo" )
-    assert_equal( "<a>foo</a>", e.to_s )
-    e[0].value = "bar"
-    assert_equal( "<a>bar</a>", e.to_s )
-    e[0].value = "<"
-    assert_equal( "<a>&lt;</a>", e.to_s )
-    assert_equal( "<", e[0].value )
-  end
+    def test_replace_text
+      e = REXML::Element.new( "a" )
+      e.add_text( "foo" )
+      assert_equal( "<a>foo</a>", e.to_s )
+      e[0].value = "bar"
+      assert_equal( "<a>bar</a>", e.to_s )
+      e[0].value = "<"
+      assert_equal( "<a>&lt;</a>", e.to_s )
+      assert_equal( "<", e[0].value )
+    end
 
 
-  def test_write_doctype
-    ## XML Document and Declaration
-    document = REXML::Document.new
-    xmldecl = REXML::XMLDecl.new("1.0", "UTF-8")
-    document.add(xmldecl)
-    s = ""
-    document.write(s)
+    def test_write_doctype
+      ## XML Document and Declaration
+      document = REXML::Document.new
+      xmldecl = REXML::XMLDecl.new("1.0", "UTF-8")
+      document.add(xmldecl)
+      s = ""
+      document.write(s)
 
-    ## XML Doctype
+      ## XML Doctype
       str = '<!DOCTYPE foo SYSTEM "bar">'
-    source  = REXML::Source.new(str)
-    doctype = REXML::DocType.new(source)
-    document.add(doctype)
-    document.write(s)
+      source  = REXML::Source.new(str)
+      doctype = REXML::DocType.new(source)
+      document.add(doctype)
+      document.write(s)
 
-    ## Element
-    element = REXML::Element.new("hoge")
-    document.add(element)
+      ## Element
+      element = REXML::Element.new("hoge")
+      document.add(element)
 
-    document.write(s)
-  end
+      document.write(s)
+    end
 
-  def test_write_cdata
-    src = "<a>A</a>"
-    doc = REXML::Document.new( src )
-    out = ""
-    doc.write( out )
-    assert_equal( src, out )
-
-    src = "<a><![CDATA[A]]></a>"
-    doc = REXML::Document.new( src )
-    out = ""
-    doc.write( out )
-    assert_equal( src, out )
-  end
+    def test_write_cdata
+      src = "<a>A</a>"
+      doc = REXML::Document.new( src )
+      out = ""
+      doc.write( out )
+      assert_equal( src, out )
+
+      src = "<a><![CDATA[A]]></a>"
+      doc = REXML::Document.new( src )
+      out = ""
+      doc.write( out )
+      assert_equal( src, out )
+    end
 
-  def test_namespace_attributes
-    source = <<-EOL
-    <a xmlns:x="1">
-      <x:b x:n="foo"/>
-    </a>
-    EOL
-    d = Document.new( source )
-    assert_equal( 'foo', REXML::XPath.first(d.root, "//x:b/@x:n").value )
-    assert_equal( nil, REXML::XPath.first(d.root, "//x:b/@x:n", {}))
-  end
+    def test_namespace_attributes
+      source = <<-EOL
+      <a xmlns:x="1">
+        <x:b x:n="foo"/>
+      </a>
+      EOL
+      d = Document.new( source )
+      assert_equal( 'foo', REXML::XPath.first(d.root, "//x:b/@x:n").value )
+      assert_equal( nil, REXML::XPath.first(d.root, "//x:b/@x:n", {}))
+    end
 
-  def test_null_element_name
-    a = REXML::Document.new
-    assert_raise( RuntimeError ) {
-      a.add_element( nil )
-    }
-  end
+    def test_null_element_name
+      a = REXML::Document.new
+      assert_raise( RuntimeError ) {
+        a.add_element( nil )
+      }
+    end
 
-  def test_text_raw
-    # From the REXML tutorial
-    # (http://www.germane-software.com/software/rexml/test/data/tutorial.html)
-    doc = Document.new <<-EOL
-    <?xml version="1.0"?>
-    <!DOCTYPE schema SYSTEM "XMLSchema.dtd" [
-    <!ENTITY % s 'Sean'>
-    ]>
-    <a/>
-    EOL
-    a = doc.root
-
-    # This makes sure that RAW text nodes don't have their entity strings
-    # replaced
-    t = Text.new "Sean", false, nil, true
-    a.text = t
-    assert_equal( "Sean", t.to_s )
-    assert_equal( "Sean", t.value )
-
-    # This makes sure that they do
-    t = Text.new "Sean", false, nil, false
-    a.text = t
-    assert_equal( "&s;", t.to_s )
-    assert_equal( "Sean", t.value )
-
-    t = Text.new "&s;", false, nil, true
-    a.text = t
-    assert_equal( "&s;", t.to_s )
-    assert_equal( "Sean", t.value )
-
-    t = Text.new "&s;", false, nil, true
-    a.text = t
-    assert_equal( "&s;", t.to_s )
-    assert_equal( "Sean", t.value )
-
-    # Ticket #44
-    t = REXML::Text.new( "&amp;", false, nil, true )
-    assert_equal( "&amp;", t.to_s )
-
-    t = REXML::Text.new("&amp;", false, false)
-    assert_equal( "&amp;amp;", t.to_s )
-  end
+    def test_text_raw
+      # From the REXML tutorial
+      # (http://www.germane-software.com/software/rexml/test/data/tutorial.html)
+      doc = Document.new <<-EOL
+      <?xml version="1.0"?>
+      <!DOCTYPE schema SYSTEM "XMLSchema.dtd" [
+      <!ENTITY % s 'Sean'>
+      ]>
+      <a/>
+      EOL
+      a = doc.root
+
+      # This makes sure that RAW text nodes don't have their entity strings
+      # replaced
+      t = Text.new "Sean", false, nil, true
+      a.text = t
+      assert_equal( "Sean", t.to_s )
+      assert_equal( "Sean", t.value )
+
+      # This makes sure that they do
+      t = Text.new "Sean", false, nil, false
+      a.text = t
+      assert_equal( "&s;", t.to_s )
+      assert_equal( "Sean", t.value )
+
+      t = Text.new "&s;", false, nil, true
+      a.text = t
+      assert_equal( "&s;", t.to_s )
+      assert_equal( "Sean", t.value )
+
+      t = Text.new "&s;", false, nil, true
+      a.text = t
+      assert_equal( "&s;", t.to_s )
+      assert_equal( "Sean", t.value )
+
+      # Ticket #44
+      t = REXML::Text.new( "&amp;", false, nil, true )
+      assert_equal( "&amp;", t.to_s )
+
+      t = REXML::Text.new("&amp;", false, false)
+      assert_equal( "&amp;amp;", t.to_s )
+    end
 
-  def test_to_xpath
-  doc = REXML::Document.new( %q{<tag1>
-      <tag2 name="tag2"/>
-      <tag2 name="tag2"/>
-    </tag1>})
-    names = %w{ /tag1/tag2[1] /tag1/tag2[2] }
-    doc.root.elements.each_with_index {|el, i|
-      assert_equal( names[i], el.xpath )
-    }
-  end
+    def test_to_xpath
+    doc = REXML::Document.new( %q{<tag1>
+        <tag2 name="tag2"/>
+        <tag2 name="tag2"/>
+      </tag1>})
+      names = %w{ /tag1/tag2[1] /tag1/tag2[2] }
+      doc.root.elements.each_with_index {|el, i|
+        assert_equal( names[i], el.xpath )
+      }
+    end
 
-  def test_transitive
-  doc = REXML::Document.new( "<a/>")
-  s = ""
-  doc.write( s, 0, true )
-  end
+    def test_transitive
+    doc = REXML::Document.new( "<a/>")
+    s = ""
+    doc.write( s, 0, true )
+    end
 
-  # This is issue #40
-  def test_replace_with
-    old = '<doc>old<foo/>old</doc>'
-    d = REXML::Document.new(old).root
-    new = REXML::Text.new('new',true,nil,true)
-    child = d.children[2]
-    child.replace_with(new)
-    assert_equal( new, d.children[2] )
-  end
+    # This is issue #40
+    def test_replace_with
+      old = '<doc>old<foo/>old</doc>'
+      d = REXML::Document.new(old).root
+      new = REXML::Text.new('new',true,nil,true)
+      child = d.children[2]
+      child.replace_with(new)
+      assert_equal( new, d.children[2] )
+    end
 
-  def test_repeated_writes
-    a = IO.read(fixture_path("iso8859-1.xml"))
-    f = REXML::Formatters::Pretty.new
+    def test_repeated_writes
+      a = IO.read(fixture_path("iso8859-1.xml"))
+      f = REXML::Formatters::Pretty.new
 
-    xmldoc = REXML::Document.new( a )
-    a_andre = xmldoc.elements['//image'].attributes['caption']
+      xmldoc = REXML::Document.new( a )
+      a_andre = xmldoc.elements['//image'].attributes['caption']
 
-    f.write(xmldoc,b="")
+      f.write(xmldoc,b="")
 
-    xmldoc = REXML::Document.new(b)
-    b_andre = xmldoc.elements['//image'].attributes['caption']
-    assert_equal( a_andre, b_andre )
+      xmldoc = REXML::Document.new(b)
+      b_andre = xmldoc.elements['//image'].attributes['caption']
+      assert_equal( a_andre, b_andre )
 
-    f.write(xmldoc,c="")
+      f.write(xmldoc,c="")
 
-    xmldoc = REXML::Document.new(c)
-    c_andre = xmldoc.elements['//image'].attributes['caption']
-    assert_equal( b_andre, c_andre )
+      xmldoc = REXML::Document.new(c)
+      c_andre = xmldoc.elements['//image'].attributes['caption']
+      assert_equal( b_andre, c_andre )
 
-    o = Output.new(d="","UTF-8")
-    f.write(xmldoc,o)
-    assert_not_equal( c, d )
-  end
+      o = Output.new(d="","UTF-8")
+      f.write(xmldoc,o)
+      assert_not_equal( c, d )
+    end
 
-  def test_pretty_format_long_text_finite
-    n = 1_000_000
-    long_text = 'aaaa ' * n
-    xml = "<doc>#{long_text}</doc>"
-    formatter = REXML::Formatters::Pretty.new
-    document = nil
-    begin
-      document = REXML::Document.new(xml)
-    rescue REXML::ParseException
-      skip_message = "skip this test because we can't check Pretty#wrap " +
-        "works without #<SystemStackError: stack level too deep> on " +
-        "small memory system. #<RegexpError: failed to allocate memory> " +
-        "will be raised on the system. See also [ruby-dev:42599]."
-      return skip_message
-    end
-    output = ""
-    formatter.write(document, output)
-    assert_equal("<doc>\n" +
-                 ((" " + (" aaaa" * 15) + "\n") * (n / 15)) +
-                 "  " + ("aaaa " * (n % 15)) + "\n" +
-                 "</doc>",
-                 output)
-  end
+    def test_pretty_format_long_text_finite
+      n = 1_000_000
+      long_text = 'aaaa ' * n
+      xml = "<doc>#{long_text}</doc>"
+      formatter = REXML::Formatters::Pretty.new
+      document = nil
+      begin
+        document = REXML::Document.new(xml)
+      rescue REXML::ParseException
+        skip_message = "skip this test because we can't check Pretty#wrap " +
+          "works without #<SystemStackError: stack level too deep> on " +
+          "small memory system. #<RegexpError: failed to allocate memory> " +
+          "will be raised on the system. See also [ruby-dev:42599]."
+        return skip_message
+      end
+      output = ""
+      formatter.write(document, output)
+      assert_equal("<doc>\n" +
+                   ((" " + (" aaaa" * 15) + "\n") * (n / 15)) +
+                   "  " + ("aaaa " * (n % 15)) + "\n" +
+                   "</doc>",
+                   output)
+    end
 
-  def test_pretty_format_deep_indent
-    n = 6
-    elements = ""
-    n.times do |i|
-      elements << "<element#{i}>"
-      elements << "element#{i} " * 5
-    end
-    (n - 1).downto(0) do |i|
-      elements << "</element#{i}>"
-    end
-    xml = "<doc>#{elements}</doc>"
-    document = REXML::Document.new(xml)
-    formatter = REXML::Formatters::Pretty.new
-    formatter.width = 20
-    output = ""
-    formatter.write(document, output)
-    assert_equal(<<-XML.strip, output)
+    def test_pretty_format_deep_indent
+      n = 6
+      elements = ""
+      n.times do |i|
+        elements << "<element#{i}>"
+        elements << "element#{i} " * 5
+      end
+      (n - 1).downto(0) do |i|
+        elements << "</element#{i}>"
+      end
+      xml = "<doc>#{elements}</doc>"
+      document = REXML::Document.new(xml)
+      formatter = REXML::Formatters::Pretty.new
+      formatter.width = 20
+      output = ""
+      formatter.write(document, output)
+      assert_equal(<<-XML.strip, output)
 <doc>
   <element0>
     element0
@@ -1211,115 +1264,115 @@ EOL
     </element1>
   </element0>
 </doc>
-    XML
-  end
+      XML
+    end
 
-  def test_ticket_58
-    doc = REXML::Document.new
-    doc << REXML::XMLDecl.default
-    doc << REXML::Element.new("a")
+    def test_ticket_58
+      doc = REXML::Document.new
+      doc << REXML::XMLDecl.default
+      doc << REXML::Element.new("a")
 
-    str = ""
-    doc.write(str)
+      str = ""
+      doc.write(str)
 
-    assert_equal("<a/>", str)
+      assert_equal("<a/>", str)
 
-    doc = REXML::Document.new
-    doc << REXML::XMLDecl.new("1.0", "UTF-8")
-    doc << REXML::Element.new("a")
+      doc = REXML::Document.new
+      doc << REXML::XMLDecl.new("1.0", "UTF-8")
+      doc << REXML::Element.new("a")
 
-    str = ""
-    doc.write(str)
+      str = ""
+      doc.write(str)
 
-    assert_equal("<?xml version='1.0' encoding='UTF-8'?><a/>", str)
-  end
+      assert_equal("<?xml version='1.0' encoding='UTF-8'?><a/>", str)
+    end
 
-  # Incomplete tags should generate an error
-  def test_ticket_53
-    assert_raise( REXML::ParseException ) {
-      REXML::Document.new( "<a><b></a>" )
-    }
-    assert_raise( REXML::ParseException ) {
-      REXML::Document.new( "<a><b>" )
-    }
-    assert_raise( REXML::ParseException ) {
-      REXML::Document.new( "<a><b/>" )
-    }
-  end
+    # Incomplete tags should generate an error
+    def test_ticket_53
+      assert_raise( REXML::ParseException ) {
+        REXML::Document.new( "<a><b></a>" )
+      }
+      assert_raise( REXML::ParseException ) {
+        REXML::Document.new( "<a><b>" )
+      }
+      assert_raise( REXML::ParseException ) {
+        REXML::Document.new( "<a><b/>" )
+      }
+    end
 
-  def test_ticket_52
-    source = "<!-- this is a single line comment -->"
-    d = REXML::Document.new(source)
-    d.write(k="")
-    assert_equal( source, k )
-
-    source = "<a><!-- Comment --></a>"
-    target = "<a>\n    <!-- Comment -->\n</a>"
-    d = REXML::Document.new(source)
-    REXML::Formatters::Pretty.new(4).write(d,k="")
-    assert_equal( target, k )
-  end
+    def test_ticket_52
+      source = "<!-- this is a single line comment -->"
+      d = REXML::Document.new(source)
+      d.write(k="")
+      assert_equal( source, k )
+
+      source = "<a><!-- Comment --></a>"
+      target = "<a>\n    <!-- Comment -->\n</a>"
+      d = REXML::Document.new(source)
+      REXML::Formatters::Pretty.new(4).write(d,k="")
+      assert_equal( target, k )
+    end
 
-  def test_ticket_76
-    src = "<div>at&t"
-    assert_raise( ParseException, %Q{"#{src}" is invalid XML} )  {
-      REXML::Document.new(src)
-    }
-  end
+    def test_ticket_76
+      src = "<div>at&t"
+      assert_raise( ParseException, %Q{"#{src}" is invalid XML} )  {
+        REXML::Document.new(src)
+      }
+    end
 
-  def test_ticket_21
-    src = "<foo bar=value/>"
+    def test_ticket_21
+      src = "<foo bar=value/>"
       exception = assert_raise(ParseException) do
-      Document.new(src)
-    end
+        Document.new(src)
+      end
       assert_equal(<<-DETAIL, exception.to_s)
 Missing attribute value start quote: <bar>
 Line: 1
 Position: 16
 Last 80 unconsumed characters:
       DETAIL
-  end
+    end
 
-  def test_ticket_63
-    Document.new(File.new(fixture_path("t63-1.xml")))
-  end
+    def test_ticket_63
+      File.open(fixture_path("t63-1.xml")) {|f| Document.new(f) }
+    end
 
-  def test_ticket_75
-    d = REXML::Document.new(File.new(fixture_path("t75.xml")))
-    assert_equal("tree", d.root.name)
-  end
+    def test_ticket_75
+      d = File.open(fixture_path("t75.xml")) {|f| REXML::Document.new(f) }
+      assert_equal("tree", d.root.name)
+    end
 
-  def test_ticket_48_part_II
-    f = REXML::Formatters::Pretty.new
-    #- rexml sanity check (bugs in ruby 1.8.4, ruby 1.8.6)
-    xmldoc = Document.new("<test/>")
-    xmldoc << XMLDecl.new(XMLDecl::DEFAULT_VERSION, "UTF-8")
-    content = ['61c3a927223c3e26'].pack("H*")
-    content.force_encoding('UTF-8') if content.respond_to?(:force_encoding)
-    #- is some UTF-8 text but just to make sure my editor won't magically convert..
-    xmldoc.root.add_attribute('attr', content)
-    f.write(xmldoc,out=[])
-
-    xmldoc = REXML::Document.new(out.join)
-    sanity1 = xmldoc.root.attributes['attr']
-    f.write(xmldoc,out=[])
-
-    xmldoc = REXML::Document.new(out.join)
-    sanity2 = xmldoc.root.attributes['attr']
-    f.write(xmldoc,out=[])
-
-    assert_equal( sanity1, sanity2 )
-  end
+    def test_ticket_48_part_II
+      f = REXML::Formatters::Pretty.new
+      #- rexml sanity check (bugs in ruby 1.8.4, ruby 1.8.6)
+      xmldoc = Document.new("<test/>")
+      xmldoc << XMLDecl.new(XMLDecl::DEFAULT_VERSION, "UTF-8")
+      content = ['61c3a927223c3e26'].pack("H*")
+      content.force_encoding('UTF-8') if content.respond_to?(:force_encoding)
+      #- is some UTF-8 text but just to make sure my editor won't magically convert..
+      xmldoc.root.add_attribute('attr', content)
+      f.write(xmldoc,out=[])
+
+      xmldoc = REXML::Document.new(out.join)
+      sanity1 = xmldoc.root.attributes['attr']
+      f.write(xmldoc,out=[])
+
+      xmldoc = REXML::Document.new(out.join)
+      sanity2 = xmldoc.root.attributes['attr']
+      f.write(xmldoc,out=[])
+
+      assert_equal( sanity1, sanity2 )
+    end
 
-  def test_ticket_88
-    doc = REXML::Document.new("<?xml version=\"1.0\" encoding=\"shift_jis\"?>")
-    assert_equal("<?xml version='1.0' encoding='SHIFT_JIS'?>", doc.to_s)
-    doc = REXML::Document.new("<?xml version = \"1.0\" encoding = \"shift_jis\"?>")
-    assert_equal("<?xml version='1.0' encoding='SHIFT_JIS'?>", doc.to_s)
-  end
+    def test_ticket_88
+      doc = REXML::Document.new("<?xml version=\"1.0\" encoding=\"shift_jis\"?>")
+      assert_equal("<?xml version='1.0' encoding='SHIFT_JIS'?>", doc.to_s)
+      doc = REXML::Document.new("<?xml version = \"1.0\" encoding = \"shift_jis\"?>")
+      assert_equal("<?xml version='1.0' encoding='SHIFT_JIS'?>", doc.to_s)
+    end
 
-  def test_ticket_85
-    xml = <<ENDXML
+    def test_ticket_85
+      xml = <<ENDXML
 <foo>
   <bar>
     <bob name='jimmy'/>
@@ -1327,137 +1380,138 @@ Last 80 unconsumed characters:
 </foo>
 ENDXML
 
-    yml = "<foo>
+      yml = "<foo>
   <bar>
     <bob name='jimmy'/>
   </bar>
 </foo>"
 
-    # The pretty printer ignores all whitespace, anyway so output1 == output2
-    f = REXML::Formatters::Pretty.new( 2 )
-    d = Document.new( xml, :ignore_whitespace_nodes=>:all )
-    f.write( d, output1="" )
+      # The pretty printer ignores all whitespace, anyway so output1 == output2
+      f = REXML::Formatters::Pretty.new( 2 )
+      d = Document.new( xml, :ignore_whitespace_nodes=>:all )
+      f.write( d, output1="" )
 
-    d = Document.new( xml )
-    f.write( d, output2="" )
+      d = Document.new( xml )
+      f.write( d, output2="" )
 
-    # Output directives should override whitespace directives.
-    assert_equal( output1, output2 )
+      # Output directives should override whitespace directives.
+      assert_equal( output1, output2 )
 
-    # The base case.
-    d = Document.new(yml)
-    f.write( d, output3="" )
+      # The base case.
+      d = Document.new(yml)
+      f.write( d, output3="" )
 
-    assert_equal( output3.strip, output2.strip )
+      assert_equal( output3.strip, output2.strip )
 
-    d = Document.new(yml)
-    f.write( d, output4="" )
+      d = Document.new(yml)
+      f.write( d, output4="" )
 
-    assert_equal( output3.strip, output4.strip )
-  end
+      assert_equal( output3.strip, output4.strip )
+    end
 
-  def test_ticket_91
-    source="<root>
-      <bah something='1' somethingelse='bah'>
-        <something>great</something>
-      </bah>
-    </root>"
+    def test_ticket_91
+      source="<root>
+        <bah something='1' somethingelse='bah'>
+          <something>great</something>
+        </bah>
+      </root>"
     expected="<root>
   <bah something='1' somethingelse='bah'>
     <something>great</something>
   </bah>
   <bah/>
 </root>"
-    d = Document.new( source )
-    d.root.add_element( "bah" )
-    p=REXML::Formatters::Pretty.new(2)
-    p.compact = true    # Don't add whitespace to text nodes unless necessary
-    p.write(d,out="")
-    assert_equal( expected, out )
-  end
+      d = Document.new( source )
+      d.root.add_element( "bah" )
+      p=REXML::Formatters::Pretty.new(2)
+      p.compact = true    # Don't add whitespace to text nodes unless necessary
+      p.write(d,out="")
+      assert_equal( expected, out )
+    end
 
-  def test_ticket_95
-    testd = REXML::Document.new "<a><b><c/><c/><c/></b></a>"
-    testd.write(out1="")
-    testd.elements["//c[2]"].xpath
-    testd.write(out2="")
-    assert_equal(out1,out2)
-  end
+    def test_ticket_95
+      testd = REXML::Document.new "<a><b><c/><c/><c/></b></a>"
+      testd.write(out1="")
+      testd.elements["//c[2]"].xpath
+      testd.write(out2="")
+      assert_equal(out1,out2)
+    end
 
-  def test_ticket_102
-    doc = REXML::Document.new '<doc xmlns="ns"><item name="foo"/></doc>'
-    assert_equal( "foo", doc.root.elements["item"].attribute("name","ns").to_s )
-    assert_equal( "item", doc.root.elements["item[@name='foo']"].name )
-  end
+    def test_ticket_102
+      doc = REXML::Document.new '<doc xmlns="ns"><item name="foo"/></doc>'
+      assert_equal( "foo", doc.root.elements["*:item"].attribute("name","ns").to_s )
+      assert_equal( "item", doc.root.elements["*:item[@name='foo']"].name )
+    end
 
-  def test_ticket_14
-    # Per .2.5 Node Tests of XPath spec
-    assert_raise( REXML::UndefinedNamespaceException,
-                   %Q{Should have gotten an Undefined Namespace error} )  {
-      Document.new("<a><n:b/></a>")
-    }
-  end
+    def test_ticket_14
+      # Per .2.5 Node Tests of XPath spec
+      assert_raise( REXML::UndefinedNamespaceException,
+                     %Q{Should have gotten an Undefined Namespace error} )  {
+        Document.new("<a><n:b/></a>")
+      }
+    end
 
-  # 5.7 Text Nodes
-  # Character data is grouped into text nodes. As much character data as
-  # possible is grouped into each text node: a text node never has an
-  # immediately following or preceding sibling that is a text node. The
-  # string-value of a text node is the character data. A text node always has
-  # at least one character of data.
-  def test_ticket_105
-    d = Document.new("<a/>")
-    d.root.add_text( "a" )
-    d.root.add_text( "b" )
-    assert_equal( 1, d.root.children.size )
-  end
+    # 5.7 Text Nodes
+    # Character data is grouped into text nodes. As much character data as
+    # possible is grouped into each text node: a text node never has an
+    # immediately following or preceding sibling that is a text node. The
+    # string-value of a text node is the character data. A text node always has
+    # at least one character of data.
+    def test_ticket_105
+      d = Document.new("<a/>")
+      d.root.add_text( "a" )
+      d.root.add_text( "b" )
+      assert_equal( 1, d.root.children.size )
+    end
 
-  # phantom namespace same as default namespace
-  def test_ticket_121
-    doc = REXML::Document.new(
-      '<doc xmlns="ns" xmlns:phantom="ns"><item name="foo">text</item></doc>'
-    )
-    assert_equal 'text', doc.text( "/doc/item[@name='foo']" )
-    assert_equal "name='foo'",
-      doc.root.elements["item"].attribute("name", "ns").inspect
-    assert_equal "<item name='foo'>text</item>",
-      doc.root.elements["item[@name='foo']"].to_s
-  end
+    # phantom namespace same as default namespace
+    def test_ticket_121
+      doc = REXML::Document.new(
+        '<doc xmlns="ns" xmlns:phantom="ns"><item name="foo">text</item></doc>'
+      )
+      assert_equal 'text', doc.text( "/*:doc/*:item[@name='foo']" )
+      assert_equal "name='foo'",
+        doc.root.elements["*:item"].attribute("name", "ns").inspect
+      assert_equal "<item name='foo'>text</item>",
+        doc.root.elements["*:item[@name='foo']"].to_s
+    end
 
-  def test_ticket_135
-    bean_element = REXML::Element.new("bean")
-    textToAdd = "(&#38;(|(memberof=CN=somegroupabcdefgh,OU=OUsucks,DC=hookemhorns,DC=com)(mail=*someco.com))(acct=%u)(!(extraparameter:2.2.222.222222.2.2.222:=2)))"
-    bean_element.add_element("prop", {"key"=> "filter"}).add_text(textToAdd)
-    doc = REXML::Document.new
-    doc.add_element(bean_element)
+    def test_ticket_135
+      bean_element = REXML::Element.new("bean")
+      textToAdd = "(&#38;(|(memberof=CN=somegroupabcdefgh,OU=OUsucks,DC=hookemhorns,DC=com)(mail=*someco.com))(acct=%u)(!(extraparameter:2.2.222.222222.2.2.222:=2)))"
+      bean_element.add_element("prop", {"key"=> "filter"}).add_text(textToAdd)
+      doc = REXML::Document.new
+      doc.add_element(bean_element)
 
-    REXML::Formatters::Pretty.new(3).write( doc, out = "" )
+      REXML::Formatters::Pretty.new(3).write( doc, out = "" )
 
-    assert_equal "<bean>\n   <prop key='filter'>\n      (&amp;#38;(|(memberof=CN=somegroupabcdefgh,OU=OUsucks,DC=hookemhorns,DC=com)(mail=*someco.com))(acct=%u)(!(extraparameter:2.2.222.222222.2.2.222:=2)))\n   </prop>\n</bean>", out
-  end
+      assert_equal "<bean>\n   <prop key='filter'>\n      (&amp;#38;(|(memberof=CN=somegroupabcdefgh,OU=OUsucks,DC=hookemhorns,DC=com)(mail=*someco.com))(acct=%u)(!(extraparameter:2.2.222.222222.2.2.222:=2)))\n   </prop>\n</bean>", out
+    end
 
-  def test_ticket_138
-    doc = REXML::Document.new(
-      '<svg xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" ' +
-         'inkscape:version="0.44" version="1.0"/>'
-    )
-    expected = {
-      "inkscape" => attribute("xmlns:inkscape",
-                              "http://www.inkscape.org/namespaces/inkscape"),
-      "version" => {
-        "inkscape" => attribute("inkscape:version", "0.44"),
-        "" => attribute("version", "1.0"),
-      },
-    }
-    assert_equal(expected, doc.root.attributes)
-    assert_equal(expected, REXML::Document.new(doc.root.to_s).root.attributes)
-  end
+    def test_ticket_138
+      doc = REXML::Document.new(
+        '<svg xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" ' +
+           'inkscape:version="0.44" version="1.0"/>'
+      )
+      expected = {
+        "inkscape" => attribute("xmlns:inkscape",
+                                "http://www.inkscape.org/namespaces/inkscape"),
+        "version" => {
+          "inkscape" => attribute("inkscape:version", "0.44"),
+          "" => attribute("version", "1.0"),
+        },
+      }
+      assert_equal(expected, doc.root.attributes)
+      assert_equal(expected, REXML::Document.new(doc.root.to_s).root.attributes)
+    end
 
-  def test_empty_doc
-    assert(REXML::Document.new('').children.empty?)
-  end
+    def test_empty_doc
+      assert(REXML::Document.new('').children.empty?)
+    end
 
-  private
-  def attribute(name, value)
-    REXML::Attribute.new(name, value)
+    private
+    def attribute(name, value)
+      REXML::Attribute.new(name, value)
+    end
   end
 end
diff --git a/test/rexml/test_doctype.rb b/test/rexml/test_doctype.rb
index b8d172f..915717d 100644
--- a/test/rexml/test_doctype.rb
+++ b/test/rexml/test_doctype.rb
@@ -1,29 +1,31 @@
-require 'test/unit'
-require 'rexml/document'
+# frozen_string_literal: false
 
-class TestDocTypeAccessor < Test::Unit::TestCase
-  def setup
-    @sysid = "urn:x-test:sysid1"
+require_relative "rexml_test_utils"
+
+module REXMLTests
+  class TestDocTypeAccessor < Test::Unit::TestCase
+    def setup
+      @sysid = "urn:x-test:sysid1"
       @notation_id1 = "urn:x-test:notation1"
       @notation_id2 = "urn:x-test:notation2"
       xml_system = <<-XML
       <!DOCTYPE root SYSTEM "#{@sysid}" [
         <!NOTATION n1 SYSTEM "#{@notation_id1}">
         <!NOTATION n2 SYSTEM "#{@notation_id2}">
-    ]>
+      ]>
       <root/>
       XML
       @doc_type_system = REXML::Document.new(xml_system).doctype
 
-    @pubid = "TEST_ID"
+      @pubid = "TEST_ID"
       xml_public_system = <<-XML
       <!DOCTYPE root PUBLIC "#{@pubid}" "#{@sysid}">
       <root/>
       XML
       @doc_type_public_system = REXML::Document.new(xml_public_system).doctype
-  end
+    end
 
-  def test_public
+    def test_public
       assert_equal([
                      nil,
                      @pubid,
@@ -37,9 +39,15 @@ class TestDocTypeAccessor < Test::Unit::TestCase
     def test_to_s
       assert_equal("<!DOCTYPE root PUBLIC \"#{@pubid}\" \"#{@sysid}\">",
                    @doc_type_public_system.to_s)
-  end
+    end
 
-  def test_system
+    def test_to_s_apostrophe
+      @doc_type_public_system.parent.context[:prologue_quote] = :apostrophe
+      assert_equal("<!DOCTYPE root PUBLIC '#{@pubid}' '#{@sysid}'>",
+                   @doc_type_public_system.to_s)
+    end
+
+    def test_system
       assert_equal([
                      @sysid,
                      @sysid,
@@ -48,9 +56,9 @@ class TestDocTypeAccessor < Test::Unit::TestCase
                      @doc_type_system.system,
                      @doc_type_public_system.system,
                    ])
-  end
+    end
 
-  def test_notation
+    def test_notation
       assert_equal([
                      @notation_id1,
                      @notation_id2,
@@ -59,117 +67,81 @@ class TestDocTypeAccessor < Test::Unit::TestCase
                      @doc_type_system.notation("n1").system,
                      @doc_type_system.notation("n2").system,
                    ])
-  end
+    end
 
-  def test_notations
+    def test_notations
       notations = @doc_type_system.notations
       assert_equal([
                      @notation_id1,
                      @notation_id2,
                    ],
                    notations.collect(&:system))
-  end
-end
-
-  class TestDocType < Test::Unit::TestCase
-    class TestExternalID < self
-      class TestSystem < self
-        class TestSystemLiteral < self
-          def test_to_s
-            doctype = REXML::DocType.new(["root", "SYSTEM", nil, "root.dtd"])
-            assert_equal("<!DOCTYPE root SYSTEM \"root.dtd\">",
-                         doctype.to_s)
-          end
-        end
-      end
-
-      class TestPublic < self
-        class TestPublicIDLiteral < self
-          def test_to_s
-            doctype = REXML::DocType.new(["root", "PUBLIC", "pub", "root.dtd"])
-            assert_equal("<!DOCTYPE root PUBLIC \"pub\" \"root.dtd\">",
-                         doctype.to_s)
-          end
-        end
-
-        class TestSystemLiteral < self
-          def test_to_s
-            doctype = REXML::DocType.new(["root", "PUBLIC", "pub", "root.dtd"])
-            assert_equal("<!DOCTYPE root PUBLIC \"pub\" \"root.dtd\">",
-                         doctype.to_s)
-          end
-
-          def test_to_s_double_quote
-            doctype = REXML::DocType.new(["root", "PUBLIC", "pub", "root\".dtd"])
-            assert_equal("<!DOCTYPE root PUBLIC \"pub\" 'root\".dtd'>",
-                         doctype.to_s)
-          end
-        end
-      end
     end
   end
 
-class TestNotationDeclPublic < Test::Unit::TestCase
-  def setup
-    @name = "vrml"
-    @id = "VRML 1.0"
-    @uri = "http://www.web3d.org/"
-  end
-
-  def test_to_s
-    assert_equal("<!NOTATION #{@name} PUBLIC \"#{@id}\">",
-                 decl(@id, nil).to_s)
-  end
-
-    def test_to_s_pubid_literal_include_apostrophe
-      assert_equal("<!NOTATION #{@name} PUBLIC \"#{@id}'\">",
-                   decl("#{@id}'", nil).to_s)
+  class TestNotationDeclPublic < Test::Unit::TestCase
+    def setup
+      @name = "vrml"
+      @id = "VRML 1.0"
+      @uri = "http://www.web3d.org/"
     end
 
-  def test_to_s_with_uri
-    assert_equal("<!NOTATION #{@name} PUBLIC \"#{@id}\" \"#{@uri}\">",
-                 decl(@id, @uri).to_s)
-  end
-
-    def test_to_s_system_literal_include_apostrophe
-      assert_equal("<!NOTATION #{@name} PUBLIC \"#{@id}\" \"system'literal\">",
-                   decl(@id, "system'literal").to_s)
+    def test_to_s
+      assert_equal("<!NOTATION #{@name} PUBLIC \"#{@id}\">",
+                   decl(@id, nil).to_s)
     end
 
-    def test_to_s_system_literal_include_double_quote
-      assert_equal("<!NOTATION #{@name} PUBLIC \"#{@id}\" 'system\"literal'>",
-                   decl(@id, "system\"literal").to_s)
+    def test_to_s_with_uri
+      assert_equal("<!NOTATION #{@name} PUBLIC \"#{@id}\" \"#{@uri}\">",
+                   decl(@id, @uri).to_s)
     end
 
-  private
-  def decl(id, uri)
-    REXML::NotationDecl.new(@name, "PUBLIC", id, uri)
-  end
-end
+    def test_to_s_apostrophe
+      document = REXML::Document.new(<<-XML)
+      <!DOCTYPE root SYSTEM "urn:x-test:sysid" [
+        #{decl(@id, @uri).to_s}
+      ]>
+      <root/>
+      XML
+      document.context[:prologue_quote] = :apostrophe
+      notation = document.doctype.notations[0]
+      assert_equal("<!NOTATION #{@name} PUBLIC '#{@id}' '#{@uri}'>",
+                   notation.to_s)
+    end
 
-class TestNotationDeclSystem < Test::Unit::TestCase
-  def setup
-    @name = "gif"
-    @id = "gif viewer"
+    private
+    def decl(id, uri)
+      REXML::NotationDecl.new(@name, "PUBLIC", id, uri)
+    end
   end
 
-  def test_to_s
-    assert_equal("<!NOTATION #{@name} SYSTEM \"#{@id}\">",
-                 decl(@id).to_s)
-  end
+  class TestNotationDeclSystem < Test::Unit::TestCase
+    def setup
+      @name = "gif"
+      @id = "gif viewer"
+    end
 
-    def test_to_s_include_apostrophe
-      assert_equal("<!NOTATION #{@name} SYSTEM \"#{@id}'\">",
-                   decl("#{@id}'").to_s)
+    def test_to_s
+      assert_equal("<!NOTATION #{@name} SYSTEM \"#{@id}\">",
+                   decl(@id).to_s)
     end
 
-    def test_to_s_include_double_quote
-      assert_equal("<!NOTATION #{@name} SYSTEM '#{@id}\"'>",
-                   decl("#{@id}\"").to_s)
+    def test_to_s_apostrophe
+      document = REXML::Document.new(<<-XML)
+      <!DOCTYPE root SYSTEM "urn:x-test:sysid" [
+        #{decl(@id).to_s}
+      ]>
+      <root/>
+      XML
+      document.context[:prologue_quote] = :apostrophe
+      notation = document.doctype.notations[0]
+      assert_equal("<!NOTATION #{@name} SYSTEM '#{@id}'>",
+                   notation.to_s)
     end
 
-  private
-  def decl(id)
-      REXML::NotationDecl.new(@name, "SYSTEM", nil, id)
+    private
+    def decl(id)
+      REXML::NotationDecl.new(@name, "SYSTEM", id, nil)
+    end
   end
 end
diff --git a/test/rexml/test_document.rb b/test/rexml/test_document.rb
index c5ac057..c0faae4 100644
--- a/test/rexml/test_document.rb
+++ b/test/rexml/test_document.rb
@@ -1,37 +1,50 @@
 # -*- coding: utf-8 -*-
+# frozen_string_literal: false
 
 require "rexml/document"
 require "test/unit"
 
-class REXML::TestDocument < Test::Unit::TestCase
-  def test_version_attributes_to_s
-    doc = REXML::Document.new(<<-eoxml)
-      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-      <svg  id="svg2"
-            xmlns:sodipodi="foo"
-            xmlns:inkscape="bar"
-            sodipodi:version="0.32"
-            inkscape:version="0.44.1"
-      >
-      </svg>
-    eoxml
-
-    string = doc.to_s
-    assert_match('xmlns:sodipodi', string)
-    assert_match('xmlns:inkscape', string)
-    assert_match('sodipodi:version', string)
-    assert_match('inkscape:version', string)
-  end
+module REXMLTests
+  class TestDocument < Test::Unit::TestCase
+    def test_version_attributes_to_s
+      doc = REXML::Document.new(<<-eoxml)
+        <?xml version="1.0" encoding="UTF-8" standalone="no"?>
+        <svg  id="svg2"
+              xmlns:sodipodi="foo"
+              xmlns:inkscape="bar"
+              sodipodi:version="0.32"
+              inkscape:version="0.44.1"
+        >
+        </svg>
+      eoxml
+
+      string = doc.to_s
+      assert_match('xmlns:sodipodi', string)
+      assert_match('xmlns:inkscape', string)
+      assert_match('sodipodi:version', string)
+      assert_match('inkscape:version', string)
+    end
 
-  def test_new
-    doc = REXML::Document.new(<<EOF)
+    def test_new
+      doc = REXML::Document.new(<<EOF)
 <?xml version="1.0" encoding="UTF-8"?>
 <message>Hello world!</message>
 EOF
-    assert_equal("Hello world!", doc.root.children.first.value)
-  end
+      assert_equal("Hello world!", doc.root.children.first.value)
+    end
+
+    class EntityExpansionLimitTest < Test::Unit::TestCase
+      def setup
+        @default_entity_expansion_limit = REXML::Security.entity_expansion_limit
+      end
+
+      def teardown
+        REXML::Security.entity_expansion_limit = @default_entity_expansion_limit
+      end
 
-  XML_WITH_NESTED_ENTITY = <<EOF
+      class GeneralEntityTest < self
+        def test_have_value
+          xml = <<EOF
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE member [
   <!ENTITY a "&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;">
@@ -47,7 +60,21 @@ EOF
 </member>
 EOF
 
-  XML_WITH_NESTED_EMPTY_ENTITY = <<EOF
+          doc = REXML::Document.new(xml)
+          assert_raise(RuntimeError) do
+            doc.root.children.first.value
+          end
+          REXML::Security.entity_expansion_limit = 100
+          assert_equal(100, REXML::Security.entity_expansion_limit)
+          doc = REXML::Document.new(xml)
+          assert_raise(RuntimeError) do
+            doc.root.children.first.value
+          end
+          assert_equal(101, doc.entity_expansion_count)
+        end
+
+        def test_empty_value
+          xml = <<EOF
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE member [
   <!ENTITY a "&b;&b;&b;&b;&b;&b;&b;&b;&b;&b;">
@@ -63,7 +90,47 @@ EOF
 </member>
 EOF
 
-  XML_WITH_NESTED_PARAMETER_ENTITY = <<EOF
+          doc = REXML::Document.new(xml)
+          assert_raise(RuntimeError) do
+            doc.root.children.first.value
+          end
+          REXML::Security.entity_expansion_limit = 100
+          assert_equal(100, REXML::Security.entity_expansion_limit)
+          doc = REXML::Document.new(xml)
+          assert_raise(RuntimeError) do
+            doc.root.children.first.value
+          end
+          assert_equal(101, doc.entity_expansion_count)
+        end
+
+        def test_with_default_entity
+          xml = <<EOF
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE member [
+  <!ENTITY a "a">
+  <!ENTITY a2 "&a; &a;">
+]>
+<member>
+&a;
+&a2;
+&lt;
+</member>
+EOF
+
+          REXML::Security.entity_expansion_limit = 4
+          doc = REXML::Document.new(xml)
+          assert_equal("\na\na a\n<\n", doc.root.children.first.value)
+          REXML::Security.entity_expansion_limit = 3
+          doc = REXML::Document.new(xml)
+          assert_raise(RuntimeError) do
+            doc.root.children.first.value
+          end
+        end
+      end
+
+      class ParameterEntityTest < self
+        def test_have_value
+          xml = <<EOF
 <!DOCTYPE root [
   <!ENTITY % a "BOOM.BOOM.BOOM.BOOM.BOOM.BOOM.BOOM.BOOM.BOOM.">
   <!ENTITY % b "%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;">
@@ -77,7 +144,18 @@ EOF
 <cd></cd>
 EOF
 
-  XML_WITH_NESTED_EMPTY_PARAMETER_ENTITY = <<EOF
+          assert_raise(REXML::ParseException) do
+            REXML::Document.new(xml)
+          end
+          REXML::Security.entity_expansion_limit = 100
+          assert_equal(100, REXML::Security.entity_expansion_limit)
+          assert_raise(REXML::ParseException) do
+            REXML::Document.new(xml)
+          end
+        end
+
+        def test_empty_value
+          xml = <<EOF
 <!DOCTYPE root [
   <!ENTITY % a "">
   <!ENTITY % b "%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;%a;">
@@ -91,306 +169,247 @@ EOF
 <cd></cd>
 EOF
 
-  XML_WITH_4_ENTITY_EXPANSION = <<EOF
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE member [
-  <!ENTITY a "a">
-  <!ENTITY a2 "&a; &a;">
-]>
-<member>
-&a;
-&a2;
-&lt;
-</member>
-EOF
-
-  def test_entity_expansion_limit
-    doc = REXML::Document.new(XML_WITH_NESTED_ENTITY)
-    assert_raise(RuntimeError) do
-      doc.root.children.first.value
-    end
-    REXML::Security.entity_expansion_limit = 100
-    assert_equal(100, REXML::Security.entity_expansion_limit)
-    doc = REXML::Document.new(XML_WITH_NESTED_ENTITY)
-    assert_raise(RuntimeError) do
-      doc.root.children.first.value
-    end
-    assert_equal(101, doc.entity_expansion_count)
-
-    doc = REXML::Document.new(XML_WITH_NESTED_EMPTY_ENTITY)
-    assert_raise(RuntimeError) do
-      doc.root.children.first.value
-    end
-    REXML::Security.entity_expansion_limit = 100
-    assert_equal(100, REXML::Security.entity_expansion_limit)
-    doc = REXML::Document.new(XML_WITH_NESTED_EMPTY_ENTITY)
-    assert_raise(RuntimeError) do
-      doc.root.children.first.value
-    end
-    assert_equal(101, doc.entity_expansion_count)
-
-    REXML::Security.entity_expansion_limit = 4
-    doc = REXML::Document.new(XML_WITH_4_ENTITY_EXPANSION)
-    assert_equal("\na\na a\n<\n", doc.root.children.first.value)
-    REXML::Security.entity_expansion_limit = 3
-    doc = REXML::Document.new(XML_WITH_4_ENTITY_EXPANSION)
-    assert_raise(RuntimeError) do
-      doc.root.children.first.value
-    end
-  ensure
-    REXML::Security.entity_expansion_limit = 10000
-  end
-
-  def test_entity_expansion_limit_for_parameter_entity
-    assert_raise(REXML::ParseException) do
-      REXML::Document.new(XML_WITH_NESTED_PARAMETER_ENTITY)
-    end
-    REXML::Security.entity_expansion_limit = 100
-    assert_equal(100, REXML::Security.entity_expansion_limit)
-    assert_raise(REXML::ParseException) do
-      REXML::Document.new(XML_WITH_NESTED_PARAMETER_ENTITY)
-    end
-
-    assert_raise(REXML::ParseException) do
-      REXML::Document.new(XML_WITH_NESTED_EMPTY_PARAMETER_ENTITY)
-    end
-    REXML::Security.entity_expansion_limit = 100
-    assert_equal(100, REXML::Security.entity_expansion_limit)
-    assert_raise(REXML::ParseException) do
-      REXML::Document.new(XML_WITH_NESTED_EMPTY_PARAMETER_ENTITY)
+          assert_raise(REXML::ParseException) do
+            REXML::Document.new(xml)
+          end
+          REXML::Security.entity_expansion_limit = 100
+          assert_equal(100, REXML::Security.entity_expansion_limit)
+          assert_raise(REXML::ParseException) do
+            REXML::Document.new(xml)
+          end
+        end
+      end
     end
-  ensure
-    REXML::Security.entity_expansion_limit = 10000
-  end
 
-  def test_tag_in_cdata_with_not_ascii_only_but_ascii8bit_encoding_source
-    tag = "<b>...</b>"
-    message = "" # Hello world! in Japanese
-    xml = <<EOX
+    def test_tag_in_cdata_with_not_ascii_only_but_ascii8bit_encoding_source
+      tag = "<b>...</b>"
+      message = "" # Hello world! in Japanese
+      xml = <<EOX
 <?xml version="1.0" encoding="UTF-8"?>
 <message><![CDATA[#{tag}#{message}]]></message>
 EOX
-    xml.force_encoding(Encoding::ASCII_8BIT)
-    doc = REXML::Document.new(xml)
-    assert_equal("#{tag}#{message}", doc.root.children.first.value)
-  end
+      xml.force_encoding(Encoding::ASCII_8BIT)
+      doc = REXML::Document.new(xml)
+      assert_equal("#{tag}#{message}", doc.root.children.first.value)
+    end
 
-  def test_xml_declaration_standalone
-    bug2539 = '[ruby-core:27345]'
-    doc = REXML::Document.new('<?xml version="1.0" standalone="no" ?>')
-    assert_equal('no', doc.stand_alone?, bug2539)
-    doc = REXML::Document.new('<?xml version="1.0" standalone= "no" ?>')
-    assert_equal('no', doc.stand_alone?, bug2539)
-    doc = REXML::Document.new('<?xml version="1.0" standalone=  "no" ?>')
-    assert_equal('no', doc.stand_alone?, bug2539)
-  end
+    def test_xml_declaration_standalone
+      bug2539 = '[ruby-core:27345]'
+      doc = REXML::Document.new('<?xml version="1.0" standalone="no" ?>')
+      assert_equal('no', doc.stand_alone?, bug2539)
+      doc = REXML::Document.new('<?xml version="1.0" standalone= "no" ?>')
+      assert_equal('no', doc.stand_alone?, bug2539)
+      doc = REXML::Document.new('<?xml version="1.0" standalone=  "no" ?>')
+      assert_equal('no', doc.stand_alone?, bug2539)
+    end
 
-  class WriteTest < Test::Unit::TestCase
-    def setup
-      @document = REXML::Document.new(<<-EOX)
+    class WriteTest < Test::Unit::TestCase
+      def setup
+        @document = REXML::Document.new(<<-EOX)
 <?xml version="1.0" encoding="UTF-8"?>
 <message>Hello world!</message>
 EOX
-    end
+      end
 
-    class ArgumentsTest < self
-      def test_output
-        output = ""
-        @document.write(output)
-        assert_equal(<<-EOX, output)
+      class ArgumentsTest < self
+        def test_output
+          output = ""
+          @document.write(output)
+          assert_equal(<<-EOX, output)
 <?xml version='1.0' encoding='UTF-8'?>
 <message>Hello world!</message>
 EOX
-      end
+        end
 
-      def test_indent
-        output = ""
-        indent = 2
-        @document.write(output, indent)
-        assert_equal(<<-EOX.chomp, output)
+        def test_indent
+          output = ""
+          indent = 2
+          @document.write(output, indent)
+          assert_equal(<<-EOX.chomp, output)
 <?xml version='1.0' encoding='UTF-8'?>
 <message>
   Hello world!
 </message>
 EOX
-      end
-
-      def test_transitive
-        output = ""
-        indent = 2
-        transitive = true
-        @document.write(output, indent, transitive)
-        assert_equal(<<-EOX, output)
+        end
+
+        def test_transitive
+          output = ""
+          indent = 2
+          transitive = true
+          @document.write(output, indent, transitive)
+          assert_equal(<<-EOX, output)
 <?xml version='1.0' encoding='UTF-8'?>
 <message
 >Hello world!</message
 >
 EOX
-      end
-
-      def test_ie_hack
-        output = ""
-        indent = -1
-        transitive = false
-        ie_hack = true
-        document = REXML::Document.new("<empty/>")
-        document.write(output, indent, transitive, ie_hack)
-        assert_equal("<empty />", output)
-      end
-
-      def test_encoding
-        output = ""
-        indent = -1
-        transitive = false
-        ie_hack = false
-        encoding = "Windows-31J"
-
-        @document.xml_decl.encoding = "Shift_JIS"
-        japanese_text = ""
-        @document.root.text = japanese_text
-        @document.write(output, indent, transitive, ie_hack, encoding)
-        assert_equal(<<-EOX.encode(encoding), output)
+        end
+
+        def test_ie_hack
+          output = ""
+          indent = -1
+          transitive = false
+          ie_hack = true
+          document = REXML::Document.new("<empty/>")
+          document.write(output, indent, transitive, ie_hack)
+          assert_equal("<empty />", output)
+        end
+
+        def test_encoding
+          output = ""
+          indent = -1
+          transitive = false
+          ie_hack = false
+          encoding = "Windows-31J"
+
+          @document.xml_decl.encoding = "Shift_JIS"
+          japanese_text = ""
+          @document.root.text = japanese_text
+          @document.write(output, indent, transitive, ie_hack, encoding)
+          assert_equal(<<-EOX.encode(encoding), output)
 <?xml version='1.0' encoding='SHIFT_JIS'?>
 <message>#{japanese_text}</message>
 EOX
+        end
       end
-    end
 
-    class OptionsTest < self
-      def test_output
-        output = ""
-        @document.write(:output => output)
-        assert_equal(<<-EOX, output)
+      class OptionsTest < self
+        def test_output
+          output = ""
+          @document.write(:output => output)
+          assert_equal(<<-EOX, output)
 <?xml version='1.0' encoding='UTF-8'?>
 <message>Hello world!</message>
 EOX
-      end
+        end
 
-      def test_indent
-        output = ""
-        @document.write(:output => output, :indent => 2)
-        assert_equal(<<-EOX.chomp, output)
+        def test_indent
+          output = ""
+          @document.write(:output => output, :indent => 2)
+          assert_equal(<<-EOX.chomp, output)
 <?xml version='1.0' encoding='UTF-8'?>
 <message>
   Hello world!
 </message>
 EOX
-      end
+        end
 
-      def test_transitive
-        output = ""
-        @document.write(:output => output, :indent => 2, :transitive => true)
-        assert_equal(<<-EOX, output)
+        def test_transitive
+          output = ""
+          @document.write(:output => output, :indent => 2, :transitive => true)
+          assert_equal(<<-EOX, output)
 <?xml version='1.0' encoding='UTF-8'?>
 <message
 >Hello world!</message
 >
 EOX
-      end
-
-      def test_ie_hack
-        output = ""
-        document = REXML::Document.new("<empty/>")
-        document.write(:output => output, :ie_hack => true)
-        assert_equal("<empty />", output)
-      end
-
-      def test_encoding
-        output = ""
-        encoding = "Windows-31J"
-        @document.xml_decl.encoding = "Shift_JIS"
-        japanese_text = ""
-        @document.root.text = japanese_text
-        @document.write(:output => output, :encoding => encoding)
-        assert_equal(<<-EOX.encode(encoding), output)
+        end
+
+        def test_ie_hack
+          output = ""
+          document = REXML::Document.new("<empty/>")
+          document.write(:output => output, :ie_hack => true)
+          assert_equal("<empty />", output)
+        end
+
+        def test_encoding
+          output = ""
+          encoding = "Windows-31J"
+          @document.xml_decl.encoding = "Shift_JIS"
+          japanese_text = ""
+          @document.root.text = japanese_text
+          @document.write(:output => output, :encoding => encoding)
+          assert_equal(<<-EOX.encode(encoding), output)
 <?xml version='1.0' encoding='SHIFT_JIS'?>
 <message>#{japanese_text}</message>
 EOX
+        end
       end
     end
-  end
 
-  class BomTest < self
-    class HaveEncodingTest < self
-      def test_utf_8
-        xml = <<-EOX.force_encoding("ASCII-8BIT")
+    class BomTest < Test::Unit::TestCase
+      class HaveEncodingTest < self
+        def test_utf_8
+          xml = <<-EOX.force_encoding("ASCII-8BIT")
 <?xml version="1.0" encoding="UTF-8"?>
 <message>Hello world!</message>
 EOX
-        bom = "\ufeff".force_encoding("ASCII-8BIT")
-        document = REXML::Document.new(bom + xml)
-        assert_equal("UTF-8", document.encoding)
-      end
+          bom = "\ufeff".force_encoding("ASCII-8BIT")
+          document = REXML::Document.new(bom + xml)
+          assert_equal("UTF-8", document.encoding)
+        end
 
-      def test_utf_16le
-        xml = <<-EOX.encode("UTF-16LE").force_encoding("ASCII-8BIT")
+        def test_utf_16le
+          xml = <<-EOX.encode("UTF-16LE").force_encoding("ASCII-8BIT")
 <?xml version="1.0" encoding="UTF-16"?>
 <message>Hello world!</message>
 EOX
-        bom = "\ufeff".encode("UTF-16LE").force_encoding("ASCII-8BIT")
-        document = REXML::Document.new(bom + xml)
-        assert_equal("UTF-16", document.encoding)
-      end
+          bom = "\ufeff".encode("UTF-16LE").force_encoding("ASCII-8BIT")
+          document = REXML::Document.new(bom + xml)
+          assert_equal("UTF-16", document.encoding)
+        end
 
-      def test_utf_16be
-        xml = <<-EOX.encode("UTF-16BE").force_encoding("ASCII-8BIT")
+        def test_utf_16be
+          xml = <<-EOX.encode("UTF-16BE").force_encoding("ASCII-8BIT")
 <?xml version="1.0" encoding="UTF-16"?>
 <message>Hello world!</message>
 EOX
-        bom = "\ufeff".encode("UTF-16BE").force_encoding("ASCII-8BIT")
-        document = REXML::Document.new(bom + xml)
-        assert_equal("UTF-16", document.encoding)
+          bom = "\ufeff".encode("UTF-16BE").force_encoding("ASCII-8BIT")
+          document = REXML::Document.new(bom + xml)
+          assert_equal("UTF-16", document.encoding)
+        end
       end
-    end
 
-    class NoEncodingTest < self
-      def test_utf_8
-        xml = <<-EOX.force_encoding("ASCII-8BIT")
+      class NoEncodingTest < self
+        def test_utf_8
+          xml = <<-EOX.force_encoding("ASCII-8BIT")
 <?xml version="1.0"?>
 <message>Hello world!</message>
 EOX
-        bom = "\ufeff".force_encoding("ASCII-8BIT")
-        document = REXML::Document.new(bom + xml)
-        assert_equal("UTF-8", document.encoding)
-      end
+          bom = "\ufeff".force_encoding("ASCII-8BIT")
+          document = REXML::Document.new(bom + xml)
+          assert_equal("UTF-8", document.encoding)
+        end
 
-      def test_utf_16le
-        xml = <<-EOX.encode("UTF-16LE").force_encoding("ASCII-8BIT")
+        def test_utf_16le
+          xml = <<-EOX.encode("UTF-16LE").force_encoding("ASCII-8BIT")
 <?xml version="1.0"?>
 <message>Hello world!</message>
 EOX
-        bom = "\ufeff".encode("UTF-16LE").force_encoding("ASCII-8BIT")
-        document = REXML::Document.new(bom + xml)
-        assert_equal("UTF-16", document.encoding)
-      end
+          bom = "\ufeff".encode("UTF-16LE").force_encoding("ASCII-8BIT")
+          document = REXML::Document.new(bom + xml)
+          assert_equal("UTF-16", document.encoding)
+        end
 
-      def test_utf_16be
-        xml = <<-EOX.encode("UTF-16BE").force_encoding("ASCII-8BIT")
+        def test_utf_16be
+          xml = <<-EOX.encode("UTF-16BE").force_encoding("ASCII-8BIT")
 <?xml version="1.0"?>
 <message>Hello world!</message>
 EOX
-        bom = "\ufeff".encode("UTF-16BE").force_encoding("ASCII-8BIT")
-        document = REXML::Document.new(bom + xml)
-        assert_equal("UTF-16", document.encoding)
+          bom = "\ufeff".encode("UTF-16BE").force_encoding("ASCII-8BIT")
+          document = REXML::Document.new(bom + xml)
+          assert_equal("UTF-16", document.encoding)
+        end
       end
-    end
 
-    class WriteTest < self
-      def test_utf_16
-        xml = <<-EOX.encode("UTF-16LE").force_encoding("ASCII-8BIT")
+      class WriteTest < self
+        def test_utf_16
+          xml = <<-EOX.encode("UTF-16LE").force_encoding("ASCII-8BIT")
 <?xml version="1.0"?>
 <message>Hello world!</message>
 EOX
-        bom = "\ufeff".encode("UTF-16LE").force_encoding("ASCII-8BIT")
-        document = REXML::Document.new(bom + xml)
+          bom = "\ufeff".encode("UTF-16LE").force_encoding("ASCII-8BIT")
+          document = REXML::Document.new(bom + xml)
 
-        actual_xml = ""
-        document.write(actual_xml)
-        expected_xml = <<-EOX.encode("UTF-16BE")
+          actual_xml = ""
+          document.write(actual_xml)
+          expected_xml = <<-EOX.encode("UTF-16BE")
 \ufeff<?xml version='1.0' encoding='UTF-16'?>
 <message>Hello world!</message>
 EOX
-        assert_equal(expected_xml, actual_xml)
+          assert_equal(expected_xml, actual_xml)
+        end
       end
     end
   end
diff --git a/test/rexml/test_element.rb b/test/rexml/test_element.rb
new file mode 100644
index 0000000..82830b4
--- /dev/null
+++ b/test/rexml/test_element.rb
@@ -0,0 +1,18 @@
+# frozen_string_literal: false
+
+require "test/unit/testcase"
+require "rexml/document"
+
+module REXMLTests
+  class ElementTester < Test::Unit::TestCase
+    def test_array_reference_string
+      doc = REXML::Document.new("<language name='Ruby'/>")
+      assert_equal("Ruby", doc.root["name"])
+    end
+
+    def test_array_reference_symbol
+      doc = REXML::Document.new("<language name='Ruby'/>")
+      assert_equal("Ruby", doc.root[:name])
+    end
+  end
+end
diff --git a/test/rexml/test_elements.rb b/test/rexml/test_elements.rb
index e5e209e..a850e62 100644
--- a/test/rexml/test_elements.rb
+++ b/test/rexml/test_elements.rb
@@ -1,116 +1,119 @@
+# frozen_string_literal: false
 require 'test/unit/testcase'
 require 'rexml/document'
 
-class ElementsTester < Test::Unit::TestCase
-  include REXML
-  def test_accessor
-    doc = Document.new '<a><b/><c id="1"/><c id="2"/><d/></a>'
-    assert_equal 'b', doc.root.elements[1].name
-    assert_equal '1', doc.root.elements['c'].attributes['id']
-    assert_equal '2', doc.root.elements[2,'c'].attributes['id']
-  end
+module REXMLTests
+  class ElementsTester < Test::Unit::TestCase
+    include REXML
+    def test_accessor
+      doc = Document.new '<a><b/><c id="1"/><c id="2"/><d/></a>'
+      assert_equal 'b', doc.root.elements[1].name
+      assert_equal '1', doc.root.elements['c'].attributes['id']
+      assert_equal '2', doc.root.elements[2,'c'].attributes['id']
+    end
 
-  def test_indexing
-    doc = Document.new '<a/>'
-    doc.root.elements[10] = Element.new('b')
-    assert_equal 'b', doc.root.elements[1].name
-    doc.root.elements[1] = Element.new('c')
-    assert_equal 'c', doc.root.elements[1].name
-    doc.root.elements['c'] = Element.new('d')
-    assert_equal 'd', doc.root.elements[1].name
-  end
+    def test_indexing
+      doc = Document.new '<a/>'
+      doc.root.elements[10] = Element.new('b')
+      assert_equal 'b', doc.root.elements[1].name
+      doc.root.elements[1] = Element.new('c')
+      assert_equal 'c', doc.root.elements[1].name
+      doc.root.elements['c'] = Element.new('d')
+      assert_equal 'd', doc.root.elements[1].name
+    end
 
-  def test_delete
-    doc = Document.new '<a><b/><c/><c id="1"/></a>'
-    block = proc { |str|
-      out = ''
-      doc.write out
-      assert_equal str, out
-    }
-    b = doc.root.elements[1]
-    doc.root.elements.delete b
-    block.call( "<a><c/><c id='1'/></a>" )
-    doc.elements.delete("a/c[@id='1']")
-    block.call( '<a><c/></a>' )
-    doc.root.elements.delete 1
-    block.call( '<a/>' )
-  end
+    def test_delete
+      doc = Document.new '<a><b/><c/><c id="1"/></a>'
+      block = proc { |str|
+        out = ''
+        doc.write out
+        assert_equal str, out
+      }
+      b = doc.root.elements[1]
+      doc.root.elements.delete b
+      block.call( "<a><c/><c id='1'/></a>" )
+      doc.elements.delete("a/c[@id='1']")
+      block.call( '<a><c/></a>' )
+      doc.root.elements.delete 1
+      block.call( '<a/>' )
+    end
 
-  def test_delete_all
-    doc = Document.new '<a><c/><c/><c/><c/></a>'
-    deleted = doc.elements.delete_all 'a/c'
-    assert_equal 4, deleted.size
-  end
+    def test_delete_all
+      doc = Document.new '<a><c/><c/><c/><c/></a>'
+      deleted = doc.elements.delete_all 'a/c'
+      assert_equal 4, deleted.size
+    end
 
-  def test_ticket_36
-    doc = Document.new( "<a xmlns:xi='foo'><b><xi:c id='1'/></b><xi:c id='2'/></a>" )
+    def test_ticket_36
+      doc = Document.new( "<a xmlns:xi='foo'><b><xi:c id='1'/></b><xi:c id='2'/></a>" )
 
-    deleted = doc.root.elements.delete_all( "xi:c" )
-    assert_equal( 1, deleted.size )
+      deleted = doc.root.elements.delete_all( "xi:c" )
+      assert_equal( 1, deleted.size )
 
-    doc = Document.new( "<a xmlns:xi='foo'><b><xi:c id='1'/></b><xi:c id='2'/></a>" )
-    deleted = doc.root.elements.delete_all( "//xi:c" )
-    assert_equal( 2, deleted.size )
-  end
+      doc = Document.new( "<a xmlns:xi='foo'><b><xi:c id='1'/></b><xi:c id='2'/></a>" )
+      deleted = doc.root.elements.delete_all( "//xi:c" )
+      assert_equal( 2, deleted.size )
+    end
 
-  def test_add
-    a = Element.new 'a'
-    a.elements.add Element.new('b')
-    assert_equal 'b', a.elements[1].name
-    a.elements.add 'c'
-    assert_equal 'c', a.elements[2].name
-  end
+    def test_add
+      a = Element.new 'a'
+      a.elements.add Element.new('b')
+      assert_equal 'b', a.elements[1].name
+      a.elements.add 'c'
+      assert_equal 'c', a.elements[2].name
+    end
 
-  def test_size
-    doc = Document.new '<a>sean<b/>elliott<b/>russell<b/></a>'
-    assert_equal 6, doc.root.size
-    assert_equal 3, doc.root.elements.size
-  end
+    def test_size
+      doc = Document.new '<a>sean<b/>elliott<b/>russell<b/></a>'
+      assert_equal 6, doc.root.size
+      assert_equal 3, doc.root.elements.size
+    end
 
-  def test_each
-    doc = Document.new '<a><b/><c/><d/>sean<b/><c/><d/></a>'
-    count = 0
-    block = proc {|e| count += 1}
-    doc.root.elements.each(&block)
-    assert_equal 6, count
-    count = 0
-    doc.root.elements.each('b', &block)
-    assert_equal 2, count
-    count = 0
-    doc.root.elements.each('child::node()', &block)
-    assert_equal 6, count
-    count = 0
-    XPath.each(doc.root, 'child::node()', &block)
-    assert_equal 7, count
-  end
+    def test_each
+      doc = Document.new '<a><b/><c/><d/>sean<b/><c/><d/></a>'
+      count = 0
+      block = proc {|e| count += 1}
+      doc.root.elements.each(&block)
+      assert_equal 6, count
+      count = 0
+      doc.root.elements.each('b', &block)
+      assert_equal 2, count
+      count = 0
+      doc.root.elements.each('child::node()', &block)
+      assert_equal 6, count
+      count = 0
+      XPath.each(doc.root, 'child::node()', &block)
+      assert_equal 7, count
+    end
 
-  def test_each_with_frozen_condition
-    doc = Document.new('<books><book name="Ruby"/><book name="XML"/></books>')
-    names = []
-    doc.root.elements.each('book'.freeze) do |element|
-      names << element.attributes["name"]
+    def test_each_with_frozen_condition
+      doc = Document.new('<books><book name="Ruby"/><book name="XML"/></books>')
+      names = []
+      doc.root.elements.each('book'.freeze) do |element|
+        names << element.attributes["name"]
+      end
+      assert_equal(["Ruby", "XML"], names)
     end
-    assert_equal(["Ruby", "XML"], names)
-  end
 
-  def test_to_a
-    doc = Document.new '<a>sean<b/>elliott<c/></a>'
-    assert_equal 2, doc.root.elements.to_a.size
-    assert_equal 2, doc.root.elements.to_a("child::node()").size
-    assert_equal 4, XPath.match(doc.root, "child::node()").size
-  end
+    def test_to_a
+      doc = Document.new '<a>sean<b/>elliott<c/></a>'
+      assert_equal 2, doc.root.elements.to_a.size
+      assert_equal 2, doc.root.elements.to_a("child::node()").size
+      assert_equal 4, XPath.match(doc.root, "child::node()").size
+    end
 
-  def test_collect
-    doc = Document.new( "<a><b id='1'/><b id='2'/></a>" )
-    r = doc.elements.collect( "/a/b" ) { |e| e.attributes["id"].to_i }
-    assert_equal( [1,2], r )
-  end
+    def test_collect
+      doc = Document.new( "<a><b id='1'/><b id='2'/></a>" )
+      r = doc.elements.collect( "/a/b" ) { |e| e.attributes["id"].to_i }
+      assert_equal( [1,2], r )
+    end
 
-  def test_inject
-    doc = Document.new( "<a><b id='1'/><b id='2'/></a>" )
-    r = doc.elements.inject( "/a/b", 3 ) { |s, e|
-      s + e.attributes["id"].to_i
-    }
-    assert_equal 6, r
+    def test_inject
+      doc = Document.new( "<a><b id='1'/><b id='2'/></a>" )
+      r = doc.elements.inject( "/a/b", 3 ) { |s, e|
+        s + e.attributes["id"].to_i
+      }
+      assert_equal 6, r
+    end
   end
 end
diff --git a/test/rexml/test_encoding.rb b/test/rexml/test_encoding.rb
index a3fda1e..919db13 100644
--- a/test/rexml/test_encoding.rb
+++ b/test/rexml/test_encoding.rb
@@ -1,94 +1,108 @@
 # coding: binary
+# frozen_string_literal: false
 
 require_relative "rexml_test_utils"
 
 require 'rexml/source'
 require 'rexml/document'
 
-class EncodingTester < Test::Unit::TestCase
-  include REXMLTestUtils
-  include REXML
+module REXMLTests
+  class EncodingTester < Test::Unit::TestCase
+    include REXMLTestUtils
+    include REXML
 
-  def setup
-    @encoded_root = "<a><b>\346</b></a>"
-    @encoded = "<?xml version='1.0' encoding='ISO-8859-3'?>"+
-      @encoded_root
-    @not_encoded = "<a><b></b></a>"
-  end
+    def setup
+      @encoded_root = "<a><b>\346</b></a>"
+      @encoded = "<?xml version='1.0' encoding='ISO-8859-3'?>"+
+        @encoded_root
+      @not_encoded = "<a><b></b></a>"
+    end
 
-  # Given an encoded document, try to write out to that encoding
-  def test_encoded_in_encoded_out
-    doc = Document.new( @encoded )
-    doc.write( out="" )
-    out.force_encoding(::Encoding::ASCII_8BIT)
-    assert_equal( @encoded, out )
-  end
+    # Given an encoded document, try to write out to that encoding
+    def test_encoded_in_encoded_out
+      doc = Document.new( @encoded )
+      doc.write( out="" )
+      out.force_encoding(::Encoding::ASCII_8BIT)
+      assert_equal( @encoded, out )
+    end
 
-  # Given an encoded document, try to change the encoding and write it out
-  def test_encoded_in_change_out
-    doc = Document.new( @encoded )
-    doc.xml_decl.encoding = "UTF-8"
-    assert_equal("UTF-8", doc.encoding)
-    REXML::Formatters::Default.new.write( doc.root, out="" )
-    out.force_encoding(::Encoding::ASCII_8BIT)
-    assert_equal( @not_encoded, out )
-    char = XPath.first( doc, "/a/b/text()" ).to_s
-    char.force_encoding(::Encoding::ASCII_8BIT)
-    assert_equal( "", char )
-  end
+    # Given an encoded document, try to change the encoding and write it out
+    def test_encoded_in_change_out
+      doc = Document.new( @encoded )
+      doc.xml_decl.encoding = "UTF-8"
+      assert_equal("UTF-8", doc.encoding)
+      REXML::Formatters::Default.new.write( doc.root, out="" )
+      out.force_encoding(::Encoding::ASCII_8BIT)
+      assert_equal( @not_encoded, out )
+      char = XPath.first( doc, "/a/b/text()" ).to_s
+      char.force_encoding(::Encoding::ASCII_8BIT)
+      assert_equal( "", char )
+    end
 
-  # * Given an encoded document, try to write it to a different encoding
-  def test_encoded_in_different_out
-    doc = Document.new( @encoded )
-    REXML::Formatters::Default.new.write( doc.root, Output.new( out="", "UTF-8" ) )
-    out.force_encoding(::Encoding::ASCII_8BIT)
-    assert_equal( @not_encoded, out )
-  end
+    # * Given an encoded document, try to write it to a different encoding
+    def test_encoded_in_different_out
+      doc = Document.new( @encoded )
+      REXML::Formatters::Default.new.write( doc.root, Output.new( out="", "UTF-8" ) )
+      out.force_encoding(::Encoding::ASCII_8BIT)
+      assert_equal( @not_encoded, out )
+    end
 
-  # * Given a non-encoded document, change the encoding
-  def test_in_change_out
-    doc = Document.new( @not_encoded )
-    doc.xml_decl.encoding = "ISO-8859-3"
-    assert_equal("ISO-8859-3", doc.encoding)
-    doc.write( out="" )
-    out.force_encoding(::Encoding::ASCII_8BIT)
-    assert_equal( @encoded, out )
-  end
+    # * Given a non-encoded document, change the encoding
+    def test_in_change_out
+      doc = Document.new( @not_encoded )
+      doc.xml_decl.encoding = "ISO-8859-3"
+      assert_equal("ISO-8859-3", doc.encoding)
+      doc.write( out="" )
+      out.force_encoding(::Encoding::ASCII_8BIT)
+      assert_equal( @encoded, out )
+    end
 
-  # * Given a non-encoded document, write to a different encoding
-  def test_in_different_out
-    doc = Document.new( @not_encoded )
-    doc.write( Output.new( out="", "ISO-8859-3" ) )
-    out.force_encoding(::Encoding::ASCII_8BIT)
-    assert_equal( "<?xml version='1.0'?>#{@encoded_root}", out )
-  end
+    # * Given a non-encoded document, write to a different encoding
+    def test_in_different_out
+      doc = Document.new( @not_encoded )
+      doc.write( Output.new( out="", "ISO-8859-3" ) )
+      out.force_encoding(::Encoding::ASCII_8BIT)
+      assert_equal( "<?xml version='1.0'?>#{@encoded_root}", out )
+    end
 
-  # * Given an encoded document, accessing text and attribute nodes
-  #   should provide UTF-8 text.
-  def test_in_different_access
-    doc = Document.new <<-EOL
-    <?xml version='1.0' encoding='ISO-8859-1'?>
-    <a a="\xFF">\xFF</a>
-    EOL
-    expect = "\303\277"
-    expect.force_encoding(::Encoding::UTF_8)
-    assert_equal( expect, doc.elements['a'].attributes['a'] )
-    assert_equal( expect, doc.elements['a'].text )
-  end
+    # * Given an encoded document, accessing text and attribute nodes
+    #   should provide UTF-8 text.
+    def test_in_different_access
+      doc = Document.new <<-EOL
+      <?xml version='1.0' encoding='ISO-8859-1'?>
+      <a a="\xFF">\xFF</a>
+      EOL
+      expect = "\303\277"
+      expect.force_encoding(::Encoding::UTF_8)
+      assert_equal( expect, doc.elements['a'].attributes['a'] )
+      assert_equal( expect, doc.elements['a'].text )
+    end
 
 
-  def test_ticket_89
-    doc = Document.new <<-EOL
-       <?xml version="1.0" encoding="CP-1252" ?>
-       <xml><foo></foo></xml>
-       EOL
+    def test_ticket_89
+      doc = Document.new <<-EOL
+         <?xml version="1.0" encoding="CP-1252" ?>
+         <xml><foo></foo></xml>
+         EOL
 
-    REXML::Document.new doc
-  end
+      REXML::Document.new doc
+    end
+
+    def test_parse_utf16
+      utf16 = File.open(fixture_path("utf16.xml")) do |f|
+        REXML::Document.new(f)
+      end
+      assert_equal("UTF-16", utf16.encoding)
+      assert( utf16[0].kind_of?(REXML::XMLDecl))
+    end
 
-  def test_ticket_110
-    utf16 = REXML::Document.new(File.new(fixture_path("ticket_110_utf16.xml")))
-    assert_equal(utf16.encoding, "UTF-16")
-    assert( utf16[0].kind_of?(REXML::XMLDecl))
+    def test_parse_utf16_with_utf8_default_internal
+      EnvUtil.with_default_internal("UTF-8") do
+        utf16 = File.open(fixture_path("utf16.xml")) do |f|
+          REXML::Document.new(f)
+        end
+        assert_equal("UTF-16", utf16.encoding)
+      end
+    end
   end
 end
diff --git a/test/rexml/test_encoding_2.rb b/test/rexml/test_encoding_2.rb
deleted file mode 100644
index 6a985f3..0000000
--- a/test/rexml/test_encoding_2.rb
+++ /dev/null
@@ -1,59 +0,0 @@
-require "test/unit/testcase"
-
-require "rexml/document"
-require "rexml/parseexception"
-
-=begin
-# THIS DOESN'T WORK
-begin
-  require 'iconv'
-
-  UnixCharsets = open("| iconv -l") do |f|
-     f.readlines[5..-1].collect { |x| x.sub(/\/\/\n/,"").delete(' ') }
-  end
-
-  DATA = <<END
-<?xml version="1.0" encoding='ENC'?>
-<Ruby xmlns="http://www.ruby-lang.org/ruby/1.8">
-</Ruby>
-END
-
-
-  class IConvTester < Test::Unit::TestCase
-
-    def test_iconv
-      broken_encodings = 0
-      UnixCharsets.each do |enc|
-        begin
-          puts "Testing encoding #{enc}"
-          data = DATA.dup
-          data[/ENC/] = enc
-          REXML::Document.new(data).root
-        rescue REXML::ParseException => e
-          broken_encodings += 1
-          fail "Encoding #{enc} does not work with REXML: #{e.message}"
-        rescue Errno::EINVAL => e
-          broken_encodings += 1
-          fail "Encoding #{enc} does not work with REXML: #{e.message}"
-        rescue ArgumentError => e
-          broken_encodings += 1
-          fail "Encoding #{enc} does not work with REXML: #{e.message}"
-        rescue
-          broken_encodings += 1
-          fail "Encoding #{enc} does not work with REXML: #{$!.message}"
-        end
-      end
-
-      if broken_encodings > 0
-        fail "There were #{broken_encodings} encoding failures out of #{UnixCharsets.size} plus some REXML internal encodings"
-      else
-        fail "There were no encoding failures"
-      end
-
-      puts "Full list of registered encodings in REXML:"
-      puts REXML::Encoding::ENCODING_CLAIMS.values.join(', ')
-    end
-  end
-rescue LoadError
-end
-=end
diff --git a/test/rexml/test_entity.rb b/test/rexml/test_entity.rb
index ddb6f45..6dc6637 100644
--- a/test/rexml/test_entity.rb
+++ b/test/rexml/test_entity.rb
@@ -1,203 +1,206 @@
+# frozen_string_literal: false
 require "test/unit/testcase"
 
 require 'rexml/document'
 require 'rexml/entity'
 require 'rexml/source'
 
-class EntityTester < Test::Unit::TestCase
-  def test_parse_general_decl
-    simple = "<!ENTITY foo 'bar'>"
-    simple =~ /#{REXML::Entity::GEDECL}/
-    assert $&
-    assert_equal simple, $&
-
-    REXML::Entity::ENTITYDECL =~ simple
-    assert REXML::Entity::matches?(simple)
-    match = REXML::Entity::ENTITYDECL.match(simple)
-    assert_equal 'foo', match[1]
-    assert_equal "'bar'", match[2]
-
-    simple = '<!ENTITY Pub-Status
-    "This is a pre-release of the specification.">'
-    assert REXML::Entity::matches?(simple)
-    match = REXML::Entity::ENTITYDECL.match(simple)
-    assert_equal 'Pub-Status', match[1]
-    assert_equal '"This is a pre-release of the specification."', match[2]
-
-    txt = '"This is a
-    pre-release of <the> specification."'
-    simple = "<!ENTITY     Pub-Status
-    #{txt}>"
-    assert REXML::Entity::matches?(simple)
-    match = REXML::Entity::ENTITYDECL.match(simple)
-    assert_equal 'Pub-Status', match[1]
-    assert_equal txt, match[2]
-  end
+module REXMLTests
+  class EntityTester < Test::Unit::TestCase
+    def test_parse_general_decl
+      simple = "<!ENTITY foo 'bar'>"
+      simple =~ /#{REXML::Entity::GEDECL}/
+      assert $&
+      assert_equal simple, $&
+
+      REXML::Entity::ENTITYDECL =~ simple
+      assert REXML::Entity::matches?(simple)
+      match = REXML::Entity::ENTITYDECL.match(simple)
+      assert_equal 'foo', match[1]
+      assert_equal "'bar'", match[2]
+
+      simple = '<!ENTITY Pub-Status
+      "This is a pre-release of the specification.">'
+      assert REXML::Entity::matches?(simple)
+      match = REXML::Entity::ENTITYDECL.match(simple)
+      assert_equal 'Pub-Status', match[1]
+      assert_equal '"This is a pre-release of the specification."', match[2]
+
+      txt = '"This is a
+      pre-release of <the> specification."'
+      simple = "<!ENTITY     Pub-Status
+      #{txt}>"
+      assert REXML::Entity::matches?(simple)
+      match = REXML::Entity::ENTITYDECL.match(simple)
+      assert_equal 'Pub-Status', match[1]
+      assert_equal txt, match[2]
+    end
 
-  def test_parse_external_decl
-    zero = '<!ENTITY open-hatch SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml" >'
-    one = '<!ENTITY open-hatch
-              SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml">'
-    two = '<!ENTITY open-hatch
-              PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
-              "http://www.textuality.com/boilerplate/OpenHatch.xml">'
-    three = '<!ENTITY hatch-pic
-              SYSTEM "../grafix/OpenHatch.gif"
-              NDATA gif >'
-    assert REXML::Entity::matches?(zero)
-    assert REXML::Entity::matches?(one)
-    assert REXML::Entity::matches?(two)
-    assert REXML::Entity::matches?(three)
-  end
+    def test_parse_external_decl
+      zero = '<!ENTITY open-hatch SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml" >'
+      one = '<!ENTITY open-hatch
+                SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml">'
+      two = '<!ENTITY open-hatch
+                PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
+                "http://www.textuality.com/boilerplate/OpenHatch.xml">'
+      three = '<!ENTITY hatch-pic
+                SYSTEM "../grafix/OpenHatch.gif"
+                NDATA gif >'
+      assert REXML::Entity::matches?(zero)
+      assert REXML::Entity::matches?(one)
+      assert REXML::Entity::matches?(two)
+      assert REXML::Entity::matches?(three)
+    end
 
-  def test_parse_entity
-    one = %q{<!ENTITY % YN '"Yes"'>}
-    two = %q{<!ENTITY WhatHeSaid "He said %YN;">}
-    assert REXML::Entity::matches?(one)
-    assert REXML::Entity::matches?(two)
-  end
+    def test_parse_entity
+      one = %q{<!ENTITY % YN '"Yes"'>}
+      two = %q{<!ENTITY WhatHeSaid "He said %YN;">}
+      assert REXML::Entity::matches?(one)
+      assert REXML::Entity::matches?(two)
+    end
 
-  def test_constructor
-    one = [ %q{<!ENTITY % YN '"Yes"'>},
-      %q{<!ENTITY % YN2 "Yes">},
-      %q{<!ENTITY WhatHeSaid "He said %YN;">},
-      '<!ENTITY open-hatch
-              SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml">',
-      '<!ENTITY open-hatch2
-              PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
-              "http://www.textuality.com/boilerplate/OpenHatch.xml">',
-      '<!ENTITY hatch-pic
-              SYSTEM "../grafix/OpenHatch.gif"
-              NDATA gif>' ]
-    source = %q{<!DOCTYPE foo [
-      <!ENTITY % YN '"Yes"'>
-      <!ENTITY % YN2 "Yes">
-      <!ENTITY WhatHeSaid "He said %YN;">
-      <!ENTITY open-hatch
-              SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml">
-      <!ENTITY open-hatch2
-              PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
-              "http://www.textuality.com/boilerplate/OpenHatch.xml">
-      <!ENTITY hatch-pic
-              SYSTEM "../grafix/OpenHatch.gif"
-              NDATA gif>
-    ]>}
-
-    d = REXML::Document.new( source )
-    dt = d.doctype
-    c = 0
-    dt.each do |child|
-      if child.kind_of? REXML::Entity
-        str = one[c].tr("\r\n\t", '   ').squeeze(" ")
-        assert_equal str, child.to_s
-        c+=1
+    def test_constructor
+      one = [ %q{<!ENTITY % YN '"Yes"'>},
+        %q{<!ENTITY % YN2 "Yes">},
+        %q{<!ENTITY WhatHeSaid "He said %YN;">},
+        '<!ENTITY open-hatch
+                SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml">',
+        '<!ENTITY open-hatch2
+                PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
+                "http://www.textuality.com/boilerplate/OpenHatch.xml">',
+        '<!ENTITY hatch-pic
+                SYSTEM "../grafix/OpenHatch.gif"
+                NDATA gif>' ]
+      source = %q{<!DOCTYPE foo [
+        <!ENTITY % YN '"Yes"'>
+        <!ENTITY % YN2 "Yes">
+        <!ENTITY WhatHeSaid "He said %YN;">
+        <!ENTITY open-hatch
+                SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml">
+        <!ENTITY open-hatch2
+                PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
+                "http://www.textuality.com/boilerplate/OpenHatch.xml">
+        <!ENTITY hatch-pic
+                SYSTEM "../grafix/OpenHatch.gif"
+                NDATA gif>
+      ]>}
+
+      d = REXML::Document.new( source )
+      dt = d.doctype
+      c = 0
+      dt.each do |child|
+        if child.kind_of? REXML::Entity
+          str = one[c].tr("\r\n\t", '   ').squeeze(" ")
+          assert_equal str, child.to_s
+          c+=1
+        end
       end
     end
-  end
-
-  def test_replace_entities
-    source = "<!DOCTYPE blah [\n<!ENTITY foo \"bar\">\n]><a>&foo;</a>"
-    doc = REXML::Document.new(source)
-    assert_equal 'bar', doc.root.text
-    out = ''
-    doc.write out
-    assert_equal source, out
-  end
 
-  def test_entity_string_limit
-    template = '<!DOCTYPE bomb [ <!ENTITY a "^" > ]> <bomb>$</bomb>'
-    len      = 5120 # 5k per entity
-    template.sub!(/\^/, "B" * len)
-
-    # 10k is OK
-    entities = '&a;' * 2 # 5k entity * 2 = 10k
-    xmldoc = REXML::Document.new(template.sub(/\$/, entities))
-    assert_equal(len * 2, xmldoc.root.text.bytesize)
-
-    # above 10k explodes
-    entities = '&a;' * 3 # 5k entity * 2 = 15k
-    xmldoc = REXML::Document.new(template.sub(/\$/, entities))
-    assert_raises(RuntimeError) do
-      xmldoc.root.text
+    def test_replace_entities
+      source = "<!DOCTYPE blah [\n<!ENTITY foo \"bar\">\n]><a>&foo;</a>"
+      doc = REXML::Document.new(source)
+      assert_equal 'bar', doc.root.text
+      out = ''
+      doc.write out
+      assert_equal source, out
     end
-  end
 
-  def test_entity_string_limit_for_parameter_entity
-    template = '<!DOCTYPE bomb [ <!ENTITY % a "^" > <!ENTITY bomb "$" > ]><root/>'
-    len      = 5120 # 5k per entity
-    template.sub!(/\^/, "B" * len)
+    def test_entity_string_limit
+      template = '<!DOCTYPE bomb [ <!ENTITY a "^" > ]> <bomb>$</bomb>'
+      len      = 5120 # 5k per entity
+      template.sub!(/\^/, "B" * len)
+
+      # 10k is OK
+      entities = '&a;' * 2 # 5k entity * 2 = 10k
+      xmldoc = REXML::Document.new(template.sub(/\$/, entities))
+      assert_equal(len * 2, xmldoc.root.text.bytesize)
+
+      # above 10k explodes
+      entities = '&a;' * 3 # 5k entity * 2 = 15k
+      xmldoc = REXML::Document.new(template.sub(/\$/, entities))
+      assert_raise(RuntimeError) do
+        xmldoc.root.text
+      end
+    end
 
-    # 10k is OK
-    entities = '%a;' * 2 # 5k entity * 2 = 10k
-    REXML::Document.new(template.sub(/\$/, entities))
+    def test_entity_string_limit_for_parameter_entity
+      template = '<!DOCTYPE bomb [ <!ENTITY % a "^" > <!ENTITY bomb "$" > ]><root/>'
+      len      = 5120 # 5k per entity
+      template.sub!(/\^/, "B" * len)
 
-    # above 10k explodes
-    entities = '%a;' * 3 # 5k entity * 2 = 15k
-    assert_raises(REXML::ParseException) do
+      # 10k is OK
+      entities = '%a;' * 2 # 5k entity * 2 = 10k
       REXML::Document.new(template.sub(/\$/, entities))
+
+      # above 10k explodes
+      entities = '%a;' * 3 # 5k entity * 2 = 15k
+      assert_raise(REXML::ParseException) do
+        REXML::Document.new(template.sub(/\$/, entities))
+      end
     end
-  end
 
-  def test_raw
-    source = '<!DOCTYPE foo [
+    def test_raw
+      source = '<!DOCTYPE foo [
 <!ENTITY ent "replace">
 ]><a>replace &ent;</a>'
-    doc = REXML::Document.new( source, {:raw=>:all})
-    assert_equal('replace &ent;', doc.root.get_text.to_s)
-    assert_equal(source, doc.to_s)
-  end
+      doc = REXML::Document.new( source, {:raw=>:all})
+      assert_equal('replace &ent;', doc.root.get_text.to_s)
+      assert_equal(source, doc.to_s)
+    end
 
-  def test_lazy_evaluation
-    source = '<!DOCTYPE foo [
+    def test_lazy_evaluation
+      source = '<!DOCTYPE foo [
 <!ENTITY ent "replace">
 ]><a>replace &ent;</a>'
-    doc = REXML::Document.new( source )
-    assert_equal(source, doc.to_s)
-    assert_equal("replace replace", doc.root.text)
-    assert_equal(source, doc.to_s)
-  end
+      doc = REXML::Document.new( source )
+      assert_equal(source, doc.to_s)
+      assert_equal("replace replace", doc.root.text)
+      assert_equal(source, doc.to_s)
+    end
 
-  # Contributed (not only test, but bug fix!!) by Kouhei Sutou
-  def test_entity_replacement
-    source = %q{<!DOCTYPE foo [
-    <!ENTITY % YN '"Yes"'>
-    <!ENTITY WhatHeSaid "He said %YN;">]>
-    <a>&WhatHeSaid;</a>}
-
-    d = REXML::Document.new( source )
-    dt = d.doctype
-    assert_equal( '"Yes"', dt.entities[ "YN" ].value )
-    assert_equal( 'He said "Yes"', dt.entities[ "WhatHeSaid" ].value )
-    assert_equal( 'He said "Yes"', d.elements[1].text )
-  end
+    # Contributed (not only test, but bug fix!!) by Kouhei Sutou
+    def test_entity_replacement
+      source = %q{<!DOCTYPE foo [
+      <!ENTITY % YN '"Yes"'>
+      <!ENTITY WhatHeSaid "He said %YN;">]>
+      <a>&WhatHeSaid;</a>}
+
+      d = REXML::Document.new( source )
+      dt = d.doctype
+      assert_equal( '"Yes"', dt.entities[ "YN" ].value )
+      assert_equal( 'He said "Yes"', dt.entities[ "WhatHeSaid" ].value )
+      assert_equal( 'He said "Yes"', d.elements[1].text )
+    end
 
-  # More unit tests from Kouhei.  I looove users who give me unit tests.
-  def test_entity_insertions
-    assert_equal("&amp;", REXML::Text.new("&amp;", false, nil, true).to_s)
-    #assert_equal("&", REXML::Text.new("&amp;", false, false).to_s)
-  end
+    # More unit tests from Kouhei.  I looove users who give me unit tests.
+    def test_entity_insertions
+      assert_equal("&amp;", REXML::Text.new("&amp;", false, nil, true).to_s)
+      #assert_equal("&", REXML::Text.new("&amp;", false, false).to_s)
+    end
 
-  def test_single_pass_unnormalization # ticket 123
-    assert_equal '&amp;&', REXML::Text::unnormalize('&#38;amp;&amp;')
-  end
+    def test_single_pass_unnormalization # ticket 123
+      assert_equal '&amp;&', REXML::Text::unnormalize('&#38;amp;&amp;')
+    end
 
-  def test_entity_filter
-    document = REXML::Document.new(<<-XML)
+    def test_entity_filter
+      document = REXML::Document.new(<<-XML)
 <!DOCTYPE root [
 <!ENTITY copy "(c)">
 <!ENTITY release-year "2013">
 ]>
 <root/>
 XML
-    respect_whitespace = false
-    parent = document.root
-    raw = false
-    entity_filter = ["copy"]
-    assert_equal("(c) &release-year;",
-                 REXML::Text.new("(c) 2013",
-                                 respect_whitespace,
-                                 parent,
-                                 raw,
-                                 entity_filter).to_s)
+      respect_whitespace = false
+      parent = document.root
+      raw = false
+      entity_filter = ["copy"]
+      assert_equal("(c) &release-year;",
+                   REXML::Text.new("(c) 2013",
+                                   respect_whitespace,
+                                   parent,
+                                   raw,
+                                   entity_filter).to_s)
+    end
   end
 end
diff --git a/test/rexml/test_functions.rb b/test/rexml/test_functions.rb
deleted file mode 100644
index 082d772..0000000
--- a/test/rexml/test_functions.rb
+++ /dev/null
@@ -1,223 +0,0 @@
-require "test/unit/testcase"
-
-require "rexml/document"
-
-class FunctionsTester < Test::Unit::TestCase
-  include REXML
-  def test_functions
-    # trivial text() test
-    # confuse-a-function
-    source = "<a>more <b id='1'/><b id='2'>dumb</b><b id='3'/><c/> text</a>"
-    doc = Document.new source
-    res = ""
-    XPath::each(doc.root, "text()") {|val| res << val.to_s}
-    assert_equal "more  text", res
-
-    res = XPath::first(doc.root, "b[last()]")
-    assert_equal '3', res.attributes['id']
-    res = XPath::first(doc.root, "b[position()=2]")
-    assert_equal '2', res.attributes['id']
-    res = XPath::first(doc.root, "*[name()='c']")
-    assert_equal "c", res.name
-  end
-
-  # Contributed by Mike Stok
-  def test_starts_with
-    source = <<-EOF
-      <foo>
-      <a href="mailto:a@b.c">a@b.c</a>
-      <a href="http://www.foo.com">http://www.foo.com</a>
-      </foo>
-    EOF
-    doc = Document.new source
-    mailtos = doc.elements.to_a("//a[starts-with(@href, 'mailto:')]")
-    assert_equal 1, mailtos.size
-    assert_equal "mailto:a@b.c", mailtos[0].attributes['href']
-
-    ailtos = doc.elements.to_a("//a[starts-with(@href, 'ailto:')]")
-    assert_equal 0, ailtos.size
-  end
-
-  def test_string_length
-    doc = Document.new <<-EOF
-      <AAA>
-      <Q/>
-      <SSSS/>
-      <BB/>
-      <CCC/>
-      <DDDDDDDD/>
-      <EEEE/>
-      </AAA>
-    EOF
-    assert doc, "create doc"
-
-    set = doc.elements.to_a("//*[string-length(name()) = 3]")
-    assert_equal 2, set.size, "nodes with names length = 3"
-
-    set = doc.elements.to_a("//*[string-length(name()) < 3]")
-    assert_equal 2, set.size, "nodes with names length < 3"
-
-    set = doc.elements.to_a("//*[string-length(name()) > 3]")
-    assert_equal 3, set.size, "nodes with names length > 3"
-  end
-
-  # Test provided by Mike Stok
-  def test_contains
-    source = <<-EOF
-      <foo>
-      <a href="mailto:a@b.c">a@b.c</a>
-      <a href="http://www.foo.com">http://www.foo.com</a>
-      </foo>
-    EOF
-    doc = Document.new source
-
-    [['o', 2], ['foo', 1], ['bar', 0]].each { |test|
-      search, expected = test
-      set = doc.elements.to_a("//a[contains(@href, '#{search}')]")
-      assert_equal expected, set.size
-    }
-  end
-
-  # Mike Stok and Sean Russell
-  def test_substring
-    # examples from http://www.w3.org/TR/xpath#function-substring
-    doc = Document.new('<test string="12345" />')
-
-    d = Document.new("<a b='1'/>")
-    #puts XPath.first(d, 'node()[0 + 1]')
-    #d = Document.new("<a b='1'/>")
-    #puts XPath.first(d, 'a[0 mod 0]')
-    [ [1.5, 2.6, '234'],
-      [0, 3, '12'],
-      [0, '0 div 0', ''],
-      [1, '0 div 0', ''],
-      ['-42', '1 div 0', '12345'],
-                        ['-1 div 0', '1 div 0', '']
-    ].each { |start, length, expected|
-      set = doc.elements.to_a("//test[substring(@string, #{start}, #{length}) = '#{expected}']")
-      assert_equal 1, set.size, "#{start}, #{length}, '#{expected}'"
-    }
-  end
-
-  def test_substring_angrez
-    testString = REXML::Functions::substring_after("helloworld","hello")
-    assert_equal( 'world', testString )
-  end
-
-  def test_translate
-    source = <<-EOF
-    <doc>
-    <case name='w3c one' result='BAr' />        <!-- w3c -->
-    <case name='w3c two' result='AAA' />        <!-- w3c -->
-    <case name='alchemy' result="gold" />   <!-- mike -->
-    <case name='vbxml one' result='A Space Odyssey' />
-    <case name='vbxml two' result='AbCdEf' />
-    </doc>
-    EOF
-
-    doc = Document.new(source)
-
-    [ ['bar', 'abc', 'ABC', 'w3c one'],
-      ['--aaa--','abc-','ABC', 'w3c two'],
-      ['lead', 'dear language', 'doll groover', 'alchemy'],
-      ['A Space Odissei', 'i', 'y', 'vbxml one'],
-      ['abcdefg', 'aceg', 'ACE', 'vbxml two'],
-    ].each { |arg1, arg2, arg3, name|
-      translate = "translate('#{arg1}', '#{arg2}', '#{arg3}')"
-      set = doc.elements.to_a("//case[@result = #{translate}]")
-      assert_equal 1, set.size, translate
-      assert_equal name, set[0].attributes['name']
-    }
-  end
-
-  def test_name
-    d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
-    assert_equal 1, d.root.elements.to_a('*[name() = "b"]').size
-    assert_equal 1, d.elements.to_a('//*[name() = "x:b"]').size
-  end
-
-  def test_local_name
-    d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
-    assert_equal 2, d.root.elements.to_a('*[local_name() = "b"]').size
-    assert_equal 2, d.elements.to_a('//*[local_name() = "b"]').size
-  end
-
-  def test_substring2
-    doc = Document.new('<test string="12345" />')
-    assert_equal(1,doc.elements.to_a("//test[substring(@string,2)='2345']").size)
-  end
-
-  # Submitted by Kouhei
-  def test_floor_ceiling_round
-    source = "<a><b id='1'/><b id='2'/><b id='3'/></a>"
-    doc = REXML::Document.new(source)
-
-    id_1 = doc.elements["/a/b[@id='1']"]
-    id_2 = doc.elements["/a/b[@id='2']"]
-    id_3 = doc.elements["/a/b[@id='3']"]
-
-    good = {
-      "floor" => [[], [id_1], [id_2], [id_3]],
-      "ceiling" => [[id_1], [id_2], [id_3], []],
-      "round" => [[id_1], [id_2], [id_3], []]
-    }
-    good.each do |key, value|
-      (0..3).each do |i|
-        xpath = "//b[number(@id) = #{key}(#{i+0.5})]"
-        assert_equal(value[i], REXML::XPath.match(doc, xpath))
-      end
-    end
-
-    good["round"] = [[], [id_1], [id_2], [id_3]]
-    good.each do |key, value|
-      (0..3).each do |i|
-        xpath = "//b[number(@id) = #{key}(#{i+0.4})]"
-        assert_equal(value[i], REXML::XPath.match(doc, xpath))
-      end
-    end
-  end
-
-  # Submitted by Kou
-  def test_lang
-    d = Document.new(<<-XML)
-    <a xml:lang="en">
-    <b xml:lang="ja">
-    <c xml:lang="fr"/>
-    <d/>
-    <e xml:lang="ja-JP"/>
-    <f xml:lang="en-US"/>
-    </b>
-    </a>
-    XML
-
-    assert_equal(1, d.elements.to_a("//*[lang('fr')]").size)
-    assert_equal(3, d.elements.to_a("//*[lang('ja')]").size)
-    assert_equal(2, d.elements.to_a("//*[lang('en')]").size)
-    assert_equal(1, d.elements.to_a("//*[lang('en-us')]").size)
-
-    d = Document.new(<<-XML)
-    <root>
-    <para xml:lang="en"/>
-    <div xml:lang="en"><para/></div>
-    <para xml:lang="EN"/>
-    <para xml:lang="en-us"/>
-    </root>
-    XML
-
-    assert_equal(5, d.elements.to_a("//*[lang('en')]").size)
-  end
-
-  def test_ticket_60
-    document = REXML::Document.new("<a><b>A</b><b>1</b></a>")
-    assert_equal( "A", REXML::XPath.first(document, '//b[.="A"]').text )
-    assert_equal( "1", REXML::XPath.first(document, '//b[.="1"]').text )
-  end
-
-  def test_normalize_space
-    source = "<a><!--COMMENT A--><b><!-- COMMENT A --></b></a>"
-    doc = REXML::Document.new(source)
-    predicate = "string(.)=normalize_space('\nCOMMENT    \n A \n\n ')"
-    m = REXML::XPath.match(doc, "//comment()[#{predicate}]")
-    assert_equal( [REXML::Comment.new("COMMENT A")], m )
-  end
-end
diff --git a/test/rexml/test_functions_number.rb b/test/rexml/test_functions_number.rb
deleted file mode 100644
index 3048c8d..0000000
--- a/test/rexml/test_functions_number.rb
+++ /dev/null
@@ -1,32 +0,0 @@
-require 'rexml/document'
-require 'test/unit'
-require 'rexml/functions'
-
-class TC_Rexml_Functions_Number < Test::Unit::TestCase
-
-  def test_functions_number_int
-    telem = REXML::Element.new("elem")
-    telem.text="9"
-    assert_equal(9, REXML::Functions::number(telem))
-  end
-  def test_functions_number_float
-    telem = REXML::Element.new("elem")
-    telem.text="10.4"
-    assert_equal(10.4, REXML::Functions::number(telem))
-  end
-  def test_functions_number_negative_int
-    telem = REXML::Element.new("elem")
-    telem.text="-9"
-    assert_equal(-9, REXML::Functions::number(telem))
-  end
-  def test_functions_number_negative_float
-    telem = REXML::Element.new("elem")
-    telem.text="-9.13"
-    assert_equal(-9.13, REXML::Functions::number(telem))
-  end
-  #def test_functions_number_scientific_notation
-  #  telem = REXML::Element.new("elem")
-  #  telem.text="9.13E12"
-  #  assert_equal(9.13E12, REXML::Functions::number(telem))
-  #end
-end
diff --git a/test/rexml/test_instruction.rb b/test/rexml/test_instruction.rb
new file mode 100644
index 0000000..96fa909
--- /dev/null
+++ b/test/rexml/test_instruction.rb
@@ -0,0 +1,14 @@
+require_relative "rexml_test_utils"
+
+module REXMLTests
+  class InstructionTest < Test::Unit::TestCase
+    def test_target_nil
+      error = assert_raise(ArgumentError) do
+        REXML::Instruction.new(nil)
+      end
+      assert_equal("processing instruction target must be String or " +
+                   "REXML::Instruction: <nil>",
+                   error.message)
+    end
+  end
+end
diff --git a/test/rexml/test_jaxen.rb b/test/rexml/test_jaxen.rb
index 05cb818..9640b82 100644
--- a/test/rexml/test_jaxen.rb
+++ b/test/rexml/test_jaxen.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 require_relative 'rexml_test_utils'
 
 require "rexml/document"
@@ -6,121 +7,125 @@ require "rexml/xpath"
 # Harness to test REXML's capabilities against the test suite from Jaxen
 # ryan.a.cox@gmail.com
 
-class JaxenTester < Test::Unit::TestCase
-  include REXMLTestUtils
-  include REXML
+module REXMLTests
+  class JaxenTester < Test::Unit::TestCase
+    include REXMLTestUtils
+    include REXML
 
-  def test_axis ; test("axis") ; end
-  def test_basic ; test("basic") ; end
-  def test_basicupdate ; test("basicupdate") ; end
-  def test_contents ; test("contents") ; end
-  def test_defaultNamespace ; test("defaultNamespace") ; end
-  def test_fibo ; test("fibo") ; end
-  def test_id ; test("id") ; end
-  def test_jaxen24 ; test("jaxen24") ; end
-  def test_lang ; test("lang") ; end
-  def test_message ; test("message") ; end
-  def test_moreover ; test("moreover") ; end
-  def test_much_ado ; test("much_ado") ; end
-  def test_namespaces ; test("namespaces") ; end
-  def test_nitf ; test("nitf") ; end
-  def test_numbers ; test("numbers") ; end
-  def test_pi ; test("pi") ; end
-  def test_pi2 ; test("pi2") ; end
-  def test_simple ; test("simple") ; end
-  def test_testNamespaces ; test("testNamespaces") ; end
-  def test_text ; test("text") ; end
-  def test_underscore ; test("underscore") ; end
-  def test_web ; test("web") ; end
-  def test_web2 ; test("web2") ; end
+    def test_axis ; process_test_case("axis") ; end
+    def test_basic ; process_test_case("basic") ; end
+    def test_basicupdate ; process_test_case("basicupdate") ; end
+    def test_contents ; process_test_case("contents") ; end
+    def test_defaultNamespace ; process_test_case("defaultNamespace") ; end
+    def test_fibo ; process_test_case("fibo") ; end
+    def test_id ; process_test_case("id") ; end
+    def test_jaxen24 ; process_test_case("jaxen24") ; end
+    def test_lang ; process_test_case("lang") ; end
+    # document() function for XSLT isn't supported
+    def _test_message ; process_test_case("message") ; end
+    def test_moreover ; process_test_case("moreover") ; end
+    def test_much_ado ; process_test_case("much_ado") ; end
+    def test_namespaces ; process_test_case("namespaces") ; end
+    def test_nitf ; process_test_case("nitf") ; end
+    # Exception should be considered
+    def _test_numbers ; process_test_case("numbers") ; end
+    def test_pi ; process_test_case("pi") ; end
+    def test_pi2 ; process_test_case("pi2") ; end
+    def test_simple ; process_test_case("simple") ; end
+    # TODO: namespace node is needed
+    def _test_testNamespaces ; process_test_case("testNamespaces") ; end
+    # document() function for XSLT isn't supported
+    def _test_text ; process_test_case("text") ; end
+    def test_underscore ; process_test_case("underscore") ; end
+    def _test_web ; process_test_case("web") ; end
+    def test_web2 ; process_test_case("web2") ; end
 
-  private
-  def test( fname )
-#    Dir.entries( xml_dir ).each { |fname|
-#      if fname =~ /\.xml$/
-        file = File.new(fixture_path(fname+".xml"))
-        doc = Document.new( file )
-        XPath.each( doc, "/tests/document" ) {|e| handleDocument(e)}
-#      end
-#    }
-  end
-
-  # processes a tests/document/context node
-  def handleContext( testDoc, ctxElement)
-    testCtx = XPath.match( testDoc, ctxElement.attributes["select"] )[0]
-    namespaces = {}
-    if testCtx.class == Element
-      testCtx.prefixes.each { |pre| handleNamespace( testCtx, pre, namespaces ) }
+    private
+    def process_test_case(name)
+      xml_path = "#{name}.xml"
+      doc = File.open(fixture_path(xml_path)) do |file|
+        Document.new(file)
+      end
+      test_doc = File.open(fixture_path("test/tests.xml")) do |file|
+        Document.new(file)
+      end
+      XPath.each(test_doc,
+                 "/tests/document[@url='xml/#{xml_path}']/context") do |context|
+        process_context(doc, context)
+      end
     end
-    variables = {}
-    XPath.each( ctxElement, "@*[namespace-uri() = 'http://jaxen.org/test-harness/var']") { |attrib| handleVariable(testCtx, variables, attrib) }
-    XPath.each( ctxElement, "valueOf") { |e| handleValueOf(testCtx, variables, namespaces, e) }
-    XPath.each( ctxElement, "test[not(@exception) or (@exception != 'true') ]") { |e| handleNominalTest(testCtx,variables, namespaces, e) }
-    XPath.each( ctxElement, "test[@exception = 'true']") { |e| handleExceptionalTest(testCtx,variables, namespaces, e) }
-  end
 
-  # processes a tests/document/context/valueOf or tests/document/context/test/valueOf node
-  def handleValueOf(ctx,variables, namespaces, valueOfElement)
-    expected = valueOfElement.text
-    got = XPath.match( ctx, valueOfElement.attributes["select"], namespaces, variables )[0]
-    assert_true( (got.nil? && expected.nil?) || !got.nil? )
-    case got.class
-    when Element
-      assert_equal( got.class, Element )
-    when Attribute, Text, Comment, TrueClass, FalseClass
-      assert_equal( expected, got.to_s )
-    when Instruction
-      assert_equal( expected, got.content )
-    when Fixnum
-      assert_equal( exected.to_f, got )
-    when String
-      # normalize values for comparison
-      got = "" if got == nil or got == ""
-      expected = "" if expected == nil or expected == ""
-      assert_equal( expected, got )
-    else
-      assert_fail( "Wassup?" )
+    # processes a tests/document/context node
+    def process_context(doc, context)
+      test_context = XPath.match(doc, context.attributes["select"])
+      namespaces = context.namespaces
+      namespaces.delete("var")
+      namespaces = nil if namespaces.empty?
+      variables = {}
+      var_namespace = "http://jaxen.org/test-harness/var"
+      XPath.each(context,
+                 "@*[namespace-uri() = '#{var_namespace}']") do |attribute|
+        variables[attribute.name] = attribute.value
+      end
+      XPath.each(context, "valueOf") do |value|
+        process_value_of(test_context, variables, namespaces, value)
+      end
+      XPath.each(context,
+                 "test[not(@exception) or (@exception != 'true')]") do |test|
+        process_nominal_test(test_context, variables, namespaces, test)
+      end
+      XPath.each(context,
+                 "test[@exception = 'true']") do |test|
+        process_exceptional_test(test_context, variables, namespaces, test)
+      end
     end
-  end
 
+    # processes a tests/document/context/valueOf or tests/document/context/test/valueOf node
+    def process_value_of(context, variables, namespaces, value_of)
+      expected = value_of.text
+      xpath = value_of.attributes["select"]
+      matched = XPath.match(context, xpath, namespaces, variables, strict: true)
 
-  # processes a tests/document/context/test node ( where @exception is false or doesn't exist )
-  def handleNominalTest(ctx, variables, namespaces, testElement)
-    expected = testElement.attributes["count"]
-    got = XPath.match( ctx, testElement.attributes["select"], namespaces, variables )
-    # might be a test with no count attribute, but nested valueOf elements
-    assert( expected == got.size.to_s ) if !expected.nil?
-
-    XPath.each( testElement, "valueOf") { |e|
-      handleValueOf(got, variables, namespaces, e)
-    }
-  end
+      message = user_message(context, xpath, matched)
+      assert_equal(expected || "",
+                   REXML::Functions.string(matched),
+                   message)
+    end
 
-  # processes a tests/document/context/test node ( where @exception is true )
-  def handleExceptionalTest(ctx, variables, namespaces, testElement)
-    assert_raise( Exception ) {
-      XPath.match( ctx, testElement.attributes["select"], namespaces, variables )
-    }
-  end
+    # processes a tests/document/context/test node ( where @exception is false or doesn't exist )
+    def process_nominal_test(context, variables, namespaces, test)
+      xpath = test.attributes["select"]
+      matched = XPath.match(context, xpath, namespaces, variables, strict: true)
+      # might be a test with no count attribute, but nested valueOf elements
+      expected = test.attributes["count"]
+      if expected
+        assert_equal(Integer(expected, 10),
+                     matched.size,
+                     user_message(context, xpath, matched))
+      end
 
-  # processes a tests/document node
-  def handleDocument(docElement)
-    puts "- Processing document: #{docElement.attributes['url']}"
-    testFile = File.new( docElement.attributes["url"] )
-    testDoc = Document.new testFile
-    XPath.each( docElement, "context") { |e| handleContext(testDoc, e) }
-  end
+      XPath.each(test, "valueOf") do |value_of|
+        process_value_of(matched, variables, namespaces, value_of)
+      end
+    end
 
-  # processes a variable definition in a namespace like <test var:foo="bar">
-  def handleVariable( ctx, variables, attrib )
-    puts "--- Found attribute: #{attrib.name}"
-    variables[attrib.name] = attrib.value
-  end
+    # processes a tests/document/context/test node ( where @exception is true )
+    def process_exceptional_test(context, variables, namespaces, test)
+      xpath = test.attributes["select"]
+      assert_raise(REXML::ParseException) do
+        XPath.match(context, xpath, namespaces, variables, strict: true)
+      end
+    end
 
-  # processes a namespace definition like <test xmlns:foo="fiz:bang:bam">
-  def handleNamespace( ctx, prefix, namespaces )
-    puts "--- Found namespace: #{prefix}"
-    namespaces[prefix] = ctx.namespaces[prefix]
+    def user_message(context, xpath, matched)
+      message = ""
+      context.each_with_index do |node, i|
+        message << "Node#{i}:\n"
+        message << "#{node}\n"
+      end
+      message << "XPath: <#{xpath}>\n"
+      message << "Matched <#{matched}>"
+      message
+    end
   end
-
 end
diff --git a/test/rexml/test_light.rb b/test/rexml/test_light.rb
index 9ce0fb5..99bd9ca 100644
--- a/test/rexml/test_light.rb
+++ b/test/rexml/test_light.rb
@@ -1,104 +1,107 @@
+# frozen_string_literal: false
 require_relative "rexml_test_utils"
 require "rexml/light/node"
 require "rexml/parsers/lightparser"
 
-class LightTester < Test::Unit::TestCase
-  include REXMLTestUtils
-  include REXML::Light
+module REXMLTests
+  class LightTester < Test::Unit::TestCase
+    include REXMLTestUtils
+    include REXML::Light
 
-  def test_parse_large
-    xml_string = fixture_path("documentation.xml")
-    parser = REXML::Parsers::LightParser.new(xml_string)
-    tag, content = parser.parse
-    assert_equal([:document, :text], [tag, content.first])
-  end
+    def test_parse_large
+      xml_string = fixture_path("documentation.xml")
+      parser = REXML::Parsers::LightParser.new(xml_string)
+      tag, content = parser.parse
+      assert_equal([:document, :text], [tag, content.first])
+    end
 
-  # FIXME INCOMPLETE
-  # This is because the light API is not yet ready to be used to produce
-  # trees.
+    # FIXME INCOMPLETE
+    # This is because the light API is not yet ready to be used to produce
+    # trees.
 =begin
-  def test_add_element
-    doc = Node.new
-    foo = doc.add_element( 'foo' )
-    assert_equal( "foo", foo.name )
-  end
+    def test_add_element
+      doc = Node.new
+      foo = doc.add_element( 'foo' )
+      assert_equal( "foo", foo.name )
+    end
 
-  def test_add_attribute
-    foo = Node.new( "a" )
-    foo["attr"] = "bar"
-    assert_equal( "bar", foo["attr"] )
-  end
+    def test_add_attribute
+      foo = Node.new( "a" )
+      foo["attr"] = "bar"
+      assert_equal( "bar", foo["attr"] )
+    end
 
-  def test_write_document
-    r = make_small_document
-    assert_equal( "<a><b/><c/></a>", r.to_s )
-  end
+    def test_write_document
+      r = make_small_document
+      assert_equal( "<a><b/><c/></a>", r.to_s )
+    end
 
-  def test_add_attribute_under_namespace
-    foo = Node.new("a")
-    foo["attr", "a"] = "1"
-    foo["attr", "b"] = "2"
-    foo["attr"] = "3"
-    assert_equal( '1', foo['attr', 'a'] )
-    assert_equal( '2', foo['attr', 'b'] )
-    assert_equal( '3', foo['attr'] )
-  end
+    def test_add_attribute_under_namespace
+      foo = Node.new("a")
+      foo["attr", "a"] = "1"
+      foo["attr", "b"] = "2"
+      foo["attr"] = "3"
+      assert_equal( '1', foo['attr', 'a'] )
+      assert_equal( '2', foo['attr', 'b'] )
+      assert_equal( '3', foo['attr'] )
+    end
 
-  def test_change_namespace_of_element
-    foo = Node.new
-    assert_equal( '', foo.namespace )
-    foo.namespace = 'a'
-    assert_equal( 'a', foo.namespace )
-  end
+    def test_change_namespace_of_element
+      foo = Node.new
+      assert_equal( '', foo.namespace )
+      foo.namespace = 'a'
+      assert_equal( 'a', foo.namespace )
+    end
 
-  def test_access_child_elements
-    foo = make_small_document
-    assert_equal( 1, foo.size )
-    a = foo[0]
-    assert_equal( 2, a.size )
-    assert_equal( 'b', a[0].name )
-    assert_equal( 'c', a[1].name )
-  end
+    def test_access_child_elements
+      foo = make_small_document
+      assert_equal( 1, foo.size )
+      a = foo[0]
+      assert_equal( 2, a.size )
+      assert_equal( 'b', a[0].name )
+      assert_equal( 'c', a[1].name )
+    end
 
-  def test_itterate_over_children
-    foo = make_small_document
-    ctr = 0
-    foo[0].each { ctr += 1 }
-    assert_equal( 2, ctr )
-  end
+    def test_itterate_over_children
+      foo = make_small_document
+      ctr = 0
+      foo[0].each { ctr += 1 }
+      assert_equal( 2, ctr )
+    end
 
-  def test_add_text
-    foo = Node.new( "a" )
-    foo.add_text( "Sean" )
-    sean = foo[0]
-    assert( sean.node_type == :text )
-  end
+    def test_add_text
+      foo = Node.new( "a" )
+      foo.add_text( "Sean" )
+      sean = foo[0]
+      assert( sean.node_type == :text )
+    end
 
-  def test_add_instruction
-    foo = Node.new( "a" )
-    foo.add_instruction( "target", "value" )
-    assert( foo[0].node_type == :processing_instruction )
-  end
+    def test_add_instruction
+      foo = Node.new( "a" )
+      foo.add_instruction( "target", "value" )
+      assert( foo[0].node_type == :processing_instruction )
+    end
 
-  def test_add_comment
-    foo = Node.new( "a" )
-    foo.add_comment( "target", "value" )
-    assert( foo[0].node_type == :comment )
-  end
+    def test_add_comment
+      foo = Node.new( "a" )
+      foo.add_comment( "target", "value" )
+      assert( foo[0].node_type == :comment )
+    end
 
-  def test_get_root
-    foo = Node.new( 'a' )
-    10.times { foo = foo.add_element('b') }
-    assert_equals( 'b', foo.name )
-    assert_equals( 'a', foo.root.name )
-  end
+    def test_get_root
+      foo = Node.new( 'a' )
+      10.times { foo = foo.add_element('b') }
+      assert_equals( 'b', foo.name )
+      assert_equals( 'a', foo.root.name )
+    end
 
-  def make_small_document
-    r = Node.new
-    a = r.add_element( "a" )
-    a.add_element( 'b' )
-    a.add_element( 'c' )
-    r
-  end
+    def make_small_document
+      r = Node.new
+      a = r.add_element( "a" )
+      a.add_element( 'b' )
+      a.add_element( 'c' )
+      r
+    end
 =end
+  end
 end
diff --git a/test/rexml/test_lightparser.rb b/test/rexml/test_lightparser.rb
index c32c1b8..1aeac07 100644
--- a/test/rexml/test_lightparser.rb
+++ b/test/rexml/test_lightparser.rb
@@ -1,12 +1,16 @@
+# frozen_string_literal: false
 require_relative 'rexml_test_utils'
 require 'rexml/parsers/lightparser'
 
-class LightParserTester < Test::Unit::TestCase
-  include REXMLTestUtils
-  include REXML
-  def test_parsing
-    f = File.new(fixture_path("documentation.xml"))
-    parser = REXML::Parsers::LightParser.new( f )
-    parser.parse
+module REXMLTests
+  class LightParserTester < Test::Unit::TestCase
+    include REXMLTestUtils
+    include REXML
+    def test_parsing
+      File.open(fixture_path("documentation.xml")) do |f|
+        parser = REXML::Parsers::LightParser.new( f )
+        parser.parse
+      end
+    end
   end
 end
diff --git a/test/rexml/test_listener.rb b/test/rexml/test_listener.rb
index a3d763c..322d368 100644
--- a/test/rexml/test_listener.rb
+++ b/test/rexml/test_listener.rb
@@ -1,129 +1,131 @@
 # coding: binary
+# frozen_string_literal: false
 
 require_relative 'rexml_test_utils'
 
 require 'rexml/document'
 require 'rexml/streamlistener'
 
-class BaseTester < Test::Unit::TestCase
-  include REXMLTestUtils
-  def test_empty
-    return unless defined? @listener
-    # Empty.
-    t1 = %Q{<string></string>}
-    assert_equal( "", @listener.parse( t1 ),
-      "Empty" )
-  end
-
-  def test_space
-    return unless defined? @listener
-    # Space.
-    t2 = %Q{<string>    </string>}
-    assert_equal( "    ", @listener.parse( t2 ),
-      "Space" )
-  end
-
-  def test_whitespace
-    return unless defined? @listener
-    # Whitespaces.
-    t3 = %Q{<string>RE\n \t \n \t XML</string>}
-    assert_equal( "RE\n \t \n \t XML", @listener.parse( t3 ),
-      "Whitespaces" )
-  end
-
-  def test_leading_trailing_whitespace
-    return unless defined? @listener
-    # Leading and trailing whitespaces.
-    t4 = %Q{<string>    REXML    </string>}
-    assert_equal( "    REXML    ", @listener.parse( t4 ),
-      "Leading and trailing whitespaces" )
-  end
+module REXMLTests
+  class BaseTester < Test::Unit::TestCase
+    include REXMLTestUtils
+    def test_empty
+      return unless defined? @listener
+      # Empty.
+      t1 = %Q{<string></string>}
+      assert_equal( "", @listener.parse( t1 ),
+        "Empty" )
+    end
 
-  def test_entity_reference
-    return unless defined? @listener
-    # Entity reference.
-    t5 = %Q{<string>&lt;&gt;&amp;lt;&amp;gt;</string>}
-    assert_equal( "<>&lt;&gt;", @listener.parse( t5 ),
-      "Entity reference" )
-  end
+    def test_space
+      return unless defined? @listener
+      # Space.
+      t2 = %Q{<string>    </string>}
+      assert_equal( "    ", @listener.parse( t2 ),
+        "Space" )
+    end
 
-  def test_character_reference
-    return unless defined? @listener
-    # Character reference.
-    t6 = %Q{<string>&#xd;</string>}
-    assert_equal( "\r", @listener.parse( t6 ),
-      "Character reference." )
-  end
+    def test_whitespace
+      return unless defined? @listener
+      # Whitespaces.
+      t3 = %Q{<string>RE\n \t \n \t XML</string>}
+      assert_equal( "RE\n \t \n \t XML", @listener.parse( t3 ),
+        "Whitespaces" )
+    end
 
-  def test_cr
-    return unless defined? @listener
-    # CR.
-    t7 = %Q{<string> \r\n \r \n </string>}
-    assert_equal( " \n \n \n ".unpack("C*").inspect,
-      @listener.parse( t7 ).unpack("C*").inspect, "CR" )
-  end
+    def test_leading_trailing_whitespace
+      return unless defined? @listener
+      # Leading and trailing whitespaces.
+      t4 = %Q{<string>    REXML    </string>}
+      assert_equal( "    REXML    ", @listener.parse( t4 ),
+        "Leading and trailing whitespaces" )
+    end
 
-  # The accent bug, and the code that exibits the bug, was contributed by
-  # Guilhem Vellut
-  class AccentListener
-    def tag_start(name,attributes)
-      #p name
-      #p attributes
+    def test_entity_reference
+      return unless defined? @listener
+      # Entity reference.
+      t5 = %Q{<string>&lt;&gt;&amp;lt;&amp;gt;</string>}
+      assert_equal( "<>&lt;&gt;", @listener.parse( t5 ),
+        "Entity reference" )
     end
-    def tag_end(name)
-      #p "/"+name
+
+    def test_character_reference
+      return unless defined? @listener
+      # Character reference.
+      t6 = %Q{<string>&#xd;</string>}
+      assert_equal( "\r", @listener.parse( t6 ),
+        "Character reference." )
     end
-    def xmldecl(a,b,c)
-      #puts "#{a} #{b} #{c}"
+
+    def test_cr
+      return unless defined? @listener
+      # CR.
+      t7 = %Q{<string> \r\n \r \n </string>}
+      assert_equal( " \n \n \n ".unpack("C*").inspect,
+        @listener.parse( t7 ).unpack("C*").inspect, "CR" )
     end
-    def text(tx)
-      #p tx
+
+    # The accent bug, and the code that exhibits the bug, was contributed by
+    # Guilhem Vellut
+    class AccentListener
+      def tag_start(name,attributes)
+        #p name
+        #p attributes
+      end
+      def tag_end(name)
+        #p "/"+name
+      end
+      def xmldecl(a,b,c)
+        #puts "#{a} #{b} #{c}"
+      end
+      def text(tx)
+        #p tx
+      end
     end
-  end
 
-  def test_accents
-    source = %[<?xml version="1.0" encoding="ISO-8859-1"?>
+    def test_accents
+      source = %[<?xml version="1.0" encoding="ISO-8859-1"?>
 <g>
 <f  a="\xE9" />
 </g>]
-    doc = REXML::Document.new( source )
-    a = doc.elements['/g/f'].attribute('a')
-                if a.value.respond_to? :force_encoding
-                  a.value.force_encoding('binary')
-                end
-    assert_equal( "\xC3\xA9", a.value)
-    doc = REXML::Document.parse_stream(
-      File::new(fixture_path("stream_accents.xml")),
-      AccentListener::new
-      )
+      doc = REXML::Document.new( source )
+      a = doc.elements['/g/f'].attribute('a')
+                  if a.value.respond_to? :force_encoding
+                    a.value.force_encoding('binary')
+                  end
+      assert_equal( "\xC3\xA9", a.value)
+      doc = File::open(fixture_path("stream_accents.xml")) do |f|
+        REXML::Document.parse_stream(f, AccentListener::new)
+      end
+    end
   end
-end
 
-class MyREXMLListener
-  include REXML::StreamListener
+  class MyREXMLListener
+    include REXML::StreamListener
 
-  def initialize
-    @text = nil
-  end
+    def initialize
+      @text = nil
+    end
 
-  def parse( stringOrReadable )
-    @text = ""
-    REXML::Document.parse_stream( stringOrReadable, self )
-    @text
-  end
+    def parse( stringOrReadable )
+      @text = ""
+      REXML::Document.parse_stream( stringOrReadable, self )
+      @text
+    end
 
-  def text( text )
-    @text << text
+    def text( text )
+      @text << text
+    end
   end
-end
 
-class REXMLTester < BaseTester
-  def setup
-    @listener = MyREXMLListener.new
-  end
+  class REXMLTester < BaseTester
+    def setup
+      @listener = MyREXMLListener.new
+    end
 
-  def test_character_reference_2
-    t6 = %Q{<string>&#xd;</string>}
-    assert_equal( t6.strip, REXML::Document.new(t6).to_s )
+    def test_character_reference_2
+      t6 = %Q{<string>&#xd;</string>}
+      assert_equal( t6.strip, REXML::Document.new(t6).to_s )
+    end
   end
 end
diff --git a/test/rexml/test_martin_fowler.rb b/test/rexml/test_martin_fowler.rb
index 1b29c3d..add3c82 100644
--- a/test/rexml/test_martin_fowler.rb
+++ b/test/rexml/test_martin_fowler.rb
@@ -1,8 +1,10 @@
+# frozen_string_literal: false
 require 'test/unit'
 require 'rexml/document'
 
-class OrderTester < Test::Unit::TestCase
-  DOC = <<END
+module REXMLTests
+  class OrderTesterMF < Test::Unit::TestCase
+    DOC = <<END
 <paper>
 <title>Remove this element and figs order differently</title>
 <figure src="fig1"/>
@@ -16,22 +18,23 @@ class OrderTester < Test::Unit::TestCase
 </paper>
 END
 
-  def initialize n
-    @doc = REXML::Document.new(DOC)
-    @figs = REXML::XPath.match(@doc,'//figure')
-    @names = @figs.collect {|f| f.attributes['src']}
-    super
-  end
-  def test_fig1
-    assert_equal 'fig1', @figs[0].attributes['src']
-  end
-  def test_fig2
-    assert_equal 'fig2', @figs[1].attributes['src']
-  end
-  def test_fig3
-    assert_equal 'fig3', @figs[2].attributes['src']
-  end
-  def test_fig4
-    assert_equal 'fig4', @figs[3].attributes['src']
+    def initialize n
+      @doc = REXML::Document.new(DOC)
+      @figs = REXML::XPath.match(@doc,'//figure')
+      @names = @figs.collect {|f| f.attributes['src']}
+      super
+    end
+    def test_fig1
+      assert_equal 'fig1', @figs[0].attributes['src']
+    end
+    def test_fig2
+      assert_equal 'fig2', @figs[1].attributes['src']
+    end
+    def test_fig3
+      assert_equal 'fig3', @figs[2].attributes['src']
+    end
+    def test_fig4
+      assert_equal 'fig4', @figs[3].attributes['src']
+    end
   end
 end
diff --git a/test/rexml/test_namespace.rb b/test/rexml/test_namespace.rb
index f855203..90e1d36 100644
--- a/test/rexml/test_namespace.rb
+++ b/test/rexml/test_namespace.rb
@@ -1,38 +1,41 @@
+# frozen_string_literal: false
 require_relative "rexml_test_utils"
 
 require "rexml/document"
 
-class TestNamespace < Test::Unit::TestCase
-  include REXMLTestUtils
-  include REXML
+module REXMLTests
+  class TestNamespace < Test::Unit::TestCase
+    include REXMLTestUtils
+    include REXML
 
-  def setup
-    @xsa_source = <<-EOL
-      <?xml version="1.0"?>
-      <?xsl stylesheet="blah.xsl"?>
-      <!-- The first line tests the XMLDecl, the second tests PI.
-      The next line tests DocType. This line tests comments. -->
-      <!DOCTYPE xsa PUBLIC
-        "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML"
-        "http://www.garshol.priv.no/download/xsa/xsa.dtd">
+    def setup
+      @xsa_source = <<-EOL
+        <?xml version="1.0"?>
+        <?xsl stylesheet="blah.xsl"?>
+        <!-- The first line tests the XMLDecl, the second tests PI.
+        The next line tests DocType. This line tests comments. -->
+        <!DOCTYPE xsa PUBLIC
+          "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML"
+          "http://www.garshol.priv.no/download/xsa/xsa.dtd">
 
-      <xsa>
-        <vendor id="blah">
-          <name>Lars Marius Garshol</name>
-          <email>larsga@garshol.priv.no</email>
-          <url>http://www.stud.ifi.uio.no/~lmariusg/</url>
-        </vendor>
-      </xsa>
-    EOL
-  end
+        <xsa>
+          <vendor id="blah">
+            <name>Lars Marius Garshol</name>
+            <email>larsga@garshol.priv.no</email>
+            <url>http://www.stud.ifi.uio.no/~lmariusg/</url>
+          </vendor>
+        </xsa>
+      EOL
+    end
 
-  def test_xml_namespace
-    xml = <<-XML
+    def test_xml_namespace
+      xml = <<-XML
 <?xml version="1.0" encoding="UTF-8"?>
 <root xmlns:xml="http://www.w3.org/XML/1998/namespace" />
 XML
-    document = Document.new(xml)
-    assert_equal("http://www.w3.org/XML/1998/namespace",
-                 document.root.namespace("xml"))
+      document = Document.new(xml)
+      assert_equal("http://www.w3.org/XML/1998/namespace",
+                   document.root.namespace("xml"))
+    end
   end
 end
diff --git a/test/rexml/test_order.rb b/test/rexml/test_order.rb
index 3fcbf97..807d9fa 100644
--- a/test/rexml/test_order.rb
+++ b/test/rexml/test_order.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 require_relative 'rexml_test_utils'
 require 'rexml/document'
 begin
@@ -5,10 +6,11 @@ begin
 rescue LoadError
 end
 
-class OrderTester < Test::Unit::TestCase
-  include REXMLTestUtils
+module REXMLTests
+  class OrderTester < Test::Unit::TestCase
+    include REXMLTestUtils
 
-  TESTDOC = <<END
+    TESTDOC = <<END
 <a>
   <b/>
   <x id='1'/>
@@ -20,86 +22,89 @@ class OrderTester < Test::Unit::TestCase
 </a>
 END
 
-   def setup
-     @doc = REXML::Document.new(TESTDOC)
-     @items = REXML::XPath.match(@doc,'//x')
-   end
-   def test_first_element
-     assert_equal '1', @items[0].attributes['id']
-   end
-   def test_second_element
-     assert_equal '2', @items[1].attributes['id']
-   end
-   def test_third_element
-     assert_equal '3', @items[2].attributes['id']
-   end
-   def test_order
-     d = REXML::Document.new( "<a><x id='1'/><x id='2'/><x id='3'/>
-     <x id='4'/><x id='5'/></a>" )
-     items = REXML::XPath.match( d, '//x' )
-     assert_equal( %w{1 2 3 4 5}, items.collect{|e| e.attributes['id']} )
-     d = REXML::Document.new( "<a>
-      <x><z><y id='1'/><y id='2'/></z><y id='3'/></x>
-      <x><y id='4'/></x></a>" )
-     items = REXML::XPath.match( d, '//y' )
-     assert_equal( %w{1 2 3 4}, items.collect{|e| e.attributes['id']} )
-   end
-   # Provided by Tom Talbott
-   def test_more_ordering
-     doc = REXML::Document.new(Zlib::GzipReader.open(fixture_path('LostineRiver.kml.gz'), encoding: 'utf-8'))
-     actual = [
-        "Head south from Phinney Ave N",
-        "Turn left at N 36th St",
-        "Turn right at Fremont Ave N",
-        "Continue on 4th Ave N",
-        "Turn left at Westlake Ave N",
-        "Bear right at 9th Ave N",
-        "Turn left at Mercer St",
-        "Take the I-5 ramp",
-        "Take the I-5 S ramp",
-        "Take the I-90 E exit #164 to Bellevue/Spokane/4th Ave S.",
-        "Take the I-90 E ramp to Bellevue/Spokane",
-        "Take exit #137 to Wanapum Dam/Richland",
-        "Bear right at WA-26",
-        "Bear right and head toward WA-243",
-        "Continue on WA-243",
-        "Bear right at WA-24",
-        "Continue on WA-240",
-        "Turn right at WA-240 E",
-        "Take the I-182 W ramp to Yakima (I-82)/Pendleton",
-        "Take the I-82 E ramp to Umatilla/Pendleton",
-        "Take the I-84 E ramp to Pendleton",
-        "Take the OR-82 exit #261 to La Grande/Elgin",
-        "Turn right at Island Ave",
-        "Continue on W 1st St",
-        "Turn left at N McAlister Rd",
-        "Bear right at OR-82",
-        "Continue on Wallowa Lake Hwy",
-        "Continue on OR-82",
-        "Continue on Ruckman Ave",
-        "Continue on OR-82",
-        "Continue on S 8th Ave",
-        "Turn right at Albany St",
-        "Continue on OR-82",
-        "Continue on Wallowa Lake Hwy",
-        "Continue on N Madison St",
-        "Bear left at W 1st St",
-        "Continue on Wallowa Lake Hwy",
-        "Continue on Water St",
-        "Bear right at Lostine River Rd",
-        "Bear right and head toward Lostine River Rd",
-        "Turn right at Lostine River Rd",
-        "Continue on NF-8210",
-        "Turn right and head toward NF-8210",
-        "Turn right at NF-8210",
-        "",
-        "Route"
-     ]
-     count = 0
-     REXML::XPath.each( doc, "//Placemark") { |element|
-       n = element.elements["name"].text.squeeze(" ")
-       assert_equal( actual[count], n ) unless n =~ /Arrive at/
-       count += 1
-     }
-   end if defined?(Zlib::GzipReader)
+     def setup
+       @doc = REXML::Document.new(TESTDOC)
+       @items = REXML::XPath.match(@doc,'//x')
+     end
+     def test_first_element
+       assert_equal '1', @items[0].attributes['id']
+     end
+     def test_second_element
+       assert_equal '2', @items[1].attributes['id']
+     end
+     def test_third_element
+       assert_equal '3', @items[2].attributes['id']
+     end
+     def test_order
+       d = REXML::Document.new( "<a><x id='1'/><x id='2'/><x id='3'/>
+       <x id='4'/><x id='5'/></a>" )
+       items = REXML::XPath.match( d, '//x' )
+       assert_equal( %w{1 2 3 4 5}, items.collect{|e| e.attributes['id']} )
+       d = REXML::Document.new( "<a>
+        <x><z><y id='1'/><y id='2'/></z><y id='3'/></x>
+        <x><y id='4'/></x></a>" )
+       items = REXML::XPath.match( d, '//y' )
+       assert_equal( %w{1 2 3 4}, items.collect{|e| e.attributes['id']} )
+     end
+     # Provided by Tom Talbott
+     def test_more_ordering
+       doc = Zlib::GzipReader.open(fixture_path('LostineRiver.kml.gz'), encoding: 'utf-8') do |f|
+         REXML::Document.new(f)
+       end
+       actual = [
+          "Head south from Phinney Ave N",
+          "Turn left at N 36th St",
+          "Turn right at Fremont Ave N",
+          "Continue on 4th Ave N",
+          "Turn left at Westlake Ave N",
+          "Bear right at 9th Ave N",
+          "Turn left at Mercer St",
+          "Take the I-5 ramp",
+          "Take the I-5 S ramp",
+          "Take the I-90 E exit #164 to Bellevue/Spokane/4th Ave S.",
+          "Take the I-90 E ramp to Bellevue/Spokane",
+          "Take exit #137 to Wanapum Dam/Richland",
+          "Bear right at WA-26",
+          "Bear right and head toward WA-243",
+          "Continue on WA-243",
+          "Bear right at WA-24",
+          "Continue on WA-240",
+          "Turn right at WA-240 E",
+          "Take the I-182 W ramp to Yakima (I-82)/Pendleton",
+          "Take the I-82 E ramp to Umatilla/Pendleton",
+          "Take the I-84 E ramp to Pendleton",
+          "Take the OR-82 exit #261 to La Grande/Elgin",
+          "Turn right at Island Ave",
+          "Continue on W 1st St",
+          "Turn left at N McAlister Rd",
+          "Bear right at OR-82",
+          "Continue on Wallowa Lake Hwy",
+          "Continue on OR-82",
+          "Continue on Ruckman Ave",
+          "Continue on OR-82",
+          "Continue on S 8th Ave",
+          "Turn right at Albany St",
+          "Continue on OR-82",
+          "Continue on Wallowa Lake Hwy",
+          "Continue on N Madison St",
+          "Bear left at W 1st St",
+          "Continue on Wallowa Lake Hwy",
+          "Continue on Water St",
+          "Bear right at Lostine River Rd",
+          "Bear right and head toward Lostine River Rd",
+          "Turn right at Lostine River Rd",
+          "Continue on NF-8210",
+          "Turn right and head toward NF-8210",
+          "Turn right at NF-8210",
+          "",
+          "Route"
+       ]
+       count = 0
+       REXML::XPath.each( doc, "//Placemark") { |element|
+         n = element.elements["name"].text.squeeze(" ")
+         assert_equal( actual[count], n ) unless n =~ /Arrive at/
+         count += 1
+       }
+     end if defined?(Zlib::GzipReader)
+  end
 end
diff --git a/test/rexml/test_preceding_sibling.rb b/test/rexml/test_preceding_sibling.rb
index 632e4da..d89a1e1 100644
--- a/test/rexml/test_preceding_sibling.rb
+++ b/test/rexml/test_preceding_sibling.rb
@@ -1,38 +1,41 @@
+# frozen_string_literal: false
 # ISSUE 32
 require 'test/unit'
 require 'rexml/document'
 
-# daz - for report by Dan Kohn in:
-#  http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/156328
-class XPathTesterDd < Test::Unit::TestCase
-  include REXML
+module REXMLTests
+  # daz - for report by Dan Kohn in:
+  #  http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/156328
+  class XPathTesterDd < Test::Unit::TestCase
+    include REXML
 
-  def setup
-    @@docDd = Document.new(<<-EOS, :ignore_whitespace_nodes => :all)
-      <a>
-        <b x='ab01A'>
-          <c y='abc01A'>Success</c>
-        </b>
-        <b x='ab02A' y='ab02B'>
-          <c>abc02C</c>
-        </b>
-      </a>
-    EOS
-  end
+    def setup
+      @@docDd = Document.new(<<-EOS, :ignore_whitespace_nodes => :all)
+        <a>
+          <b x='ab01A'>
+            <c y='abc01A'>Success</c>
+          </b>
+          <b x='ab02A' y='ab02B'>
+            <c>abc02C</c>
+          </b>
+        </a>
+      EOS
+    end
 
-  def test_Dd_preceding_sibling_children
-    arr = []
-    XPath.each(@@docDd, "//b[@x='ab02A']/preceding-sibling::b/child::*") do |cell|
-      arr << cell.texts.join
+    def test_Dd_preceding_sibling_children
+      arr = []
+      XPath.each(@@docDd, "//b[@x='ab02A']/preceding-sibling::b/child::*") do |cell|
+        arr << cell.texts.join
+      end
+      assert_equal( 'Success', arr.join )
     end
-    assert_equal( 'Success', arr.join )
-  end
 
-  def test_Dd_preceding_sibling_all
-    arr = []
-    XPath.each(@@docDd, "//b[@x='ab02A']/preceding-sibling::*") do |cell|
-      arr << cell.to_s
+    def test_Dd_preceding_sibling_all
+      arr = []
+      XPath.each(@@docDd, "//b[@x='ab02A']/preceding-sibling::*") do |cell|
+        arr << cell.to_s
+      end
+      assert_equal( "<b x='ab01A'><c y='abc01A'>Success</c></b>", arr.join )
     end
-    assert_equal( "<b x='ab01A'><c y='abc01A'>Success</c></b>", arr.join )
   end
 end
diff --git a/test/rexml/test_pullparser.rb b/test/rexml/test_pullparser.rb
index 03c9564..31b5b74 100644
--- a/test/rexml/test_pullparser.rb
+++ b/test/rexml/test_pullparser.rb
@@ -1,100 +1,103 @@
+# frozen_string_literal: false
 require "test/unit/testcase"
 
 require 'rexml/parsers/pullparser'
 
-class PullParserTester < Test::Unit::TestCase
-  include REXML
-  def test_basics
-    source = '<?xml version="1.0"?>
-    <!DOCTYPE blah>
-    <a>foo &lt;<b attribute="value">bar</b> nooo</a>'
-    parser = REXML::Parsers::PullParser.new(source)
-    res = { :text=>0 }
-    until parser.empty?
-      results = parser.pull
-      res[ :xmldecl ] = true if results.xmldecl?
-      res[ :doctype ] = true if results.doctype?
-      res[ :a ] = true if results.start_element? and results[0] == 'a'
-      if results.start_element? and results[0] == 'b'
-        res[ :b ] = true
-        assert_equal 'value', results[1]['attribute']
+module REXMLTests
+  class PullParserTester < Test::Unit::TestCase
+    include REXML
+    def test_basics
+      source = '<?xml version="1.0"?>
+      <!DOCTYPE blah>
+      <a>foo &lt;<b attribute="value">bar</b> nooo</a>'
+      parser = REXML::Parsers::PullParser.new(source)
+      res = { :text=>0 }
+      until parser.empty?
+        results = parser.pull
+        res[ :xmldecl ] = true if results.xmldecl?
+        res[ :doctype ] = true if results.doctype?
+        res[ :a ] = true if results.start_element? and results[0] == 'a'
+        if results.start_element? and results[0] == 'b'
+          res[ :b ] = true
+          assert_equal 'value', results[1]['attribute']
+        end
+        res[ :text ] += 1 if results.text?
       end
-      res[ :text ] += 1 if results.text?
+      [ :xmldecl, :doctype, :a, :b ].each { |tag|
+        assert res[tag] , "#{tag} wasn't processed"
+      }
+      assert_equal 4, res[ :text ]
+    rescue ParseException
+      puts $!
     end
-    [ :xmldecl, :doctype, :a, :b ].each { |tag|
-      assert res[tag] , "#{tag} wasn't processed"
-    }
-    assert_equal 4, res[ :text ]
-  rescue ParseException
-    puts $!
-  end
 
-  def test_bad_document
-    source = "<a><b></a>"
-    parser = REXML::Parsers::PullParser.new(source)
-    assert_raise(ParseException, "Parsing should have failed") {
-      parser.pull while parser.has_next?
-    }
-  end
+    def test_bad_document
+      source = "<a><b></a>"
+      parser = REXML::Parsers::PullParser.new(source)
+      assert_raise(ParseException, "Parsing should have failed") {
+        parser.pull while parser.has_next?
+      }
+    end
 
-  def test_entity_replacement
-    source = '<!DOCTYPE foo [
-    <!ENTITY la "1234">
-    <!ENTITY lala "--&la;--">
-    <!ENTITY lalal "&la;&la;">
-    ]><a><la>&la;</la><lala>&lala;</lala></a>'
-    pp = REXML::Parsers::PullParser.new( source )
-    el_name = ''
-    while pp.has_next?
-      event = pp.pull
-      case event.event_type
-      when :start_element
-        el_name = event[0]
-      when :text
-        case el_name
-        when 'la'
-          assert_equal('1234', event[1])
-        when 'lala'
-          assert_equal('--1234--', event[1])
+    def test_entity_replacement
+      source = '<!DOCTYPE foo [
+      <!ENTITY la "1234">
+      <!ENTITY lala "--&la;--">
+      <!ENTITY lalal "&la;&la;">
+      ]><a><la>&la;</la><lala>&lala;</lala></a>'
+      pp = REXML::Parsers::PullParser.new( source )
+      el_name = ''
+      while pp.has_next?
+        event = pp.pull
+        case event.event_type
+        when :start_element
+          el_name = event[0]
+        when :text
+          case el_name
+          when 'la'
+            assert_equal('1234', event[1])
+          when 'lala'
+            assert_equal('--1234--', event[1])
+          end
         end
       end
     end
-  end
 
-  def test_peek_unshift
-    source = "<a><b/></a>"
-    REXML::Parsers::PullParser.new(source)
-    # FINISH ME!
-  end
+    def test_peek_unshift
+      source = "<a><b/></a>"
+      REXML::Parsers::PullParser.new(source)
+      # FINISH ME!
+    end
 
-  def test_inspect
-    xml =  '<a id="1"><b id="2">Hey</b></a>'
-    parser = Parsers::PullParser.new( xml )
-    while parser.has_next?
-      pull_event = parser.pull
-      if pull_event.start_element?
-        peek = parser.peek()
-        peek.inspect
+    def test_inspect
+      xml =  '<a id="1"><b id="2">Hey</b></a>'
+      parser = Parsers::PullParser.new( xml )
+      while parser.has_next?
+        pull_event = parser.pull
+        if pull_event.start_element?
+          peek = parser.peek()
+          peek.inspect
+        end
       end
     end
-  end
 
-  def test_peek
-    xml =  '<a id="1"><b id="2">Hey</b></a>'
-    parser = Parsers::PullParser.new( xml )
-    names = %w{ a b }
-    while parser.has_next?
-      pull_event = parser.pull
-      if pull_event.start_element?
-        assert_equal( :start_element, pull_event.event_type )
-        assert_equal( names.shift, pull_event[0] )
-        if names[0] == 'b'
-          peek = parser.peek()
-          assert_equal( :start_element, peek.event_type )
-          assert_equal( names[0], peek[0] )
+    def test_peek
+      xml =  '<a id="1"><b id="2">Hey</b></a>'
+      parser = Parsers::PullParser.new( xml )
+      names = %w{ a b }
+      while parser.has_next?
+        pull_event = parser.pull
+        if pull_event.start_element?
+          assert_equal( :start_element, pull_event.event_type )
+          assert_equal( names.shift, pull_event[0] )
+          if names[0] == 'b'
+            peek = parser.peek()
+            assert_equal( :start_element, peek.event_type )
+            assert_equal( names[0], peek[0] )
+          end
         end
       end
+      assert_equal( 0, names.length )
     end
-    assert_equal( 0, names.length )
   end
 end
diff --git a/test/rexml/test_rexml_issuezilla.rb b/test/rexml/test_rexml_issuezilla.rb
index 2a12006..1c54c9d 100644
--- a/test/rexml/test_rexml_issuezilla.rb
+++ b/test/rexml/test_rexml_issuezilla.rb
@@ -1,14 +1,19 @@
+# frozen_string_literal: false
 require_relative 'rexml_test_utils'
 require 'rexml/document'
 
-class TestIssuezillaParsing < Test::Unit::TestCase
-  include REXMLTestUtils
-  def test_rexml
-    doc = REXML::Document.new(File.new(fixture_path("ofbiz-issues-full-177.xml")))
-    ctr = 1
-    doc.root.each_element('//issue') do |issue|
-      assert_equal( ctr, issue.elements['issue_id'].text.to_i )
-      ctr += 1
+module REXMLTests
+  class TestIssuezillaParsing < Test::Unit::TestCase
+    include REXMLTestUtils
+    def test_rexml
+      doc = File.open(fixture_path("ofbiz-issues-full-177.xml")) do |f|
+        REXML::Document.new(f)
+      end
+      ctr = 1
+      doc.root.each_element('//issue') do |issue|
+        assert_equal( ctr, issue.elements['issue_id'].text.to_i )
+        ctr += 1
+      end
     end
   end
 end
diff --git a/test/rexml/test_sax.rb b/test/rexml/test_sax.rb
index 4a9db40..00539f0 100644
--- a/test/rexml/test_sax.rb
+++ b/test/rexml/test_sax.rb
@@ -1,279 +1,287 @@
+# frozen_string_literal: false
 require_relative "rexml_test_utils"
 require 'rexml/sax2listener'
 require 'rexml/parsers/sax2parser'
 require 'rexml/document'
 
-class SAX2Tester < Test::Unit::TestCase
-  include REXMLTestUtils
-  include REXML
-  def test_characters
-    d = Document.new( "<A>@blah@</A>" )
-    txt = d.root.text
-    p = Parsers::SAX2Parser.new "<A>@blah@</A>"
-    p.listen(:characters) {|x| assert_equal txt, x}
-    p.listen(:characters, ["A"]) {|x| assert_equal txt,x}
-    p.parse
-  end
+module REXMLTests
+  class SAX2Tester < Test::Unit::TestCase
+    include REXMLTestUtils
+    include REXML
+    def test_characters
+      d = Document.new( "<A>@blah@</A>" )
+      txt = d.root.text
+      p = Parsers::SAX2Parser.new "<A>@blah@</A>"
+      p.listen(:characters) {|x| assert_equal txt, x}
+      p.listen(:characters, ["A"]) {|x| assert_equal txt,x}
+      p.parse
+    end
 
-  def test_entity_replacement
-    source = '<!DOCTYPE foo [
-    <!ENTITY la "1234">
-    <!ENTITY lala "--&la;--">
-    <!ENTITY lalal "&la;&la;">
-    ]><a><la>&la;</la><lala>&lala;</lala></a>'
-    sax = Parsers::SAX2Parser.new( source )
-    results = []
-    sax.listen(:characters) {|x| results << x }
-    sax.parse
-    assert_equal 2, results.size
-    assert_equal '1234', results[0]
-    assert_equal '--1234--', results[1]
-  end
+    def test_entity_replacement
+      source = '<!DOCTYPE foo [
+      <!ENTITY la "1234">
+      <!ENTITY lala "--&la;--">
+      <!ENTITY lalal "&la;&la;">
+      ]><a><la>&la;</la><lala>&lala;</lala></a>'
+      sax = Parsers::SAX2Parser.new( source )
+      results = []
+      sax.listen(:characters) {|x| results << x }
+      sax.parse
+      assert_equal 2, results.size
+      assert_equal '1234', results[0]
+      assert_equal '--1234--', results[1]
+    end
 
-  def test_sax2
-    f = File.new(fixture_path("documentation.xml"))
-    parser = Parsers::SAX2Parser.new( f )
-    # Listen to all events on the following elements
-    count = 0
-    blok = proc { |uri,localname,qname,attributes|
-      assert %w{ bugs todo }.include?(localname),
-      "Mismatched name; we got '#{qname}'\nArgs were:\n\tURI: #{uri}\n\tLOCALNAME: #{localname}\n\tQNAME: #{qname}\n\tATTRIBUTES: #{attributes.inspect}\n\tSELF=#{blok}"
-      count += 1
-    }
+    def test_sax2
+      File.open(fixture_path("documentation.xml")) do |f|
+        parser = Parsers::SAX2Parser.new( f )
+        # Listen to all events on the following elements
+        count = 0
+        blok = proc { |uri,localname,qname,attributes|
+          assert %w{ bugs todo }.include?(localname),
+          "Mismatched name; we got '#{qname}'\nArgs were:\n\tURI: #{uri}\n\tLOCALNAME: #{localname}\n\tQNAME: #{qname}\n\tATTRIBUTES: #{attributes.inspect}\n\tSELF=#{blok}"
+          count += 1
+        }
 
-    start_document = 0
-    end_document = 0
-    parser.listen( :start_document ) { start_document += 1 }
-    parser.listen( :end_document ) { end_document += 1 }
-    parser.listen( :start_element, %w{ changelog bugs todo }, &blok )
-    # Listen to all events on the following elements.  Synonymous with
-    # listen( :start_element, %w{ ... } )
-    parser.listen( %w{ changelog bugs todo }, &blok )
-    # Listen for all start element events
-    parser.listen( :start_element ) { |uri,localname,qname,attributes|
-    }
-    listener = MySAX2Listener.new
-    # Listen for all events
-    parser.listen( listener )
-    # Listen for all events on the given elements.  Does not include children
-    # events.  Regular expressions work as well!
-    parser.listen( %w{ /change/ bugs todo }, listener )
-    # Test the deafening method
-    blok = proc  { |uri,localname,qname,attributes|
-      assert_fail "This listener should have been deafened!"
-    }
-    parser.listen( %w{ changelog }, &blok )
-    parser.deafen( &blok )
+        start_document = 0
+        end_document = 0
+        parser.listen( :start_document ) { start_document += 1 }
+        parser.listen( :end_document ) { end_document += 1 }
+        parser.listen( :start_element, %w{ changelog bugs todo }, &blok )
+        # Listen to all events on the following elements.  Synonymous with
+        # listen( :start_element, %w{ ... } )
+        parser.listen( %w{ changelog bugs todo }, &blok )
+        # Listen for all start element events
+        parser.listen( :start_element ) { |uri,localname,qname,attributes|
+        }
+        listener = MySAX2Listener.new
+        # Listen for all events
+        parser.listen( listener )
+        # Listen for all events on the given elements.  Does not include children
+        # events.  Regular expressions work as well!
+        parser.listen( %w{ /change/ bugs todo }, listener )
+        # Test the deafening method
+        blok = proc  { |uri,localname,qname,attributes|
+          assert_fail "This listener should have been deafened!"
+        }
+        parser.listen( %w{ changelog }, &blok )
+        parser.deafen( &blok )
 
-    tc = 0
-    parser.listen( :characters, %w{version} ) {|text|
-      assert(text=~/@ANT_VERSION@/, "version was '#{text}'")
-      tc += 1
-    }
+        tc = 0
+        parser.listen( :characters, %w{version} ) {|text|
+          assert(text=~/@ANT_VERSION@/, "version was '#{text}'")
+          tc += 1
+        }
 
-    begin
-      parser.parse
-    rescue => exception
-      if exception.kind_of? Test::Unit::AssertionFailedError
-        raise exception
+        begin
+          parser.parse
+        rescue => exception
+          if exception.kind_of? Test::Unit::AssertionFailedError
+            raise exception
+          end
+          puts $!
+          puts exception.backtrace
+        end
+        assert_equal 2, count
+        assert_equal 1, tc
+        assert_equal 1, start_document
+        assert_equal 1, end_document
       end
-      puts $!
-      puts exception.backtrace
     end
-    assert_equal 2, count
-    assert_equal 1, tc
-    assert_equal 1, start_document
-    assert_equal 1, end_document
-  end
-
 
+    # used by test_simple_doctype_listener
+    # submitted by Jeff Barczewski
+    class SimpleDoctypeListener
+      include REXML::SAX2Listener
+      attr_reader :name, :pub_sys, :long_name, :uri
 
-  # used by test_simple_doctype_listener
-  # submitted by Jeff Barczewski
-  class SimpleDoctypeListener
-    include REXML::SAX2Listener
-    attr_reader :name, :pub_sys, :long_name, :uri
-
-    def initialize
-      @name = @pub_sys = @long_name = @uri = nil
-    end
+      def initialize
+        @name = @pub_sys = @long_name = @uri = nil
+      end
 
-    def doctype(name, pub_sys, long_name, uri)
-      @name = name
-      @pub_sys = pub_sys
-      @long_name = long_name
-      @uri = uri
+      def doctype(name, pub_sys, long_name, uri)
+        @name = name
+        @pub_sys = pub_sys
+        @long_name = long_name
+        @uri = uri
+      end
     end
-  end
 
-  # test simple non-entity doctype in sax listener
-  # submitted by Jeff Barczewski
-  def test_simple_doctype_listener
-    xml = <<-END
-      <?xml version="1.0"?>
-      <!DOCTYPE greeting PUBLIC "Hello Greeting DTD" "http://foo/hello.dtd">
-      <greeting>Hello, world!</greeting>
-    END
-    parser = Parsers::SAX2Parser.new(xml)
-    dtl = SimpleDoctypeListener.new
-    parser.listen(dtl)
-    tname = nil
-    tpub_sys = nil
-    tlong_name = nil
-    turi = nil
-    parser.listen(:doctype) do |name, pub_sys, long_name, uri|
-      tname = name
-      tpub_sys = pub_sys
-      tlong_name = long_name
-      turi = uri
+    # test simple non-entity doctype in sax listener
+    # submitted by Jeff Barczewski
+    def test_simple_doctype_listener
+      xml = <<-END
+        <?xml version="1.0"?>
+        <!DOCTYPE greeting PUBLIC "Hello Greeting DTD" "http://foo/hello.dtd">
+        <greeting>Hello, world!</greeting>
+      END
+      parser = Parsers::SAX2Parser.new(xml)
+      dtl = SimpleDoctypeListener.new
+      parser.listen(dtl)
+      tname = nil
+      tpub_sys = nil
+      tlong_name = nil
+      turi = nil
+      parser.listen(:doctype) do |name, pub_sys, long_name, uri|
+        tname = name
+        tpub_sys = pub_sys
+        tlong_name = long_name
+        turi = uri
+      end
+      parser.parse
+      assert_equal 'greeting', tname, 'simple doctype block listener failed - incorrect name'
+      assert_equal 'PUBLIC', tpub_sys, 'simple doctype block listener failed - incorrect pub_sys'
+      assert_equal 'Hello Greeting DTD', tlong_name, 'simple doctype block listener failed - incorrect long_name'
+      assert_equal 'http://foo/hello.dtd', turi, 'simple doctype block listener failed - incorrect uri'
+      assert_equal 'greeting', dtl.name, 'simple doctype listener failed - incorrect name'
+      assert_equal 'PUBLIC', dtl.pub_sys, 'simple doctype listener failed - incorrect pub_sys'
+      assert_equal 'Hello Greeting DTD', dtl.long_name, 'simple doctype listener failed - incorrect long_name'
+      assert_equal 'http://foo/hello.dtd', dtl.uri, 'simple doctype listener failed - incorrect uri'
     end
-    parser.parse
-    assert_equal 'greeting', tname, 'simple doctype block listener failed - incorrect name'
-    assert_equal 'PUBLIC', tpub_sys, 'simple doctype block listener failed - incorrect pub_sys'
-    assert_equal 'Hello Greeting DTD', tlong_name, 'simple doctype block listener failed - incorrect long_name'
-    assert_equal 'http://foo/hello.dtd', turi, 'simple doctype block listener failed - incorrect uri'
-    assert_equal 'greeting', dtl.name, 'simple doctype listener failed - incorrect name'
-    assert_equal 'PUBLIC', dtl.pub_sys, 'simple doctype listener failed - incorrect pub_sys'
-    assert_equal 'Hello Greeting DTD', dtl.long_name, 'simple doctype listener failed - incorrect long_name'
-    assert_equal 'http://foo/hello.dtd', dtl.uri, 'simple doctype listener failed - incorrect uri'
-  end
 
-  # test doctype with missing name, should throw ParseException
-  # submitted by Jeff Barczewseki
-  def test_doctype_with_mising_name_throws_exception
-    xml = <<-END
-      <?xml version="1.0"?>
-      <!DOCTYPE >
-      <greeting>Hello, world!</greeting>
-    END
-    parser = Parsers::SAX2Parser.new(xml)
-    assert_raise(REXML::ParseException, 'doctype missing name did not throw ParseException') do
-      parser.parse
+    # test doctype with missing name, should throw ParseException
+    # submitted by Jeff Barczewseki
+    def test_doctype_with_mising_name_throws_exception
+      xml = <<-END
+        <?xml version="1.0"?>
+        <!DOCTYPE >
+        <greeting>Hello, world!</greeting>
+      END
+      parser = Parsers::SAX2Parser.new(xml)
+      assert_raise(REXML::ParseException, 'doctype missing name did not throw ParseException') do
+        parser.parse
+      end
     end
-  end
 
 
-  class KouListener
-    include REXML::SAX2Listener
-    attr_accessor :sdoc, :edoc
-    attr_reader :selem, :decl, :pi
-    def initialize
-      @sdoc = @edoc = @selem = false
-      @decl = 0
-      @pi = 0
-    end
-    def start_document
-      @sdoc = true
-    end
-    def end_document
-      @edoc = true
-    end
-    def xmldecl( *arg )
-      @decl += 1
-    end
-    def processing_instruction( *arg )
-      @pi += 1
-    end
-    def start_element( *arg )
-      @selem = true
+    class KouListener
+      include REXML::SAX2Listener
+      attr_accessor :sdoc, :edoc
+      attr_reader :selem, :decl, :pi
+      def initialize
+        @sdoc = @edoc = @selem = false
+        @decl = 0
+        @pi = 0
+      end
+      def start_document
+        @sdoc = true
+      end
+      def end_document
+        @edoc = true
+      end
+      def xmldecl( *arg )
+        @decl += 1
+      end
+      def processing_instruction( *arg )
+        @pi += 1
+      end
+      def start_element( *arg )
+        @selem = true
+      end
     end
-  end
 
-  # Submitted by Kou
-  def test_begin_end_document
-    parser = Parsers::SAX2Parser.new("<a/>")
+    # Submitted by Kou
+    def test_begin_end_document
+      parser = Parsers::SAX2Parser.new("<a/>")
 
-    kl = KouListener.new
-    parser.listen(kl)
-    sd = false
-    ed = false
-    parser.listen(:start_document) { sd = true }
-    parser.listen(:end_document) { ed = true }
+      kl = KouListener.new
+      parser.listen(kl)
+      sd = false
+      ed = false
+      parser.listen(:start_document) { sd = true }
+      parser.listen(:end_document) { ed = true }
 
-    parser.parse
-    assert( sd, ':start_document block failed' )
-    assert( ed, ':end_document block failed' )
-    assert( kl.sdoc, ':start_document listener failed' )
-    assert( kl.edoc, ':end_document listener failed' )
-  end
-
-  # Submitted by Kou
-  def test_listen_before_start
-    # FIXME: the following comment should be a test for validity. (The xml declaration
-    # is invalid).
-    #parser =  Parsers::SAX2Parser.new( "<?xml ?><?pi?><a><?pi?></a>")
-    parser =  Parsers::SAX2Parser.new( "<?xml version='1.0'?><?pi?><a><?pi?></a>")
-    k1 = KouListener.new
-    parser.listen( k1 )
-    xmldecl = false
-    pi = 0
-    parser.listen( :xmldecl ) { xmldecl = true }
-    parser.listen( :processing_instruction ) { pi += 1 }
+      parser.parse
+      assert( sd, ':start_document block failed' )
+      assert( ed, ':end_document block failed' )
+      assert( kl.sdoc, ':start_document listener failed' )
+      assert( kl.edoc, ':end_document listener failed' )
+    end
 
-    parser.parse
+    # Submitted by Kou
+    def test_listen_before_start
+      # FIXME: the following comment should be a test for validity. (The xml declaration
+      # is invalid).
+      #parser =  Parsers::SAX2Parser.new( "<?xml ?><?pi?><a><?pi?></a>")
+      parser =  Parsers::SAX2Parser.new( "<?xml version='1.0'?><?pi?><a><?pi?></a>")
+      k1 = KouListener.new
+      parser.listen( k1 )
+      xmldecl = false
+      pi = 0
+      parser.listen( :xmldecl ) { xmldecl = true }
+      parser.listen( :processing_instruction ) { pi += 1 }
 
-    assert( xmldecl, ':xmldecl failed' )
-    assert_equal( 2, pi, ':processing_instruction failed' )
-    assert( k1.decl, 'Listener for xmldecl failed' )
-    assert_equal( 2, k1.pi, 'Listener for processing instruction failed' )
-  end
+      parser.parse
 
+      assert( xmldecl, ':xmldecl failed' )
+      assert_equal( 2, pi, ':processing_instruction failed' )
+      assert( k1.decl, 'Listener for xmldecl failed' )
+      assert_equal( 2, k1.pi, 'Listener for processing instruction failed' )
+    end
 
-  def test_socket
-    require 'socket'
 
-    server = TCPServer.new('127.0.0.1', 0)
-    socket = TCPSocket.new('127.0.0.1', server.addr[1])
+    def test_socket
+      require 'socket'
 
-    ok = false
-    session = server.accept
-    session << '<foo>'
-    parser = REXML::Parsers::SAX2Parser.new(socket)
-    Fiber.new do
-      parser.listen(:start_element) do
-        ok = true
-        Fiber.yield
+      TCPServer.open('127.0.0.1', 0) do |server|
+        TCPSocket.open('127.0.0.1', server.addr[1]) do |socket|
+          ok = false
+          session = server.accept
+          begin
+            session << '<foo>'
+            parser = REXML::Parsers::SAX2Parser.new(socket)
+            Fiber.new do
+              parser.listen(:start_element) do
+                ok = true
+                Fiber.yield
+              end
+              parser.parse
+            end.resume
+            assert(ok)
+          ensure
+            session.close
+          end
+        end
       end
-      parser.parse
-    end.resume
-    assert(ok)
-  end
+    end
 
-  def test_char_ref_sax2()
-    parser = REXML::Parsers::SAX2Parser.new('<ABC>&#252;</ABC>')
-    result = nil
-    parser.listen(:characters) {|text| result = text.unpack('U*')}
-    parser.parse()
-    assert_equal(1, result.size)
-    assert_equal(252, result[0])
-  end
+    def test_char_ref_sax2()
+      parser = REXML::Parsers::SAX2Parser.new('<ABC>&#252;</ABC>')
+      result = nil
+      parser.listen(:characters) {|text| result = text.unpack('U*')}
+      parser.parse()
+      assert_equal(1, result.size)
+      assert_equal(252, result[0])
+    end
 
 
-  def test_char_ref_dom()
-    doc = REXML::Document.new('<ABC>&#252;</ABC>')
-    result = doc.root.text.unpack('U*')
-    assert_equal(1, result.size)
-    assert_equal(252, result[0])
-  end
+    def test_char_ref_dom()
+      doc = REXML::Document.new('<ABC>&#252;</ABC>')
+      result = doc.root.text.unpack('U*')
+      assert_equal(1, result.size)
+      assert_equal(252, result[0])
+    end
 
-  class Ticket68
-    include REXML::SAX2Listener
-  end
-  def test_ticket_68
-    parser = REXML::Parsers::SAX2Parser.new(File.new(fixture_path('ticket_68.xml')))
-    parser.listen( Ticket68.new )
-    begin
-      parser.parse
-    rescue
-      p parser.source.position
-      p parser.source.current_line
-      puts $!.backtrace.join("\n")
-      flunk $!.message
+    class Ticket68
+      include REXML::SAX2Listener
+    end
+    def test_ticket_68
+      File.open(fixture_path('ticket_68.xml')) do |f|
+        parser = REXML::Parsers::SAX2Parser.new(f)
+        parser.listen( Ticket68.new )
+        begin
+          parser.parse
+        rescue
+          p parser.source.position
+          p parser.source.current_line
+          puts $!.backtrace.join("\n")
+          flunk $!.message
+        end
+      end
     end
   end
-end
 
-class MySAX2Listener
-  include REXML::SAX2Listener
+  class MySAX2Listener
+    include REXML::SAX2Listener
+  end
 end
-
diff --git a/test/rexml/test_stream.rb b/test/rexml/test_stream.rb
index 0ae1bc6..08d4462 100644
--- a/test/rexml/test_stream.rb
+++ b/test/rexml/test_stream.rb
@@ -1,127 +1,130 @@
+# frozen_string_literal: false
 require "test/unit/testcase"
 require "rexml/document"
 require 'rexml/streamlistener'
 require 'stringio'
 
-class MyListener
-  include REXML::StreamListener
-end
+module REXMLTests
+  class MyListener
+    include REXML::StreamListener
+  end
 
 
-class StreamTester < Test::Unit::TestCase
-  # Submitted by Han Holl
-  def test_listener
-    data = %Q{<session1 user="han" password="rootWeiler" />\n<session2 user="han" password="rootWeiler" />}
+  class StreamTester < Test::Unit::TestCase
+    # Submitted by Han Holl
+    def test_listener
+      data = %Q{<session1 user="han" password="rootWeiler" />\n<session2 user="han" password="rootWeiler" />}
 
-    b = RequestReader.new( data )
-    b = RequestReader.new( data )
-  end
+      RequestReader.new( data )
+      RequestReader.new( data )
+    end
 
-  def test_ticket_49
-    source = StringIO.new( <<-EOL )
-    <!DOCTYPE foo [
-      <!ENTITY ent "replace">
-    ]>
-    <a>&ent;</a>
-    EOL
-    REXML::Document.parse_stream(source, MyListener.new)
-  end
+    def test_ticket_49
+      source = StringIO.new( <<-EOL )
+      <!DOCTYPE foo [
+        <!ENTITY ent "replace">
+      ]>
+      <a>&ent;</a>
+      EOL
+      REXML::Document.parse_stream(source, MyListener.new)
+    end
 
-  def test_ticket_10
-    source = StringIO.new( <<-EOL )
-    <!DOCTYPE foo [
-      <!ENTITY ent "replace">
-      <!ATTLIST a
-       xmlns:human CDATA #FIXED "http://www.foo.com/human">
-      <!ELEMENT bar (#PCDATA)>
-      <!NOTATION n1 PUBLIC "-//HM//NOTATION TEST1//EN" 'urn:x-henrikmartensson.org:test5'>
-    ]>
-    <a/>
-    EOL
-    listener = MyListener.new
-    class << listener
-      attr_accessor :events
-      def entitydecl( content )
-        @events[ :entitydecl ] = true
-      end
-      def attlistdecl( element_name, attributes, raw_content )
-        @events[ :attlistdecl ] = true
+    def test_ticket_10
+      source = StringIO.new( <<-EOL )
+      <!DOCTYPE foo [
+        <!ENTITY ent "replace">
+        <!ATTLIST a
+         xmlns:human CDATA #FIXED "http://www.foo.com/human">
+        <!ELEMENT bar (#PCDATA)>
+        <!NOTATION n1 PUBLIC "-//HM//NOTATION TEST1//EN" 'urn:x-henrikmartensson.org:test5'>
+      ]>
+      <a/>
+      EOL
+      listener = MyListener.new
+      class << listener
+        attr_accessor :events
+        def entitydecl( content )
+          @events[ :entitydecl ] = true
+        end
+        def attlistdecl( element_name, attributes, raw_content )
+          @events[ :attlistdecl ] = true
+        end
+        def elementdecl( content )
+          @events[ :elementdecl ] = true
+        end
+        def notationdecl( content )
+          @events[ :notationdecl ] = true
+        end
       end
-      def elementdecl( content )
-        @events[ :elementdecl ] = true
-      end
-      def notationdecl( content )
-        @events[ :notationdecl ] = true
-      end
-    end
-    listener.events = {}
+      listener.events = {}
 
-    REXML::Document.parse_stream( source, listener )
+      REXML::Document.parse_stream( source, listener )
 
-    assert( listener.events[:entitydecl] )
-    assert( listener.events[:attlistdecl] )
-    assert( listener.events[:elementdecl] )
-    assert( listener.events[:notationdecl] )
-  end
+      assert( listener.events[:entitydecl] )
+      assert( listener.events[:attlistdecl] )
+      assert( listener.events[:elementdecl] )
+      assert( listener.events[:notationdecl] )
+    end
 
-  def test_entity
-    listener = MyListener.new
-    class << listener
-      attr_accessor :entities
-      def entity(content)
-        @entities << content
+    def test_entity
+      listener = MyListener.new
+      class << listener
+        attr_accessor :entities
+        def entity(content)
+          @entities << content
+        end
       end
-    end
-    listener.entities = []
+      listener.entities = []
 
-    source = StringIO.new(<<-XML)
+      source = StringIO.new(<<-XML)
 <!DOCTYPE root [
 <!ENTITY % ISOLat2
          SYSTEM "http://www.xml.com/iso/isolat2-xml.entities" >
 %ISOLat2;
 ]>
 <root/>
-    XML
-    REXML::Document.parse_stream(source, listener)
+      XML
+      REXML::Document.parse_stream(source, listener)
 
-    assert_equal(["ISOLat2"], listener.entities)
+      assert_equal(["ISOLat2"], listener.entities)
+    end
   end
-end
 
 
-# For test_listener
-class RequestReader
-  attr_reader :doc
-  def initialize(io)
-    @stack = []
-    @doc = nil
-    catch(:fini) do
-      REXML::Document.parse_stream(io, self)
-      raise IOError
+  # For test_listener
+  class RequestReader
+    attr_reader :doc
+    def initialize(io)
+      @stack = []
+      @doc = nil
+      catch(:fini) do
+        REXML::Document.parse_stream(io, self)
+        raise IOError
+      end
     end
-  end
-  def tag_start(name, args)
-    if @doc
-      @stack.push(REXML::Element.new(name, @stack.last))
-    else
-      @doc = REXML::Document.new("<#{name}/>")
-      @stack.push(@doc.root)
+    def tag_start(name, args)
+      if @doc
+        @stack.push(REXML::Element.new(name, @stack.last))
+      else
+        @doc = REXML::Document.new("<#{name}/>")
+        @stack.push(@doc.root)
+      end
+      args.each do |attr,val|
+        @stack.last.add_attribute(attr, val)
+      end
     end
-    args.each do |attr,val|
-      @stack.last.add_attribute(attr, val)
+    def tag_end(name, *args)
+      @stack.pop
+      throw(:fini) if @stack.empty?
+    end
+    def text(str)
+      @stack.last.text = str
+    end
+    def comment(str)
+    end
+    def doctype( name, pub_sys, long_name, uri )
+    end
+    def doctype_end
     end
-  end
-  def tag_end(name, *args)
-    @stack.pop
-    throw(:fini) if @stack.empty?
-  end
-  def text(str)
-    @stack.last.text = str
-  end
-  def comment(str)
-  end
-  def doctype( name, pub_sys, long_name, uri )
-  end
-  def doctype_end
   end
 end
diff --git a/test/rexml/test_text.rb b/test/rexml/test_text.rb
index 81bc56b..e9a246e 100644
--- a/test/rexml/test_text.rb
+++ b/test/rexml/test_text.rb
@@ -1,19 +1,75 @@
-require "rexml/text"
+# frozen_string_literal: false
 
-class TextTester < Test::Unit::TestCase
-  include REXML
+require_relative "rexml_test_utils"
 
-  def test_shift_operator_chain
-    text = Text.new("original\r\n")
-    text << "append1\r\n" << "append2\r\n"
-    assert_equal("original\nappend1\nappend2\n", text.to_s)
-  end
+module REXMLTests
+  class TextTester < Test::Unit::TestCase
+    include REXML
+
+    def test_new_text_response_whitespace_default
+      text = Text.new("a  b\t\tc", true)
+      assert_equal("a b\tc", Text.new(text).to_s)
+    end
+
+    def test_new_text_response_whitespace_true
+      text = Text.new("a  b\t\tc", true)
+      assert_equal("a  b\t\tc", Text.new(text, true).to_s)
+    end
+
+    def test_new_text_raw_default
+      text = Text.new("&amp;lt;", false, nil, true)
+      assert_equal("&amp;lt;", Text.new(text).to_s)
+    end
+
+    def test_new_text_raw_false
+      text = Text.new("&amp;lt;", false, nil, true)
+      assert_equal("&amp;amp;lt;", Text.new(text, false, nil, false).to_s)
+    end
+
+    def test_new_text_entity_filter_default
+      document = REXML::Document.new(<<-XML)
+<!DOCTYPE root [
+  <!ENTITY a "aaa">
+  <!ENTITY b "bbb">
+]>
+<root/>
+      XML
+      text = Text.new("aaa bbb", false, document.root, nil, ["a"])
+      assert_equal("aaa &b;",
+                   Text.new(text, false, document.root).to_s)
+    end
+
+    def test_new_text_entity_filter_custom
+      document = REXML::Document.new(<<-XML)
+<!DOCTYPE root [
+  <!ENTITY a "aaa">
+  <!ENTITY b "bbb">
+]>
+<root/>
+      XML
+      text = Text.new("aaa bbb", false, document.root, nil, ["a"])
+      assert_equal("&a; bbb",
+                   Text.new(text, false, document.root, nil, ["b"]).to_s)
+    end
+
+    def test_shift_operator_chain
+      text = Text.new("original\r\n")
+      text << "append1\r\n" << "append2\r\n"
+      assert_equal("original\nappend1\nappend2\n", text.to_s)
+    end
+
+    def test_shift_operator_cache
+      text = Text.new("original\r\n")
+      text << "append1\r\n" << "append2\r\n"
+      assert_equal("original\nappend1\nappend2\n", text.to_s)
+      text << "append3\r\n" << "append4\r\n"
+      assert_equal("original\nappend1\nappend2\nappend3\nappend4\n", text.to_s)
+    end
 
-  def test_shift_operator_cache
-    text = Text.new("original\r\n")
-    text << "append1\r\n" << "append2\r\n"
-    assert_equal("original\nappend1\nappend2\n", text.to_s)
-    text << "append3\r\n" << "append4\r\n"
-    assert_equal("original\nappend1\nappend2\nappend3\nappend4\n", text.to_s)
+    def test_clone
+      text = Text.new("&amp;lt; <")
+      assert_equal(text.to_s,
+                   text.clone.to_s)
+    end
   end
 end
diff --git a/test/rexml/test_ticket_80.rb b/test/rexml/test_ticket_80.rb
index 629a213..ab6a57e 100644
--- a/test/rexml/test_ticket_80.rb
+++ b/test/rexml/test_ticket_80.rb
@@ -1,3 +1,4 @@
+# frozen_string_literal: false
 #------------------------------------------------------------------------------
 # file: rexml_test.rb
 # desc: test's REXML's XML/XPath implementation
@@ -9,9 +10,10 @@
 require 'test/unit'
 require 'rexml/document'
 
-class Ticket80 < Test::Unit::TestCase
+module REXMLTests
+  class Ticket80 < Test::Unit::TestCase
 
-  @@xmlstr = '<?xml version="1.0"?>
+    @@xmlstr = '<?xml version="1.0"?>
 <root xmlns="urn:some-xml-ns" xmlns:other="urn:some-other-xml-ns">
  <l1-foo>
   <l2 value="foo-01"/>
@@ -27,28 +29,29 @@ class Ticket80 < Test::Unit::TestCase
  </l1-bar>
 </root>'
 
-  #----------------------------------------------------------------------------
-  def test_xpathNamespacedChildWildcard
-    # tests the "prefix:*" node test syntax
-    out = Array.new
-    REXML::XPath.each( REXML::Document.new(@@xmlstr),
-                       '/ns:root/ns:*/ns:l2/@value',
-                       { 'ns' => 'urn:some-xml-ns' } ) do |node| out.push node.value ; end
-    chk = [ 'foo-01', 'foo-02', 'foo-03', 'bar-01', 'bar-02' ]
-    assert_equal chk, out
-  end
+    #----------------------------------------------------------------------------
+    def test_xpathNamespacedChildWildcard
+      # tests the "prefix:*" node test syntax
+      out = Array.new
+      REXML::XPath.each( REXML::Document.new(@@xmlstr),
+                         '/ns:root/ns:*/ns:l2/@value',
+                         { 'ns' => 'urn:some-xml-ns' } ) do |node| out.push node.value ; end
+      chk = [ 'foo-01', 'foo-02', 'foo-03', 'bar-01', 'bar-02' ]
+      assert_equal chk, out
+    end
 
-  #----------------------------------------------------------------------------
-  def test_xpathNamespacedChildWildcardWorkaround
-    # tests a workaround for the "prefix:*" node test syntax
-    out = Array.new
-    REXML::XPath.each( REXML::Document.new(@@xmlstr),
-                       '/ns:root/*[namespace-uri()="urn:some-xml-ns"]/ns:l2/@value',
-                       { 'ns' => 'urn:some-xml-ns' } ) do |node| out.push node.value ; end
-    chk = [ 'foo-01', 'foo-02', 'foo-03', 'bar-01', 'bar-02' ]
-    assert_equal chk, out
-  end
+    #----------------------------------------------------------------------------
+    def test_xpathNamespacedChildWildcardWorkaround
+      # tests a workaround for the "prefix:*" node test syntax
+      out = Array.new
+      REXML::XPath.each( REXML::Document.new(@@xmlstr),
+                         '/ns:root/*[namespace-uri()="urn:some-xml-ns"]/ns:l2/@value',
+                         { 'ns' => 'urn:some-xml-ns' } ) do |node| out.push node.value ; end
+      chk = [ 'foo-01', 'foo-02', 'foo-03', 'bar-01', 'bar-02' ]
+      assert_equal chk, out
+    end
 
+  end
 end
 
 #------------------------------------------------------------------------------
diff --git a/test/rexml/test_validation_rng.rb b/test/rexml/test_validation_rng.rb
index 3643f0c..b5b5045 100644
--- a/test/rexml/test_validation_rng.rb
+++ b/test/rexml/test_validation_rng.rb
@@ -1,13 +1,15 @@
+# frozen_string_literal: false
 require "test/unit/testcase"
 
 require "rexml/document"
 require "rexml/validation/relaxng"
 
-class RNGValidation < Test::Unit::TestCase
-  include REXML
+module REXMLTests
+  class RNGValidation < Test::Unit::TestCase
+    include REXML
 
-  def test_validate
-    rng = %q{
+    def test_validate
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -24,16 +26,16 @@ class RNGValidation < Test::Unit::TestCase
     </element>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    no_error( validator, %q{<A><B><C X="x"><E/><E/></C><D/></B></A>} )
-    error( validator, %q{<A><B><D/><C X="x"/></B></A>} )
-  end
+      no_error( validator, %q{<A><B><C X="x"><E/><E/></C><D/></B></A>} )
+      error( validator, %q{<A><B><D/><C X="x"/></B></A>} )
+    end
 
 
-  def test_sequence
-    rng = %q{
+    def test_sequence
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -45,18 +47,18 @@ class RNGValidation < Test::Unit::TestCase
     </element>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B><C/><C/><D/></B></A>} )
-    error( validator, %q{<A><B><D/><C/></B></A>} )
-    error( validator, %q{<A><C/><D/></A>} )
-    no_error( validator, %q{<A><B><C/><D/></B></A>} )
-  end
+      error( validator, %q{<A><B><C/><C/><D/></B></A>} )
+      error( validator, %q{<A><B><D/><C/></B></A>} )
+      error( validator, %q{<A><C/><D/></A>} )
+      no_error( validator, %q{<A><B><C/><D/></B></A>} )
+    end
 
 
-  def test_choice
-    rng = %q{
+    def test_choice
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -70,16 +72,16 @@ class RNGValidation < Test::Unit::TestCase
     </choice>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B><C/><D/></B></A>} )
-    no_error( validator, %q{<A><B><D/></B></A>} )
-    no_error( validator, %q{<A><B><C/></B></A>} )
-  end
+      error( validator, %q{<A><B><C/><D/></B></A>} )
+      no_error( validator, %q{<A><B><D/></B></A>} )
+      no_error( validator, %q{<A><B><C/></B></A>} )
+    end
 
-  def test_optional
-    rng = %q{
+    def test_optional
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -90,17 +92,17 @@ class RNGValidation < Test::Unit::TestCase
     </optional>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    no_error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><B><C/></B></A>} )
-    error( validator, %q{<A><B><D/></B></A>} )
-    error( validator, %q{<A><B><C/><C/></B></A>} )
-  end
+      no_error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><B><C/></B></A>} )
+      error( validator, %q{<A><B><D/></B></A>} )
+      error( validator, %q{<A><B><C/><C/></B></A>} )
+    end
 
-  def test_zero_or_more
-    rng = %q{
+    def test_zero_or_more
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -111,15 +113,15 @@ class RNGValidation < Test::Unit::TestCase
     </zeroOrMore>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
-    no_error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><B><C/></B></A>} )
-    no_error( validator, %q{<A><B><C/><C/><C/></B></A>} )
-    error( validator, %q{<A><B><D/></B></A>} )
-    error( validator, %q{<A></A>} )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
+      no_error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><B><C/></B></A>} )
+      no_error( validator, %q{<A><B><C/><C/><C/></B></A>} )
+      error( validator, %q{<A><B><D/></B></A>} )
+      error( validator, %q{<A></A>} )
 
-    rng = %q{
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -133,17 +135,17 @@ class RNGValidation < Test::Unit::TestCase
     </zeroOrMore>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    no_error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><B><C/><D/></B></A>} )
-    no_error( validator, %q{<A><B><C/><D/><C/><D/></B></A>} )
-    error( validator, %q{<A><B><D/></B></A>} )
-  end
+      no_error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><B><C/><D/></B></A>} )
+      no_error( validator, %q{<A><B><C/><D/><C/><D/></B></A>} )
+      error( validator, %q{<A><B><D/></B></A>} )
+    end
 
-  def test_one_or_more
-    rng = %q{
+    def test_one_or_more
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -154,34 +156,34 @@ class RNGValidation < Test::Unit::TestCase
     </oneOrMore>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
-
-    error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><B><C/></B></A>} )
-    no_error( validator, %q{<A><B><C/><C/><C/></B></A>} )
-    error( validator, %q{<A><B><D/></B></A>} )
-    error( validator, %q{<A></A>} )
-  end
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
+
+      error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><B><C/></B></A>} )
+      no_error( validator, %q{<A><B><C/><C/><C/></B></A>} )
+      error( validator, %q{<A><B><D/></B></A>} )
+      error( validator, %q{<A></A>} )
+    end
 
-  def test_attribute
-    rng = %q{
+    def test_attribute
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <attribute name="X"/>
   <attribute name="Y"/>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A/>} )
-    error( validator, %q{<A X=""/>} )
-    no_error( validator, %q{<A X="1" Y="1"/>} )
-  end
+      error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A/>} )
+      error( validator, %q{<A X=""/>} )
+      no_error( validator, %q{<A X="1" Y="1"/>} )
+    end
 
-  def test_choice_attributes
-    rng = %q{
+    def test_choice_attributes
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <choice>
@@ -189,17 +191,17 @@ class RNGValidation < Test::Unit::TestCase
     <attribute name="Y"/>
   </choice>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A X="1" Y="1"/>} )
-    error( validator, %q{<A/>} )
-    no_error( validator, %q{<A X="1"/>})
-    no_error( validator, %q{<A Y="1"/>} )
-  end
+      error( validator, %q{<A X="1" Y="1"/>} )
+      error( validator, %q{<A/>} )
+      no_error( validator, %q{<A X="1"/>})
+      no_error( validator, %q{<A Y="1"/>} )
+    end
 
-  def test_choice_attribute_element
-    rng = %q{
+    def test_choice_attribute_element
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <choice>
@@ -207,45 +209,45 @@ class RNGValidation < Test::Unit::TestCase
     <element name="B"/>
   </choice>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A X="1"><B/></A>} )
-    error( validator, %q{<A/>} )
-    no_error( validator, %q{<A X="1"/>})
-    no_error( validator, %q{<A><B/></A>} )
-  end
+      error( validator, %q{<A X="1"><B/></A>} )
+      error( validator, %q{<A/>} )
+      no_error( validator, %q{<A X="1"/>})
+      no_error( validator, %q{<A><B/></A>} )
+    end
 
-  def test_empty
-    rng = %q{
+    def test_empty
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <empty/>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A>Text</A>} )
-    no_error( validator, %q{<A/>})
-  end
+      error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A>Text</A>} )
+      no_error( validator, %q{<A/>})
+    end
 
-  def test_text_val
-    rng = %q{
+    def test_text_val
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <text/>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A>Text</A>} )
-    error( validator, %q{<A/>})
-  end
+      error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A>Text</A>} )
+      error( validator, %q{<A/>})
+    end
 
-  def test_choice_text
-    rng = %q{
+    def test_choice_text
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <choice>
@@ -253,17 +255,17 @@ class RNGValidation < Test::Unit::TestCase
     <text/>
   </choice>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/>Text</A>} )
-    error( validator, %q{<A>Text<B/></A>} )
-    no_error( validator, %q{<A>Text</A>} )
-    no_error( validator, %q{<A><B/></A>} )
-  end
+      error( validator, %q{<A><B/>Text</A>} )
+      error( validator, %q{<A>Text<B/></A>} )
+      no_error( validator, %q{<A>Text</A>} )
+      no_error( validator, %q{<A><B/></A>} )
+    end
 
-  def test_group
-    rng = %q{
+    def test_group
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <choice>
@@ -274,15 +276,15 @@ class RNGValidation < Test::Unit::TestCase
     </group>
   </choice>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/><C/></A>} )
-    error( validator, %q{<A><C/></A>} )
-    no_error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><C/><D/></A>} )
+      error( validator, %q{<A><B/><C/></A>} )
+      error( validator, %q{<A><C/></A>} )
+      no_error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><C/><D/></A>} )
 
-    rng = %q{
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B"/>
@@ -291,33 +293,33 @@ class RNGValidation < Test::Unit::TestCase
     <element name="D"/>
   </group>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/><C/></A>} )
-    error( validator, %q{<A><B/><D/></A>} )
-    error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><B/><C/><D/></A>} )
-  end
+      error( validator, %q{<A><B/><C/></A>} )
+      error( validator, %q{<A><B/><D/></A>} )
+      error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><B/><C/><D/></A>} )
+    end
 
-  def test_value
-    # Values as text nodes
-    rng = %q{
+    def test_value
+      # Values as text nodes
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
     <value>VaLuE</value>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B>X</B></A>} )
-    error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><B>VaLuE</B></A>} )
+      error( validator, %q{<A><B>X</B></A>} )
+      error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><B>VaLuE</B></A>} )
 
-    # Values as text nodes, via choice
-    rng = %q{
+      # Values as text nodes, via choice
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -327,32 +329,32 @@ class RNGValidation < Test::Unit::TestCase
     </choice>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A><B>XYZ</B></A>} )
-    no_error( validator, %q{<A><B>Option 1</B></A>} )
-    no_error( validator, %q{<A><B>Option 2</B></A>} )
+      error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A><B>XYZ</B></A>} )
+      no_error( validator, %q{<A><B>Option 1</B></A>} )
+      no_error( validator, %q{<A><B>Option 2</B></A>} )
 
-    # Attribute values
-    rng = %q{
+      # Attribute values
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <attribute name="B">
     <value>VaLuE</value>
   </attribute>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A/>} )
-    error( validator, %q{<A B=""/>} )
-    error( validator, %q{<A B="Lala"/>} )
-    no_error( validator, %q{<A B="VaLuE"/>} )
+      error( validator, %q{<A/>} )
+      error( validator, %q{<A B=""/>} )
+      error( validator, %q{<A B="Lala"/>} )
+      no_error( validator, %q{<A B="VaLuE"/>} )
 
-    # Attribute values via choice
-    rng = %q{
+      # Attribute values via choice
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <attribute name="B">
@@ -362,17 +364,17 @@ class RNGValidation < Test::Unit::TestCase
     </choice>
   </attribute>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A B=""/>} )
-    error( validator, %q{<A B="Value"/>} )
-    no_error( validator, %q{<A B="Option 1"></A>} )
-    no_error( validator, %q{<A B="Option 2"/>} )
-  end
+      error( validator, %q{<A B=""/>} )
+      error( validator, %q{<A B="Value"/>} )
+      no_error( validator, %q{<A B="Option 1"></A>} )
+      no_error( validator, %q{<A B="Option 2"/>} )
+    end
 
-  def test_interleave
-    rng = %q{
+    def test_interleave
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -383,20 +385,20 @@ class RNGValidation < Test::Unit::TestCase
     </interleave>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
-
-    error( validator, %q{<A><B><C/></B></A>} )
-    error( validator, %q{<A><B><C/><D/><C/></B></A>} )
-    no_error( validator, %q{<A><B><C/><D/><E/></B></A>} )
-    no_error( validator, %q{<A><B><E/><D/><C/></B></A>} )
-    no_error( validator, %q{<A><B><D/><C/><E/></B></A>} )
-    no_error( validator, %q{<A><B><E/><C/><D/></B></A>} )
-    error( validator, %q{<A><B><E/><C/><D/><C/></B></A>} )
-  end
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-  def test_mixed
-    rng = %q{
+      error( validator, %q{<A><B><C/></B></A>} )
+      error( validator, %q{<A><B><C/><D/><C/></B></A>} )
+      no_error( validator, %q{<A><B><C/><D/><E/></B></A>} )
+      no_error( validator, %q{<A><B><E/><D/><C/></B></A>} )
+      no_error( validator, %q{<A><B><D/><C/><E/></B></A>} )
+      no_error( validator, %q{<A><B><E/><C/><D/></B></A>} )
+      error( validator, %q{<A><B><E/><C/><D/><C/></B></A>} )
+    end
+
+    def test_mixed
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <element name="A" xmlns="http://relaxng.org/ns/structure/1.0">
   <element name="B">
@@ -405,15 +407,15 @@ class RNGValidation < Test::Unit::TestCase
     </mixed>
   </element>
 </element>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    no_error( validator, %q{<A><B>Text<D/></B></A>} )
-    no_error( validator, %q{<A><B><D/>Text</B></A>} )
-  end
+      no_error( validator, %q{<A><B>Text<D/></B></A>} )
+      no_error( validator, %q{<A><B><D/>Text</B></A>} )
+    end
 
-  def test_ref_sequence
-    rng = %q{
+    def test_ref_sequence
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -429,15 +431,15 @@ class RNGValidation < Test::Unit::TestCase
     </element>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    no_error( validator, %q{<A><B X=''/><B X=''/></A>} )
-    error( validator, %q{<A><B X=''/></A>} )
-  end
+      no_error( validator, %q{<A><B X=''/><B X=''/></A>} )
+      error( validator, %q{<A><B X=''/></A>} )
+    end
 
-  def test_ref_choice
-    rng = %q{
+    def test_ref_choice
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -453,15 +455,15 @@ class RNGValidation < Test::Unit::TestCase
     <element name="C"/>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><D/></A>} )
-    error( validator, %q{<A><B/><C/></A>} )
-    no_error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><C/></A>} )
+      error( validator, %q{<A><D/></A>} )
+      error( validator, %q{<A><B/><C/></A>} )
+      no_error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><C/></A>} )
 
-    rng = %q{
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -477,15 +479,15 @@ class RNGValidation < Test::Unit::TestCase
     </choice>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><D/></A>} )
-    error( validator, %q{<A><B/><C/></A>} )
-    no_error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><C/></A>} )
+      error( validator, %q{<A><D/></A>} )
+      error( validator, %q{<A><B/><C/></A>} )
+      no_error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><C/></A>} )
 
-    rng = %q{
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -502,18 +504,18 @@ class RNGValidation < Test::Unit::TestCase
     <element name="C"/>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/><C/></A>} )
-    no_error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><C/></A>} )
-    no_error( validator, %q{<A><D/></A>} )
-  end
+      error( validator, %q{<A><B/><C/></A>} )
+      no_error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><C/></A>} )
+      no_error( validator, %q{<A><D/></A>} )
+    end
 
 
-  def test_ref_zero_plus
-    rng = %q{
+    def test_ref_zero_plus
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -530,15 +532,15 @@ class RNGValidation < Test::Unit::TestCase
     </element>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A/>} )
-    no_error( validator, %q{<A><B X=''/></A>} )
-    no_error( validator, %q{<A><B X=''/><B X=''/><B X=''/></A>} )
+      error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A/>} )
+      no_error( validator, %q{<A><B X=''/></A>} )
+      no_error( validator, %q{<A><B X=''/><B X=''/><B X=''/></A>} )
 
-    rng = %q{
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -555,18 +557,18 @@ class RNGValidation < Test::Unit::TestCase
     </zeroOrMore>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A/>} )
-    no_error( validator, %q{<A><B X=''/></A>} )
-    no_error( validator, %q{<A><B X=''/><B X=''/><B X=''/></A>} )
-  end
+      error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A/>} )
+      no_error( validator, %q{<A><B X=''/></A>} )
+      no_error( validator, %q{<A><B X=''/><B X=''/><B X=''/></A>} )
+    end
 
 
-  def test_ref_one_plus
-    rng = %q{
+    def test_ref_one_plus
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -583,15 +585,15 @@ class RNGValidation < Test::Unit::TestCase
     </element>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A/>} )
-    no_error( validator, %q{<A><B X=''/></A>} )
-    no_error( validator, %q{<A><B X=''/><B X=''/><B X=''/></A>} )
+      error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A/>} )
+      no_error( validator, %q{<A><B X=''/></A>} )
+      no_error( validator, %q{<A><B X=''/><B X=''/><B X=''/></A>} )
 
-    rng = %q{
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -608,17 +610,17 @@ class RNGValidation < Test::Unit::TestCase
     </oneOrMore>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A/>} )
-    no_error( validator, %q{<A><B X=''/></A>} )
-    no_error( validator, %q{<A><B X=''/><B X=''/><B X=''/></A>} )
-  end
+      error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A/>} )
+      no_error( validator, %q{<A><B X=''/></A>} )
+      no_error( validator, %q{<A><B X=''/><B X=''/><B X=''/></A>} )
+    end
 
-  def test_ref_interleave
-    rng = %q{
+    def test_ref_interleave
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -634,16 +636,16 @@ class RNGValidation < Test::Unit::TestCase
     <element name="C"/>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A><C/></A>} )
-    error( validator, %q{<A><C/><C/></A>} )
-    no_error( validator, %q{<A><B/><C/></A>} )
-    no_error( validator, %q{<A><C/><B/></A>} )
+      error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A><C/></A>} )
+      error( validator, %q{<A><C/><C/></A>} )
+      no_error( validator, %q{<A><B/><C/></A>} )
+      no_error( validator, %q{<A><C/><B/></A>} )
 
-    rng = %q{
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -659,16 +661,16 @@ class RNGValidation < Test::Unit::TestCase
     </interleave>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A><C/></A>} )
-    error( validator, %q{<A><C/><C/></A>} )
-    no_error( validator, %q{<A><B/><C/></A>} )
-    no_error( validator, %q{<A><C/><B/></A>} )
+      error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A><C/></A>} )
+      error( validator, %q{<A><C/><C/></A>} )
+      no_error( validator, %q{<A><B/><C/></A>} )
+      no_error( validator, %q{<A><C/><B/></A>} )
 
-    rng = %q{
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -687,18 +689,18 @@ class RNGValidation < Test::Unit::TestCase
     <element name="C"/>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
-
-    error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A><C/></A>} )
-    error( validator, %q{<A><C/><C/></A>} )
-    no_error( validator, %q{<A><B/><C/></A>} )
-    no_error( validator, %q{<A><C/><B/></A>} )
-  end
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
+
+      error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A><C/></A>} )
+      error( validator, %q{<A><C/><C/></A>} )
+      no_error( validator, %q{<A><B/><C/></A>} )
+      no_error( validator, %q{<A><C/><B/></A>} )
+    end
 
-  def test_ref_recurse
-    rng = %q{
+    def test_ref_recurse
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -715,16 +717,16 @@ class RNGValidation < Test::Unit::TestCase
     </element>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    error( validator, %q{<A></A>} )
-    no_error( validator, %q{<A><B/></A>} )
-    no_error( validator, %q{<A><B><B/></B></A>} )
-  end
+      error( validator, %q{<A></A>} )
+      no_error( validator, %q{<A><B/></A>} )
+      no_error( validator, %q{<A><B><B/></B></A>} )
+    end
 
-  def test_ref_optional
-    rng = %q{
+    def test_ref_optional
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -740,15 +742,15 @@ class RNGValidation < Test::Unit::TestCase
     </element>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    no_error( validator, %q{<A></A>} )
-    no_error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A><B/><B/></A>} )
-    error( validator, %q{<A><C/></A>} )
+      no_error( validator, %q{<A></A>} )
+      no_error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A><B/><B/></A>} )
+      error( validator, %q{<A><C/></A>} )
 
-    rng = %q{
+      rng = %q{
 <?xml version="1.0" encoding="UTF-8"?>
 <grammar xmlns="http://relaxng.org/ns/structure/1.0">
   <start>
@@ -764,27 +766,28 @@ class RNGValidation < Test::Unit::TestCase
     </optional>
   </define>
 </grammar>
-    }
-    validator = REXML::Validation::RelaxNG.new( rng )
+      }
+      validator = REXML::Validation::RelaxNG.new( rng )
 
-    no_error( validator, %q{<A></A>} )
-    no_error( validator, %q{<A><B/></A>} )
-    error( validator, %q{<A><B/><B/></A>} )
-    error( validator, %q{<A><C/></A>} )
-  end
+      no_error( validator, %q{<A></A>} )
+      no_error( validator, %q{<A><B/></A>} )
+      error( validator, %q{<A><B/><B/></A>} )
+      error( validator, %q{<A><C/></A>} )
+    end
 
 
 
-  def error( validator, source )
-    parser = REXML::Parsers::TreeParser.new( source )
-    parser.add_listener( validator.reset )
-    assert_raise( REXML::Validation::ValidationException,
-                  "Expected a validation error" ) { parser.parse }
-  end
+    def error( validator, source )
+      parser = REXML::Parsers::TreeParser.new( source )
+      parser.add_listener( validator.reset )
+      assert_raise( REXML::Validation::ValidationException,
+                    "Expected a validation error" ) { parser.parse }
+    end
 
-  def no_error( validator, source )
-    parser = REXML::Parsers::TreeParser.new( source )
-    parser.add_listener( validator.reset )
-    assert_nothing_raised { parser.parse }
+    def no_error( validator, source )
+      parser = REXML::Parsers::TreeParser.new( source )
+      parser.add_listener( validator.reset )
+      assert_nothing_raised { parser.parse }
+    end
   end
 end
diff --git a/test/rexml/test_xml_declaration.rb b/test/rexml/test_xml_declaration.rb
index eb717bf..da70761 100644
--- a/test/rexml/test_xml_declaration.rb
+++ b/test/rexml/test_xml_declaration.rb
@@ -1,4 +1,4 @@
-# -*- coding: utf-8 -*-
+# frozen_string_literal: false
 #
 #  Created by Henrik Mrtensson on 2007-02-18.
 #  Copyright (c) 2007. All rights reserved.
@@ -6,28 +6,43 @@
 require "rexml/document"
 require "test/unit"
 
-class TestXmlDeclaration < Test::Unit::TestCase
-  def setup
-    xml = <<-'END_XML'
-    <?xml encoding= 'UTF-8' standalone='yes'?>
-    <root>
-    </root>
-    END_XML
-    @doc = REXML::Document.new xml
-    @root = @doc.root
-    @xml_declaration = @doc.children[0]
-  end
+module REXMLTests
+  class TestXmlDeclaration < Test::Unit::TestCase
+    def setup
+      xml = <<-XML
+      <?xml encoding= 'UTF-8' standalone='yes'?>
+      <root>
+      </root>
+      XML
+      @doc = REXML::Document.new xml
+      @root = @doc.root
+      @xml_declaration = @doc.children[0]
+    end
 
-  def test_is_first_child
-    assert_kind_of(REXML::XMLDecl, @xml_declaration)
-  end
+    def test_is_first_child
+      assert_kind_of(REXML::XMLDecl, @xml_declaration)
+    end
 
-  def test_has_document_as_parent
-   assert_kind_of(REXML::Document, @xml_declaration.parent)
-  end
+    def test_has_document_as_parent
+     assert_kind_of(REXML::Document, @xml_declaration.parent)
+    end
+
+    def test_has_sibling
+      assert_kind_of(REXML::XMLDecl, @root.previous_sibling.previous_sibling)
+      assert_kind_of(REXML::Element, @xml_declaration.next_sibling.next_sibling)
+    end
+
+    def test_write_prologue_quote
+      @doc.context[:prologue_quote] = :quote
+      assert_equal("<?xml version=\"1.0\" " +
+                   "encoding=\"UTF-8\" standalone=\"yes\"?>",
+                   @xml_declaration.to_s)
+    end
 
-  def test_has_sibling
-    assert_kind_of(REXML::XMLDecl, @root.previous_sibling.previous_sibling)
-    assert_kind_of(REXML::Element, @xml_declaration.next_sibling.next_sibling)
+    def test_is_writethis_attribute_copied_by_clone
+      assert_equal(true, @xml_declaration.clone.writethis)
+      @xml_declaration.nowrite
+      assert_equal(false, @xml_declaration.clone.writethis)
+    end
   end
 end
diff --git a/test/rexml/test_xpath.rb b/test/rexml/test_xpath.rb
deleted file mode 100644
index 927909a..0000000
--- a/test/rexml/test_xpath.rb
+++ /dev/null
@@ -1,1079 +0,0 @@
-require_relative "rexml_test_utils"
-
-require "rexml/document"
-
-class XPathTester < Test::Unit::TestCase
-  include REXMLTestUtils
-  include REXML
-  SOURCE = <<-EOF
-    <a id='1'>
-      <b id='2' x='y'>
-        <c id='3'/>
-        <c id='4'/>
-      </b>
-      <d id='5'>
-        <c id='6' x='y'/>
-        <c id='7'/>
-        <c id='8'/>
-        <q id='19'/>
-      </d>
-      <e id='9'>
-        <f id='10' a='b'/>
-        <f id='11' a='c'/>
-        <f id='12' a='d'>
-          <g id='13'/>
-        </f>
-        <f id='14' a='d'/>
-      </e>
-      <m id='15'>
-        <n id='16'>
-          <o id='17'>
-            <p id='18'/>
-          </o>
-        </n>
-      </m>
-    </a>
-    EOF
-  JENI_TENNISON = <<-EOJT
-  <a>
-    <b>
-      <c>
-        <d>
-          <e id='x'>
-            <f/>
-          </e>
-        </d>
-      </c>
-      <c>
-        <d>
-          <e id='y'/>
-        </d>
-      </c>
-    </b>
-    <b>
-      <c>
-        <d>
-          <e id='z'/>
-        </d>
-      </c>
-    </b>
-  </a>
-  EOJT
-
-  def setup
-    @@doc = Document.new(SOURCE) unless defined? @@doc
-    @@jeni = Document.new( JENI_TENNISON ) unless defined? @@jeni
-  end
-
-  def each_test( element, xpath )
-    count = 0
-    XPath::each( element, xpath ) { |child|
-      count += 1
-      yield child if block_given?
-    }
-    count
-  end
-
-  def test_descendant
-    doc = Document.new("<a><b><c id='1'/></b><d><b><c id='2'/></b></d></a>")
-    p = XPath.match( doc, "//c" )
-    assert_equal( 2, p.size )
-    p = XPath.first( @@doc, "//p" )
-    assert_equal "p", p.name
-    c = each_test( @@doc, "//c" ) { |child| assert_equal "c", child.name }
-    assert_equal 5, c
-    c = each_test( @@doc.root, "b//c" ) { |child|
-        assert_equal "c", child.name
-    }
-    assert_equal 2, c
-
-    doc = Document.new( "<a><z id='1'/><b><z id='11'/><z id='12'/></b><c><z id='21'/><z id='22'/><d><z id='31'/><z id='32'/></d></c></a>" )
-    # //para[1] : all descendants which are the first para child of their parent
-    assert_equal( 4, XPath.match( doc, "//z[1]" ).size )
-    # /descendant::para[1] : the first descendant para element
-    assert_equal( 1, XPath.match( doc, "/descendant::z[1]" ).size )
-  end
-
-  def test_root
-    source = "<a><b/></a>"
-    doc = Document.new( source )
-    assert_equal doc, doc.root_node
-    assert_equal "a", XPath::first( doc, "/" ).elements[1].name
-  end
-
-  def test_abbreviated_simple_child
-    assert_equal "a", XPath::first(@@doc, "a").name
-  end
-
-  def test_child
-    c = XPath::first( @@doc, "a/b/c" )
-    assert_equal "c", c.name
-    assert_equal "3", XPath::first(@@doc, "a/b/c").attributes["id"]
-  end
-
-  def test_root_child
-    assert_equal "a", XPath::first(@@doc, "/a").name
-    c = XPath::first( @@doc, "a/b/c" )
-    assert_equal "a", XPath::first(c, "/a").name
-  end
-
-  def test_root_children
-    c = XPath::first( @@doc, "a/b/c" )
-    assert_equal "2", XPath::first(c, "/a/b").attributes["id"]
-  end
-
-  def test_abbreviated_step
-    c = XPath::first( @@doc, "a/b/c" )
-    assert_equal("c", c.name)
-    assert_equal("a", XPath::first(@@doc.root, ".").name)
-    assert_equal("b", XPath::first(c, "..").name)
-    assert_equal("a", XPath::first(@@doc, "a/b/..").name)
-
-    doc = REXML::Document.new(File.new(fixture_path("project.xml")))
-    c = each_test(doc.root, "./Description" ) { |child|
-      assert_equal("Description",child.name)
-    }
-    assert_equal 1, c
-  end
-
-  # Things that aren't tested elsewhere
-  def test_predicates
-    assert_equal "12", XPath::first(@@doc, "a/e/f[3]").attributes["id"]
-    assert_equal "13", XPath::first(@@doc, "a/e/f[3]/g").attributes["id"]
-    assert_equal "14", XPath::first(@@doc, "a/e/f[@a='d'][2]").attributes["id"]
-    assert_equal "14", XPath::first(@@doc, "a/e/f[@a='d'][@id='14']").attributes["id"]
-    assert_equal "a", XPath::first( @@doc, "*[name()='a' and @id='1']" ).name
-    c=each_test( @@doc, "//*[name()='f' and @a='d']") { |i|
-      assert_equal "f", i.name
-    }
-    assert_equal 2, c
-    c=each_test( @@doc, "//*[name()='m' or @a='d']") { |i|
-      assert ["m","f"].include?(i.name)
-    }
-    assert_equal 3, c
-
-    assert_equal "b", XPath::first( @@doc, "//b[@x]" ).name
-  end
-
-  def test_node_type
-    doc = Document.new "<a><?foo bar?><!--comment-->text</a>"
-    #res = XPath::first(doc.root, "text()")
-    #assert_equal "text", res.to_s
-
-    #res = XPath::first(doc, "*")
-    #assert_equal "a", res.name
-
-    assert_equal( :processing_instruction,
-    XPath::first(doc.root, "processing-instruction()").node_type)
-    assert_equal( :comment, XPath::first(doc.root, "comment()").node_type)
-  end
-
-  def test_functions
-    # trivial text() test
-    # confuse-a-function
-    source = "<a>more <b id='1'/><b id='2'>dumb</b><b id='3'/><c/> text</a>"
-    doc = Document.new source
-    res = ""
-    #XPath::each(doc.root, "text()") {|val| res << val.to_s}
-    #assert_equal "more  text", res
-
-    #res = XPath::first(doc.root, "b[last()]")
-    #assert_equal '3', res.attributes['id']
-    res = XPath::first(doc.root, "b[position()=2]")
-    assert_equal '2', res.attributes['id']
-    res = XPath::first(doc.root, "*[name()='c']")
-    assert_equal "c", res.name
-  end
-
-  def no_test_ancestor
-    doc = REXML::Document.new(File.new(fixture_path("testsrc.xml")))
-    doc.elements.each("//item") { |el| print el.name
-      if el.attributes['x']
-        puts " -- "+el.attributes['x']
-      else
-        puts
-      end
-    }
-    doc.elements.each("//item/ancestor::") { |el| print el.name
-      if el.attributes['x']
-        puts " -- "+el.attributes['x']
-      else
-        puts
-      end
-    }
-  end
-
-  # Here are some XPath tests that were originally submitted by ...
-  # The code has changed some, but the logic and the source documents are the
-  # same.
-  # This method reads a document from a file, and then a series of xpaths,
-  # also from a file.  It then checks each xpath against the source file.
-  def test_more
-    xmlsource   = fixture_path("testsrc.xml")
-    xpathtests  = fixture_path("xp.tst")
-
-    doc = REXML::Document.new(File.new(xmlsource))
-    #results = ""
-    results = REXML::Document.new
-    results.add_element "test-results"
-    for line in File.new(xpathtests)
-      line.strip!
-      begin
-        doc.root
-        #puts "#"*80
-        #print "\nDoing #{line} " ; $stdout.flush
-        doc.elements.each(line) do |el|
-          #print "." ; $stdout.flush
-          results.root << el.clone
-          #results << el.to_s
-        end
-        #ObjectSpace.garbage_collect
-        GC::start
-      rescue Exception => z
-        #puts "\n'#{line}' failed"
-        fail("Error on line #{line}:\n#{z.message}\n"+z.backtrace[0,10].join("\n"))
-        #results.root.add_element( "error", {"path"=>line}).text = z.message+"\n"+z.backtrace[0,10].join("\n")
-        #results << "<error path='"+line+"'>"+z.message+"</error>"
-      end
-    end
-  end
-
-  def test_axe_descendant
-    assert_equal "f", XPath::first( @@doc, "descendant::f").name
-  end
-
-  def test_axe_parent
-    q = XPath.first( @@doc, "a/d/c/parent::*/q" )
-    assert_equal 19, q.attributes["id"].to_i
-  end
-
-  def test_abbreviated_attribute
-    assert_equal 'a', XPath::first( @@doc, "a[@id='1']" ).name
-    c = XPath::first( @@doc, "a/b/c[@id='4']" )
-    assert_equal 'c', c.name
-    assert_equal '4', c.attributes['id']
-
-    result = XPath::first( @@doc, "descendant::f[@a='c']")
-    assert_equal "11", result.attributes['id']
-
-    assert_equal "11", XPath::first(@@doc, "a/e/f[@a='c']").attributes["id"]
-    assert_equal "11", XPath::first(@@doc, "a/e/*[@a='c']").attributes["id"]
-  end
-
-  def test_axe_self
-    c = XPath::first( @@doc, "a/b/c" )
-    assert c
-    assert_equal "c", c.name
-    assert_equal "c", XPath::first( c, "self::node()" ).name
-  end
-
-  def test_axe_ancestor
-    doc = REXML::Document.new "
-    <a>
-      <b id='1'>
-        <c>
-          <b id='2'>
-            <d/>
-          </b>
-        </c>
-      </b>
-    </a>"
-
-    d = XPath.first( doc, "//d" )
-    assert_equal "d", d.name
-    b = each_test( d, "ancestor::b" ) { |el|
-      assert((1..2) === el.attributes['id'].to_i,
-        "Expected #{el.attributes['id']} to be either 1 or 2"
-      )
-    }
-    assert_equal 2, b
-  end
-
-  def test_axe_child
-    m = XPath.first( @@doc, "a/child::m" )
-    assert_equal 15, m.attributes['id'].to_i
-  end
-
-  def test_axe_attribute
-    a = XPath.first( @@doc, "a/attribute::id" )
-    assert_equal "1", a.value
-    a = XPath.first( @@doc, "a/e/f[@id='14']/attribute::a" )
-    assert_equal "d", a.value
-  end
-
-  def test_axe_sibling
-    doc = Document.new "<a><b><c/></b><e><f id='10'/><f id='11'/><f id='12'/></e></a>"
-    first_f = XPath.first( doc, "a/e/f" )
-    assert first_f
-    assert_equal '10', first_f.attributes['id']
-    next_f = XPath.first( doc, "a/e/f/following-sibling::node()" )
-    assert_equal '11', next_f.attributes['id']
-
-    b = XPath.first( doc, "a/e/preceding-sibling::node()" )
-    assert_equal 'b', b.name
-  end
-
-  def test_lang
-    doc = Document.new(File.new(fixture_path("lang0.xml")))
-    #puts IO.read( "test/lang.xml" )
-
-    #puts XPath.match( doc, "//language/*" ).size
-    c = each_test( doc, "//language/*" ) { |element|
-      #puts "#{element.name}: #{element.text}"
-    }
-    assert_equal 4, c
-  end
-
-  def test_namespaces_1
-    source = <<-EOF
-      <foo xmlns:ts="this" xmlns:tt="that">
-        <ts:bar>this bar</ts:bar>
-        <tt:bar>that bar</tt:bar>
-      </foo>
-    EOF
-    doc = Document.new source
-    XPath.each( doc, "//bar" ) {
-      fail "'bar' should match nothing in this case"
-    }
-
-    namespace = {"t"=>"this"}
-    results = XPath.first( doc, "//t:bar", namespace )
-    assert_equal "this bar", results.text
-  end
-
-  def test_namespaces_2
-    source = <<-EOF
-      <foo xmlns:ts="this" xmlns:tt="that">
-        <ts:bar>this bar</ts:bar>
-        <tt:bar>that bar</tt:bar>
-      </foo>
-    EOF
-    doc = Document.new source
-    res = XPath::first(doc, "//*[local_name()='bar']")
-    assert res, "looking for //*[name()='bar']"
-    assert_equal 'this', res.namespace
-    res = XPath::first(doc.root, "*[namespace_uri()='that']")
-    assert_equal 'that bar', res.text
-  end
-
-  def test_complex
-    next_f = XPath.first( @@doc, "a/e/f[@id='11']/following-sibling::*" )
-    assert_equal 12, next_f.attributes['id'].to_i
-    prev_f = XPath.first( @@doc, "a/e/f[@id='11']/preceding-sibling::*" )
-    assert_equal 10, prev_f.attributes['id'].to_i
-    c = each_test( @@doc, "descendant-or-self::*[@x='y']" )
-    assert_equal 2, c
-  end
-
-  def test_grouping
-    t = XPath.first( @@doc, "a/d/*[name()='d' and (name()='f' or name()='q')]" )
-    assert_nil t
-    t = XPath.first( @@doc, "a/d/*[(name()='d' and name()='f') or name()='q']" )
-    assert_equal 'q', t.name
-  end
-
-  def test_preceding
-    d = Document.new "<a><b id='0'/><b id='2'/><b><c id='0'/><c id='1'/><c id='2'/></b><b id='1'/></a>"
-    start = XPath.first( d, "/a/b[@id='1']" )
-    assert_equal 'b', start.name
-    c = XPath.first( start, "preceding::c" )
-    assert_equal '2', c.attributes['id']
-
-    c1, c0 = XPath.match( d, "/a/b/c[@id='2']/preceding::node()" )
-    assert_equal '1', c1.attributes['id']
-    assert_equal '0', c0.attributes['id']
-
-    c2, c1, c0, b, b2, b0 = XPath.match( start, "preceding::node()" )
-
-    assert_equal 'c', c2.name
-    assert_equal 'c', c1.name
-    assert_equal 'c', c0.name
-    assert_equal 'b', b.name
-    assert_equal 'b', b2.name
-    assert_equal 'b', b0.name
-
-    assert_equal '2', c2.attributes['id']
-    assert_equal '1', c1.attributes['id']
-    assert_equal '0', c0.attributes['id']
-    assert b.attributes.empty?
-    assert_equal '2', b2.attributes['id']
-    assert_equal '0', b0.attributes['id']
-
-    d = REXML::Document.new("<a><b/><c/><d/></a>")
-    matches = REXML::XPath.match(d, "/a/d/preceding::node()")
-    assert_equal("c", matches[0].name)
-    assert_equal("b", matches[1].name)
-
-    s = "<a><b><c id='1'/></b><b><b><c id='2'/><c id='3'/></b><c id='4'/></b><c id='NOMATCH'><c id='5'/></c></a>"
-    d = REXML::Document.new(s)
-    c = REXML::XPath.match( d, "//c[@id = '5']")
-    cs = REXML::XPath.match( c, "preceding::c" )
-    assert_equal( 4, cs.length )
-  end
-
-  def test_following
-    d = Document.new "<a><b id='0'/><b/><b><c id='1'/><c id='2'/></b><b id='1'/></a>"
-    start = XPath.first( d, "/a/b[@id='0']" )
-    assert_equal 'b', start.name
-    c = XPath.first( start, "following::c" )
-    assert_equal '1', c.attributes['id']
-
-    s = "<a><b><c><d/></c><e/></b><f><g><h/><i/></g></f><i/></a>"
-    d = Document.new(s)
-    c = XPath.first(d, '/a/b/c')
-    assert_equal 'c', c.name
-    res = XPath.match( c, 'following::*' )
-    assert_equal 6, res.size
-    res = XPath.match( c, 'following::i' )
-    assert_equal 2, res.size
-  end
-
-  # The following three paths were provided by
-  # Jeni Tennison <jeni@jenitennison.com>
-  # a consultant who is also an XSL and XPath expert
-  #def test_child_cubed
-  #  els = @@jeni.elements.to_a("*****")
-  #  assert_equal 3, els.size
-  #end
-
-  #def test_div_2
-  #  results = doc.elements.to_a("/ div 2")
-  #end
-
-  #def test_nested_predicates
-  #  puts @@jeni.root.elements[1].elements[1].name
-  #  results = @@jeni.root.elements[1].elements[1].elements.to_a("../following-sibling::*[*[name() = name(current())]]")
-  #  puts results
-  #end
-
-  # Contributed by Mike Stok
-  def test_starts_with
-    source = <<-EOF
-      <foo>
-      <a href="mailto:a@b.c">a@b.c</a>
-      <a href="http://www.foo.com">http://www.foo.com</a>
-      </foo>
-    EOF
-    doc = Document.new source
-    mailtos = doc.elements.to_a("//a[starts-with(@href, 'mailto:')]")
-    assert_equal 1, mailtos.size
-    assert_equal "mailto:a@b.c", mailtos[0].attributes['href']
-
-    ailtos = doc.elements.to_a("//a[starts-with(@href, 'ailto:')]")
-    assert_equal 0, ailtos.size
-  end
-
-  def test_toms_text_node
-    file = "<a>A<b>B</b><c>C<d>D</d>E</c>F</a>"
-    doc = Document.new(file)
-    assert_equal 'A', XPath.first(doc[0], 'text()').to_s
-    assert_equal 'AF', XPath.match(doc[0], 'text()').collect { |n|
-      n.to_s
-    }.join('')
-    assert_equal 'B', XPath.first(doc[0], 'b/text()').to_s
-    assert_equal 'D', XPath.first(doc[0], '//d/text()').to_s
-    assert_equal 'ABCDEF', XPath.match(doc[0], '//text()').collect {|n|
-      n.to_s
-    }.join('')
-  end
-
-  def test_string_length
-    doc = Document.new <<-EOF
-      <AAA>
-      <Q/>
-      <SSSS/>
-      <BB/>
-      <CCC/>
-      <DDDDDDDD/>
-      <EEEE/>
-      </AAA>
-    EOF
-    assert doc, "create doc"
-
-    set = doc.elements.to_a("//*[string-length(name()) = 3]")
-    assert_equal 2, set.size, "nodes with names length = 3"
-
-    set = doc.elements.to_a("//*[string-length(name()) < 3]")
-    assert_equal 2, set.size, "nodes with names length < 3"
-
-    set = doc.elements.to_a("//*[string-length(name()) > 3]")
-    assert_equal 3, set.size, "nodes with names length > 3"
-  end
-
-  # Test provided by Mike Stok
-  def test_contains
-    source = <<-EOF
-      <foo>
-      <a href="mailto:a@b.c">a@b.c</a>
-      <a href="http://www.foo.com">http://www.foo.com</a>
-      </foo>
-    EOF
-    doc = Document.new source
-
-    [
-    #['o', 2],
-    ['foo', 1], ['bar', 0]].each { |search, expected|
-      set = doc.elements.to_a("//a[contains(@href, '#{search}')]")
-      assert_equal expected, set.size
-    }
-  end
-
-  # Mike Stok and Sean Russell
-  def test_substring
-    # examples from http://www.w3.org/TR/xpath#function-substring
-    doc = Document.new('<test string="12345" />')
-
-    Document.new("<a b='1'/>")
-    #puts XPath.first(d, 'node()[0 + 1]')
-    #d = Document.new("<a b='1'/>")
-    #puts XPath.first(d, 'a[0 mod 0]')
-    [ [1.5, 2.6, '234'],
-      [0, 3, '12'],
-      [0, '0 div 0', ''],
-      [1, '0 div 0', ''],
-      ['-42', '1 div 0', '12345'],
-      ['-1 div 0', '1 div 0', '']
-    ].each { |start, length, expected|
-      set = doc.elements.to_a("//test[substring(@string, #{start}, #{length}) = '#{expected}']")
-      assert_equal 1, set.size, "#{start}, #{length}, '#{expected}'"
-    }
-  end
-
-  def test_translate
-    source = <<-EOF
-    <doc>
-    <case name='w3c one' result='BAr' />        <!-- w3c -->
-    <case name='w3c two' result='AAA' />        <!-- w3c -->
-    <case name='alchemy' result="gold" />   <!-- mike -->
-    <case name='vbxml one' result='A Space Odyssey' />
-    <case name='vbxml two' result='AbCdEf' />
-    </doc>
-    EOF
-
-    doc = Document.new(source)
-
-    [ ['bar', 'abc', 'ABC', 'w3c one'],
-    ['--aaa--','abc-','ABC', 'w3c two'],
-    ['lead', 'dear language', 'doll groover', 'alchemy'],
-    ['A Space Odissei', 'i', 'y', 'vbxml one'],
-    ['abcdefg', 'aceg', 'ACE', 'vbxml two'],
-    ].each { |arg1, arg2, arg3, name|
-      translate = "translate('#{arg1}', '#{arg2}', '#{arg3}')"
-      set = doc.elements.to_a("//case[@result = #{translate}]")
-      assert_equal 1, set.size, translate
-      assert_equal name, set[0].attributes['name']
-    }
-  end
-
-  def test_math
-    d = Document.new( '<a><b/><c/></a>' )
-    assert XPath.first( d.root, 'node()[1]' )
-    assert_equal 'b', XPath.first( d.root, 'node()[1]' ).name
-    assert XPath.first( d.root, 'node()[0 + 1]' )
-    assert_equal 'b', XPath.first( d.root, './node()[0 + 1]' ).name
-    assert XPath.first( d.root, 'node()[1 + 1]' )
-    assert_equal 'c', XPath.first( d.root, './node()[1 + 1]' ).name
-    assert XPath.first( d.root, 'node()[4 div 2]' )
-    assert_equal 'c', XPath.first( d.root, './node()[4 div 2]' ).name
-    assert XPath.first( d.root, 'node()[2 - 1]' )
-    assert_equal 'b', XPath.first( d.root, './node()[2 - 1]' ).name
-    assert XPath.first( d.root, 'node()[5 mod 2]' )
-    assert_equal 'b', XPath.first( d.root, './node()[5 mod 2]' ).name
-    assert XPath.first( d.root, 'node()[8 mod 3]' )
-    assert_equal 'c', XPath.first( d.root, './node()[8 mod 3]' ).name
-    assert XPath.first( d.root, 'node()[1 * 2]' )
-    assert_equal 'c', XPath.first( d.root, './node()[1 * 2]' ).name
-    assert XPath.first( d.root, 'node()[2 + -1]' )
-    assert_equal 'b', XPath.first( d.root, './node()[2 + -1]' ).name
-  end
-
-  def test_name
-    assert_raise( UndefinedNamespaceException, "x should be undefined" ) {
-      REXML::Document.new("<a x='foo'><b/><x:b/></a>")
-    }
-    d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
-    assert_equal 1, d.root.elements.to_a('*[name() = "b"]').size
-    assert_equal 1, d.elements.to_a('//*[name() = "x:b"]').size
-  end
-
-  def test_local_name
-    d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
-    assert_equal 2, d.root.elements.to_a('*[local_name() = "b"]').size
-    assert_equal 2, d.elements.to_a('//*[local_name() = "b"]').size
-  end
-
-  def test_comparisons
-    source = "<a><b id='1'/><b id='2'/><b id='3'/></a>"
-    doc = REXML::Document.new(source)
-
-    # NOTE TO SER: check that number() is required
-    assert_equal 2, REXML::XPath.match(doc, "//b[number(@id) > 1]").size
-    assert_equal 3, REXML::XPath.match(doc, "//b[number(@id) >= 1]").size
-    assert_equal 1, REXML::XPath.match(doc, "//b[number(@id) <= 1]").size
-    assert_equal 1, REXML::XPath.match(doc, "//b[number(@id) = (1 * 1)]").size
-    assert_equal 1, REXML::XPath.match(doc, "//b[number(@id) = (1 mod 2)]").size
-    assert_equal 1, REXML::XPath.match(doc, "//b[number(@id) = (4 div 2)]").size
-  end
-
-  # Contributed by Kouhei
-  def test_substring_before
-    doc = Document.new("<r><a/><b/><c/></r>")
-    assert_equal("a", doc.root.elements.to_a("*[name()=substring-before('abc', 'b')]")[0].name)
-    assert_equal("c", doc.root.elements.to_a("*[name()=substring-after('abc', 'b')]")[0].name)
-  end
-
-  def test_spaces
-    doc = Document.new("<a>
-      <b>
-        <c id='a'/>
-      </b>
-      <c id='b'/>
-    </a>")
-    assert_equal( 1, REXML::XPath.match(doc,
-      "//*[local-name()='c' and @id='b']").size )
-    assert_equal( 1, REXML::XPath.match(doc,
-      "//*[ local-name()='c' and @id='b' ]").size )
-    assert_equal( 1, REXML::XPath.match(doc,
-      "//*[ local-name() = 'c' and @id = 'b' ]").size )
-    assert_equal( 1,
-      REXML::XPath.match(doc, '/a/c[@id]').size )
-    assert_equal( 1,
-      REXML::XPath.match(doc, '/a/c[(@id)]').size )
-    assert_equal( 1,
-      REXML::XPath.match(doc, '/a/c[ @id ]').size )
-    assert_equal( 1,
-      REXML::XPath.match(doc, '/a/c[ (@id) ]').size )
-    assert_equal( 1,
-      REXML::XPath.match(doc, '/a/c[( @id )]').size )
-    assert_equal( 1, REXML::XPath.match(doc.root,
-      '/a/c[ ( @id ) ]').size )
-    assert_equal( 1, REXML::XPath.match(doc,
-      '/a/c [ ( @id ) ] ').size )
-    assert_equal( 1, REXML::XPath.match(doc,
-      ' / a / c [ ( @id ) ] ').size )
-  end
-
-  def test_text_nodes
-    #  source = "<root>
-    #<child/>
-    #<child>test</child>
-    #</root>"
-    source = "<root><child>test</child></root>"
-    d = REXML::Document.new( source )
-    r = REXML::XPath.match( d, %q{/root/child[text()="test"]} )
-    assert_equal( 1, r.size )
-    assert_equal( "child", r[0].name )
-    assert_equal( "test", r[0].text )
-  end
-
-  def test_auto_string_value
-    source = "<root><foo/><title>Introduction</title></root>"
-    d = REXML::Document.new( source )
-    #r = REXML::XPath.match( d, %q{/root[title="Introduction"]} )
-    #assert_equal( 1, r.size )
-    source = "<a><b/><c/><c>test</c></a>"
-    d = REXML::Document.new( source )
-    r = REXML::XPath.match( d, %q{/a[c='test']} )
-    assert_equal( 1, r.size )
-    r = REXML::XPath.match( d, %q{a[c='test']} )
-    assert_equal( 1, r.size )
-    r = d.elements["/a[c='test']"]
-    assert_not_nil( r )
-    r = d.elements["a[c='test']"]
-    assert_not_nil( r )
-    r = d.elements["a[c='xtest']"]
-    assert_nil( r )
-    r = REXML::XPath.match( d, %q{a[c='xtest']} )
-    assert_equal( 0, r.size )
-  end
-
-  def test_ordering
-    source = "<a><b><c id='1'/><c id='2'/></b><b><d id='1'/><d id='2'/></b></a>"
-    d = REXML::Document.new( source )
-    r = REXML::XPath.match( d, %q{/a/*/*[1]} )
-    assert_equal( 1, r.size )
-    r.each { |el| assert_equal( '1', el.attribute('id').value ) }
-  end
-
-  def test_descendant_or_self_ordering
-    source = "<a>
-    <b>
-      <c id='1'/>
-      <c id='2'/>
-    </b>
-    <b>
-      <d id='1'>
-        <c id='3'/>
-      </d>
-      <d id='2'>
-        <e>
-          <c id='4'/>
-        </e>
-      </d>
-    </b>
-  </a>"
-    d = REXML::Document.new( source )
-    cs = XPath.match( d, "/descendant-or-self::c" )
-    assert_equal( 4, cs.length )
-    1.upto(4) {|x| assert_equal( x.to_s, cs[x-1].attributes['id'] ) }
-  end
-
-  def test_and
-    d = Document.new %q{<doc><route run='*' title='HNO'
-    destination='debian_production1' date='*' edition='*'
-    source='debian_satellite1'/></doc>}
-    assert_equal( nil, d.root.elements["route[@run='0']"] )
-    assert_equal( nil, d.root.elements["route[@run='0' and @title='HNO']"] )
-  end
-
-
-  def test_numbers
-    d = Document.new %q{<a x="0" y="*" z="4e" w="e4" v="a"/>}
-
-    xp1 = "/a[ @x = 0 ]"
-    xp2 = "/a[ @x = '0' ]"
-    xp3 = "/a[ (@x + 1) = 1 ]"
-    xp4 = "/a[ @y = 0 ]"
-    xp5 = "/a[ (@z + 1) = 5 ]"
-    xp6 = "/a[ (@w + 1) = 5 ]"
-    xp7 = "/a[ (@v + 1) = 1 ]"
-    xp8 = "/a[ @n = 0 ]"
-
-    assert_equal( 1, XPath.match( d, xp1 ).length )
-    assert_equal( 1, XPath.match( d, xp2 ).length )
-    assert_equal( 1, XPath.match( d, xp3 ).length )
-    assert_equal( 0, XPath.match( d, xp4 ).length )
-    assert_equal( 0, XPath.match( d, xp5 ).length )
-    assert_equal( 0, XPath.match( d, xp6 ).length )
-    assert_equal( 0, XPath.match( d, xp7 ).length )
-    assert_equal( 0, XPath.match( d, xp8 ).length )
-  end
-
-  def test_tobis_preceding
-    doc_string = '<a>
-  <b/>
-  <c>
-    <d/>
-    <e/>
-  </c>
-</a>'
-
-    doc = Document.new(doc_string)
-
-    # e = REXML::XPath.first(doc,'/a/c/e')
-    e = doc.root.get_elements('/a/c/e')[0]
-    assert_equal( 1, e.get_elements('preceding-sibling::*').length )
-    assert_equal( 2, XPath.match(e, 'preceding::*').length )
-  end
-
-
-  def test_filtering
-    #doc=Document.new("<a><b><c1/><c2/></b><b><c3/><c4/></b><b><c5/><c6/></b></a>")
-    #assert_equal( 3, XPath.match( doc, '/a/b/*[1]' ).length )
-    #assert_equal( 2, XPath.match( doc, '/a/b/following-sibling::*[1]' ).length )
-  end
-
-  # Submitted by Alex
-  def test_union
-    data = %Q{<div id="the_div">
-  <span id="the_span">
-  <strong id="the_strong">a</strong>
-  </span>
-  <em id="the_em2">b</em>
-</div>}
-    rd = REXML::Document.new( data )
-    #union = rd.get_elements("/div/span | /div/em")
-    #assert_equal(2, union.length, "/div/span | /div/em" )
-    union = rd.get_elements('//*[name()="em" or name()="strong"]')
-    assert_equal(2, union.length, 'name() and "or" failed')
-    union = rd.get_elements('//em|//strong')
-    assert_equal(2, union.length,
-           'Both tag types are returned by XPath union operator')
-  end
-
-
-  def test_union2
-    src = <<-EOL
-<div id="the_div">
-<span id="the_span">
-<strong id="the_strong">a</strong>
-</span>
-<em id="the_em2">b</em>
-</div>
-    EOL
-    rd = REXML::Document.new( src )
-    union = rd.get_elements('//em|//strong')
-    assert_equal(2, union.length,
-      'Both tag types are returned by XPath union operator')
-  end
-
-
-  def test_a_star_star_one
-    string = <<-EOL
-<a>
-  <b>
-    <c1/>
-    <d/>
-    <e/>
-    <f/>
-  </b>
-  <b>
-    <c2/>
-    <d/>
-    <e/>
-    <f/>
-  </b>
-</a>
-    EOL
-    d = REXML::Document.new( string )
-    c1 = XPath.match( d, '/a/*/*[1]' )
-    assert_equal( 1, c1.length )
-    assert_equal( 'c1', c1[0].name )
-  end
-
-  def test_sum
-    d = Document.new("<a>"+
-    "<b>1</b><b>2</b><b>3</b>"+
-    "<c><d>1</d><d>2</d></c>"+
-    "<e att='1'/><e att='2'/>"+
-    "</a>")
-
-    for v,p in [[6, "sum(/a/b)"],
-      [9, "sum(//b | //d)"],
-      [3, "sum(/a/e/@*)"] ]
-      assert_equal( v, XPath::match( d, p ).first )
-    end
-  end
-
-  def test_xpath_namespace
-    d = REXML::Document.new("<tag1 xmlns='ns1'><tag2 xmlns='ns2'/><tada>xa</tada></tag1>")
-    x = d.root
-    num = 0
-    x.each_element('tada') {  num += 1 }
-    assert_equal(1, num)
-  end
-
-  def test_ticket_39
-    doc = REXML::Document.new( <<-EOL )
-    <rss>
-      <channel>
-        <!-- removing the namespace declaration makes the test pass -->
-        <convertLineBreaks xmlns="http://www.blogger.com/atom/ns#">true</convertLineBreaks>
-        <item>
-          <title>Item 1</title>
-        </item>
-        <item>
-          <title>Item 2</title>
-          <pubDate>Thu, 13 Oct 2005 19:59:00 +0000</pubDate>
-        </item>
-        <item>
-          <title>Item 3</title>
-        </item>
-      </channel>
-    </rss>
-    EOL
-    root_node = XPath.first(doc, "rss")
-    assert_not_nil root_node
-    channel_node = XPath.first(root_node, "channel")
-    assert_not_nil channel_node
-    items = XPath.match(channel_node, "*")
-    assert_equal 4, items.size
-    items = XPath.match(channel_node, "item")
-    assert_equal 3, items.size  # fails
-  end
-
-
-  def test_ticket_42
-    source = "<a></a>"
-    doc = Document.new(source)
-    bElem = Element.new('b')
-    doc.root.add_element(bElem)
-    doc.elements.each('//b[name(..) = "a"]') { |x|
-      assert_equal x,bElem
-    }
-  end
-
-  def test_ticket_56
-    namespaces = {'h' => 'http://www.w3.org/1999/xhtml'}
-
-    finaldoc = REXML::Document.new(File.read(fixture_path('google.2.xml')))
-
-    column_headers = []
-
-    REXML::XPath.each(finaldoc, '//h:form[@action="ModifyCampaign"]//h:th',
-                      namespaces) do |el|
-      node = REXML::XPath.first(el, 'h:a/text()', namespaces)
-      column_headers << (node ? node.value : nil)
-    end
-    column_headers.map! { |h| h.to_s.strip.chomp }
-    expected = ["", "", "Current Status", "Current Budget",
-      "Clicks", "Impr.", "CTR", "Avg. CPC", "Cost", "Conv. Rate",
-      "Cost/Conv."]
-    assert_equal( expected, column_headers )
-  end
-
-
-  def test_ticket_70
-    string = <<EOF
-
-<mydoc>
-
-    <someelement attribute="1.10">Text1, text,
-text</someelement>
-
-    <someelement attribute="1.11">Text2, text,
-text</someelement>
-
-
-</mydoc>
-
-EOF
-    doc = Document.new string
-    assert_equal( 1, XPath.match( doc, "//someelement[contains(@attribute,'1.10')]" ).length )
-  end
-
-  def test_ticket_43
-    #url = http://news.search.yahoo.com/news/rss?p=market&ei=UTF-8&fl=0&x=wrt
-
-    sum = Document.new(File.new(fixture_path("yahoo.xml"))).elements.to_a("//item").size
-    assert_equal( 10, sum )
-
-    text = Document.new(File.new(fixture_path("yahoo.xml"))).elements.to_a(%Q{//title[contains(text(), "'")]}).collect{|e| e.text}.join
-    assert_equal( "Broward labor market's a solid performer (Miami Herald)", text )
-  end
-
-  def test_ticket_57
-    data = "<?xml version='1.0'?><a:x xmlns:a='1'><a:y p='p' q='q'><a:z>zzz</a:z></a:y></a:x>"
-
-    r = Document.new(data)
-
-    assert_equal(Text, REXML::XPath.first(r,"a:x/a:y[@p='p' and @q='q']/a:z/text()").class)
-    assert_equal("zzz", REXML::XPath.first(r,"a:x/a:y[@p='p' and @q='q']/a:z/text()").to_s)
-  end
-
-  def test_ticket_59
-    data = "<a>
-      <c id='1'/>
-      <c id='2'/>
-      <b>
-        <c id='3'/>
-      </b>
-      <c id='4'/>
-      <b>
-        <b>
-          <c id='5'/>
-        </b>
-        <c id='6'/>
-      </b>
-      <c id='7'/>
-      <b>
-        <b>
-          <c id='8'/>
-          <b>
-            <c id='9'/>
-            <b>
-              <c id='10'/>
-            </b>
-            <c id='11'/>
-          </b>
-        </b>
-      </b>
-      <c id='12'/>
-    </a>"
-    d = Document.new(data)
-    res = d.elements.to_a( "//c" ).collect {|e| e.attributes['id'].to_i}
-    assert_equal( res, res.sort )
-  end
-
-  def ticket_61_fixture(doc, xpath)
-    matches = []
-    doc.elements.each(xpath) do |element|
-      matches << element
-      assert_equal('Add', element.text)
-      assert_equal('ButtonText', element.attributes['class'])
-    end
-    assert_equal(1, matches.length)
-  end
-
-  def test_ticket_61_text
-    file = File.open(fixture_path("ticket_61.xml"))
-    doc = REXML::Document.new file
-    ticket_61_fixture( doc, "//div[text()='Add' and @class='ButtonText']" )
-  end
-
-  def test_ticket_61_contains
-    file = File.open(fixture_path("ticket_61.xml"))
-    doc = REXML::Document.new file
-    ticket_61_fixture( doc, "//div[contains(.,'Add') and @class='ButtonText']" )
-  end
-
-  def test_namespaces_0
-    d = Document.new(%q{<x:a xmlns:x="y"/>})
-    assert_equal( 1,  XPath.match( d, "//x:a" ).size )
-    assert_equal( 1,  XPath.match( d, "//x:*" ).size )
-  end
-
-  def test_ticket_71
-    doc = Document.new(%Q{<root xmlns:ns1="xyz" xmlns:ns2="123"><element ns1:attrname="foo" ns2:attrname="bar"/></root>})
-    el = doc.root.elements[1]
-    assert_equal( "element", el.name )
-    el2 = XPath.first( doc.root, "element[@ns:attrname='foo']", { 'ns' => "xyz" } )
-    assert_equal( el, el2 )
-  end
-
-  def test_ticket_78
-    doc = <<-EOT
-    <root>
-        <element>
-            <tag x='1'>123</tag>
-        </element>
-        <element>
-            <tag x='2'>123a</tag>
-        </element>
-    </root>
-    EOT
-    seq = %w{BEGIN 123 END BEGIN 123a END}
-
-    xmlDoc = Document.new(doc)
-
-    ["//element[tag='123']/tag", "//element[tag='123a']/tag"].each do |query|
-      assert_equal( "BEGIN", seq.shift )
-      XPath.each(xmlDoc, query) { |element|
-        assert_equal( seq.shift, element.text )
-      }
-      assert_equal( "END", seq.shift )
-    end
-  end
-
-  def test_ticket_79
-    source = "<a><b><c>test</c></b><b><c>3</c></b></a>"
-    d = REXML::Document.new( source )
-    r = REXML::XPath.match( d, %q{/a/b[c='test']} )
-    assert_equal(1, r.size())
-    r = REXML::XPath.match( d, %q{/a/b[c='3']} )
-    assert_equal(1, r.size())
-  end
-
-  def test_or_and
-    doc = "
-<html>
-  <head>
-    <title>test</title>
-  </head>
-  <body>
-    <p>
-      A <a rel=\"sub\" href=\"/\">link</a>.
-    </p>
-  </body>
-</html>
-"
-
-    xmldoc = REXML::Document.new(doc)
-    xpath = "descendant::node()[(local-name()='link' or local-name()='a') and @rel='sub']"
-    hrefs = []
-    xmldoc.elements.each(xpath) do |element|
-      hrefs << element.attributes["href"]
-    end
-    assert_equal(["/"], hrefs, "Bug #3842 [ruby-core:32447]")
-  end
-end
diff --git a/test/rexml/test_xpath_attribute_query.rb b/test/rexml/test_xpath_attribute_query.rb
deleted file mode 100644
index c0ad2c2..0000000
--- a/test/rexml/test_xpath_attribute_query.rb
+++ /dev/null
@@ -1,89 +0,0 @@
-# rexml_xpath_attribute_query.rb
-# May 16, 2007
-#
-
-require 'test/unit'
-require 'rexml/document'
-
-class TestRexmlXpathAttributeQuery < Test::Unit::TestCase
-
-  # xmlstr1 and xmlstr2 only differ in the second line - namespaces in the root element
-  @@xmlstr1 = '<?xml version="1.0" encoding="UTF-8"?>
-<feed xmlns="http://www.w3.org/2005/Atom" xmlns:openSearch="http://a9.com/-/spec/opensearchrss/1.0/" xmlns:gd="http://schemas.google.com/g/2005" xmlns:gCal="http://schemas.google.com/gCal/2005">
-  <id>http://www.google.com/calendar/feeds/me%40gmail.com</id>
-  <entry>
-    <id>http://www.google.com/calendar/feeds/me%40gmail.com/me%40gmail.com</id>
-    <published>2007-05-16T13:42:27.942Z</published>
-    <updated>2007-05-15T03:29:28.000Z</updated>
-    <title type="text">My Calendar</title>
-    <link rel="alternate" type="application/atom+xml" href="http://www.google.com/calendar/feeds/me%40gmail.com/private/full"/>
-    <link rel="http://schemas.google.com/acl/2007#accessControlList" type="application/atom+xml" href="http://www.google.com/calendar/feeds/me%40gmail.com/acl/full"/>
-    <link rel="self" type="application/atom+xml" href="http://www.google.com/calendar/feeds/me%40gmail.com/me%40gmail.com"/>
-    <author>
-      <name>Me</name>
-      <email>me@gmail.com</email>
-    </author>
-  </entry>
-</feed>'
-
-
-  @@xmlstr2 = '<?xml version="1.0" encoding="UTF-8"?>
-<feed>
-  <id>http://www.google.com/calendar/feeds/me%40gmail.com</id>
-  <entry>
-    <id>http://www.google.com/calendar/feeds/me%40gmail.com/me%40gmail.com</id>
-    <published>2007-05-16T13:42:27.942Z</published>
-    <updated>2007-05-15T03:29:28.000Z</updated>
-    <title type="text">My Calendar</title>
-    <link rel="alternate" type="application/atom+xml" href="http://www.google.com/calendar/feeds/me%40gmail.com/private/full"/>
-    <link rel="http://schemas.google.com/acl/2007#accessControlList" type="application/atom+xml" href="http://www.google.com/calendar/feeds/me%40gmail.com/acl/full"/>
-    <link rel="self" type="application/atom+xml" href="http://www.google.com/calendar/feeds/me%40gmail.com/me%40gmail.com"/>
-    <author>
-      <name>Me</name>
-      <email>me@gmail.com</email>
-    </author>
-  </entry>
-</feed>'
-
-  # Fails
-  def test_xpath_query
-    do_test @@xmlstr1
-  end
-
-  # Passes
-  def test_xpath_query_no_namespace
-    do_test @@xmlstr2
-  end
-
-  def do_test(xmlString)
-    hrefs = [
-      "http://www.google.com/calendar/feeds/me%40gmail.com/private/full",
-      "http://www.google.com/calendar/feeds/me%40gmail.com/acl/full",
-      "http://www.google.com/calendar/feeds/me%40gmail.com/me%40gmail.com"
-    ]
-    ctr=0
-    REXML::Document.new(xmlString).elements.each("feed/entry") do |element|
-      @alternate_link = element.elements["link[@rel='alternate']"]
-      assert_not_nil( @alternate_link )
-      assert_equal( hrefs[ctr], @alternate_link.attributes['href'])
-      ctr += 1
-    end
-  end
-
-
-  def test_another_way
-    doc = REXML::Document.new(@@xmlstr1)
-    hrefs = [
-      "http://www.google.com/calendar/feeds/me%40gmail.com/private/full",
-      "http://www.google.com/calendar/feeds/me%40gmail.com/acl/full",
-      "http://www.google.com/calendar/feeds/me%40gmail.com/me%40gmail.com"
-    ]
-    ctr=0
-    REXML::XPath.each(doc, "//link[@rel='alternate']") do |element|
-      @alternate_link = element
-      assert_not_nil @alternate_link
-      assert_equal( hrefs[ctr], @alternate_link.attributes['href'])
-      ctr += 1
-    end
-  end
-end
diff --git a/test/rexml/test_xpath_msw.rb b/test/rexml/test_xpath_msw.rb
deleted file mode 100644
index d0b474f..0000000
--- a/test/rexml/test_xpath_msw.rb
+++ /dev/null
@@ -1,38 +0,0 @@
-require "test/unit/testcase"
-require "rexml/document"
-
-class XPathAxesTester < Test::Unit::TestCase
-  include REXML
-  SOURCE = <<-EOF
-    <a id='1'>
-      <e id='2'>
-        <f id='3'/>
-        <f id='4'/>
-        <f id='5'/>
-        <f id='6'/>
-      </e>
-    </a>
-    EOF
-
-  def setup
-    @@doc = Document.new(SOURCE) unless defined? @@doc
-  end
-
-  def test_preceding_sibling_axis
-    context = XPath.first(@@doc,"/a/e/f[last()]")
-    assert_equal "6", context.attributes["id"]
-
-    prev = XPath.first(context, "preceding-sibling::f")
-    assert_equal "5", prev.attributes["id"]
-
-    prev = XPath.first(context, "preceding-sibling::f[1]")
-    assert_equal "5", prev.attributes["id"]
-
-    prev = XPath.first(context, "preceding-sibling::f[2]")
-    assert_equal "4", prev.attributes["id"]
-
-    prev = XPath.first(context, "preceding-sibling::f[3]")
-    assert_equal "3", prev.attributes["id"]
-  end
-end
-
diff --git a/test/rexml/test_xpath_pred.rb b/test/rexml/test_xpath_pred.rb
deleted file mode 100644
index 5843589..0000000
--- a/test/rexml/test_xpath_pred.rb
+++ /dev/null
@@ -1,80 +0,0 @@
-require "test/unit/testcase"
-require "rexml/document"
-require "rexml/xpath"
-require "rexml/parsers/xpathparser"
-
-class XPathPredicateTester < Test::Unit::TestCase
-  include REXML
-  SRC=<<-EOL
-  <article>
-     <section role="subdivision" id="1">
-        <para>free flowing text.</para>
-     </section>
-     <section role="division">
-        <section role="subdivision" id="2">
-           <para>free flowing text.</para>
-        </section>
-        <section role="division">
-           <para>free flowing text.</para>
-        </section>
-     </section>
-  </article>
-  EOL
-
-  def setup
-    @doc = REXML::Document.new( SRC )
-    @parser = REXML::Parsers::XPathParser.new
-
-  end
-
-  def test_predicates_parent
-    path = '//section[../self::section[@role="division"]]'
-    m = do_path( path )
-    assert_equal( 2, m.size )
-    assert_equal( "2", m[0].attributes["id"] )
-    assert_nil( m[1].attributes["id"] )
-  end
-
-  def test_predicates_single
-    path = '//section[@role="subdivision" and not(../self::section[@role="division"])]'
-    m = do_path( path )
-    assert_equal( 1, m.size )
-    assert_equal( "1", m[0].attributes["id"] )
-  end
-
-  def test_predicates_multi
-    path = '//section[@role="subdivision"][not(../self::section[@role="division"])]'
-    m = do_path( path )
-    assert_equal( 1, m.size )
-    assert_equal( "1", m[0].attributes["id"] )
-  end
-
-  def do_path( path )
-    m = REXML::XPath.match( @doc, path )
-    #puts path, @parser.parse( path ).inspect
-    return m
-  end
-
-  def test_get_no_siblings_terminal_nodes
-    source = <<-XML
-<a>
-  <b number='1' str='abc'>TEXT1</b>
-  <c number='1'/>
-  <c number='2' str='def'>
-    <b number='3'/>
-    <d number='1' str='abc'>TEXT2</d>
-    <b number='2'><!--COMMENT--></b>
-  </c>
-</a>
-XML
-    doc = REXML::Document.new(source)
-    predicate = "count(child::node()|" +
-                      "following-sibling::node()|" +
-                      "preceding-sibling::node())=0"
-    m = REXML::XPath.match(doc, "/descendant-or-self::node()[#{predicate}]")
-    assert_equal( [REXML::Text.new("TEXT1"),
-                   REXML::Text.new("TEXT2"),
-                   REXML::Comment.new("COMMENT")],
-                  m )
-  end
-end
diff --git a/test/rexml/test_xpathtext.rb b/test/rexml/test_xpathtext.rb
deleted file mode 100644
index 87441cb..0000000
--- a/test/rexml/test_xpathtext.rb
+++ /dev/null
@@ -1,72 +0,0 @@
-require 'test/unit'
-require 'rexml/document'
-require 'rexml/element'
-require 'rexml/xpath'
-
-class XpathTestCase < Test::Unit::TestCase
-  def setup
-    @doc = REXML::Document.new
-  end
-
-  def tear_down
-  end
-
-  def test_text_as_element
-    node1 = REXML::Element.new('a', @doc)
-    node2 = REXML::Element.new('b', node1)
-    REXML::Text.new('test', false, node2)
-    assert_equal(1, @doc.elements.size, "doc owns 1 element node1")
-    assert_same(node1, @doc.elements[1], "doc owns 1 element node1")
-    assert_equal(1, node1.elements.size, "node1 owns 1 element node2")
-    assert_same(node2, node1.elements[1], "node1 owns 1 element node2")
-    assert_equal(1, node2.size, "node2 owns 1 text element")
-  end
-
-  def test_text_in_xpath_query
-    node1 = REXML::Element.new('a', @doc)
-    node2 = REXML::Element.new('b', node1)
-    textnode = REXML::Text.new('test', false, node2)
-    textnode.parent = node2   # should be unnecessary
-    nodes = @doc.get_elements('//b')
-    assert_equal(1, nodes.size, "document has one element")
-    # why doesn't this query work right?
-    nodes = REXML::XPath.match(@doc, '//text()')
-    assert_equal(1, nodes.size, "//text() should yield one Text element")
-    assert_equal(REXML::Text, nodes[0].class)
-  end
-
-  def test_comment_in_xpath_query
-    node1 = REXML::Element.new('a', @doc)
-    node2 = REXML::Element.new('b', node1)
-    commentnode = REXML::Comment.new('test', node2)
-    nodes = REXML::XPath.match(@doc, '//comment()')
-    assert_equal(1, nodes.size, "//comment() should yield one Comment element")
-    assert_same commentnode, nodes[0]
-  end
-
-  def test_parentage
-    node1 = REXML::Element.new('a', @doc)
-    assert_same(@doc, node1.parent, "node1 parent is document")
-    node2 = REXML::Element.new('b', node1)
-    assert_same(node1, node2.parent, "node2 parent is node1")
-    textnode = REXML::Text.new('test', false, node2)
-    # why isn't the text's parent node2?
-    # Also look at Comment, etc.
-    assert_same(node2, textnode.parent)
-    comment = REXML::Comment.new('Test comment', node2)
-    assert_same(node2, comment.parent)
-  end
-
-  def test_ancestors
-    node1 = REXML::Element.new('a', @doc)
-    node2 = REXML::Element.new('b', node1)
-    textnode = REXML::Text.new('test', false, node2)
-    #textnode.parent = node2   # should be unnecessary
-    assert_same node2, textnode.parent
-    nodes = @doc.get_elements('//b/ancestor::*')
-    assert_equal(1, nodes.size, "<b> has one element ancestor")
-    nodes = @doc.get_elements('//b/ancestor::node()')
-    assert_equal(2, nodes.size, "<b> has two node ancestors")
-    assert nodes[1].kind_of?(REXML::Document)
-  end
-end
diff --git a/test/rexml/xpath/test_attribute.rb b/test/rexml/xpath/test_attribute.rb
new file mode 100644
index 0000000..713d77b
--- /dev/null
+++ b/test/rexml/xpath/test_attribute.rb
@@ -0,0 +1,38 @@
+# frozen_string_literal: false
+require 'test/unit'
+require 'rexml/document'
+
+module REXMLTests
+  class TestXPathAttribute < Test::Unit::TestCase
+    def setup
+      @xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root xmlns="http://example.com/">
+  <child name="one">child1</child>
+  <child name="two">child2</child>
+  <child name="three">child3</child>
+</root>
+      XML
+      @document = REXML::Document.new(@xml)
+    end
+
+    def test_elements
+      root = @document.elements["root"]
+      second_child = root.elements["child[@name='two']"]
+      assert_equal("child2", second_child.text)
+    end
+
+    def test_xpath_each
+      children = REXML::XPath.each(@document, "/root/child[@name='two']")
+      assert_equal(["child2"], children.collect(&:text))
+    end
+
+    def test_no_namespace
+      children = REXML::XPath.match(@document,
+                                    "/root/child[@nothing:name='two']",
+                                    "" => "http://example.com/",
+                                    "nothing" => "")
+      assert_equal(["child2"], children.collect(&:text))
+    end
+  end
+end
diff --git a/test/rexml/xpath/test_axis_preceding_sibling.rb b/test/rexml/xpath/test_axis_preceding_sibling.rb
new file mode 100644
index 0000000..5842c6b
--- /dev/null
+++ b/test/rexml/xpath/test_axis_preceding_sibling.rb
@@ -0,0 +1,40 @@
+# frozen_string_literal: false
+require "test/unit/testcase"
+require "rexml/document"
+
+module REXMLTests
+  class TestXPathAxisPredcedingSibling < Test::Unit::TestCase
+    include REXML
+    SOURCE = <<-EOF
+      <a id='1'>
+        <e id='2'>
+          <f id='3'/>
+          <f id='4'/>
+          <f id='5'/>
+          <f id='6'/>
+        </e>
+      </a>
+      EOF
+
+    def setup
+      @@doc = Document.new(SOURCE) unless defined? @@doc
+    end
+
+    def test_preceding_sibling_axis
+      context = XPath.first(@@doc,"/a/e/f[last()]")
+      assert_equal "6", context.attributes["id"]
+
+      prev = XPath.first(context, "preceding-sibling::f")
+      assert_equal "5", prev.attributes["id"]
+
+      prev = XPath.first(context, "preceding-sibling::f[1]")
+      assert_equal "5", prev.attributes["id"]
+
+      prev = XPath.first(context, "preceding-sibling::f[2]")
+      assert_equal "4", prev.attributes["id"]
+
+      prev = XPath.first(context, "preceding-sibling::f[3]")
+      assert_equal "3", prev.attributes["id"]
+    end
+  end
+end
diff --git a/test/rexml/xpath/test_base.rb b/test/rexml/xpath/test_base.rb
new file mode 100644
index 0000000..210d6c7
--- /dev/null
+++ b/test/rexml/xpath/test_base.rb
@@ -0,0 +1,1125 @@
+# frozen_string_literal: false
+require_relative "../rexml_test_utils"
+
+require "rexml/document"
+
+module REXMLTests
+  class TestXPathBase < Test::Unit::TestCase
+    include REXMLTestUtils
+    include REXML
+    SOURCE = <<-EOF
+      <a id='1'>
+        <b id='2' x='y'>
+          <c id='3'/>
+          <c id='4'/>
+        </b>
+        <d id='5'>
+          <c id='6' x='y'/>
+          <c id='7'/>
+          <c id='8'/>
+          <q id='19'/>
+        </d>
+        <e id='9'>
+          <f id='10' a='b'/>
+          <f id='11' a='c'/>
+          <f id='12' a='d'>
+            <g id='13'/>
+          </f>
+          <f id='14' a='d'/>
+        </e>
+        <m id='15'>
+          <n id='16'>
+            <o id='17'>
+              <p id='18'/>
+            </o>
+          </n>
+        </m>
+      </a>
+      EOF
+    JENI_TENNISON = <<-EOJT
+    <a>
+      <b>
+        <c>
+          <d>
+            <e id='x'>
+              <f/>
+            </e>
+          </d>
+        </c>
+        <c>
+          <d>
+            <e id='y'/>
+          </d>
+        </c>
+      </b>
+      <b>
+        <c>
+          <d>
+            <e id='z'/>
+          </d>
+        </c>
+      </b>
+    </a>
+    EOJT
+
+    def setup
+      @@doc = Document.new(SOURCE) unless defined? @@doc
+      @@jeni = Document.new( JENI_TENNISON ) unless defined? @@jeni
+    end
+
+    def each_test( element, xpath )
+      count = 0
+      XPath::each( element, xpath ) { |child|
+        count += 1
+        yield child if block_given?
+      }
+      count
+    end
+
+    def test_descendant
+      doc = Document.new("<a><b><c id='1'/></b><d><b><c id='2'/></b></d></a>")
+      p = XPath.match( doc, "//c" )
+      assert_equal( 2, p.size )
+      p = XPath.first( @@doc, "//p" )
+      assert_equal "p", p.name
+      c = each_test( @@doc, "//c" ) { |child| assert_equal "c", child.name }
+      assert_equal 5, c
+      c = each_test( @@doc.root, "b//c" ) { |child|
+          assert_equal "c", child.name
+      }
+      assert_equal 2, c
+
+      doc = Document.new( "<a><z id='1'/><b><z id='11'/><z id='12'/></b><c><z id='21'/><z id='22'/><d><z id='31'/><z id='32'/></d></c></a>" )
+      # //para[1] : all descendants which are the first para child of their parent
+      assert_equal( 4, XPath.match( doc, "//z[1]" ).size )
+      # /descendant::para[1] : the first descendant para element
+      assert_equal( 1, XPath.match( doc, "/descendant::z[1]" ).size )
+    end
+
+    def test_root
+      source = "<a><b/></a>"
+      doc = Document.new( source )
+      assert_equal doc, doc.root_node
+      assert_equal "a", XPath::first( doc, "/" ).elements[1].name
+    end
+
+    def test_abbreviated_simple_child
+      assert_equal "a", XPath::first(@@doc, "a").name
+    end
+
+    def test_child
+      c = XPath::first( @@doc, "a/b/c" )
+      assert_equal "c", c.name
+      assert_equal "3", XPath::first(@@doc, "a/b/c").attributes["id"]
+    end
+
+    def test_root_child
+      assert_equal "a", XPath::first(@@doc, "/a").name
+      c = XPath::first( @@doc, "a/b/c" )
+      assert_equal "a", XPath::first(c, "/a").name
+    end
+
+    def test_root_children
+      c = XPath::first( @@doc, "a/b/c" )
+      assert_equal "2", XPath::first(c, "/a/b").attributes["id"]
+    end
+
+    def test_abbreviated_step
+      c = XPath::first( @@doc, "a/b/c" )
+      assert_equal("c", c.name)
+      assert_equal("a", XPath::first(@@doc.root, ".").name)
+      assert_equal("b", XPath::first(c, "..").name)
+      assert_equal("a", XPath::first(@@doc, "a/b/..").name)
+
+      doc = File.open(fixture_path("project.xml")) do |f|
+        REXML::Document.new(f)
+      end
+      c = each_test(doc.root, "./Description" ) { |child|
+        assert_equal("Description",child.name)
+      }
+      assert_equal 1, c
+    end
+
+    # Things that aren't tested elsewhere
+    def test_predicates
+      assert_equal "12", XPath::first(@@doc, "a/e/f[3]").attributes["id"]
+      assert_equal "13", XPath::first(@@doc, "a/e/f[3]/g").attributes["id"]
+      assert_equal "14", XPath::first(@@doc, "a/e/f[@a='d'][2]").attributes["id"]
+      assert_equal "14", XPath::first(@@doc, "a/e/f[@a='d'][@id='14']").attributes["id"]
+      assert_equal "a", XPath::first( @@doc, "*[name()='a' and @id='1']" ).name
+      c=each_test( @@doc, "//*[name()='f' and @a='d']") { |i|
+        assert_equal "f", i.name
+      }
+      assert_equal 2, c
+      c=each_test( @@doc, "//*[name()='m' or @a='d']") { |i|
+        assert ["m","f"].include?(i.name)
+      }
+      assert_equal 3, c
+
+      assert_equal "b", XPath::first( @@doc, "//b[@x]" ).name
+    end
+
+    def test_node_type
+      doc = Document.new "<a><?foo bar?><!--comment-->text</a>"
+      #res = XPath::first(doc.root, "text()")
+      #assert_equal "text", res.to_s
+
+      #res = XPath::first(doc, "*")
+      #assert_equal "a", res.name
+
+      assert_equal( :processing_instruction,
+      XPath::first(doc.root, "processing-instruction()").node_type)
+      assert_equal( :comment, XPath::first(doc.root, "comment()").node_type)
+    end
+
+    def test_functions
+      # trivial text() test
+      # confuse-a-function
+      source = "<a>more <b id='1'/><b id='2'>dumb</b><b id='3'/><c/> text</a>"
+      doc = Document.new source
+      res = ""
+      #XPath::each(doc.root, "text()") {|val| res << val.to_s}
+      #assert_equal "more  text", res
+
+      #res = XPath::first(doc.root, "b[last()]")
+      #assert_equal '3', res.attributes['id']
+      res = XPath::first(doc.root, "b[position()=2]")
+      assert_equal '2', res.attributes['id']
+      res = XPath::first(doc.root, "*[name()='c']")
+      assert_equal "c", res.name
+    end
+
+    def no_test_ancestor
+      doc = REXML::Document.new(File.new(fixture_path("testsrc.xml")))
+      doc.elements.each("//item") { |el| print el.name
+        if el.attributes['x']
+          puts " -- "+el.attributes['x']
+        else
+          puts
+        end
+      }
+      doc.elements.each("//item/ancestor::") { |el| print el.name
+        if el.attributes['x']
+          puts " -- "+el.attributes['x']
+        else
+          puts
+        end
+      }
+    end
+
+    # Here are some XPath tests that were originally submitted by ...
+    # The code has changed some, but the logic and the source documents are the
+    # same.
+    # This method reads a document from a file, and then a series of xpaths,
+    # also from a file.  It then checks each xpath against the source file.
+    def test_more
+      xmlsource   = fixture_path("testsrc.xml")
+      xpathtests  = fixture_path("xp.tst")
+
+      doc = File.open(xmlsource) {|f| REXML::Document.new(f) }
+      #results = ""
+      results = REXML::Document.new
+      results.add_element "test-results"
+      File.foreach(xpathtests) do |line|
+        line.strip!
+        begin
+          doc.root
+          #puts "#"*80
+          #print "\nDoing #{line} " ; $stdout.flush
+          doc.elements.each(line) do |el|
+            #print "." ; $stdout.flush
+            results.root << el.clone
+            #results << el.to_s
+          end
+          #ObjectSpace.garbage_collect
+          GC::start
+        rescue Exception => z
+          #puts "\n'#{line}' failed"
+          fail("Error on line #{line}:\n#{z.message}\n"+z.backtrace[0,10].join("\n"))
+          #results.root.add_element( "error", {"path"=>line}).text = z.message+"\n"+z.backtrace[0,10].join("\n")
+          #results << "<error path='"+line+"'>"+z.message+"</error>"
+        end
+      end
+    end
+
+    def test_axe_descendant
+      assert_equal "f", XPath::first( @@doc, "descendant::f").name
+    end
+
+    def test_axe_parent
+      q = XPath.first( @@doc, "a/d/c/parent::*/q" )
+      assert_equal 19, q.attributes["id"].to_i
+    end
+
+    def test_abbreviated_attribute
+      assert_equal 'a', XPath::first( @@doc, "a[@id='1']" ).name
+      c = XPath::first( @@doc, "a/b/c[@id='4']" )
+      assert_equal 'c', c.name
+      assert_equal '4', c.attributes['id']
+
+      result = XPath::first( @@doc, "descendant::f[@a='c']")
+      assert_equal "11", result.attributes['id']
+
+      assert_equal "11", XPath::first(@@doc, "a/e/f[@a='c']").attributes["id"]
+      assert_equal "11", XPath::first(@@doc, "a/e/*[@a='c']").attributes["id"]
+    end
+
+    def test_axe_self
+      c = XPath::first( @@doc, "a/b/c" )
+      assert c
+      assert_equal "c", c.name
+      assert_equal "c", XPath::first( c, "self::node()" ).name
+    end
+
+    def test_axe_ancestor
+      doc = REXML::Document.new "
+      <a>
+        <b id='1'>
+          <c>
+            <b id='2'>
+              <d/>
+            </b>
+          </c>
+        </b>
+      </a>"
+
+      d = XPath.first( doc, "//d" )
+      assert_equal "d", d.name
+      b = each_test( d, "ancestor::b" ) { |el|
+        assert((1..2) === el.attributes['id'].to_i,
+          "Expected #{el.attributes['id']} to be either 1 or 2"
+        )
+      }
+      assert_equal 2, b
+    end
+
+    def test_axe_child
+      m = XPath.first( @@doc, "a/child::m" )
+      assert_equal 15, m.attributes['id'].to_i
+    end
+
+    def test_axe_attribute
+      a = XPath.first( @@doc, "a/attribute::id" )
+      assert_equal "1", a.value
+      a = XPath.first( @@doc, "a/e/f[@id='14']/attribute::a" )
+      assert_equal "d", a.value
+    end
+
+    def test_axe_sibling
+      doc = Document.new "<a><b><c/></b><e><f id='10'/><f id='11'/><f id='12'/></e></a>"
+      first_f = XPath.first( doc, "a/e/f" )
+      assert first_f
+      assert_equal '10', first_f.attributes['id']
+      next_f = XPath.first( doc, "a/e/f/following-sibling::node()" )
+      assert_equal '11', next_f.attributes['id']
+
+      b = XPath.first( doc, "a/e/preceding-sibling::node()" )
+      assert_equal 'b', b.name
+    end
+
+    def test_lang
+      doc = File.open(fixture_path("lang0.xml")) {|f| Document.new(f) }
+      #puts IO.read( "test/lang.xml" )
+
+      #puts XPath.match( doc, "//language/*" ).size
+      c = each_test( doc, "//language/*" ) { |element|
+        #puts "#{element.name}: #{element.text}"
+      }
+      assert_equal 4, c
+    end
+
+    def test_namespaces_1
+      source = <<-EOF
+        <foo xmlns:ts="this" xmlns:tt="that">
+          <ts:bar>this bar</ts:bar>
+          <tt:bar>that bar</tt:bar>
+        </foo>
+      EOF
+      doc = Document.new source
+      XPath.each( doc, "//bar" ) {
+        fail "'bar' should match nothing in this case"
+      }
+
+      namespace = {"t"=>"this"}
+      results = XPath.first( doc, "//t:bar", namespace )
+      assert_equal "this bar", results.text
+    end
+
+    def test_namespaces_2
+      source = <<-EOF
+        <foo xmlns:ts="this" xmlns:tt="that">
+          <ts:bar>this bar</ts:bar>
+          <tt:bar>that bar</tt:bar>
+        </foo>
+      EOF
+      doc = Document.new source
+      res = XPath::first(doc, "//*[local_name()='bar']")
+      assert res, "looking for //*[name()='bar']"
+      assert_equal 'this', res.namespace
+      res = XPath::first(doc.root, "*[namespace_uri()='that']")
+      assert_equal 'that bar', res.text
+    end
+
+    def test_complex
+      next_f = XPath.first( @@doc, "a/e/f[@id='11']/following-sibling::*" )
+      assert_equal 12, next_f.attributes['id'].to_i
+      prev_f = XPath.first( @@doc, "a/e/f[@id='11']/preceding-sibling::*" )
+      assert_equal 10, prev_f.attributes['id'].to_i
+      c = each_test( @@doc, "descendant-or-self::*[@x='y']" )
+      assert_equal 2, c
+    end
+
+    def match(xpath)
+      XPath.match(@@doc, xpath).collect(&:to_s)
+    end
+
+    def test_grouping
+      assert_equal([],
+                   match("a/d/*[name()='d' and (name()='f' or name()='q')]"))
+      assert_equal(["<q id='19'/>"],
+                   match("a/d/*[(name()='d' and name()='f') or name()='q']"))
+    end
+
+    def test_preceding
+      d = Document.new "<a><b id='0'/><b id='2'/><b><c id='0'/><c id='1'/><c id='2'/></b><b id='1'/></a>"
+      start = XPath.first( d, "/a/b[@id='1']" )
+      assert_equal 'b', start.name
+      c = XPath.first( start, "preceding::c" )
+      assert_equal '2', c.attributes['id']
+
+      c1, c0 = XPath.match( d, "/a/b/c[@id='2']/preceding::node()" )
+      assert_equal '1', c1.attributes['id']
+      assert_equal '0', c0.attributes['id']
+
+      c2, c1, c0, b, b2, b0 = XPath.match( start, "preceding::node()" )
+
+      assert_equal 'c', c2.name
+      assert_equal 'c', c1.name
+      assert_equal 'c', c0.name
+      assert_equal 'b', b.name
+      assert_equal 'b', b2.name
+      assert_equal 'b', b0.name
+
+      assert_equal '2', c2.attributes['id']
+      assert_equal '1', c1.attributes['id']
+      assert_equal '0', c0.attributes['id']
+      assert b.attributes.empty?
+      assert_equal '2', b2.attributes['id']
+      assert_equal '0', b0.attributes['id']
+
+      d = REXML::Document.new("<a><b/><c/><d/></a>")
+      matches = REXML::XPath.match(d, "/a/d/preceding::node()")
+      assert_equal("c", matches[0].name)
+      assert_equal("b", matches[1].name)
+
+      s = "<a><b><c id='1'/></b><b><b><c id='2'/><c id='3'/></b><c id='4'/></b><c id='NOMATCH'><c id='5'/></c></a>"
+      d = REXML::Document.new(s)
+      c = REXML::XPath.match( d, "//c[@id = '5']")
+      cs = REXML::XPath.match( c, "preceding::c" )
+      assert_equal( 4, cs.length )
+    end
+
+    def test_following
+      d = Document.new "<a><b id='0'/><b/><b><c id='1'/><c id='2'/></b><b id='1'/></a>"
+      start = XPath.first( d, "/a/b[@id='0']" )
+      assert_equal 'b', start.name
+      c = XPath.first( start, "following::c" )
+      assert_equal '1', c.attributes['id']
+
+      s = "<a><b><c><d/></c><e/></b><f><g><h/><i/></g></f><i/></a>"
+      d = Document.new(s)
+      c = XPath.first(d, '/a/b/c')
+      assert_equal 'c', c.name
+      res = XPath.match( c, 'following::*' )
+      assert_equal 6, res.size
+      res = XPath.match( c, 'following::i' )
+      assert_equal 2, res.size
+    end
+
+    # The following three paths were provided by
+    # Jeni Tennison <jeni@jenitennison.com>
+    # a consultant who is also an XSL and XPath expert
+    #def test_child_cubed
+    #  els = @@jeni.elements.to_a("*****")
+    #  assert_equal 3, els.size
+    #end
+
+    #def test_div_2
+    #  results = doc.elements.to_a("/ div 2")
+    #end
+
+    #def test_nested_predicates
+    #  puts @@jeni.root.elements[1].elements[1].name
+    #  results = @@jeni.root.elements[1].elements[1].elements.to_a("../following-sibling::*[*[name() = name(current())]]")
+    #  puts results
+    #end
+
+    # Contributed by Mike Stok
+    def test_starts_with
+      source = <<-EOF
+        <foo>
+        <a href="mailto:a@b.c">a@b.c</a>
+        <a href="http://www.foo.com">http://www.foo.com</a>
+        </foo>
+      EOF
+      doc = Document.new source
+      mailtos = doc.elements.to_a("//a[starts-with(@href, 'mailto:')]")
+      assert_equal 1, mailtos.size
+      assert_equal "mailto:a@b.c", mailtos[0].attributes['href']
+
+      ailtos = doc.elements.to_a("//a[starts-with(@href, 'ailto:')]")
+      assert_equal 0, ailtos.size
+    end
+
+    def test_toms_text_node
+      file = "<a>A<b>B</b><c>C<d>D</d>E</c>F</a>"
+      doc = Document.new(file)
+      assert_equal 'A', XPath.first(doc[0], 'text()').to_s
+      assert_equal 'AF', XPath.match(doc[0], 'text()').collect { |n|
+        n.to_s
+      }.join('')
+      assert_equal 'B', XPath.first(doc[0], 'b/text()').to_s
+      assert_equal 'D', XPath.first(doc[0], '//d/text()').to_s
+      assert_equal 'ABCDEF', XPath.match(doc[0], '//text()').collect {|n|
+        n.to_s
+      }.join('')
+    end
+
+    def test_string_length
+      doc = Document.new <<-EOF
+        <AAA>
+        <Q/>
+        <SSSS/>
+        <BB/>
+        <CCC/>
+        <DDDDDDDD/>
+        <EEEE/>
+        </AAA>
+      EOF
+      assert doc, "create doc"
+
+      set = doc.elements.to_a("//*[string-length(name()) = 3]")
+      assert_equal 2, set.size, "nodes with names length = 3"
+
+      set = doc.elements.to_a("//*[string-length(name()) < 3]")
+      assert_equal 2, set.size, "nodes with names length < 3"
+
+      set = doc.elements.to_a("//*[string-length(name()) > 3]")
+      assert_equal 3, set.size, "nodes with names length > 3"
+    end
+
+    # Test provided by Mike Stok
+    def test_contains
+      source = <<-EOF
+        <foo>
+        <a href="mailto:a@b.c">a@b.c</a>
+        <a href="http://www.foo.com">http://www.foo.com</a>
+        </foo>
+      EOF
+      doc = Document.new source
+
+      [
+      #['o', 2],
+      ['foo', 1], ['bar', 0]].each { |search, expected|
+        set = doc.elements.to_a("//a[contains(@href, '#{search}')]")
+        assert_equal expected, set.size
+      }
+    end
+
+    # Mike Stok and Sean Russell
+    def test_substring
+      # examples from http://www.w3.org/TR/xpath#function-substring
+      doc = Document.new('<test string="12345" />')
+
+      Document.new("<a b='1'/>")
+      #puts XPath.first(d, 'node()[0 + 1]')
+      #d = Document.new("<a b='1'/>")
+      #puts XPath.first(d, 'a[0 mod 0]')
+      [ [1.5, 2.6, '234'],
+        [0, 3, '12'],
+        [0, '0 div 0', ''],
+        [1, '0 div 0', ''],
+        ['-42', '1 div 0', '12345'],
+        ['-1 div 0', '1 div 0', '']
+      ].each { |start, length, expected|
+        set = doc.elements.to_a("//test[substring(@string, #{start}, #{length}) = '#{expected}']")
+        assert_equal 1, set.size, "#{start}, #{length}, '#{expected}'"
+      }
+    end
+
+    def test_translate
+      source = <<-EOF
+      <doc>
+      <case name='w3c one' result='BAr' />        <!-- w3c -->
+      <case name='w3c two' result='AAA' />        <!-- w3c -->
+      <case name='alchemy' result="gold" />   <!-- mike -->
+      <case name='vbxml one' result='A Space Odyssey' />
+      <case name='vbxml two' result='AbCdEf' />
+      </doc>
+      EOF
+
+      doc = Document.new(source)
+
+      [ ['bar', 'abc', 'ABC', 'w3c one'],
+      ['--aaa--','abc-','ABC', 'w3c two'],
+      ['lead', 'dear language', 'doll groover', 'alchemy'],
+      ['A Space Odissei', 'i', 'y', 'vbxml one'],
+      ['abcdefg', 'aceg', 'ACE', 'vbxml two'],
+      ].each { |arg1, arg2, arg3, name|
+        translate = "translate('#{arg1}', '#{arg2}', '#{arg3}')"
+        set = doc.elements.to_a("//case[@result = #{translate}]")
+        assert_equal 1, set.size, translate
+        assert_equal name, set[0].attributes['name']
+      }
+    end
+
+    def test_math
+      d = Document.new( '<a><b/><c/></a>' )
+      assert XPath.first( d.root, 'node()[1]' )
+      assert_equal 'b', XPath.first( d.root, 'node()[1]' ).name
+      assert XPath.first( d.root, 'node()[0 + 1]' )
+      assert_equal 'b', XPath.first( d.root, './node()[0 + 1]' ).name
+      assert XPath.first( d.root, 'node()[1 + 1]' )
+      assert_equal 'c', XPath.first( d.root, './node()[1 + 1]' ).name
+      assert XPath.first( d.root, 'node()[4 div 2]' )
+      assert_equal 'c', XPath.first( d.root, './node()[4 div 2]' ).name
+      assert XPath.first( d.root, 'node()[2 - 1]' )
+      assert_equal 'b', XPath.first( d.root, './node()[2 - 1]' ).name
+      assert XPath.first( d.root, 'node()[5 mod 2]' )
+      assert_equal 'b', XPath.first( d.root, './node()[5 mod 2]' ).name
+      assert XPath.first( d.root, 'node()[8 mod 3]' )
+      assert_equal 'c', XPath.first( d.root, './node()[8 mod 3]' ).name
+      assert XPath.first( d.root, 'node()[1 * 2]' )
+      assert_equal 'c', XPath.first( d.root, './node()[1 * 2]' ).name
+      assert XPath.first( d.root, 'node()[2 + -1]' )
+      assert_equal 'b', XPath.first( d.root, './node()[2 + -1]' ).name
+    end
+
+    def test_name
+      assert_raise( UndefinedNamespaceException, "x should be undefined" ) {
+        REXML::Document.new("<a x='foo'><b/><x:b/></a>")
+      }
+      d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
+      assert_equal 1, d.root.elements.to_a('*[name() = "b"]').size
+      assert_equal 1, d.elements.to_a('//*[name() = "x:b"]').size
+    end
+
+    def test_local_name
+      d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
+      assert_equal 2, d.root.elements.to_a('*[local_name() = "b"]').size
+      assert_equal 2, d.elements.to_a('//*[local_name() = "b"]').size
+    end
+
+    def test_comparisons
+      source = "<a><b id='1'/><b id='2'/><b id='3'/></a>"
+      doc = REXML::Document.new(source)
+
+      # NOTE TO SER: check that number() is required
+      assert_equal 2, REXML::XPath.match(doc, "//b[number(@id) > 1]").size
+      assert_equal 3, REXML::XPath.match(doc, "//b[number(@id) >= 1]").size
+      assert_equal 1, REXML::XPath.match(doc, "//b[number(@id) <= 1]").size
+      assert_equal 1, REXML::XPath.match(doc, "//b[number(@id) = (1 * 1)]").size
+      assert_equal 1, REXML::XPath.match(doc, "//b[number(@id) = (1 mod 2)]").size
+      assert_equal 1, REXML::XPath.match(doc, "//b[number(@id) = (4 div 2)]").size
+    end
+
+    # Contributed by Kouhei
+    def test_substring_before
+      doc = Document.new("<r><a/><b/><c/></r>")
+      assert_equal("a", doc.root.elements.to_a("*[name()=substring-before('abc', 'b')]")[0].name)
+      assert_equal("c", doc.root.elements.to_a("*[name()=substring-after('abc', 'b')]")[0].name)
+    end
+
+    def test_spaces
+      doc = Document.new("<a>
+        <b>
+          <c id='a'/>
+        </b>
+        <c id='b'/>
+        <c id='c'/>
+        <c/>
+      </a>")
+      match = lambda do |xpath|
+        REXML::XPath.match(doc, xpath).collect(&:to_s)
+      end
+      assert_equal(["<c id='b'/>"],
+                   match.call("//*[local-name()='c' and @id='b']"))
+      assert_equal(["<c id='b'/>"],
+                   match.call("//*[ local-name()='c' and @id='b' ]"))
+      assert_equal(["<c id='b'/>"],
+                   match.call("//*[ local-name() = 'c' and @id = 'b' ]"))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[@id]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[(@id)]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[ @id ]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[ (@id) ]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[( @id )]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[ ( @id ) ]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c [ ( @id ) ] '))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call(' / a / c [ ( @id ) ] '))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/ a / child:: c [( @id )] /'))
+    end
+
+    def test_text_nodes
+      #  source = "<root>
+      #<child/>
+      #<child>test</child>
+      #</root>"
+      source = "<root><child>test</child></root>"
+      d = REXML::Document.new( source )
+      r = REXML::XPath.match( d, %q{/root/child[text()="test"]} )
+      assert_equal( 1, r.size )
+      assert_equal( "child", r[0].name )
+      assert_equal( "test", r[0].text )
+    end
+
+    def test_auto_string_value
+      source = "<root><foo/><title>Introduction</title></root>"
+      d = REXML::Document.new( source )
+      #r = REXML::XPath.match( d, %q{/root[title="Introduction"]} )
+      #assert_equal( 1, r.size )
+      source = "<a><b/><c/><c>test</c></a>"
+      d = REXML::Document.new( source )
+      r = REXML::XPath.match( d, %q{/a[c='test']} )
+      assert_equal( 1, r.size )
+      r = REXML::XPath.match( d, %q{a[c='test']} )
+      assert_equal( 1, r.size )
+      r = d.elements["/a[c='test']"]
+      assert_not_nil( r )
+      r = d.elements["a[c='test']"]
+      assert_not_nil( r )
+      r = d.elements["a[c='xtest']"]
+      assert_nil( r )
+      r = REXML::XPath.match( d, %q{a[c='xtest']} )
+      assert_equal( 0, r.size )
+    end
+
+    def test_ordering
+      source = <<-XML
+<a>
+  <b>
+    <c id='1'/>
+    <c id='2'/>
+  </b>
+  <b>
+    <d id='3'/>
+    <d id='4'/>
+  </b>
+</a>
+      XML
+      d = REXML::Document.new( source )
+      r = REXML::XPath.match( d, %q{/a/*/*[1]} )
+      assert_equal(["1", "3"],
+                   r.collect {|element| element.attribute("id").value})
+    end
+
+    def test_descendant_or_self_ordering
+      source = "<a>
+      <b>
+        <c id='1'/>
+        <c id='2'/>
+      </b>
+      <b>
+        <d id='1'>
+          <c id='3'/>
+        </d>
+        <d id='2'>
+          <e>
+            <c id='4'/>
+          </e>
+        </d>
+      </b>
+    </a>"
+      d = REXML::Document.new( source )
+      cs = XPath.match( d, "/descendant-or-self::c" )
+      assert_equal( 4, cs.length )
+      1.upto(4) {|x| assert_equal( x.to_s, cs[x-1].attributes['id'] ) }
+    end
+
+    def test_and
+      d = Document.new %q{<doc><route run='*' title='HNO'
+      destination='debian_production1' date='*' edition='*'
+      source='debian_satellite1'/></doc>}
+      assert_equal( nil, d.root.elements["route[@run='0']"] )
+      assert_equal( nil, d.root.elements["route[@run='0' and @title='HNO']"] )
+    end
+
+
+    def test_numbers
+      d = Document.new %q{<a x="0" y="*" z="4e" w="e4" v="a"/>}
+
+      xp1 = "/a[ @x = 0 ]"
+      xp2 = "/a[ @x = '0' ]"
+      xp3 = "/a[ (@x + 1) = 1 ]"
+      xp4 = "/a[ @y = 0 ]"
+      xp5 = "/a[ (@z + 1) = 5 ]"
+      xp6 = "/a[ (@w + 1) = 5 ]"
+      xp7 = "/a[ (@v + 1) = 1 ]"
+      xp8 = "/a[ @n = 0 ]"
+
+      assert_equal( 1, XPath.match( d, xp1 ).length )
+      assert_equal( 1, XPath.match( d, xp2 ).length )
+      assert_equal( 1, XPath.match( d, xp3 ).length )
+      assert_equal( 0, XPath.match( d, xp4 ).length )
+      assert_equal( 0, XPath.match( d, xp5 ).length )
+      assert_equal( 0, XPath.match( d, xp6 ).length )
+      assert_equal( 0, XPath.match( d, xp7 ).length )
+      assert_equal( 0, XPath.match( d, xp8 ).length )
+    end
+
+    def test_tobis_preceding
+      doc_string = '<a>
+  <b/>
+  <c>
+    <d/>
+    <e/>
+  </c>
+</a>'
+
+      doc = Document.new(doc_string)
+
+      # e = REXML::XPath.first(doc,'/a/c/e')
+      e = doc.root.get_elements('/a/c/e')[0]
+      assert_equal( 1, e.get_elements('preceding-sibling::*').length )
+      assert_equal( 2, XPath.match(e, 'preceding::*').length )
+    end
+
+
+    def test_filtering
+      #doc=Document.new("<a><b><c1/><c2/></b><b><c3/><c4/></b><b><c5/><c6/></b></a>")
+      #assert_equal( 3, XPath.match( doc, '/a/b/*[1]' ).length )
+      #assert_equal( 2, XPath.match( doc, '/a/b/following-sibling::*[1]' ).length )
+    end
+
+    # Submitted by Alex
+    def test_union
+      data = %Q{<div id="the_div">
+  <span id="the_span">
+  <strong id="the_strong">a</strong>
+  </span>
+  <em id="the_em2">b</em>
+</div>}
+      rd = REXML::Document.new( data )
+      #union = rd.get_elements("/div/span | /div/em")
+      #assert_equal(2, union.length, "/div/span | /div/em" )
+      union = rd.get_elements('//*[name()="em" or name()="strong"]')
+      assert_equal(2, union.length, 'name() and "or" failed')
+      union = rd.get_elements('//em|//strong')
+      assert_equal(2, union.length,
+             'Both tag types are returned by XPath union operator')
+    end
+
+
+    def test_union2
+      src = <<-EOL
+<div id="the_div">
+<span id="the_span">
+<strong id="the_strong">a</strong>
+</span>
+<em id="the_em2">b</em>
+</div>
+      EOL
+      rd = REXML::Document.new( src )
+      union = rd.get_elements('//em|//strong')
+      assert_equal(2, union.length,
+        'Both tag types are returned by XPath union operator')
+    end
+
+
+    def test_a_star_star_one
+      string = <<-EOL
+<a>
+  <b>
+    <c1/>
+    <d/>
+    <e/>
+    <f/>
+  </b>
+  <b>
+    <c2/>
+    <d/>
+    <e/>
+    <f/>
+  </b>
+</a>
+      EOL
+      d = REXML::Document.new( string )
+      cs = XPath.match( d, '/a/*/*[1]' )
+      assert_equal(["c1", "c2"], cs.collect(&:name))
+    end
+
+    def test_sum
+      d = Document.new(<<-XML)
+<a>
+  <b>1</b>
+  <b>2</b>
+  <b>3</b>
+  <c>
+    <d>1</d>
+    <d>2</d>
+  </c>
+  <e att='1'/>
+  <e att='2'/>
+</a>
+      XML
+
+      assert_equal([6], XPath::match(d, "sum(/a/b)"))
+      assert_equal([9], XPath::match(d, "sum(//b | //d)"))
+      assert_equal([3], XPath::match(d, "sum(/a/e/@*)"))
+    end
+
+    def test_xpath_namespace
+      d = REXML::Document.new(<<-XML)
+<tag1 xmlns='ns1'>
+  <tag2 xmlns='ns2'/>
+  <tada>xa</tada>
+  <tada xmlns=''>xb</tada>
+</tag1>
+      XML
+      actual = []
+      d.root.each_element('tada') do |element|
+        actual << element.to_s
+      end
+      assert_equal(["<tada>xa</tada>", "<tada xmlns=''>xb</tada>"],
+                   actual)
+    end
+
+    def test_ticket_39
+      doc = REXML::Document.new( <<-EOL )
+      <rss>
+        <channel>
+          <!-- removing the namespace declaration makes the test pass -->
+          <convertLineBreaks xmlns="http://www.blogger.com/atom/ns#">true</convertLineBreaks>
+          <item>
+            <title>Item 1</title>
+          </item>
+          <item>
+            <title>Item 2</title>
+            <pubDate>Thu, 13 Oct 2005 19:59:00 +0000</pubDate>
+          </item>
+          <item>
+            <title>Item 3</title>
+          </item>
+        </channel>
+      </rss>
+      EOL
+      root_node = XPath.first(doc, "rss")
+      assert_not_nil root_node
+      channel_node = XPath.first(root_node, "channel")
+      assert_not_nil channel_node
+      items = XPath.match(channel_node, "*")
+      assert_equal 4, items.size
+      items = XPath.match(channel_node, "item")
+      assert_equal 3, items.size  # fails
+    end
+
+
+    def test_ticket_42
+      source = "<a></a>"
+      doc = Document.new(source)
+      bElem = Element.new('b')
+      doc.root.add_element(bElem)
+      doc.elements.each('//b[name(..) = "a"]') { |x|
+        assert_equal x,bElem
+      }
+    end
+
+    def test_ticket_56
+      namespaces = {'h' => 'http://www.w3.org/1999/xhtml'}
+
+      finaldoc = REXML::Document.new(File.read(fixture_path('google.2.xml')))
+
+      column_headers = []
+
+      REXML::XPath.each(finaldoc, '//h:form[@action="ModifyCampaign"]//h:th',
+                        namespaces) do |el|
+        node = REXML::XPath.first(el, 'h:a/text()', namespaces)
+        column_headers << (node ? node.value : nil)
+      end
+      column_headers.map! { |h| h.to_s.strip.chomp }
+      expected = ["", "", "Current Status", "Current Budget",
+        "Clicks", "Impr.", "CTR", "Avg. CPC", "Cost", "Conv. Rate",
+        "Cost/Conv."]
+      assert_equal( expected, column_headers )
+    end
+
+
+    def test_ticket_70
+      string = <<EOF
+
+<mydoc>
+
+    <someelement attribute="1.10">Text1, text,
+text</someelement>
+
+    <someelement attribute="1.11">Text2, text,
+text</someelement>
+
+
+</mydoc>
+
+EOF
+      doc = Document.new string
+      assert_equal( 1, XPath.match( doc, "//someelement[contains(@attribute,'1.10')]" ).length )
+    end
+
+    def test_ticket_43
+      #url = http://news.search.yahoo.com/news/rss?p=market&ei=UTF-8&fl=0&x=wrt
+
+      sum = File.open(fixture_path("yahoo.xml")) do |f|
+        Document.new(f).elements.to_a("//item").size
+      end
+      assert_equal( 10, sum )
+
+      text = File.open(fixture_path("yahoo.xml")) do |f|
+        Document.new(f).elements.to_a(%Q{//title[contains(text(), "'")]}).collect{|e| e.text}.join
+      end
+      assert_equal( "Broward labor market's a solid performer (Miami Herald)", text )
+    end
+
+    def test_ticket_57
+      data = "<?xml version='1.0'?><a:x xmlns:a='1'><a:y p='p' q='q'><a:z>zzz</a:z></a:y></a:x>"
+
+      r = Document.new(data)
+
+      assert_equal(Text, REXML::XPath.first(r,"a:x/a:y[@p='p' and @q='q']/a:z/text()").class)
+      assert_equal("zzz", REXML::XPath.first(r,"a:x/a:y[@p='p' and @q='q']/a:z/text()").to_s)
+    end
+
+    def test_ticket_59
+      data = "<a>
+        <c id='1'/>
+        <c id='2'/>
+        <b>
+          <c id='3'/>
+        </b>
+        <c id='4'/>
+        <b>
+          <b>
+            <c id='5'/>
+          </b>
+          <c id='6'/>
+        </b>
+        <c id='7'/>
+        <b>
+          <b>
+            <c id='8'/>
+            <b>
+              <c id='9'/>
+              <b>
+                <c id='10'/>
+              </b>
+              <c id='11'/>
+            </b>
+          </b>
+        </b>
+        <c id='12'/>
+      </a>"
+      d = Document.new(data)
+      res = d.elements.to_a( "//c" ).collect {|e| e.attributes['id'].to_i}
+      assert_equal((1..12).to_a, res)
+    end
+
+    def ticket_61_fixture(doc, xpath)
+      matches = []
+      doc.elements.each(xpath) do |element|
+        matches << element
+        assert_equal('Add', element.text)
+        assert_equal('ButtonText', element.attributes['class'])
+      end
+      assert_equal(1, matches.length)
+    end
+
+    def test_ticket_61_text
+      doc = File.open(fixture_path("ticket_61.xml")) do |file|
+        REXML::Document.new file
+      end
+      ticket_61_fixture( doc, "//div[text()='Add' and @class='ButtonText']" )
+    end
+
+    def test_ticket_61_contains
+      doc = File.open(fixture_path("ticket_61.xml")) do |file|
+        REXML::Document.new file
+      end
+      ticket_61_fixture( doc, "//div[contains(.,'Add') and @class='ButtonText']" )
+    end
+
+    def test_namespaces_0
+      d = Document.new(%q{<x:a xmlns:x="y"/>})
+      assert_equal( 1,  XPath.match( d, "//x:a" ).size )
+      assert_equal( 1,  XPath.match( d, "//x:*" ).size )
+    end
+
+    def test_ticket_71
+      doc = Document.new(%Q{<root xmlns:ns1="xyz" xmlns:ns2="123"><element ns1:attrname="foo" ns2:attrname="bar"/></root>})
+      el = doc.root.elements[1]
+      assert_equal( "element", el.name )
+      el2 = XPath.first( doc.root, "element[@ns:attrname='foo']", { 'ns' => "xyz" } )
+      assert_equal( el, el2 )
+    end
+
+    def test_ticket_78
+      doc = <<-EOT
+      <root>
+          <element>
+              <tag x='1'>123</tag>
+          </element>
+          <element>
+              <tag x='2'>123a</tag>
+          </element>
+      </root>
+      EOT
+      seq = %w{BEGIN 123 END BEGIN 123a END}
+
+      xmlDoc = Document.new(doc)
+
+      ["//element[tag='123']/tag", "//element[tag='123a']/tag"].each do |query|
+        assert_equal( "BEGIN", seq.shift )
+        XPath.each(xmlDoc, query) { |element|
+          assert_equal( seq.shift, element.text )
+        }
+        assert_equal( "END", seq.shift )
+      end
+    end
+
+    def test_ticket_79
+      source = "<a><b><c>test</c></b><b><c>3</c></b></a>"
+      d = REXML::Document.new( source )
+      r = REXML::XPath.match( d, %q{/a/b[c='test']} )
+      assert_equal(1, r.size())
+      r = REXML::XPath.match( d, %q{/a/b[c='3']} )
+      assert_equal(1, r.size())
+    end
+
+    def test_or_and
+      doc = "
+<html>
+  <head>
+    <title>test</title>
+  </head>
+  <body>
+    <p>
+      A <a rel=\"sub\" href=\"/\">link</a>.
+    </p>
+  </body>
+</html>
+"
+
+      xmldoc = REXML::Document.new(doc)
+      xpath = "descendant::node()[(local-name()='link' or local-name()='a') and @rel='sub']"
+      hrefs = []
+      xmldoc.elements.each(xpath) do |element|
+        hrefs << element.attributes["href"]
+      end
+      assert_equal(["/"], hrefs, "Bug #3842 [ruby-core:32447]")
+    end
+  end
+end
diff --git a/test/rexml/xpath/test_compare.rb b/test/rexml/xpath/test_compare.rb
new file mode 100644
index 0000000..bb666c9
--- /dev/null
+++ b/test/rexml/xpath/test_compare.rb
@@ -0,0 +1,256 @@
+# frozen_string_literal: false
+
+require_relative "../rexml_test_utils"
+
+require "rexml/document"
+
+module REXMLTests
+  class TestXPathCompare < Test::Unit::TestCase
+    def match(xml, xpath)
+      document = REXML::Document.new(xml)
+      REXML::XPath.match(document, xpath)
+    end
+
+    class TestEqual < self
+      class TestNodeSet < self
+        def test_boolean_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child/>
+  <child/>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child=true()"))
+        end
+
+        def test_boolean_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+</root>
+        XML
+          assert_equal([false],
+                       match(xml, "/root/child=true()"))
+        end
+
+        def test_number_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child=100"))
+        end
+
+        def test_number_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([false],
+                       match(xml, "/root/child=300"))
+        end
+
+        def test_string_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>text</child>
+  <child>string</child>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child='string'"))
+        end
+
+        def test_string_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>text</child>
+  <child>string</child>
+</root>
+          XML
+          assert_equal([false],
+                       match(xml, "/root/child='nonexistent'"))
+        end
+      end
+
+      class TestBoolean < self
+        def test_number_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "true()=1"))
+        end
+
+        def test_number_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "true()=0"))
+        end
+
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "true()='string'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "true()=''"))
+        end
+      end
+
+      class TestNumber < self
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "1='1'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "1='2'"))
+        end
+      end
+    end
+
+    class TestGreaterThan < self
+      class TestNodeSet < self
+        def test_boolean_truex
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child/>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child>false()"))
+        end
+
+        def test_boolean_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child/>
+</root>
+        XML
+          assert_equal([false],
+                       match(xml, "/root/child>true()"))
+        end
+
+        def test_number_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child>199"))
+        end
+
+        def test_number_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([false],
+                       match(xml, "/root/child>200"))
+        end
+
+        def test_string_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child>'199'"))
+        end
+
+        def test_string_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([false],
+                       match(xml, "/root/child>'200'"))
+        end
+      end
+
+      class TestBoolean < self
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "true()>'0'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "true()>'1'"))
+        end
+      end
+
+      class TestNumber < self
+        def test_boolean_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "true()>0"))
+        end
+
+        def test_number_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "true()>1"))
+        end
+
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "1>'0'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "1>'1'"))
+        end
+      end
+
+      class TestString < self
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "'1'>'0'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "'1'>'1'"))
+        end
+      end
+    end
+  end
+end
diff --git a/test/rexml/xpath/test_node.rb b/test/rexml/xpath/test_node.rb
new file mode 100644
index 0000000..e0e958e
--- /dev/null
+++ b/test/rexml/xpath/test_node.rb
@@ -0,0 +1,43 @@
+# -*- coding: utf-8 -*-
+# frozen_string_literal: false
+
+require_relative "../rexml_test_utils"
+
+require "rexml/document"
+
+module REXMLTests
+  class TestXPathNode < Test::Unit::TestCase
+    def matches(xml, xpath)
+      document = REXML::Document.new(xml)
+      REXML::XPath.each(document, xpath).collect(&:to_s)
+    end
+
+    class TestQName < self
+      def test_ascii
+        xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <ascii>
+    <child>child</child>
+  </ascii>
+</root>
+        XML
+        assert_equal(["<child>child</child>"],
+                     matches(xml, "/root/ascii/child"))
+      end
+
+      def test_non_ascii
+        xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <non-scii>
+    <child>child</child>
+  </non-scii>
+</root>
+        XML
+        assert_equal(["<child>child</child>"],
+                     matches(xml, "/root/non-scii/child"))
+      end
+    end
+  end
+end
diff --git a/test/rexml/xpath/test_predicate.rb b/test/rexml/xpath/test_predicate.rb
new file mode 100644
index 0000000..ce1aaa3
--- /dev/null
+++ b/test/rexml/xpath/test_predicate.rb
@@ -0,0 +1,83 @@
+# frozen_string_literal: false
+require "test/unit/testcase"
+require "rexml/document"
+require "rexml/xpath"
+require "rexml/parsers/xpathparser"
+
+module REXMLTests
+  class TestXPathPredicate < Test::Unit::TestCase
+    include REXML
+    SRC=<<-EOL
+    <article>
+       <section role="subdivision" id="1">
+          <para>free flowing text.</para>
+       </section>
+       <section role="division">
+          <section role="subdivision" id="2">
+             <para>free flowing text.</para>
+          </section>
+          <section role="division">
+             <para>free flowing text.</para>
+          </section>
+       </section>
+    </article>
+    EOL
+
+    def setup
+      @doc = REXML::Document.new( SRC )
+      @parser = REXML::Parsers::XPathParser.new
+
+    end
+
+    def test_predicates_parent
+      path = '//section[../self::section[@role="division"]]'
+      m = do_path( path )
+      assert_equal( 2, m.size )
+      assert_equal( "2", m[0].attributes["id"] )
+      assert_nil( m[1].attributes["id"] )
+    end
+
+    def test_predicates_single
+      path = '//section[@role="subdivision" and not(../self::section[@role="division"])]'
+      m = do_path( path )
+      assert_equal( 1, m.size )
+      assert_equal( "1", m[0].attributes["id"] )
+    end
+
+    def test_predicates_multi
+      path = '//section[@role="subdivision"][not(../self::section[@role="division"])]'
+      m = do_path( path )
+      assert_equal( 1, m.size )
+      assert_equal( "1", m[0].attributes["id"] )
+    end
+
+    def do_path( path )
+      m = REXML::XPath.match( @doc, path )
+      #puts path, @parser.parse( path ).inspect
+      return m
+    end
+
+    def test_get_no_siblings_terminal_nodes
+      source = <<-XML
+<a>
+  <b number='1' str='abc'>TEXT1</b>
+  <c number='1'/>
+  <c number='2' str='def'>
+    <b number='3'/>
+    <d number='1' str='abc'>TEXT2</d>
+    <b number='2'><!--COMMENT--></b>
+  </c>
+</a>
+XML
+      doc = REXML::Document.new(source)
+      predicate = "count(child::node()|" +
+                        "following-sibling::node()|" +
+                        "preceding-sibling::node())=0"
+      m = REXML::XPath.match(doc, "/descendant-or-self::node()[#{predicate}]")
+      assert_equal( [REXML::Text.new("TEXT1"),
+                     REXML::Text.new("TEXT2"),
+                     REXML::Comment.new("COMMENT")],
+                    m )
+    end
+  end
+end
diff --git a/test/rexml/xpath/test_text.rb b/test/rexml/xpath/test_text.rb
new file mode 100644
index 0000000..7222388
--- /dev/null
+++ b/test/rexml/xpath/test_text.rb
@@ -0,0 +1,77 @@
+# frozen_string_literal: false
+require 'test/unit'
+require 'rexml/document'
+require 'rexml/element'
+require 'rexml/xpath'
+
+module REXMLTests
+  class TestXPathText < Test::Unit::TestCase
+    def setup
+      @doc = REXML::Document.new
+    end
+
+    def tear_down
+    end
+
+    def test_text_as_element
+      node1 = REXML::Element.new('a', @doc)
+      node2 = REXML::Element.new('b', node1)
+      REXML::Text.new('test', false, node2)
+      assert_equal(1, @doc.elements.size, "doc owns 1 element node1")
+      assert_same(node1, @doc.elements[1], "doc owns 1 element node1")
+      assert_equal(1, node1.elements.size, "node1 owns 1 element node2")
+      assert_same(node2, node1.elements[1], "node1 owns 1 element node2")
+      assert_equal(1, node2.size, "node2 owns 1 text element")
+    end
+
+    def test_text_in_xpath_query
+      node1 = REXML::Element.new('a', @doc)
+      node2 = REXML::Element.new('b', node1)
+      textnode = REXML::Text.new('test', false, node2)
+      textnode.parent = node2   # should be unnecessary
+      nodes = @doc.get_elements('//b')
+      assert_equal(1, nodes.size, "document has one element")
+      # why doesn't this query work right?
+      nodes = REXML::XPath.match(@doc, '//text()')
+      assert_equal(1, nodes.size, "//text() should yield one Text element")
+      assert_equal(REXML::Text, nodes[0].class)
+    end
+
+    def test_comment_in_xpath_query
+      node1 = REXML::Element.new('a', @doc)
+      node2 = REXML::Element.new('b', node1)
+      commentnode = REXML::Comment.new('test', node2)
+      nodes = REXML::XPath.match(@doc, '//comment()')
+      assert_equal(1, nodes.size, "//comment() should yield one Comment element")
+      assert_same commentnode, nodes[0]
+    end
+
+    def test_parentage
+      node1 = REXML::Element.new('a', @doc)
+      assert_same(@doc, node1.parent, "node1 parent is document")
+      node2 = REXML::Element.new('b', node1)
+      assert_same(node1, node2.parent, "node2 parent is node1")
+      textnode = REXML::Text.new('test', false, node2)
+      # why isn't the text's parent node2?
+      # Also look at Comment, etc.
+      assert_same(node2, textnode.parent)
+      comment = REXML::Comment.new('Test comment', node2)
+      assert_same(node2, comment.parent)
+    end
+
+    def test_ancestors
+      node1 = REXML::Element.new('a', @doc)
+      node2 = REXML::Element.new('b', node1)
+      textnode = REXML::Text.new('test', false, node2)
+      #textnode.parent = node2   # should be unnecessary
+      assert_same node2, textnode.parent
+      nodes = @doc.get_elements('//b/ancestor::*')
+      assert_equal(1, nodes.size, "<b> has one element ancestor")
+      nodes = @doc.get_elements('//b/ancestor::node()')
+      assert_equal(2, nodes.size, "<b> has two node ancestors")
+      nodes.sort_by!(&:name)
+      assert_kind_of REXML::Document, nodes[0]
+      assert_kind_of REXML::Element, nodes[1]
+    end
+  end
+end
