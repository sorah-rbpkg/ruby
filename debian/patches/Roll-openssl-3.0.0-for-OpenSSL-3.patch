From: Sorah Fukumori <her@sorah.jp>
Date: Tue, 26 Apr 2022 11:05:15 +0900
Subject: Roll openssl-3.0.0 for OpenSSL 3

---
 ext/openssl/History.md                 |  104 +-
 ext/openssl/depend                     |    2 +
 ext/openssl/extconf.rb                 |   50 +-
 ext/openssl/lib/openssl.rb             |    1 -
 ext/openssl/lib/openssl/buffering.rb   |    9 +
 ext/openssl/lib/openssl/config.rb      |  501 ---------
 ext/openssl/lib/openssl/hmac.rb        |   65 ++
 ext/openssl/lib/openssl/pkey.rb        |  417 ++++++++
 ext/openssl/lib/openssl/ssl.rb         |   14 +-
 ext/openssl/lib/openssl/version.rb     |    2 +-
 ext/openssl/lib/openssl/x509.rb        |   22 +
 ext/openssl/openssl.gemspec            |   10 +-
 ext/openssl/openssl_missing.c          |   66 --
 ext/openssl/openssl_missing.h          |   71 +-
 ext/openssl/ossl.c                     |  105 +-
 ext/openssl/ossl.h                     |   26 +-
 ext/openssl/ossl_asn1.c                |   20 +-
 ext/openssl/ossl_bn.c                  |  314 +++---
 ext/openssl/ossl_cipher.c              |   22 +-
 ext/openssl/ossl_config.c              |  453 +++++++-
 ext/openssl/ossl_config.h              |   11 +-
 ext/openssl/ossl_digest.c              |   18 +-
 ext/openssl/ossl_engine.c              |   31 +-
 ext/openssl/ossl_hmac.c                |  183 +---
 ext/openssl/ossl_kdf.c                 |    8 +
 ext/openssl/ossl_ocsp.c                |   54 +-
 ext/openssl/ossl_pkcs12.c              |   24 +-
 ext/openssl/ossl_pkcs7.c               |  101 +-
 ext/openssl/ossl_pkey.c                | 1293 +++++++++++++++++++----
 ext/openssl/ossl_pkey.h                |  107 +-
 ext/openssl/ossl_pkey_dh.c             |  458 +++------
 ext/openssl/ossl_pkey_dsa.c            |  491 ++-------
 ext/openssl/ossl_pkey_ec.c             |  444 +++-----
 ext/openssl/ossl_pkey_rsa.c            |  587 ++---------
 ext/openssl/ossl_ssl.c                 |  611 +++++------
 ext/openssl/ossl_ssl_session.c         |   53 +-
 ext/openssl/ossl_ts.c                  |   55 +-
 ext/openssl/ossl_x509.c                |    6 -
 ext/openssl/ossl_x509cert.c            |  172 +++-
 ext/openssl/ossl_x509crl.c             |   17 +-
 ext/openssl/ossl_x509ext.c             |    3 +-
 ext/openssl/ossl_x509name.c            |   11 +-
 ext/openssl/ossl_x509req.c             |   17 +-
 ext/openssl/ossl_x509store.c           |  224 ++--
 ext/openssl/ruby_missing.h             |   24 -
 test/openssl/fixtures/pkey/dh-1.pem    |   13 -
 test/openssl/fixtures/pkey/dh1024.pem  |    5 -
 test/openssl/fixtures/pkey/dsa1024.pem |   12 -
 test/openssl/fixtures/pkey/dsa256.pem  |    8 -
 test/openssl/fixtures/pkey/dsa512.pem  |    8 -
 test/openssl/fixtures/pkey/p256.pem    |    5 -
 test/openssl/fixtures/pkey/rsa-1.pem   |   51 -
 test/openssl/fixtures/pkey/rsa-2.pem   |   51 -
 test/openssl/fixtures/pkey/rsa-3.pem   |   51 -
 test/openssl/fixtures/pkey/rsa1024.pem |   15 -
 test/openssl/fixtures/pkey/rsa2048.pem |   27 -
 test/openssl/test_asn1.rb              |  720 -------------
 test/openssl/test_bn.rb                |  286 ------
 test/openssl/test_buffering.rb         |   97 --
 test/openssl/test_cipher.rb            |  388 -------
 test/openssl/test_config.rb            |  374 -------
 test/openssl/test_digest.rb            |  149 ---
 test/openssl/test_engine.rb            |   97 --
 test/openssl/test_fips.rb              |   30 -
 test/openssl/test_hmac.rb              |   54 -
 test/openssl/test_kdf.rb               |  183 ----
 test/openssl/test_ns_spki.rb           |   53 -
 test/openssl/test_ocsp.rb              |  311 ------
 test/openssl/test_ossl.rb              |   65 --
 test/openssl/test_pair.rb              |  509 ---------
 test/openssl/test_pkcs12.rb            |  313 ------
 test/openssl/test_pkcs7.rb             |  309 ------
 test/openssl/test_pkey.rb              |   28 -
 test/openssl/test_pkey_dh.rb           |  110 --
 test/openssl/test_pkey_dsa.rb          |  207 ----
 test/openssl/test_pkey_ec.rb           |  381 -------
 test/openssl/test_pkey_rsa.rb          |  459 ---------
 test/openssl/test_random.rb            |   19 -
 test/openssl/test_ssl.rb               | 1761 --------------------------------
 test/openssl/test_ssl_session.rb       |  401 --------
 test/openssl/test_ts.rb                |  680 ------------
 test/openssl/test_x509attr.rb          |   94 --
 test/openssl/test_x509cert.rb          |  288 ------
 test/openssl/test_x509crl.rb           |  284 -----
 test/openssl/test_x509ext.rb           |  104 --
 test/openssl/test_x509name.rb          |  469 ---------
 test/openssl/test_x509req.rb           |  170 ---
 test/openssl/test_x509store.rb         |  241 -----
 test/openssl/ut_eof.rb                 |  133 ---
 test/openssl/utils.rb                  |  405 --------
 90 files changed, 3778 insertions(+), 13917 deletions(-)
 delete mode 100644 ext/openssl/lib/openssl/config.rb
 delete mode 100644 test/openssl/fixtures/pkey/dh-1.pem
 delete mode 100644 test/openssl/fixtures/pkey/dh1024.pem
 delete mode 100644 test/openssl/fixtures/pkey/dsa1024.pem
 delete mode 100644 test/openssl/fixtures/pkey/dsa256.pem
 delete mode 100644 test/openssl/fixtures/pkey/dsa512.pem
 delete mode 100644 test/openssl/fixtures/pkey/p256.pem
 delete mode 100644 test/openssl/fixtures/pkey/rsa-1.pem
 delete mode 100644 test/openssl/fixtures/pkey/rsa-2.pem
 delete mode 100644 test/openssl/fixtures/pkey/rsa-3.pem
 delete mode 100644 test/openssl/fixtures/pkey/rsa1024.pem
 delete mode 100644 test/openssl/fixtures/pkey/rsa2048.pem
 delete mode 100644 test/openssl/test_asn1.rb
 delete mode 100644 test/openssl/test_bn.rb
 delete mode 100644 test/openssl/test_buffering.rb
 delete mode 100644 test/openssl/test_cipher.rb
 delete mode 100644 test/openssl/test_config.rb
 delete mode 100644 test/openssl/test_digest.rb
 delete mode 100644 test/openssl/test_engine.rb
 delete mode 100644 test/openssl/test_fips.rb
 delete mode 100644 test/openssl/test_hmac.rb
 delete mode 100644 test/openssl/test_kdf.rb
 delete mode 100644 test/openssl/test_ns_spki.rb
 delete mode 100644 test/openssl/test_ocsp.rb
 delete mode 100644 test/openssl/test_ossl.rb
 delete mode 100644 test/openssl/test_pair.rb
 delete mode 100644 test/openssl/test_pkcs12.rb
 delete mode 100644 test/openssl/test_pkcs7.rb
 delete mode 100644 test/openssl/test_pkey.rb
 delete mode 100644 test/openssl/test_pkey_dh.rb
 delete mode 100644 test/openssl/test_pkey_dsa.rb
 delete mode 100644 test/openssl/test_pkey_ec.rb
 delete mode 100644 test/openssl/test_pkey_rsa.rb
 delete mode 100644 test/openssl/test_random.rb
 delete mode 100644 test/openssl/test_ssl.rb
 delete mode 100644 test/openssl/test_ssl_session.rb
 delete mode 100644 test/openssl/test_ts.rb
 delete mode 100644 test/openssl/test_x509attr.rb
 delete mode 100644 test/openssl/test_x509cert.rb
 delete mode 100644 test/openssl/test_x509crl.rb
 delete mode 100644 test/openssl/test_x509ext.rb
 delete mode 100644 test/openssl/test_x509name.rb
 delete mode 100644 test/openssl/test_x509req.rb
 delete mode 100644 test/openssl/test_x509store.rb
 delete mode 100644 test/openssl/ut_eof.rb
 delete mode 100644 test/openssl/utils.rb

diff --git a/ext/openssl/History.md b/ext/openssl/History.md
index 46435f9..479ec3b 100644
--- a/ext/openssl/History.md
+++ b/ext/openssl/History.md
@@ -1,3 +1,105 @@
+Version 3.0.0
+=============
+
+Compatibility notes
+-------------------
+
+* OpenSSL 1.0.1 and Ruby 2.3-2.5 are no longer supported.
+  [[GitHub #396]](https://github.com/ruby/openssl/pull/396)
+  [[GitHub #466]](https://github.com/ruby/openssl/pull/466)
+
+* OpenSSL 3.0 support is added. It is the first major version bump from OpenSSL
+  1.1 and contains incompatible changes that affect Ruby/OpenSSL.
+  Note that OpenSSL 3.0 support is preliminary and not all features are
+  currently available:
+  [[GitHub #369]](https://github.com/ruby/openssl/issues/369)
+
+  - Deprecate the ability to modify `OpenSSL::PKey::PKey` instances. OpenSSL 3.0
+    made EVP_PKEY structure immutable, and hence the following methods are not
+    available when Ruby/OpenSSL is linked against OpenSSL 3.0.
+    [[GitHub #480]](https://github.com/ruby/openssl/pull/480)
+
+    - `OpenSSL::PKey::RSA#set_key`, `#set_factors`, `#set_crt_params`
+    - `OpenSSL::PKey::DSA#set_pqg`, `#set_key`
+    - `OpenSSL::PKey::DH#set_pqg`, `#set_key`, `#generate_key!`
+    - `OpenSSL::PKey::EC#private_key=`, `#public_key=`, `#group=`, `#generate_key!`
+
+  - Deprecate `OpenSSL::Engine`. The ENGINE API has been deprecated in OpenSSL 3.0
+    in favor of the new "provider" concept and will be removed in a future
+    version.
+    [[GitHub #481]](https://github.com/ruby/openssl/pull/481)
+
+* `OpenSSL::SSL::SSLContext#tmp_ecdh_callback` has been removed. It has been
+  deprecated since v2.0.0 because it is incompatible with modern OpenSSL
+  versions.
+  [[GitHub #394]](https://github.com/ruby/openssl/pull/394)
+
+* `OpenSSL::SSL::SSLSocket#read` and `#write` now raise `OpenSSL::SSL::SSLError`
+  if called before a TLS connection is established. Historically, they
+  read/wrote unencrypted data to the underlying socket directly in that case.
+  [[GitHub #9]](https://github.com/ruby/openssl/issues/9)
+  [[GitHub #469]](https://github.com/ruby/openssl/pull/469)
+
+
+Notable changes
+---------------
+
+* Enhance OpenSSL::PKey's common interface.
+  [[GitHub #370]](https://github.com/ruby/openssl/issues/370)
+
+  - Key deserialization: Enhance `OpenSSL::PKey.read` to handle PEM encoding of
+    DH parameters, which used to be only deserialized by `OpenSSL::PKey::DH.new`.
+    [[GitHub #328]](https://github.com/ruby/openssl/issues/328)
+  - Key generation: Add `OpenSSL::PKey.generate_parameters` and
+    `OpenSSL::PKey.generate_key`.
+    [[GitHub #329]](https://github.com/ruby/openssl/issues/329)
+  - Public key signing: Enhance `OpenSSL::PKey::PKey#sign` and `#verify` to use
+    the new EVP_DigestSign() family to enable PureEdDSA support on OpenSSL 1.1.1
+    or later. They also now take optional algorithm-specific parameters for more
+    control.
+    [[GitHub #329]](https://github.com/ruby/openssl/issues/329)
+  - Low-level public key signing and verification: Add
+    `OpenSSL::PKey::PKey#sign_raw`, `#verify_raw`, and `#verify_recover`.
+    [[GitHub #382]](https://github.com/ruby/openssl/issues/382)
+  - Public key encryption: Add `OpenSSL::PKey::PKey#encrypt` and `#decrypt`.
+    [[GitHub #382]](https://github.com/ruby/openssl/issues/382)
+  - Key agreement: Add `OpenSSL::PKey::PKey#derive`.
+    [[GitHub #329]](https://github.com/ruby/openssl/issues/329)
+  - Key comparison: Add `OpenSSL::PKey::PKey#compare?` to conveniently check
+    that two keys have common parameters and a public key.
+    [[GitHub #383]](https://github.com/ruby/openssl/issues/383)
+
+* Add `OpenSSL::BN#set_flags` and `#get_flags`. This can be used in combination
+  with `OpenSSL::BN::CONSTTIME` to force constant-time computation.
+  [[GitHub #417]](https://github.com/ruby/openssl/issues/417)
+
+* Add `OpenSSL::BN#abs` to get the absolute value of the BIGNUM.
+  [[GitHub #430]](https://github.com/ruby/openssl/issues/430)
+
+* Add `OpenSSL::SSL::SSLSocket#getbyte`.
+  [[GitHub #438]](https://github.com/ruby/openssl/issues/438)
+
+* Add `OpenSSL::SSL::SSLContext#tmp_dh=`.
+  [[GitHub #459]](https://github.com/ruby/openssl/pull/459)
+
+* Add `OpenSSL::X509::Certificate.load` to load a PEM-encoded and concatenated
+  list of X.509 certificates at once.
+  [[GitHub #441]](https://github.com/ruby/openssl/pull/441)
+
+* Change `OpenSSL::X509::Certificate.new` to attempt to deserialize the given
+  string first as DER encoding first and then as PEM encoding to ensure the
+  round-trip consistency.
+  [[GitHub #442]](https://github.com/ruby/openssl/pull/442)
+
+* Update various part of the code base to use the modern API. No breaking
+  changes are intended with this. This includes:
+
+  - `OpenSSL::HMAC` uses the EVP API.
+    [[GitHub #371]](https://github.com/ruby/openssl/issues/371)
+  - `OpenSSL::Config` uses native OpenSSL API to parse config files.
+    [[GitHub #342]](https://github.com/ruby/openssl/issues/342)
+
+
 Version 2.2.1
 =============
 
@@ -113,7 +215,7 @@ Bug fixes
   [[GitHub #453]](https://github.com/ruby/openssl/pull/453)
 * Fix misuse of input record separator in `OpenSSL::Buffering` where it was
   for output.
-* Fix wrong interger casting in `OpenSSL::PKey::EC#dsa_verify_asn1`.
+* Fix wrong integer casting in `OpenSSL::PKey::EC#dsa_verify_asn1`.
   [[GitHub #460]](https://github.com/ruby/openssl/pull/460)
 * `extconf.rb` explicitly checks that OpenSSL's version number is 1.0.1 or
   newer but also less than 3.0. Ruby/OpenSSL v2.1.x and v2.2.x will not support
diff --git a/ext/openssl/depend b/ext/openssl/depend
index 92825ba..8c6db94 100644
--- a/ext/openssl/depend
+++ b/ext/openssl/depend
@@ -5990,3 +5990,5 @@ ossl_x509store.o: ossl_x509.h
 ossl_x509store.o: ossl_x509store.c
 ossl_x509store.o: ruby_missing.h
 # AUTOGENERATED DEPENDENCIES END
+
+ruby_missing.h:
diff --git a/ext/openssl/extconf.rb b/ext/openssl/extconf.rb
index e13595c..fedcb93 100644
--- a/ext/openssl/extconf.rb
+++ b/ext/openssl/extconf.rb
@@ -26,6 +26,8 @@ if with_config("debug") or enable_config("debug")
   $defs.push("-DOSSL_DEBUG")
 end
 
+have_func("rb_io_maybe_wait") # Ruby 3.1
+
 Logging::message "=== Checking for system dependent stuff... ===\n"
 have_library("nsl", "t_open")
 have_library("socket", "socket")
@@ -102,15 +104,14 @@ end
 
 version_ok = if have_macro("LIBRESSL_VERSION_NUMBER", "openssl/opensslv.h")
   is_libressl = true
-  checking_for("LibreSSL version >= 2.5.0") {
-    try_static_assert("LIBRESSL_VERSION_NUMBER >= 0x20500000L", "openssl/opensslv.h") }
+  checking_for("LibreSSL version >= 3.1.0") {
+    try_static_assert("LIBRESSL_VERSION_NUMBER >= 0x30100000L", "openssl/opensslv.h") }
 else
-  checking_for("OpenSSL version >= 1.0.1 and < 3.0.0") {
-    try_static_assert("OPENSSL_VERSION_NUMBER >= 0x10001000L", "openssl/opensslv.h") &&
-    !try_static_assert("OPENSSL_VERSION_MAJOR >= 3", "openssl/opensslv.h") }
+  checking_for("OpenSSL version >= 1.0.2") {
+    try_static_assert("OPENSSL_VERSION_NUMBER >= 0x10002000L", "openssl/opensslv.h") }
 end
 unless version_ok
-  raise "OpenSSL >= 1.0.1, < 3.0.0 or LibreSSL >= 2.5.0 is required"
+  raise "OpenSSL >= 1.0.2 or LibreSSL >= 3.1.0 is required"
 end
 
 # Prevent wincrypt.h from being included, which defines conflicting macro with openssl/x509.h
@@ -127,29 +128,13 @@ engines.each { |name|
   have_func("ENGINE_load_#{name}()", "openssl/engine.h")
 }
 
-# added in 1.0.2
-have_func("EC_curve_nist2nid")
-have_func("X509_REVOKED_dup")
-have_func("X509_STORE_CTX_get0_store")
-have_func("SSL_CTX_set_alpn_select_cb")
-have_func("SSL_CTX_set1_curves_list(NULL, NULL)", "openssl/ssl.h")
-have_func("SSL_CTX_set_ecdh_auto(NULL, 0)", "openssl/ssl.h")
-have_func("SSL_get_server_tmp_key(NULL, NULL)", "openssl/ssl.h")
-have_func("SSL_is_server")
-
 # added in 1.1.0
-if !have_struct_member("SSL", "ctx", "openssl/ssl.h") ||
-    try_static_assert("LIBRESSL_VERSION_NUMBER >= 0x2070000fL", "openssl/opensslv.h")
+if !have_struct_member("SSL", "ctx", "openssl/ssl.h") || is_libressl
   $defs.push("-DHAVE_OPAQUE_OPENSSL")
 end
-have_func("CRYPTO_lock") || $defs.push("-DHAVE_OPENSSL_110_THREADING_API")
-have_func("BN_GENCB_new")
-have_func("BN_GENCB_free")
-have_func("BN_GENCB_get_arg")
 have_func("EVP_MD_CTX_new")
 have_func("EVP_MD_CTX_free")
-have_func("HMAC_CTX_new")
-have_func("HMAC_CTX_free")
+have_func("EVP_MD_CTX_pkey_ctx")
 have_func("X509_STORE_get_ex_data")
 have_func("X509_STORE_set_ex_data")
 have_func("X509_STORE_get_ex_new_index")
@@ -168,7 +153,6 @@ have_func("X509_CRL_up_ref")
 have_func("X509_STORE_up_ref")
 have_func("SSL_SESSION_up_ref")
 have_func("EVP_PKEY_up_ref")
-have_func("SSL_CTX_set_tmp_ecdh_callback(NULL, NULL)", "openssl/ssl.h") # removed
 have_func("SSL_CTX_set_min_proto_version(NULL, 0)", "openssl/ssl.h")
 have_func("SSL_CTX_get_security_level")
 have_func("X509_get0_notBefore")
@@ -176,13 +160,27 @@ have_func("SSL_SESSION_get_protocol_version")
 have_func("TS_STATUS_INFO_get0_status")
 have_func("TS_STATUS_INFO_get0_text")
 have_func("TS_STATUS_INFO_get0_failure_info")
-have_func("TS_VERIFY_CTS_set_certs")
+have_func("TS_VERIFY_CTS_set_certs(NULL, NULL)", "openssl/ts.h")
 have_func("TS_VERIFY_CTX_set_store")
 have_func("TS_VERIFY_CTX_add_flags")
 have_func("TS_RESP_CTX_set_time_cb")
 have_func("EVP_PBE_scrypt")
 have_func("SSL_CTX_set_post_handshake_auth")
 
+# added in 1.1.1
+have_func("EVP_PKEY_check")
+
+# added in 3.0.0
+have_func("SSL_set0_tmp_dh_pkey")
+have_func("ERR_get_error_all")
+have_func("TS_VERIFY_CTX_set_certs(NULL, NULL)", "openssl/ts.h")
+have_func("SSL_CTX_load_verify_file")
+have_func("BN_check_prime")
+have_func("EVP_MD_CTX_get0_md")
+have_func("EVP_MD_CTX_get_pkey_ctx")
+have_func("EVP_PKEY_eq")
+have_func("EVP_PKEY_dup")
+
 Logging::message "=== Checking done. ===\n"
 
 create_header
diff --git a/ext/openssl/lib/openssl.rb b/ext/openssl/lib/openssl.rb
index b047485..8a342f1 100644
--- a/ext/openssl/lib/openssl.rb
+++ b/ext/openssl/lib/openssl.rb
@@ -15,7 +15,6 @@ require 'openssl.so'
 require_relative 'openssl/bn'
 require_relative 'openssl/pkey'
 require_relative 'openssl/cipher'
-require_relative 'openssl/config'
 require_relative 'openssl/digest'
 require_relative 'openssl/hmac'
 require_relative 'openssl/x509'
diff --git a/ext/openssl/lib/openssl/buffering.rb b/ext/openssl/lib/openssl/buffering.rb
index 32e04b4..d47e108 100644
--- a/ext/openssl/lib/openssl/buffering.rb
+++ b/ext/openssl/lib/openssl/buffering.rb
@@ -101,6 +101,15 @@ module OpenSSL::Buffering
 
   public
 
+  # call-seq:
+  #   ssl.getbyte => 81
+  #
+  # Get the next 8bit byte from `ssl`.  Returns `nil` on EOF
+  def getbyte
+    byte = read(1)
+    byte && byte.unpack1("C")
+  end
+
   ##
   # Reads _size_ bytes from the stream.  If _buf_ is provided it must
   # reference a string which will receive the data.
diff --git a/ext/openssl/lib/openssl/config.rb b/ext/openssl/lib/openssl/config.rb
deleted file mode 100644
index 9a0b787..0000000
--- a/ext/openssl/lib/openssl/config.rb
+++ /dev/null
@@ -1,501 +0,0 @@
-# frozen_string_literal: true
-=begin
-= Ruby-space definitions that completes C-space funcs for Config
-
-= Info
-  Copyright (C) 2010  Hiroshi Nakamura <nahi@ruby-lang.org>
-
-= Licence
-  This program is licensed under the same licence as Ruby.
-  (See the file 'LICENCE'.)
-
-=end
-
-require 'stringio'
-
-module OpenSSL
-  ##
-  # = OpenSSL::Config
-  #
-  # Configuration for the openssl library.
-  #
-  # Many system's installation of openssl library will depend on your system
-  # configuration. See the value of OpenSSL::Config::DEFAULT_CONFIG_FILE for
-  # the location of the file for your host.
-  #
-  # See also http://www.openssl.org/docs/apps/config.html
-  class Config
-    include Enumerable
-
-    class << self
-
-      ##
-      # Parses a given _string_ as a blob that contains configuration for
-      # OpenSSL.
-      #
-      # If the source of the IO is a file, then consider using #parse_config.
-      def parse(string)
-        c = new()
-        parse_config(StringIO.new(string)).each do |section, hash|
-          c.set_section(section, hash)
-        end
-        c
-      end
-
-      ##
-      # load is an alias to ::new
-      alias load new
-
-      ##
-      # Parses the configuration data read from _io_, see also #parse.
-      #
-      # Raises a ConfigError on invalid configuration data.
-      def parse_config(io)
-        begin
-          parse_config_lines(io)
-        rescue => error
-          raise ConfigError, "error in line #{io.lineno}: " + error.message
-        end
-      end
-
-      def get_key_string(data, section, key) # :nodoc:
-        if v = data[section] && data[section][key]
-          return v
-        elsif section == 'ENV'
-          if v = ENV[key]
-            return v
-          end
-        end
-        if v = data['default'] && data['default'][key]
-          return v
-        end
-      end
-
-    private
-
-      def parse_config_lines(io)
-        section = 'default'
-        data = {section => {}}
-        io_stack = [io]
-        while definition = get_definition(io_stack)
-          definition = clear_comments(definition)
-          next if definition.empty?
-          case definition
-          when /\A\[/
-            if /\[([^\]]*)\]/ =~ definition
-              section = $1.strip
-              data[section] ||= {}
-            else
-              raise ConfigError, "missing close square bracket"
-            end
-          when /\A\.include (\s*=\s*)?(.+)\z/
-            path = $2
-            if File.directory?(path)
-              files = Dir.glob(File.join(path, "*.{cnf,conf}"), File::FNM_EXTGLOB)
-            else
-              files = [path]
-            end
-
-            files.each do |filename|
-              begin
-                io_stack << StringIO.new(File.read(filename))
-              rescue
-                raise ConfigError, "could not include file '%s'" % filename
-              end
-            end
-          when /\A([^:\s]*)(?:::([^:\s]*))?\s*=(.*)\z/
-            if $2
-              section = $1
-              key = $2
-            else
-              key = $1
-            end
-            value = unescape_value(data, section, $3)
-            (data[section] ||= {})[key] = value.strip
-          else
-            raise ConfigError, "missing equal sign"
-          end
-        end
-        data
-      end
-
-      # escape with backslash
-      QUOTE_REGEXP_SQ = /\A([^'\\]*(?:\\.[^'\\]*)*)'/
-      # escape with backslash and doubled dq
-      QUOTE_REGEXP_DQ = /\A([^"\\]*(?:""[^"\\]*|\\.[^"\\]*)*)"/
-      # escaped char map
-      ESCAPE_MAP = {
-        "r" => "\r",
-        "n" => "\n",
-        "b" => "\b",
-        "t" => "\t",
-      }
-
-      def unescape_value(data, section, value)
-        scanned = []
-        while m = value.match(/['"\\$]/)
-          scanned << m.pre_match
-          c = m[0]
-          value = m.post_match
-          case c
-          when "'"
-            if m = value.match(QUOTE_REGEXP_SQ)
-              scanned << m[1].gsub(/\\(.)/, '\\1')
-              value = m.post_match
-            else
-              break
-            end
-          when '"'
-            if m = value.match(QUOTE_REGEXP_DQ)
-              scanned << m[1].gsub(/""/, '').gsub(/\\(.)/, '\\1')
-              value = m.post_match
-            else
-              break
-            end
-          when "\\"
-            c = value.slice!(0, 1)
-            scanned << (ESCAPE_MAP[c] || c)
-          when "$"
-            ref, value = extract_reference(value)
-            refsec = section
-            if ref.index('::')
-              refsec, ref = ref.split('::', 2)
-            end
-            if v = get_key_string(data, refsec, ref)
-              scanned << v
-            else
-              raise ConfigError, "variable has no value"
-            end
-          else
-            raise 'must not reaced'
-          end
-        end
-        scanned << value
-        scanned.join
-      end
-
-      def extract_reference(value)
-        rest = ''
-        if m = value.match(/\(([^)]*)\)|\{([^}]*)\}/)
-          value = m[1] || m[2]
-          rest = m.post_match
-        elsif [?(, ?{].include?(value[0])
-          raise ConfigError, "no close brace"
-        end
-        if m = value.match(/[a-zA-Z0-9_]*(?:::[a-zA-Z0-9_]*)?/)
-          return m[0], m.post_match + rest
-        else
-          raise
-        end
-      end
-
-      def clear_comments(line)
-        # FCOMMENT
-        if m = line.match(/\A([\t\n\f ]*);.*\z/)
-          return m[1]
-        end
-        # COMMENT
-        scanned = []
-        while m = line.match(/[#'"\\]/)
-          scanned << m.pre_match
-          c = m[0]
-          line = m.post_match
-          case c
-          when '#'
-            line = nil
-            break
-          when "'", '"'
-            regexp = (c == "'") ? QUOTE_REGEXP_SQ : QUOTE_REGEXP_DQ
-            scanned << c
-            if m = line.match(regexp)
-              scanned << m[0]
-              line = m.post_match
-            else
-              scanned << line
-              line = nil
-              break
-            end
-          when "\\"
-            scanned << c
-            scanned << line.slice!(0, 1)
-          else
-            raise 'must not reaced'
-          end
-        end
-        scanned << line
-        scanned.join
-      end
-
-      def get_definition(io_stack)
-        if line = get_line(io_stack)
-          while /[^\\]\\\z/ =~ line
-            if extra = get_line(io_stack)
-              line += extra
-            else
-              break
-            end
-          end
-          return line.strip
-        end
-      end
-
-      def get_line(io_stack)
-        while io = io_stack.last
-          if line = io.gets
-            return line.gsub(/[\r\n]*/, '')
-          end
-          io_stack.pop
-        end
-      end
-    end
-
-    ##
-    # Creates an instance of OpenSSL's configuration class.
-    #
-    # This can be used in contexts like OpenSSL::X509::ExtensionFactory.config=
-    #
-    # If the optional _filename_ parameter is provided, then it is read in and
-    # parsed via #parse_config.
-    #
-    # This can raise IO exceptions based on the access, or availability of the
-    # file. A ConfigError exception may be raised depending on the validity of
-    # the data being configured.
-    #
-    def initialize(filename = nil)
-      @data = {}
-      if filename
-        File.open(filename.to_s) do |file|
-          Config.parse_config(file).each do |section, hash|
-            set_section(section, hash)
-          end
-        end
-      end
-    end
-
-    ##
-    # Gets the value of _key_ from the given _section_
-    #
-    # Given the following configurating file being loaded:
-    #
-    #   config = OpenSSL::Config.load('foo.cnf')
-    #     #=> #<OpenSSL::Config sections=["default"]>
-    #   puts config.to_s
-    #     #=> [ default ]
-    #     #   foo=bar
-    #
-    # You can get a specific value from the config if you know the _section_
-    # and _key_ like so:
-    #
-    #   config.get_value('default','foo')
-    #     #=> "bar"
-    #
-    def get_value(section, key)
-      if section.nil?
-        raise TypeError.new('nil not allowed')
-      end
-      section = 'default' if section.empty?
-      get_key_string(section, key)
-    end
-
-    ##
-    #
-    # *Deprecated*
-    #
-    # Use #get_value instead
-    def value(arg1, arg2 = nil) # :nodoc:
-      warn('Config#value is deprecated; use Config#get_value')
-      if arg2.nil?
-        section, key = 'default', arg1
-      else
-        section, key = arg1, arg2
-      end
-      section ||= 'default'
-      section = 'default' if section.empty?
-      get_key_string(section, key)
-    end
-
-    ##
-    # *Deprecated in v2.2.0*. This method will be removed in a future release.
-    #
-    # Set the target _key_ with a given _value_ under a specific _section_.
-    #
-    # Given the following configurating file being loaded:
-    #
-    #   config = OpenSSL::Config.load('foo.cnf')
-    #     #=> #<OpenSSL::Config sections=["default"]>
-    #   puts config.to_s
-    #     #=> [ default ]
-    #     #   foo=bar
-    #
-    # You can set the value of _foo_ under the _default_ section to a new
-    # value:
-    #
-    #   config.add_value('default', 'foo', 'buzz')
-    #     #=> "buzz"
-    #   puts config.to_s
-    #     #=> [ default ]
-    #     #   foo=buzz
-    #
-    def add_value(section, key, value)
-      check_modify
-      (@data[section] ||= {})[key] = value
-    end
-
-    ##
-    # Get a specific _section_ from the current configuration
-    #
-    # Given the following configurating file being loaded:
-    #
-    #   config = OpenSSL::Config.load('foo.cnf')
-    #     #=> #<OpenSSL::Config sections=["default"]>
-    #   puts config.to_s
-    #     #=> [ default ]
-    #     #   foo=bar
-    #
-    # You can get a hash of the specific section like so:
-    #
-    #   config['default']
-    #     #=> {"foo"=>"bar"}
-    #
-    def [](section)
-      @data[section] || {}
-    end
-
-    ##
-    # Deprecated
-    #
-    # Use #[] instead
-    def section(name) # :nodoc:
-      warn('Config#section is deprecated; use Config#[]')
-      @data[name] || {}
-    end
-
-    ##
-    # *Deprecated in v2.2.0*. This method will be removed in a future release.
-    #
-    # Sets a specific _section_ name with a Hash _pairs_.
-    #
-    # Given the following configuration being created:
-    #
-    #   config = OpenSSL::Config.new
-    #     #=> #<OpenSSL::Config sections=[]>
-    #   config['default'] = {"foo"=>"bar","baz"=>"buz"}
-    #     #=> {"foo"=>"bar", "baz"=>"buz"}
-    #   puts config.to_s
-    #     #=> [ default ]
-    #     #   foo=bar
-    #     #   baz=buz
-    #
-    # It's important to note that this will essentially merge any of the keys
-    # in _pairs_ with the existing _section_. For example:
-    #
-    #   config['default']
-    #     #=> {"foo"=>"bar", "baz"=>"buz"}
-    #   config['default'] = {"foo" => "changed"}
-    #     #=> {"foo"=>"changed"}
-    #   config['default']
-    #     #=> {"foo"=>"changed", "baz"=>"buz"}
-    #
-    def []=(section, pairs)
-      check_modify
-      set_section(section, pairs)
-    end
-
-    def set_section(section, pairs) # :nodoc:
-      hash = @data[section] ||= {}
-      pairs.each do |key, value|
-        hash[key] = value
-      end
-    end
-
-    ##
-    # Get the names of all sections in the current configuration
-    def sections
-      @data.keys
-    end
-
-    ##
-    # Get the parsable form of the current configuration
-    #
-    # Given the following configuration being created:
-    #
-    #   config = OpenSSL::Config.new
-    #     #=> #<OpenSSL::Config sections=[]>
-    #   config['default'] = {"foo"=>"bar","baz"=>"buz"}
-    #     #=> {"foo"=>"bar", "baz"=>"buz"}
-    #   puts config.to_s
-    #     #=> [ default ]
-    #     #   foo=bar
-    #     #   baz=buz
-    #
-    # You can parse get the serialized configuration using #to_s and then parse
-    # it later:
-    #
-    #   serialized_config = config.to_s
-    #   # much later...
-    #   new_config = OpenSSL::Config.parse(serialized_config)
-    #     #=> #<OpenSSL::Config sections=["default"]>
-    #   puts new_config
-    #     #=> [ default ]
-    #         foo=bar
-    #         baz=buz
-    #
-    def to_s
-      ary = []
-      @data.keys.sort.each do |section|
-        ary << "[ #{section} ]\n"
-        @data[section].keys.each do |key|
-          ary << "#{key}=#{@data[section][key]}\n"
-        end
-        ary << "\n"
-      end
-      ary.join
-    end
-
-    ##
-    # For a block.
-    #
-    # Receive the section and its pairs for the current configuration.
-    #
-    #   config.each do |section, key, value|
-    #     # ...
-    #   end
-    #
-    def each
-      @data.each do |section, hash|
-        hash.each do |key, value|
-          yield [section, key, value]
-        end
-      end
-    end
-
-    ##
-    # String representation of this configuration object, including the class
-    # name and its sections.
-    def inspect
-      "#<#{self.class.name} sections=#{sections.inspect}>"
-    end
-
-  protected
-
-    def data # :nodoc:
-      @data
-    end
-
-  private
-
-    def initialize_copy(other)
-      @data = other.data.dup
-    end
-
-    def check_modify
-      warn "#{caller(2, 1)[0]}: warning: do not modify OpenSSL::Config; this " \
-        "method is deprecated and will be removed in a future release."
-      raise TypeError.new("Insecure: can't modify OpenSSL config") if frozen?
-    end
-
-    def get_key_string(section, key)
-      Config.get_key_string(@data, section, key)
-    end
-  end
-end
diff --git a/ext/openssl/lib/openssl/hmac.rb b/ext/openssl/lib/openssl/hmac.rb
index 3d44276..c8c844d 100644
--- a/ext/openssl/lib/openssl/hmac.rb
+++ b/ext/openssl/lib/openssl/hmac.rb
@@ -9,5 +9,70 @@ module OpenSSL
 
       OpenSSL.fixed_length_secure_compare(self.digest, other.digest)
     end
+
+    # :call-seq:
+    #    hmac.base64digest -> string
+    #
+    # Returns the authentication code an a Base64-encoded string.
+    def base64digest
+      [digest].pack("m0")
+    end
+
+    class << self
+      # :call-seq:
+      #    HMAC.digest(digest, key, data) -> aString
+      #
+      # Returns the authentication code as a binary string. The _digest_ parameter
+      # specifies the digest algorithm to use. This may be a String representing
+      # the algorithm name or an instance of OpenSSL::Digest.
+      #
+      # === Example
+      #  key = 'key'
+      #  data = 'The quick brown fox jumps over the lazy dog'
+      #
+      #  hmac = OpenSSL::HMAC.digest('SHA1', key, data)
+      #  #=> "\xDE|\x9B\x85\xB8\xB7\x8A\xA6\xBC\x8Az6\xF7\n\x90p\x1C\x9D\xB4\xD9"
+      def digest(digest, key, data)
+        hmac = new(key, digest)
+        hmac << data
+        hmac.digest
+      end
+
+      # :call-seq:
+      #    HMAC.hexdigest(digest, key, data) -> aString
+      #
+      # Returns the authentication code as a hex-encoded string. The _digest_
+      # parameter specifies the digest algorithm to use. This may be a String
+      # representing the algorithm name or an instance of OpenSSL::Digest.
+      #
+      # === Example
+      #  key = 'key'
+      #  data = 'The quick brown fox jumps over the lazy dog'
+      #
+      #  hmac = OpenSSL::HMAC.hexdigest('SHA1', key, data)
+      #  #=> "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9"
+      def hexdigest(digest, key, data)
+        hmac = new(key, digest)
+        hmac << data
+        hmac.hexdigest
+      end
+
+      # :call-seq:
+      #    HMAC.base64digest(digest, key, data) -> aString
+      #
+      # Returns the authentication code as a Base64-encoded string. The _digest_
+      # parameter specifies the digest algorithm to use. This may be a String
+      # representing the algorithm name or an instance of OpenSSL::Digest.
+      #
+      # === Example
+      #  key = 'key'
+      #  data = 'The quick brown fox jumps over the lazy dog'
+      #
+      #  hmac = OpenSSL::HMAC.base64digest('SHA1', key, data)
+      #  #=> "3nybhbi3iqa8ino29wqQcBydtNk="
+      def base64digest(digest, key, data)
+        [digest(digest, key, data)].pack("m0")
+      end
+    end
   end
 end
diff --git a/ext/openssl/lib/openssl/pkey.rb b/ext/openssl/lib/openssl/pkey.rb
index 9cc3276..c3e0629 100644
--- a/ext/openssl/lib/openssl/pkey.rb
+++ b/ext/openssl/lib/openssl/pkey.rb
@@ -9,16 +9,282 @@ require_relative 'marshal'
 module OpenSSL::PKey
   class DH
     include OpenSSL::Marshal
+
+    # :call-seq:
+    #    dh.public_key -> dhnew
+    #
+    # Returns a new DH instance that carries just the \DH parameters.
+    #
+    # Contrary to the method name, the returned DH object contains only
+    # parameters and not the public key.
+    #
+    # This method is provided for backwards compatibility. In most cases, there
+    # is no need to call this method.
+    #
+    # For the purpose of re-generating the key pair while keeping the
+    # parameters, check OpenSSL::PKey.generate_key.
+    #
+    # Example:
+    #   # OpenSSL::PKey::DH.generate by default generates a random key pair
+    #   dh1 = OpenSSL::PKey::DH.generate(2048)
+    #   p dh1.priv_key #=> #<OpenSSL::BN 1288347...>
+    #   dhcopy = dh1.public_key
+    #   p dhcopy.priv_key #=> nil
+    def public_key
+      DH.new(to_der)
+    end
+
+    # :call-seq:
+    #    dh.compute_key(pub_bn) -> string
+    #
+    # Returns a String containing a shared secret computed from the other
+    # party's public value.
+    #
+    # This method is provided for backwards compatibility, and calls #derive
+    # internally.
+    #
+    # === Parameters
+    # * _pub_bn_ is a OpenSSL::BN, *not* the DH instance returned by
+    #   DH#public_key as that contains the DH parameters only.
+    def compute_key(pub_bn)
+      # FIXME: This is constructing an X.509 SubjectPublicKeyInfo and is very
+      # inefficient
+      obj = OpenSSL::ASN1.Sequence([
+        OpenSSL::ASN1.Sequence([
+          OpenSSL::ASN1.ObjectId("dhKeyAgreement"),
+          OpenSSL::ASN1.Sequence([
+            OpenSSL::ASN1.Integer(p),
+            OpenSSL::ASN1.Integer(g),
+          ]),
+        ]),
+        OpenSSL::ASN1.BitString(OpenSSL::ASN1.Integer(pub_bn).to_der),
+      ])
+      derive(OpenSSL::PKey.read(obj.to_der))
+    end
+
+    # :call-seq:
+    #    dh.generate_key! -> self
+    #
+    # Generates a private and public key unless a private key already exists.
+    # If this DH instance was generated from public \DH parameters (e.g. by
+    # encoding the result of DH#public_key), then this method needs to be
+    # called first in order to generate the per-session keys before performing
+    # the actual key exchange.
+    #
+    # <b>Deprecated in version 3.0</b>. This method is incompatible with
+    # OpenSSL 3.0.0 or later.
+    #
+    # See also OpenSSL::PKey.generate_key.
+    #
+    # Example:
+    #   # DEPRECATED USAGE: This will not work on OpenSSL 3.0 or later
+    #   dh0 = OpenSSL::PKey::DH.new(2048)
+    #   dh = dh0.public_key # #public_key only copies the DH parameters (contrary to the name)
+    #   dh.generate_key!
+    #   puts dh.private? # => true
+    #   puts dh0.pub_key == dh.pub_key #=> false
+    #
+    #   # With OpenSSL::PKey.generate_key
+    #   dh0 = OpenSSL::PKey::DH.new(2048)
+    #   dh = OpenSSL::PKey.generate_key(dh0)
+    #   puts dh0.pub_key == dh.pub_key #=> false
+    def generate_key!
+      if OpenSSL::OPENSSL_VERSION_NUMBER >= 0x30000000
+        raise DHError, "OpenSSL::PKey::DH is immutable on OpenSSL 3.0; " \
+        "use OpenSSL::PKey.generate_key instead"
+      end
+
+      unless priv_key
+        tmp = OpenSSL::PKey.generate_key(self)
+        set_key(tmp.pub_key, tmp.priv_key)
+      end
+      self
+    end
+
+    class << self
+      # :call-seq:
+      #    DH.generate(size, generator = 2) -> dh
+      #
+      # Creates a new DH instance from scratch by generating random parameters
+      # and a key pair.
+      #
+      # See also OpenSSL::PKey.generate_parameters and
+      # OpenSSL::PKey.generate_key.
+      #
+      # +size+::
+      #   The desired key size in bits.
+      # +generator+::
+      #   The generator.
+      def generate(size, generator = 2, &blk)
+        dhparams = OpenSSL::PKey.generate_parameters("DH", {
+          "dh_paramgen_prime_len" => size,
+          "dh_paramgen_generator" => generator,
+        }, &blk)
+        OpenSSL::PKey.generate_key(dhparams)
+      end
+
+      # Handle DH.new(size, generator) form here; new(str) and new() forms
+      # are handled by #initialize
+      def new(*args, &blk) # :nodoc:
+        if args[0].is_a?(Integer)
+          generate(*args, &blk)
+        else
+          super
+        end
+      end
+    end
   end
 
   class DSA
     include OpenSSL::Marshal
+
+    # :call-seq:
+    #    dsa.public_key -> dsanew
+    #
+    # Returns a new DSA instance that carries just the \DSA parameters and the
+    # public key.
+    #
+    # This method is provided for backwards compatibility. In most cases, there
+    # is no need to call this method.
+    #
+    # For the purpose of serializing the public key, to PEM or DER encoding of
+    # X.509 SubjectPublicKeyInfo format, check PKey#public_to_pem and
+    # PKey#public_to_der.
+    def public_key
+      OpenSSL::PKey.read(public_to_der)
+    end
+
+    class << self
+      # :call-seq:
+      #    DSA.generate(size) -> dsa
+      #
+      # Creates a new DSA instance by generating a private/public key pair
+      # from scratch.
+      #
+      # See also OpenSSL::PKey.generate_parameters and
+      # OpenSSL::PKey.generate_key.
+      #
+      # +size+::
+      #   The desired key size in bits.
+      def generate(size, &blk)
+        dsaparams = OpenSSL::PKey.generate_parameters("DSA", {
+          "dsa_paramgen_bits" => size,
+        }, &blk)
+        OpenSSL::PKey.generate_key(dsaparams)
+      end
+
+      # Handle DSA.new(size) form here; new(str) and new() forms
+      # are handled by #initialize
+      def new(*args, &blk) # :nodoc:
+        if args[0].is_a?(Integer)
+          generate(*args, &blk)
+        else
+          super
+        end
+      end
+    end
+
+    # :call-seq:
+    #    dsa.syssign(string) -> string
+    #
+    # Computes and returns the \DSA signature of +string+, where +string+ is
+    # expected to be an already-computed message digest of the original input
+    # data. The signature is issued using the private key of this DSA instance.
+    #
+    # <b>Deprecated in version 3.0</b>.
+    # Consider using PKey::PKey#sign_raw and PKey::PKey#verify_raw instead.
+    #
+    # +string+::
+    #   A message digest of the original input data to be signed.
+    #
+    # Example:
+    #   dsa = OpenSSL::PKey::DSA.new(2048)
+    #   doc = "Sign me"
+    #   digest = OpenSSL::Digest.digest('SHA1', doc)
+    #
+    #   # With legacy #syssign and #sysverify:
+    #   sig = dsa.syssign(digest)
+    #   p dsa.sysverify(digest, sig) #=> true
+    #
+    #   # With #sign_raw and #verify_raw:
+    #   sig = dsa.sign_raw(nil, digest)
+    #   p dsa.verify_raw(nil, sig, digest) #=> true
+    def syssign(string)
+      q or raise OpenSSL::PKey::DSAError, "incomplete DSA"
+      private? or raise OpenSSL::PKey::DSAError, "Private DSA key needed!"
+      begin
+        sign_raw(nil, string)
+      rescue OpenSSL::PKey::PKeyError
+        raise OpenSSL::PKey::DSAError, $!.message
+      end
+    end
+
+    # :call-seq:
+    #    dsa.sysverify(digest, sig) -> true | false
+    #
+    # Verifies whether the signature is valid given the message digest input.
+    # It does so by validating +sig+ using the public key of this DSA instance.
+    #
+    # <b>Deprecated in version 3.0</b>.
+    # Consider using PKey::PKey#sign_raw and PKey::PKey#verify_raw instead.
+    #
+    # +digest+::
+    #   A message digest of the original input data to be signed.
+    # +sig+::
+    #   A \DSA signature value.
+    def sysverify(digest, sig)
+      verify_raw(nil, sig, digest)
+    rescue OpenSSL::PKey::PKeyError
+      raise OpenSSL::PKey::DSAError, $!.message
+    end
   end
 
   if defined?(EC)
   class EC
     include OpenSSL::Marshal
+
+    # :call-seq:
+    #    key.dsa_sign_asn1(data) -> String
+    #
+    # <b>Deprecated in version 3.0</b>.
+    # Consider using PKey::PKey#sign_raw and PKey::PKey#verify_raw instead.
+    def dsa_sign_asn1(data)
+      sign_raw(nil, data)
+    rescue OpenSSL::PKey::PKeyError
+      raise OpenSSL::PKey::ECError, $!.message
+    end
+
+    # :call-seq:
+    #    key.dsa_verify_asn1(data, sig) -> true | false
+    #
+    # <b>Deprecated in version 3.0</b>.
+    # Consider using PKey::PKey#sign_raw and PKey::PKey#verify_raw instead.
+    def dsa_verify_asn1(data, sig)
+      verify_raw(nil, sig, data)
+    rescue OpenSSL::PKey::PKeyError
+      raise OpenSSL::PKey::ECError, $!.message
+    end
+
+    # :call-seq:
+    #    ec.dh_compute_key(pubkey) -> string
+    #
+    # Derives a shared secret by ECDH. _pubkey_ must be an instance of
+    # OpenSSL::PKey::EC::Point and must belong to the same group.
+    #
+    # This method is provided for backwards compatibility, and calls #derive
+    # internally.
+    def dh_compute_key(pubkey)
+      obj = OpenSSL::ASN1.Sequence([
+        OpenSSL::ASN1.Sequence([
+          OpenSSL::ASN1.ObjectId("id-ecPublicKey"),
+          group.to_der,
+        ]),
+        OpenSSL::ASN1.BitString(pubkey.to_octet_string(:uncompressed)),
+      ])
+      derive(OpenSSL::PKey.read(obj.to_der))
+    end
   end
+
   class EC::Point
     # :call-seq:
     #    point.to_bn([conversion_form]) -> OpenSSL::BN
@@ -38,5 +304,156 @@ module OpenSSL::PKey
 
   class RSA
     include OpenSSL::Marshal
+
+    # :call-seq:
+    #    rsa.public_key -> rsanew
+    #
+    # Returns a new RSA instance that carries just the public key components.
+    #
+    # This method is provided for backwards compatibility. In most cases, there
+    # is no need to call this method.
+    #
+    # For the purpose of serializing the public key, to PEM or DER encoding of
+    # X.509 SubjectPublicKeyInfo format, check PKey#public_to_pem and
+    # PKey#public_to_der.
+    def public_key
+      OpenSSL::PKey.read(public_to_der)
+    end
+
+    class << self
+      # :call-seq:
+      #    RSA.generate(size, exponent = 65537) -> RSA
+      #
+      # Generates an \RSA keypair.
+      #
+      # See also OpenSSL::PKey.generate_key.
+      #
+      # +size+::
+      #   The desired key size in bits.
+      # +exponent+::
+      #   An odd Integer, normally 3, 17, or 65537.
+      def generate(size, exp = 0x10001, &blk)
+        OpenSSL::PKey.generate_key("RSA", {
+          "rsa_keygen_bits" => size,
+          "rsa_keygen_pubexp" => exp,
+        }, &blk)
+      end
+
+      # Handle RSA.new(size, exponent) form here; new(str) and new() forms
+      # are handled by #initialize
+      def new(*args, &blk) # :nodoc:
+        if args[0].is_a?(Integer)
+          generate(*args, &blk)
+        else
+          super
+        end
+      end
+    end
+
+    # :call-seq:
+    #    rsa.private_encrypt(string)          -> String
+    #    rsa.private_encrypt(string, padding) -> String
+    #
+    # Encrypt +string+ with the private key.  +padding+ defaults to
+    # PKCS1_PADDING. The encrypted string output can be decrypted using
+    # #public_decrypt.
+    #
+    # <b>Deprecated in version 3.0</b>.
+    # Consider using PKey::PKey#sign_raw and PKey::PKey#verify_raw, and
+    # PKey::PKey#verify_recover instead.
+    def private_encrypt(string, padding = PKCS1_PADDING)
+      n or raise OpenSSL::PKey::RSAError, "incomplete RSA"
+      private? or raise OpenSSL::PKey::RSAError, "private key needed."
+      begin
+        sign_raw(nil, string, {
+          "rsa_padding_mode" => translate_padding_mode(padding),
+        })
+      rescue OpenSSL::PKey::PKeyError
+        raise OpenSSL::PKey::RSAError, $!.message
+      end
+    end
+
+    # :call-seq:
+    #    rsa.public_decrypt(string)          -> String
+    #    rsa.public_decrypt(string, padding) -> String
+    #
+    # Decrypt +string+, which has been encrypted with the private key, with the
+    # public key.  +padding+ defaults to PKCS1_PADDING.
+    #
+    # <b>Deprecated in version 3.0</b>.
+    # Consider using PKey::PKey#sign_raw and PKey::PKey#verify_raw, and
+    # PKey::PKey#verify_recover instead.
+    def public_decrypt(string, padding = PKCS1_PADDING)
+      n or raise OpenSSL::PKey::RSAError, "incomplete RSA"
+      begin
+        verify_recover(nil, string, {
+          "rsa_padding_mode" => translate_padding_mode(padding),
+        })
+      rescue OpenSSL::PKey::PKeyError
+        raise OpenSSL::PKey::RSAError, $!.message
+      end
+    end
+
+    # :call-seq:
+    #    rsa.public_encrypt(string)          -> String
+    #    rsa.public_encrypt(string, padding) -> String
+    #
+    # Encrypt +string+ with the public key.  +padding+ defaults to
+    # PKCS1_PADDING. The encrypted string output can be decrypted using
+    # #private_decrypt.
+    #
+    # <b>Deprecated in version 3.0</b>.
+    # Consider using PKey::PKey#encrypt and PKey::PKey#decrypt instead.
+    def public_encrypt(data, padding = PKCS1_PADDING)
+      n or raise OpenSSL::PKey::RSAError, "incomplete RSA"
+      begin
+        encrypt(data, {
+          "rsa_padding_mode" => translate_padding_mode(padding),
+        })
+      rescue OpenSSL::PKey::PKeyError
+        raise OpenSSL::PKey::RSAError, $!.message
+      end
+    end
+
+    # :call-seq:
+    #    rsa.private_decrypt(string)          -> String
+    #    rsa.private_decrypt(string, padding) -> String
+    #
+    # Decrypt +string+, which has been encrypted with the public key, with the
+    # private key. +padding+ defaults to PKCS1_PADDING.
+    #
+    # <b>Deprecated in version 3.0</b>.
+    # Consider using PKey::PKey#encrypt and PKey::PKey#decrypt instead.
+    def private_decrypt(data, padding = PKCS1_PADDING)
+      n or raise OpenSSL::PKey::RSAError, "incomplete RSA"
+      private? or raise OpenSSL::PKey::RSAError, "private key needed."
+      begin
+        decrypt(data, {
+          "rsa_padding_mode" => translate_padding_mode(padding),
+        })
+      rescue OpenSSL::PKey::PKeyError
+        raise OpenSSL::PKey::RSAError, $!.message
+      end
+    end
+
+    PKCS1_PADDING = 1
+    SSLV23_PADDING = 2
+    NO_PADDING = 3
+    PKCS1_OAEP_PADDING = 4
+
+    private def translate_padding_mode(num)
+      case num
+      when PKCS1_PADDING
+        "pkcs1"
+      when SSLV23_PADDING
+        "sslv23"
+      when NO_PADDING
+        "none"
+      when PKCS1_OAEP_PADDING
+        "oaep"
+      else
+        raise OpenSSL::PKey::PKeyError, "unsupported padding mode"
+      end
+    end
   end
 end
diff --git a/ext/openssl/lib/openssl/ssl.rb b/ext/openssl/lib/openssl/ssl.rb
index 8e12007..a9103ec 100644
--- a/ext/openssl/lib/openssl/ssl.rb
+++ b/ext/openssl/lib/openssl/ssl.rb
@@ -91,15 +91,17 @@ YoaOffgTf5qxiwkjnlVZQc3whgnEt9FpVMvQ9eknyeGB5KHfayAc3+hUAvI3/Cr3
       DEFAULT_CERT_STORE.set_default_paths
       DEFAULT_CERT_STORE.flags = OpenSSL::X509::V_FLAG_CRL_CHECK_ALL
 
-      # A callback invoked when DH parameters are required.
+      # A callback invoked when DH parameters are required for ephemeral DH key
+      # exchange.
       #
-      # The callback is invoked with the Session for the key exchange, an
+      # The callback is invoked with the SSLSocket, a
       # flag indicating the use of an export cipher and the keylength
       # required.
       #
       # The callback must return an OpenSSL::PKey::DH instance of the correct
       # key length.
-
+      #
+      # <b>Deprecated in version 3.0.</b> Use #tmp_dh= instead.
       attr_accessor :tmp_dh_callback
 
       # A callback invoked at connect time to distinguish between multiple
@@ -122,6 +124,8 @@ YoaOffgTf5qxiwkjnlVZQc3whgnEt9FpVMvQ9eknyeGB5KHfayAc3+hUAvI3/Cr3
       def initialize(version = nil)
         self.options |= OpenSSL::SSL::OP_ALL
         self.ssl_version = version if version
+        self.verify_mode = OpenSSL::SSL::VERIFY_NONE
+        self.verify_hostname = false
       end
 
       ##
@@ -430,10 +434,6 @@ YoaOffgTf5qxiwkjnlVZQc3whgnEt9FpVMvQ9eknyeGB5KHfayAc3+hUAvI3/Cr3
         @context.tmp_dh_callback || OpenSSL::SSL::SSLContext::DEFAULT_TMP_DH_CALLBACK
       end
 
-      def tmp_ecdh_callback
-        @context.tmp_ecdh_callback
-      end
-
       def session_new_cb
         @context.session_new_cb
       end
diff --git a/ext/openssl/lib/openssl/version.rb b/ext/openssl/lib/openssl/version.rb
index d541cbf..5e60604 100644
--- a/ext/openssl/lib/openssl/version.rb
+++ b/ext/openssl/lib/openssl/version.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: true
 
 module OpenSSL
-  VERSION = "2.2.1"
+  VERSION = "3.0.0"
 end
diff --git a/ext/openssl/lib/openssl/x509.rb b/ext/openssl/lib/openssl/x509.rb
index 6771b90..f973f4f 100644
--- a/ext/openssl/lib/openssl/x509.rb
+++ b/ext/openssl/lib/openssl/x509.rb
@@ -279,11 +279,29 @@ module OpenSSL
       end
 
       class << self
+        # Parses the UTF-8 string representation of a distinguished name,
+        # according to RFC 2253.
+        #
+        # See also #to_utf8 for the opposite operation.
         def parse_rfc2253(str, template=OBJECT_TYPE_TEMPLATE)
           ary = OpenSSL::X509::Name::RFC2253DN.scan(str)
           self.new(ary, template)
         end
 
+        # Parses the string representation of a distinguished name. Two
+        # different forms are supported:
+        #
+        # - \OpenSSL format (<tt>X509_NAME_oneline()</tt>) used by
+        #   <tt>#to_s</tt>. For example: <tt>/DC=com/DC=example/CN=nobody</tt>
+        # - \OpenSSL format (<tt>X509_NAME_print()</tt>)
+        #   used by <tt>#to_s(OpenSSL::X509::Name::COMPAT)</tt>. For example:
+        #   <tt>DC=com, DC=example, CN=nobody</tt>
+        #
+        # Neither of them is standardized and has quirks and inconsistencies
+        # in handling of escaped characters or multi-valued RDNs.
+        #
+        # Use of this method is discouraged in new applications. See
+        # Name.parse_rfc2253 and #to_utf8 for the alternative.
         def parse_openssl(str, template=OBJECT_TYPE_TEMPLATE)
           if str.start_with?("/")
             # /A=B/C=D format
@@ -338,6 +356,10 @@ module OpenSSL
           q.text 'not_after='; q.pp self.not_after
         }
       end
+
+      def self.load_file(path)
+        load(File.binread(path))
+      end
     end
 
     class CRL
diff --git a/ext/openssl/openssl.gemspec b/ext/openssl/openssl.gemspec
index ebbd092..c6cd818 100644
--- a/ext/openssl/openssl.gemspec
+++ b/ext/openssl/openssl.gemspec
@@ -1,6 +1,6 @@
 Gem::Specification.new do |spec|
   spec.name          = "openssl"
-  spec.version       = "2.2.1"
+  spec.version       = "3.0.0"
   spec.authors       = ["Martin Bosslet", "SHIBATA Hiroshi", "Zachary Scott", "Kazuki Yamaguchi"]
   spec.email         = ["ruby-core@ruby-lang.org"]
   spec.summary       = %q{OpenSSL provides SSL, TLS and general purpose cryptography.}
@@ -15,13 +15,7 @@ Gem::Specification.new do |spec|
   spec.extra_rdoc_files = Dir["*.md"]
   spec.rdoc_options = ["--main", "README.md"]
 
-  spec.required_ruby_version = ">= 2.3.0"
-
-  spec.add_runtime_dependency "ipaddr"
-  spec.add_development_dependency "rake"
-  spec.add_development_dependency "rake-compiler"
-  spec.add_development_dependency "test-unit", "~> 3.0"
-  spec.add_development_dependency "rdoc"
+  spec.required_ruby_version = ">= 2.6.0"
 
   spec.metadata["msys2_mingw_dependencies"] = "openssl"
 end
diff --git a/ext/openssl/openssl_missing.c b/ext/openssl/openssl_missing.c
index b36ef02..4415703 100644
--- a/ext/openssl/openssl_missing.c
+++ b/ext/openssl/openssl_missing.c
@@ -10,77 +10,11 @@
 #include RUBY_EXTCONF_H
 
 #include <string.h> /* memcpy() */
-#if !defined(OPENSSL_NO_ENGINE)
-# include <openssl/engine.h>
-#endif
-#if !defined(OPENSSL_NO_HMAC)
-# include <openssl/hmac.h>
-#endif
 #include <openssl/x509_vfy.h>
 
 #include "openssl_missing.h"
 
-/* added in 1.0.2 */
-#if !defined(OPENSSL_NO_EC)
-#if !defined(HAVE_EC_CURVE_NIST2NID)
-static struct {
-    const char *name;
-    int nid;
-} nist_curves[] = {
-    {"B-163", NID_sect163r2},
-    {"B-233", NID_sect233r1},
-    {"B-283", NID_sect283r1},
-    {"B-409", NID_sect409r1},
-    {"B-571", NID_sect571r1},
-    {"K-163", NID_sect163k1},
-    {"K-233", NID_sect233k1},
-    {"K-283", NID_sect283k1},
-    {"K-409", NID_sect409k1},
-    {"K-571", NID_sect571k1},
-    {"P-192", NID_X9_62_prime192v1},
-    {"P-224", NID_secp224r1},
-    {"P-256", NID_X9_62_prime256v1},
-    {"P-384", NID_secp384r1},
-    {"P-521", NID_secp521r1}
-};
-
-int
-ossl_EC_curve_nist2nid(const char *name)
-{
-    size_t i;
-    for (i = 0; i < (sizeof(nist_curves) / sizeof(nist_curves[0])); i++) {
-	if (!strcmp(nist_curves[i].name, name))
-	    return nist_curves[i].nid;
-    }
-    return NID_undef;
-}
-#endif
-#endif
-
 /*** added in 1.1.0 ***/
-#if !defined(HAVE_HMAC_CTX_NEW)
-HMAC_CTX *
-ossl_HMAC_CTX_new(void)
-{
-    HMAC_CTX *ctx = OPENSSL_malloc(sizeof(HMAC_CTX));
-    if (!ctx)
-	return NULL;
-    HMAC_CTX_init(ctx);
-    return ctx;
-}
-#endif
-
-#if !defined(HAVE_HMAC_CTX_FREE)
-void
-ossl_HMAC_CTX_free(HMAC_CTX *ctx)
-{
-    if (ctx) {
-	HMAC_CTX_cleanup(ctx);
-	OPENSSL_free(ctx);
-    }
-}
-#endif
-
 #if !defined(HAVE_X509_CRL_GET0_SIGNATURE)
 void
 ossl_X509_CRL_get0_signature(const X509_CRL *crl, const ASN1_BIT_STRING **psig,
diff --git a/ext/openssl/openssl_missing.h b/ext/openssl/openssl_missing.h
index 7d218f8..8629bfe 100644
--- a/ext/openssl/openssl_missing.h
+++ b/ext/openssl/openssl_missing.h
@@ -12,40 +12,7 @@
 
 #include "ruby/config.h"
 
-/* added in 1.0.2 */
-#if !defined(OPENSSL_NO_EC)
-#if !defined(HAVE_EC_CURVE_NIST2NID)
-int ossl_EC_curve_nist2nid(const char *);
-#  define EC_curve_nist2nid ossl_EC_curve_nist2nid
-#endif
-#endif
-
-#if !defined(HAVE_X509_REVOKED_DUP)
-# define X509_REVOKED_dup(rev) (X509_REVOKED *)ASN1_dup((i2d_of_void *)i2d_X509_REVOKED, \
-	(d2i_of_void *)d2i_X509_REVOKED, (char *)(rev))
-#endif
-
-#if !defined(HAVE_X509_STORE_CTX_GET0_STORE)
-#  define X509_STORE_CTX_get0_store(x) ((x)->ctx)
-#endif
-
-#if !defined(HAVE_SSL_IS_SERVER)
-#  define SSL_is_server(s) ((s)->server)
-#endif
-
 /* added in 1.1.0 */
-#if !defined(HAVE_BN_GENCB_NEW)
-#  define BN_GENCB_new() ((BN_GENCB *)OPENSSL_malloc(sizeof(BN_GENCB)))
-#endif
-
-#if !defined(HAVE_BN_GENCB_FREE)
-#  define BN_GENCB_free(cb) OPENSSL_free(cb)
-#endif
-
-#if !defined(HAVE_BN_GENCB_GET_ARG)
-#  define BN_GENCB_get_arg(cb) (cb)->arg
-#endif
-
 #if !defined(HAVE_EVP_MD_CTX_NEW)
 #  define EVP_MD_CTX_new EVP_MD_CTX_create
 #endif
@@ -54,16 +21,6 @@ int ossl_EC_curve_nist2nid(const char *);
 #  define EVP_MD_CTX_free EVP_MD_CTX_destroy
 #endif
 
-#if !defined(HAVE_HMAC_CTX_NEW)
-HMAC_CTX *ossl_HMAC_CTX_new(void);
-#  define HMAC_CTX_new ossl_HMAC_CTX_new
-#endif
-
-#if !defined(HAVE_HMAC_CTX_FREE)
-void ossl_HMAC_CTX_free(HMAC_CTX *);
-#  define HMAC_CTX_free ossl_HMAC_CTX_free
-#endif
-
 #if !defined(HAVE_X509_STORE_GET_EX_DATA)
 #  define X509_STORE_get_ex_data(x, idx) \
 	CRYPTO_get_ex_data(&(x)->ex_data, (idx))
@@ -147,8 +104,7 @@ void ossl_X509_REQ_get0_signature(const X509_REQ *, const ASN1_BIT_STRING **, co
 	CRYPTO_add(&(x)->references, 1, CRYPTO_LOCK_EVP_PKEY);
 #endif
 
-#if !defined(HAVE_OPAQUE_OPENSSL) && \
-    (!defined(LIBRESSL_VERSION_NUMBER) || LIBRESSL_VERSION_NUMBER < 0x2070000fL)
+#if !defined(HAVE_OPAQUE_OPENSSL)
 #define IMPL_PKEY_GETTER(_type, _name) \
 static inline _type *EVP_PKEY_get0_##_type(EVP_PKEY *pkey) { \
 	return pkey->pkey._name; }
@@ -254,4 +210,29 @@ IMPL_PKEY_GETTER(EC_KEY, ec)
     } while (0)
 #endif
 
+/* added in 3.0.0 */
+#if !defined(HAVE_TS_VERIFY_CTX_SET_CERTS)
+#  define TS_VERIFY_CTX_set_certs(ctx, crts) TS_VERIFY_CTS_set_certs(ctx, crts)
+#endif
+
+#ifndef HAVE_EVP_MD_CTX_GET0_MD
+#  define EVP_MD_CTX_get0_md(ctx) EVP_MD_CTX_md(ctx)
+#endif
+
+/*
+ * OpenSSL 1.1.0 added EVP_MD_CTX_pkey_ctx(), and then it was renamed to
+ * EVP_MD_CTX_get_pkey_ctx(x) in OpenSSL 3.0.
+ */
+#ifndef HAVE_EVP_MD_CTX_GET_PKEY_CTX
+# ifdef HAVE_EVP_MD_CTX_PKEY_CTX
+#  define EVP_MD_CTX_get_pkey_ctx(x) EVP_MD_CTX_pkey_ctx(x)
+# else
+#  define EVP_MD_CTX_get_pkey_ctx(x) (x)->pctx
+# endif
+#endif
+
+#ifndef HAVE_EVP_PKEY_EQ
+#  define EVP_PKEY_eq(a, b) EVP_PKEY_cmp(a, b)
+#endif
+
 #endif /* _OSSL_OPENSSL_MISSING_H_ */
diff --git a/ext/openssl/ossl.c b/ext/openssl/ossl.c
index ce02efd..6c532ac 100644
--- a/ext/openssl/ossl.c
+++ b/ext/openssl/ossl.c
@@ -9,13 +9,19 @@
  */
 #include "ossl.h"
 #include <stdarg.h> /* for ossl_raise */
-#include <ruby/thread_native.h> /* for OpenSSL < 1.1.0 locks */
+
+/* OpenSSL >= 1.1.0 and LibreSSL >= 2.9.0 */
+#if defined(LIBRESSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER >= 0x10100000
+# define HAVE_OPENSSL_110_THREADING_API
+#else
+# include <ruby/thread_native.h>
+#endif
 
 /*
  * Data Conversion
  */
 #define OSSL_IMPL_ARY2SK(name, type, expected_class, dup)	\
-STACK_OF(type) *						\
+VALUE								\
 ossl_##name##_ary2sk0(VALUE ary)				\
 {								\
     STACK_OF(type) *sk;						\
@@ -37,7 +43,7 @@ ossl_##name##_ary2sk0(VALUE ary)				\
 	x = dup(val); /* NEED TO DUP */				\
 	sk_##type##_push(sk, x);				\
     }								\
-    return sk;							\
+    return (VALUE)sk;						\
 }								\
 								\
 STACK_OF(type) *						\
@@ -262,15 +268,11 @@ ossl_to_der_if_possible(VALUE obj)
 /*
  * Errors
  */
-static VALUE
-ossl_make_error(VALUE exc, const char *fmt, va_list args)
+VALUE
+ossl_make_error(VALUE exc, VALUE str)
 {
-    VALUE str = Qnil;
     unsigned long e;
 
-    if (fmt) {
-	str = rb_vsprintf(fmt, args);
-    }
     e = ERR_peek_last_error();
     if (e) {
 	const char *msg = ERR_reason_error_string(e);
@@ -294,37 +296,48 @@ ossl_raise(VALUE exc, const char *fmt, ...)
 {
     va_list args;
     VALUE err;
-    va_start(args, fmt);
-    err = ossl_make_error(exc, fmt, args);
-    va_end(args);
-    rb_exc_raise(err);
+
+    if (fmt) {
+	va_start(args, fmt);
+	err = rb_vsprintf(fmt, args);
+	va_end(args);
+    }
+    else {
+	err = Qnil;
+    }
+
+    rb_exc_raise(ossl_make_error(exc, err));
 }
 
 void
 ossl_clear_error(void)
 {
     if (dOSSL == Qtrue) {
-	unsigned long e;
-	const char *file, *data, *errstr;
-	int line, flags;
-
-	while ((e = ERR_get_error_line_data(&file, &line, &data, &flags))) {
-	    errstr = ERR_error_string(e, NULL);
-	    if (!errstr)
-		errstr = "(null)";
-
-	    if (flags & ERR_TXT_STRING) {
-		if (!data)
-		    data = "(null)";
-		rb_warn("error on stack: %s (%s)", errstr, data);
-	    }
-	    else {
-		rb_warn("error on stack: %s", errstr);
-	    }
-	}
+        unsigned long e;
+        const char *file, *data, *func, *lib, *reason;
+        char append[256] = "";
+        int line, flags;
+
+#ifdef HAVE_ERR_GET_ERROR_ALL
+        while ((e = ERR_get_error_all(&file, &line, &func, &data, &flags))) {
+#else
+        while ((e = ERR_get_error_line_data(&file, &line, &data, &flags))) {
+            func = ERR_func_error_string(e);
+#endif
+            lib = ERR_lib_error_string(e);
+            reason = ERR_reason_error_string(e);
+
+            if (flags & ERR_TXT_STRING) {
+                if (!data)
+                    data = "(null)";
+                snprintf(append, sizeof(append), " (%s)", data);
+            }
+            rb_warn("error on stack: error:%08lX:%s:%s:%s%s", e, lib ? lib : "",
+                    func ? func : "", reason ? reason : "", append);
+        }
     }
     else {
-	ERR_clear_error();
+        ERR_clear_error();
     }
 }
 
@@ -386,7 +399,7 @@ ossl_debug_get(VALUE self)
  * call-seq:
  *   OpenSSL.debug = boolean -> boolean
  *
- * Turns on or off debug mode. With debug mode, all erros added to the OpenSSL
+ * Turns on or off debug mode. With debug mode, all errors added to the OpenSSL
  * error queue will be printed to stderr.
  */
 static VALUE
@@ -667,7 +680,7 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
  * ahold of the key may use it unless it is encrypted.  In order to securely
  * export a key you may export it with a pass phrase.
  *
- *   cipher = OpenSSL::Cipher.new 'AES-256-CBC'
+ *   cipher = OpenSSL::Cipher.new 'aes-256-cbc'
  *   pass_phrase = 'my secure pass phrase goes here'
  *
  *   key_secure = key.export cipher, pass_phrase
@@ -682,13 +695,13 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
  *
  * A key can also be loaded from a file.
  *
- *   key2 = OpenSSL::PKey::RSA.new File.read 'private_key.pem'
+ *   key2 = OpenSSL::PKey.read File.read 'private_key.pem'
  *   key2.public? # => true
  *   key2.private? # => true
  *
  * or
  *
- *   key3 = OpenSSL::PKey::RSA.new File.read 'public_key.pem'
+ *   key3 = OpenSSL::PKey.read File.read 'public_key.pem'
  *   key3.public? # => true
  *   key3.private? # => false
  *
@@ -700,7 +713,7 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
  *
  *   key4_pem = File.read 'private.secure.pem'
  *   pass_phrase = 'my secure pass phrase goes here'
- *   key4 = OpenSSL::PKey::RSA.new key4_pem, pass_phrase
+ *   key4 = OpenSSL::PKey.read key4_pem, pass_phrase
  *
  * == RSA Encryption
  *
@@ -775,7 +788,7 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
  * using PBKDF2. PKCS #5 v2.0 recommends at least 8 bytes for the salt,
  * the number of iterations largely depends on the hardware being used.
  *
- *   cipher = OpenSSL::Cipher.new 'AES-256-CBC'
+ *   cipher = OpenSSL::Cipher.new 'aes-256-cbc'
  *   cipher.encrypt
  *   iv = cipher.random_iv
  *
@@ -798,7 +811,7 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
  * Use the same steps as before to derive the symmetric AES key, this time
  * setting the Cipher up for decryption.
  *
- *   cipher = OpenSSL::Cipher.new 'AES-256-CBC'
+ *   cipher = OpenSSL::Cipher.new 'aes-256-cbc'
  *   cipher.decrypt
  *   cipher.iv = iv # the one generated with #random_iv
  *
@@ -833,7 +846,7 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
  *
  * First set up the cipher for encryption
  *
- *   encryptor = OpenSSL::Cipher.new 'AES-256-CBC'
+ *   encryptor = OpenSSL::Cipher.new 'aes-256-cbc'
  *   encryptor.encrypt
  *   encryptor.pkcs5_keyivgen pass_phrase, salt
  *
@@ -846,7 +859,7 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
  *
  * Use a new Cipher instance set up for decryption
  *
- *   decryptor = OpenSSL::Cipher.new 'AES-256-CBC'
+ *   decryptor = OpenSSL::Cipher.new 'aes-256-cbc'
  *   decryptor.decrypt
  *   decryptor.pkcs5_keyivgen pass_phrase, salt
  *
@@ -934,7 +947,7 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
  *   ca_key = OpenSSL::PKey::RSA.new 2048
  *   pass_phrase = 'my secure pass phrase goes here'
  *
- *   cipher = OpenSSL::Cipher.new 'AES-256-CBC'
+ *   cipher = OpenSSL::Cipher.new 'aes-256-cbc'
  *
  *   open 'ca_key.pem', 'w', 0400 do |io|
  *     io.write ca_key.export(cipher, pass_phrase)
@@ -1072,13 +1085,13 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
  *   loop do
  *     ssl_connection = ssl_server.accept
  *
- *     data = connection.gets
+ *     data = ssl_connection.gets
  *
  *     response = "I got #{data.dump}"
  *     puts response
  *
- *     connection.puts "I got #{data.dump}"
- *     connection.close
+ *     ssl_connection.puts "I got #{data.dump}"
+ *     ssl_connection.close
  *   end
  *
  * === SSL client
@@ -1129,7 +1142,7 @@ ossl_crypto_fixed_length_secure_compare(VALUE dummy, VALUE str1, VALUE str2)
 void
 Init_openssl(void)
 {
-#if HAVE_RB_EXT_RACTOR_SAFE
+#ifdef HAVE_RB_EXT_RACTOR_SAFE
     rb_ext_ractor_safe(true);
 #endif
 
diff --git a/ext/openssl/ossl.h b/ext/openssl/ossl.h
index c20f506..4b51268 100644
--- a/ext/openssl/ossl.h
+++ b/ext/openssl/ossl.h
@@ -18,22 +18,19 @@
 #include <ruby/io.h>
 #include <ruby/thread.h>
 #include <openssl/opensslv.h>
+
 #include <openssl/err.h>
 #include <openssl/asn1.h>
 #include <openssl/x509v3.h>
 #include <openssl/ssl.h>
 #include <openssl/pkcs12.h>
 #include <openssl/pkcs7.h>
-#include <openssl/hmac.h>
 #include <openssl/rand.h>
 #include <openssl/conf.h>
 #ifndef OPENSSL_NO_TS
   #include <openssl/ts.h>
 #endif
 #include <openssl/crypto.h>
-#if !defined(OPENSSL_NO_ENGINE)
-#  include <openssl/engine.h>
-#endif
 #if !defined(OPENSSL_NO_OCSP)
 #  include <openssl/ocsp.h>
 #endif
@@ -43,6 +40,22 @@
 #include <openssl/evp.h>
 #include <openssl/dh.h>
 
+#ifndef LIBRESSL_VERSION_NUMBER
+# define OSSL_IS_LIBRESSL 0
+# define OSSL_OPENSSL_PREREQ(maj, min, pat) \
+      (OPENSSL_VERSION_NUMBER >= (maj << 28) | (min << 20) | (pat << 12))
+# define OSSL_LIBRESSL_PREREQ(maj, min, pat) 0
+#else
+# define OSSL_IS_LIBRESSL 1
+# define OSSL_OPENSSL_PREREQ(maj, min, pat) 0
+# define OSSL_LIBRESSL_PREREQ(maj, min, pat) \
+      (LIBRESSL_VERSION_NUMBER >= (maj << 28) | (min << 20) | (pat << 12))
+#endif
+
+#if !defined(OPENSSL_NO_ENGINE) && !OSSL_OPENSSL_PREREQ(3, 0, 0)
+# define OSSL_USE_ENGINE
+#endif
+
 /*
  * Common Module
  */
@@ -121,7 +134,9 @@ int ossl_pem_passwd_cb(char *, int, int, void *);
 /*
  * ERRor messages
  */
-NORETURN(void ossl_raise(VALUE, const char *, ...));
+PRINTF_ARGS(NORETURN(void ossl_raise(VALUE, const char *, ...)), 2, 3);
+/* Make exception instance from str and OpenSSL error reason string. */
+VALUE ossl_make_error(VALUE exc, VALUE str);
 /* Clear OpenSSL error queue. If dOSSL is set, rb_warn() them. */
 void ossl_clear_error(void);
 
@@ -154,7 +169,6 @@ void ossl_debug(const char *, ...);
  * Include all parts
  */
 #include "openssl_missing.h"
-#include "ruby_missing.h"
 #include "ossl_asn1.h"
 #include "ossl_bio.h"
 #include "ossl_bn.h"
diff --git a/ext/openssl/ossl_asn1.c b/ext/openssl/ossl_asn1.c
index 9eb1826..a61d3ee 100644
--- a/ext/openssl/ossl_asn1.c
+++ b/ext/openssl/ossl_asn1.c
@@ -69,6 +69,12 @@ asn1time_to_time(const ASN1_TIME *time)
     return rb_funcall2(rb_cTime, rb_intern("utc"), 6, argv);
 }
 
+static VALUE
+asn1time_to_time_i(VALUE arg)
+{
+    return asn1time_to_time((ASN1_TIME *)arg);
+}
+
 void
 ossl_time_split(VALUE time, time_t *sec, int *days)
 {
@@ -136,6 +142,12 @@ num_to_asn1integer(VALUE obj, ASN1_INTEGER *ai)
     return ai;
 }
 
+static VALUE
+asn1integer_to_num_i(VALUE arg)
+{
+    return asn1integer_to_num((ASN1_INTEGER *)arg);
+}
+
 /********/
 /*
  * ASN1 module
@@ -325,7 +337,7 @@ decode_int(unsigned char* der, long length)
     p = der;
     if(!(ai = d2i_ASN1_INTEGER(NULL, &p, length)))
 	ossl_raise(eASN1Error, NULL);
-    ret = rb_protect((VALUE (*)(VALUE))asn1integer_to_num,
+    ret = rb_protect(asn1integer_to_num_i,
 		     (VALUE)ai, &status);
     ASN1_INTEGER_free(ai);
     if(status) rb_jump_tag(status);
@@ -365,7 +377,7 @@ decode_enum(unsigned char* der, long length)
     p = der;
     if(!(ai = d2i_ASN1_ENUMERATED(NULL, &p, length)))
 	ossl_raise(eASN1Error, NULL);
-    ret = rb_protect((VALUE (*)(VALUE))asn1integer_to_num,
+    ret = rb_protect(asn1integer_to_num_i,
 		     (VALUE)ai, &status);
     ASN1_ENUMERATED_free(ai);
     if(status) rb_jump_tag(status);
@@ -427,7 +439,7 @@ decode_time(unsigned char* der, long length)
     p = der;
     if(!(time = d2i_ASN1_TIME(NULL, &p, length)))
 	ossl_raise(eASN1Error, NULL);
-    ret = rb_protect((VALUE (*)(VALUE))asn1time_to_time,
+    ret = rb_protect(asn1time_to_time_i,
 		     (VALUE)time, &status);
     ASN1_TIME_free(time);
     if(status) rb_jump_tag(status);
@@ -1510,7 +1522,7 @@ Init_ossl_asn1(void)
      *
      * An Array that stores the name of a given tag number. These names are
      * the same as the name of the tag constant that is additionally defined,
-     * e.g. UNIVERSAL_TAG_NAME[2] = "INTEGER" and OpenSSL::ASN1::INTEGER = 2.
+     * e.g. +UNIVERSAL_TAG_NAME[2] = "INTEGER"+ and +OpenSSL::ASN1::INTEGER = 2+.
      *
      * == Example usage
      *
diff --git a/ext/openssl/ossl_bn.c b/ext/openssl/ossl_bn.c
index bec3729..56fa0ec 100644
--- a/ext/openssl/ossl_bn.c
+++ b/ext/openssl/ossl_bn.c
@@ -10,7 +10,7 @@
 /* modified by Michal Rokos <m.rokos@sh.cvut.cz> */
 #include "ossl.h"
 
-#if HAVE_RB_EXT_RACTOR_SAFE
+#ifdef HAVE_RB_EXT_RACTOR_SAFE
 #include <ruby/ractor.h>
 #endif
 
@@ -155,7 +155,7 @@ ossl_bn_value_ptr(volatile VALUE *ptr)
  * Private
  */
 
-#if HAVE_RB_EXT_RACTOR_SAFE
+#ifdef HAVE_RB_EXT_RACTOR_SAFE
 void
 ossl_bn_ctx_free(void *ptr)
 {
@@ -223,12 +223,29 @@ ossl_bn_alloc(VALUE klass)
 
 /*
  * call-seq:
- *    OpenSSL::BN.new(bn) => aBN
- *    OpenSSL::BN.new(integer) => aBN
- *    OpenSSL::BN.new(string) => aBN
- *    OpenSSL::BN.new(string, 0 | 2 | 10 | 16) => aBN
+ *    OpenSSL::BN.new(bn) -> aBN
+ *    OpenSSL::BN.new(integer) -> aBN
+ *    OpenSSL::BN.new(string, base = 10) -> aBN
+ *
+ * Construct a new \OpenSSL BIGNUM object.
+ *
+ * If +bn+ is an Integer or OpenSSL::BN, a new instance of OpenSSL::BN
+ * representing the same value is returned. See also Integer#to_bn for the
+ * short-hand.
  *
- * Construct a new OpenSSL BIGNUM object.
+ * If a String is given, the content will be parsed according to +base+.
+ *
+ * +string+::
+ *   The string to be parsed.
+ * +base+::
+ *   The format. Must be one of the following:
+ *   - +0+  - MPI format. See the man page BN_mpi2bn(3) for details.
+ *   - +2+  - Variable-length and big-endian binary encoding of a positive
+ *     number.
+ *   - +10+ - Decimal number representation, with a leading '-' for a negative
+ *     number.
+ *   - +16+ - Hexadeciaml number representation, with a leading '-' for a
+ *     negative number.
  */
 static VALUE
 ossl_bn_initialize(int argc, VALUE *argv, VALUE self)
@@ -296,16 +313,21 @@ ossl_bn_initialize(int argc, VALUE *argv, VALUE self)
 
 /*
  * call-seq:
- *    bn.to_s => string
- *    bn.to_s(base) => string
+ *    bn.to_s(base = 10) -> string
  *
- * === Parameters
- * * _base_ - Integer
- *   Valid values:
- *   * 0 - MPI
- *   * 2 - binary
- *   * 10 - the default
- *   * 16 - hex
+ * Returns the string representation of the bignum.
+ *
+ * BN.new can parse the encoded string to convert back into an OpenSSL::BN.
+ *
+ * +base+::
+ *   The format. Must be one of the following:
+ *   - +0+  - MPI format. See the man page BN_bn2mpi(3) for details.
+ *   - +2+  - Variable-length and big-endian binary encoding. The sign of
+ *     the bignum is ignored.
+ *   - +10+ - Decimal number representation, with a leading '-' for a negative
+ *     bignum.
+ *   - +16+ - Hexadeciaml number representation, with a leading '-' for a
+ *     negative bignum.
  */
 static VALUE
 ossl_bn_to_s(int argc, VALUE *argv, VALUE self)
@@ -770,78 +792,64 @@ BIGNUM_SELF_SHIFT(lshift)
  */
 BIGNUM_SELF_SHIFT(rshift)
 
-#define BIGNUM_RAND(func)					\
-    static VALUE						\
-    ossl_bn_s_##func(int argc, VALUE *argv, VALUE klass)	\
-    {								\
-	BIGNUM *result;						\
-	int bottom = 0, top = 0, b;				\
-	VALUE bits, fill, odd, obj;				\
-								\
-	switch (rb_scan_args(argc, argv, "12", &bits, &fill, &odd)) {	\
-	case 3:							\
-	    bottom = (odd == Qtrue) ? 1 : 0;			\
-	    /* FALLTHROUGH */					\
-	case 2:							\
-	    top = NUM2INT(fill);				\
-	}							\
-	b = NUM2INT(bits);					\
-	obj = NewBN(klass);					\
-	if (!(result = BN_new())) {				\
-	    ossl_raise(eBNError, NULL);				\
-	}							\
-	if (BN_##func(result, b, top, bottom) <= 0) {		\
-	    BN_free(result);					\
-	    ossl_raise(eBNError, NULL);				\
-	}							\
-	SetBN(obj, result);					\
-	return obj;						\
-    }
-
-/*
- * Document-method: OpenSSL::BN.rand
- *   BN.rand(bits [, fill [, odd]]) -> aBN
- */
-BIGNUM_RAND(rand)
-
-/*
- * Document-method: OpenSSL::BN.pseudo_rand
- *   BN.pseudo_rand(bits [, fill [, odd]]) -> aBN
- */
-BIGNUM_RAND(pseudo_rand)
-
-#define BIGNUM_RAND_RANGE(func)					\
-    static VALUE						\
-    ossl_bn_s_##func##_range(VALUE klass, VALUE range)		\
-    {								\
-	BIGNUM *bn = GetBNPtr(range), *result;			\
-	VALUE obj = NewBN(klass);				\
-	if (!(result = BN_new())) {				\
-	    ossl_raise(eBNError, NULL);				\
-	}							\
-	if (BN_##func##_range(result, bn) <= 0) {		\
-	    BN_free(result);					\
-	    ossl_raise(eBNError, NULL);				\
-	}							\
-	SetBN(obj, result);					\
-	return obj;						\
-    }
-
 /*
- * Document-method: OpenSSL::BN.rand_range
  * call-seq:
- *   BN.rand_range(range) -> aBN
+ *    BN.rand(bits [, fill [, odd]]) -> aBN
+ *
+ * Generates a cryptographically strong pseudo-random number of +bits+.
  *
+ * See also the man page BN_rand(3).
  */
-BIGNUM_RAND_RANGE(rand)
+static VALUE
+ossl_bn_s_rand(int argc, VALUE *argv, VALUE klass)
+{
+    BIGNUM *result;
+    int bottom = 0, top = 0, b;
+    VALUE bits, fill, odd, obj;
+
+    switch (rb_scan_args(argc, argv, "12", &bits, &fill, &odd)) {
+      case 3:
+        bottom = (odd == Qtrue) ? 1 : 0;
+        /* FALLTHROUGH */
+      case 2:
+        top = NUM2INT(fill);
+    }
+    b = NUM2INT(bits);
+    obj = NewBN(klass);
+    if (!(result = BN_new())) {
+        ossl_raise(eBNError, "BN_new");
+    }
+    if (BN_rand(result, b, top, bottom) <= 0) {
+        BN_free(result);
+        ossl_raise(eBNError, "BN_rand");
+    }
+    SetBN(obj, result);
+    return obj;
+}
 
 /*
- * Document-method: OpenSSL::BN.pseudo_rand_range
  * call-seq:
- *   BN.pseudo_rand_range(range) -> aBN
+ *    BN.rand_range(range) -> aBN
  *
+ * Generates a cryptographically strong pseudo-random number in the range
+ * 0...+range+.
+ *
+ * See also the man page BN_rand_range(3).
  */
-BIGNUM_RAND_RANGE(pseudo_rand)
+static VALUE
+ossl_bn_s_rand_range(VALUE klass, VALUE range)
+{
+    BIGNUM *bn = GetBNPtr(range), *result;
+    VALUE obj = NewBN(klass);
+    if (!(result = BN_new()))
+        ossl_raise(eBNError, "BN_new");
+    if (BN_rand_range(result, bn) <= 0) {
+        BN_free(result);
+        ossl_raise(eBNError, "BN_rand_range");
+    }
+    SetBN(obj, result);
+    return obj;
+}
 
 /*
  * call-seq:
@@ -936,7 +944,17 @@ ossl_bn_copy(VALUE self, VALUE other)
 static VALUE
 ossl_bn_uplus(VALUE self)
 {
-    return self;
+    VALUE obj;
+    BIGNUM *bn1, *bn2;
+
+    GetBN(self, bn1);
+    obj = NewBN(cBN);
+    bn2 = BN_dup(bn1);
+    if (!bn2)
+	ossl_raise(eBNError, "BN_dup");
+    SetBN(obj, bn2);
+
+    return obj;
 }
 
 /*
@@ -960,6 +978,24 @@ ossl_bn_uminus(VALUE self)
     return obj;
 }
 
+/*
+ * call-seq:
+ *   bn.abs -> aBN
+ */
+static VALUE
+ossl_bn_abs(VALUE self)
+{
+    BIGNUM *bn1;
+
+    GetBN(self, bn1);
+    if (BN_is_negative(bn1)) {
+        return ossl_bn_uminus(self);
+    }
+    else {
+        return ossl_bn_uplus(self);
+    }
+}
+
 #define BIGNUM_CMP(func)				\
     static VALUE					\
     ossl_bn_##func(VALUE self, VALUE other)		\
@@ -1068,34 +1104,29 @@ ossl_bn_hash(VALUE self)
  *    bn.prime? => true | false
  *    bn.prime?(checks) => true | false
  *
- * Performs a Miller-Rabin probabilistic primality test with _checks_
- * iterations. If _checks_ is not specified, a number of iterations is used
- * that yields a false positive rate of at most 2^-80 for random input.
+ * Performs a Miller-Rabin probabilistic primality test for +bn+.
  *
- * === Parameters
- * * _checks_ - integer
+ * <b>+checks+ parameter is deprecated in version 3.0.</b> It has no effect.
  */
 static VALUE
 ossl_bn_is_prime(int argc, VALUE *argv, VALUE self)
 {
     BIGNUM *bn;
-    VALUE vchecks;
-    int checks = BN_prime_checks;
+    int ret;
 
-    if (rb_scan_args(argc, argv, "01", &vchecks) == 1) {
-	checks = NUM2INT(vchecks);
-    }
+    rb_check_arity(argc, 0, 1);
     GetBN(self, bn);
-    switch (BN_is_prime_ex(bn, checks, ossl_bn_ctx, NULL)) {
-    case 1:
-	return Qtrue;
-    case 0:
-	return Qfalse;
-    default:
-	ossl_raise(eBNError, NULL);
-    }
-    /* not reachable */
-    return Qnil;
+
+#ifdef HAVE_BN_CHECK_PRIME
+    ret = BN_check_prime(bn, ossl_bn_ctx, NULL);
+    if (ret < 0)
+        ossl_raise(eBNError, "BN_check_prime");
+#else
+    ret = BN_is_prime_fasttest_ex(bn, BN_prime_checks, ossl_bn_ctx, 1, NULL);
+    if (ret < 0)
+        ossl_raise(eBNError, "BN_is_prime_fasttest_ex");
+#endif
+    return ret ? Qtrue : Qfalse;
 }
 
 /*
@@ -1104,39 +1135,52 @@ ossl_bn_is_prime(int argc, VALUE *argv, VALUE self)
  *    bn.prime_fasttest?(checks) => true | false
  *    bn.prime_fasttest?(checks, trial_div) => true | false
  *
- * Performs a Miller-Rabin primality test. This is same as #prime? except this
- * first attempts trial divisions with some small primes.
+ * Performs a Miller-Rabin probabilistic primality test for +bn+.
  *
- * === Parameters
- * * _checks_ - integer
- * * _trial_div_ - boolean
+ * <b>Deprecated in version 3.0.</b> Use #prime? instead.
+ *
+ * +checks+ and +trial_div+ parameters no longer have any effect.
  */
 static VALUE
 ossl_bn_is_prime_fasttest(int argc, VALUE *argv, VALUE self)
+{
+    rb_check_arity(argc, 0, 2);
+    return ossl_bn_is_prime(0, argv, self);
+}
+
+/*
+ * call-seq:
+ *    bn.get_flags(flags) => flags
+ *
+ * Returns the flags on the BN object.
+ * The argument is used as a bit mask.
+ *
+ * === Parameters
+ * * _flags_ - integer
+ */
+static VALUE
+ossl_bn_get_flags(VALUE self, VALUE arg)
 {
     BIGNUM *bn;
-    VALUE vchecks, vtrivdiv;
-    int checks = BN_prime_checks, do_trial_division = 1;
+    GetBN(self, bn);
 
-    rb_scan_args(argc, argv, "02", &vchecks, &vtrivdiv);
+    return INT2NUM(BN_get_flags(bn, NUM2INT(arg)));
+}
 
-    if (!NIL_P(vchecks)) {
-	checks = NUM2INT(vchecks);
-    }
+/*
+ * call-seq:
+ *    bn.set_flags(flags) => nil
+ *
+ * Enables the flags on the BN object.
+ * Currently, the flags argument can contain zero of OpenSSL::BN::CONSTTIME.
+ */
+static VALUE
+ossl_bn_set_flags(VALUE self, VALUE arg)
+{
+    BIGNUM *bn;
     GetBN(self, bn);
-    /* handle true/false */
-    if (vtrivdiv == Qfalse) {
-	do_trial_division = 0;
-    }
-    switch (BN_is_prime_fasttest_ex(bn, checks, ossl_bn_ctx, do_trial_division, NULL)) {
-    case 1:
-	return Qtrue;
-    case 0:
-	return Qfalse;
-    default:
-	ossl_raise(eBNError, NULL);
-    }
-    /* not reachable */
+
+    BN_set_flags(bn, NUM2INT(arg));
     return Qnil;
 }
 
@@ -1176,6 +1220,7 @@ Init_ossl_bn(void)
 
     rb_define_method(cBN, "+@", ossl_bn_uplus, 0);
     rb_define_method(cBN, "-@", ossl_bn_uminus, 0);
+    rb_define_method(cBN, "abs", ossl_bn_abs, 0);
 
     rb_define_method(cBN, "+", ossl_bn_add, 1);
     rb_define_method(cBN, "-", ossl_bn_sub, 1);
@@ -1219,9 +1264,9 @@ Init_ossl_bn(void)
      * get_word */
 
     rb_define_singleton_method(cBN, "rand", ossl_bn_s_rand, -1);
-    rb_define_singleton_method(cBN, "pseudo_rand", ossl_bn_s_pseudo_rand, -1);
     rb_define_singleton_method(cBN, "rand_range", ossl_bn_s_rand_range, 1);
-    rb_define_singleton_method(cBN, "pseudo_rand_range", ossl_bn_s_pseudo_rand_range, 1);
+    rb_define_alias(rb_singleton_class(cBN), "pseudo_rand", "rand");
+    rb_define_alias(rb_singleton_class(cBN), "pseudo_rand_range", "rand_range");
 
     rb_define_singleton_method(cBN, "generate_prime", ossl_bn_s_generate_prime, -1);
     rb_define_method(cBN, "prime?", ossl_bn_is_prime, -1);
@@ -1238,6 +1283,23 @@ Init_ossl_bn(void)
     /* lshift1 - DON'T IMPL. */
     /* rshift1 - DON'T IMPL. */
 
+    rb_define_method(cBN, "get_flags", ossl_bn_get_flags, 1);
+    rb_define_method(cBN, "set_flags", ossl_bn_set_flags, 1);
+
+#ifdef BN_FLG_CONSTTIME
+    rb_define_const(cBN, "CONSTTIME", INT2NUM(BN_FLG_CONSTTIME));
+#endif
+    /* BN_FLG_MALLOCED and BN_FLG_STATIC_DATA seems for C programming.
+     * Allowing them leads to memory leak.
+     * So, for now, they are not exported
+#ifdef BN_FLG_MALLOCED
+    rb_define_const(cBN, "MALLOCED", INT2NUM(BN_FLG_MALLOCED));
+#endif
+#ifdef BN_FLG_STATIC_DATA
+    rb_define_const(cBN, "STATIC_DATA", INT2NUM(BN_FLG_STATIC_DATA));
+#endif
+    */
+
     /*
      * bn2bin
      * bin2bn
diff --git a/ext/openssl/ossl_cipher.c b/ext/openssl/ossl_cipher.c
index 5b92fc3..d9c7891 100644
--- a/ext/openssl/ossl_cipher.c
+++ b/ext/openssl/ossl_cipher.c
@@ -104,7 +104,7 @@ ossl_cipher_alloc(VALUE klass)
  *  call-seq:
  *     Cipher.new(string) -> cipher
  *
- *  The string must contain a valid cipher name like "AES-256-CBC".
+ *  The string must contain a valid cipher name like "aes-256-cbc".
  *
  *  A list of cipher names is available by calling OpenSSL::Cipher.ciphers.
  */
@@ -149,11 +149,11 @@ ossl_cipher_copy(VALUE self, VALUE other)
     return self;
 }
 
-static void*
-add_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)
+static void
+add_cipher_name_to_ary(const OBJ_NAME *name, void *arg)
 {
+    VALUE ary = (VALUE)arg;
     rb_ary_push(ary, rb_str_new2(name->name));
-    return NULL;
 }
 
 /*
@@ -169,7 +169,7 @@ ossl_s_ciphers(VALUE self)
 
     ary = rb_ary_new();
     OBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_CIPHER_METH,
-                    (void(*)(const OBJ_NAME*,void*))add_cipher_name_to_ary,
+                    add_cipher_name_to_ary,
                     (void*)ary);
 
     return ary;
@@ -874,7 +874,7 @@ Init_ossl_cipher(void)
      * individual components name, key length and mode. Either all uppercase
      * or all lowercase strings may be used, for example:
      *
-     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')
+     *  cipher = OpenSSL::Cipher.new('aes-128-cbc')
      *
      * === Choosing either encryption or decryption mode
      *
@@ -904,7 +904,7 @@ Init_ossl_cipher(void)
      * without processing the password further. A simple and secure way to
      * create a key for a particular Cipher is
      *
-     *  cipher = OpenSSL::Cipher.new('AES-256-CFB')
+     *  cipher = OpenSSL::Cipher.new('aes-256-cfb')
      *  cipher.encrypt
      *  key = cipher.random_key # also sets the generated key on the Cipher
      *
@@ -972,14 +972,14 @@ Init_ossl_cipher(void)
      *
      *   data = "Very, very confidential data"
      *
-     *   cipher = OpenSSL::Cipher.new('AES-128-CBC')
+     *   cipher = OpenSSL::Cipher.new('aes-128-cbc')
      *   cipher.encrypt
      *   key = cipher.random_key
      *   iv = cipher.random_iv
      *
      *   encrypted = cipher.update(data) + cipher.final
      *   ...
-     *   decipher = OpenSSL::Cipher.new('AES-128-CBC')
+     *   decipher = OpenSSL::Cipher.new('aes-128-cbc')
      *   decipher.decrypt
      *   decipher.key = key
      *   decipher.iv = iv
@@ -1015,7 +1015,7 @@ Init_ossl_cipher(void)
      * not to reuse the _key_ and _nonce_ pair. Reusing an nonce ruins the
      * security guarantees of GCM mode.
      *
-     *   cipher = OpenSSL::Cipher.new('AES-128-GCM').encrypt
+     *   cipher = OpenSSL::Cipher.new('aes-128-gcm').encrypt
      *   cipher.key = key
      *   cipher.iv = nonce
      *   cipher.auth_data = auth_data
@@ -1031,7 +1031,7 @@ Init_ossl_cipher(void)
      * ciphertext with a probability of 1/256.
      *
      *   raise "tag is truncated!" unless tag.bytesize == 16
-     *   decipher = OpenSSL::Cipher.new('AES-128-GCM').decrypt
+     *   decipher = OpenSSL::Cipher.new('aes-128-gcm').decrypt
      *   decipher.key = key
      *   decipher.iv = nonce
      *   decipher.auth_tag = tag
diff --git a/ext/openssl/ossl_config.c b/ext/openssl/ossl_config.c
index 28392e2..0bac027 100644
--- a/ext/openssl/ossl_config.c
+++ b/ext/openssl/ossl_config.c
@@ -9,81 +9,452 @@
  */
 #include "ossl.h"
 
+static VALUE cConfig, eConfigError;
+
+static void
+nconf_free(void *conf)
+{
+    NCONF_free(conf);
+}
+
+static const rb_data_type_t ossl_config_type = {
+    "OpenSSL/CONF",
+    {
+        0, nconf_free,
+    },
+    0, 0, RUBY_TYPED_FREE_IMMEDIATELY,
+};
+
+CONF *
+GetConfig(VALUE obj)
+{
+    CONF *conf;
+
+    TypedData_Get_Struct(obj, CONF, &ossl_config_type, conf);
+    if (!conf)
+        rb_raise(rb_eRuntimeError, "CONF is not initialized");
+    return conf;
+}
+
+static VALUE
+config_s_alloc(VALUE klass)
+{
+    VALUE obj;
+    CONF *conf;
+
+    obj = TypedData_Wrap_Struct(klass, &ossl_config_type, 0);
+    conf = NCONF_new(NULL);
+    if (!conf)
+        ossl_raise(eConfigError, "NCONF_new");
+    RTYPEDDATA_DATA(obj) = conf;
+    return obj;
+}
+
+static void
+config_load_bio(CONF *conf, BIO *bio)
+{
+    long eline = -1;
+
+    if (!NCONF_load_bio(conf, bio, &eline)) {
+        BIO_free(bio);
+        if (eline <= 0)
+            ossl_raise(eConfigError, "wrong config format");
+        else
+            ossl_raise(eConfigError, "error in line %ld", eline);
+    }
+    BIO_free(bio);
+
+    /*
+     * Clear the error queue even if it is parsed successfully.
+     * Particularly, when the .include directive refers to a non-existent file,
+     * it is only reported in the error queue.
+     */
+    ossl_clear_error();
+}
 
 /*
- * Classes
- */
-VALUE cConfig;
-/* Document-class: OpenSSL::ConfigError
+ * call-seq:
+ *    Config.parse(string) -> OpenSSL::Config
  *
- * General error for openssl library configuration files. Including formatting,
- * parsing errors, etc.
+ * Parses a given _string_ as a blob that contains configuration for OpenSSL.
  */
-VALUE eConfigError;
+static VALUE
+config_s_parse(VALUE klass, VALUE str)
+{
+    VALUE obj = config_s_alloc(klass);
+    CONF *conf = GetConfig(obj);
+    BIO *bio;
+
+    bio = ossl_obj2bio(&str);
+    config_load_bio(conf, bio); /* Consumes BIO */
+    return obj;
+}
+
+static VALUE config_get_sections(VALUE self);
+static VALUE config_get_section(VALUE self, VALUE section);
 
 /*
- * Public
+ * call-seq:
+ *    Config.parse_config(io) -> hash
+ *
+ * Parses the configuration data read from _io_ and returns the whole content
+ * as a Hash.
  */
+static VALUE
+config_s_parse_config(VALUE klass, VALUE io)
+{
+    VALUE obj, sections, ret;
+    long i;
+
+    obj = config_s_parse(klass, io);
+    sections = config_get_sections(obj);
+    ret = rb_hash_new();
+    for (i = 0; i < RARRAY_LEN(sections); i++) {
+        VALUE section = rb_ary_entry(sections, i);
+        rb_hash_aset(ret, section, config_get_section(obj, section));
+    }
+    return ret;
+}
 
 /*
- * DupConfigPtr is a public C-level function for getting OpenSSL CONF struct
- * from an OpenSSL::Config(eConfig) instance.  We decided to implement
- * OpenSSL::Config in Ruby level but we need to pass native CONF struct for
- * some OpenSSL features such as X509V3_EXT_*.
+ * call-seq:
+ *    Config.new(filename) -> OpenSSL::Config
+ *
+ * Creates an instance of OpenSSL::Config from the content of the file
+ * specified by _filename_.
+ *
+ * This can be used in contexts like OpenSSL::X509::ExtensionFactory.config=
+ *
+ * This can raise IO exceptions based on the access, or availability of the
+ * file. A ConfigError exception may be raised depending on the validity of
+ * the data being configured.
  */
-CONF *
-DupConfigPtr(VALUE obj)
+static VALUE
+config_initialize(int argc, VALUE *argv, VALUE self)
 {
-    CONF *conf;
+    CONF *conf = GetConfig(self);
+    VALUE filename;
+
+    /* 0-arguments call has no use-case, but is kept for compatibility */
+    rb_scan_args(argc, argv, "01", &filename);
+    rb_check_frozen(self);
+    if (!NIL_P(filename)) {
+        BIO *bio = BIO_new_file(StringValueCStr(filename), "rb");
+        if (!bio)
+            ossl_raise(eConfigError, "BIO_new_file");
+        config_load_bio(conf, bio); /* Consumes BIO */
+    }
+    return self;
+}
+
+static VALUE
+config_initialize_copy(VALUE self, VALUE other)
+{
+    CONF *conf = GetConfig(self);
     VALUE str;
     BIO *bio;
-    long eline = -1;
 
-    OSSL_Check_Kind(obj, cConfig);
-    str = rb_funcall(obj, rb_intern("to_s"), 0);
+    str = rb_funcall(other, rb_intern("to_s"), 0);
+    rb_check_frozen(self);
     bio = ossl_obj2bio(&str);
-    conf = NCONF_new(NULL);
-    if(!conf){
-	BIO_free(bio);
-	ossl_raise(eConfigError, NULL);
+    config_load_bio(conf, bio); /* Consumes BIO */
+    return self;
+}
+
+/*
+ * call-seq:
+ *    config.get_value(section, key) -> string
+ *
+ * Gets the value of _key_ from the given _section_.
+ *
+ * Given the following configurating file being loaded:
+ *
+ *   config = OpenSSL::Config.load('foo.cnf')
+ *     #=> #<OpenSSL::Config sections=["default"]>
+ *   puts config.to_s
+ *     #=> [ default ]
+ *     #   foo=bar
+ *
+ * You can get a specific value from the config if you know the _section_
+ * and _key_ like so:
+ *
+ *   config.get_value('default','foo')
+ *     #=> "bar"
+ */
+static VALUE
+config_get_value(VALUE self, VALUE section, VALUE key)
+{
+    CONF *conf = GetConfig(self);
+    const char *str, *sectionp;
+
+    StringValueCStr(section);
+    StringValueCStr(key);
+    /* For compatibility; NULL means "default". */
+    sectionp = RSTRING_LEN(section) ? RSTRING_PTR(section) : NULL;
+    str = NCONF_get_string(conf, sectionp, RSTRING_PTR(key));
+    if (!str) {
+        ossl_clear_error();
+        return Qnil;
+    }
+    return rb_str_new_cstr(str);
+}
+
+/*
+ * call-seq:
+ *    config[section] -> hash
+ *
+ * Gets all key-value pairs in a specific _section_ from the current
+ * configuration.
+ *
+ * Given the following configurating file being loaded:
+ *
+ *   config = OpenSSL::Config.load('foo.cnf')
+ *     #=> #<OpenSSL::Config sections=["default"]>
+ *   puts config.to_s
+ *     #=> [ default ]
+ *     #   foo=bar
+ *
+ * You can get a hash of the specific section like so:
+ *
+ *   config['default']
+ *     #=> {"foo"=>"bar"}
+ *
+ */
+static VALUE
+config_get_section(VALUE self, VALUE section)
+{
+    CONF *conf = GetConfig(self);
+    STACK_OF(CONF_VALUE) *sk;
+    int i, entries;
+    VALUE hash;
+
+    hash = rb_hash_new();
+    StringValueCStr(section);
+    if (!(sk = NCONF_get_section(conf, RSTRING_PTR(section)))) {
+        ossl_clear_error();
+        return hash;
     }
-    if(!NCONF_load_bio(conf, bio, &eline)){
-	BIO_free(bio);
-	NCONF_free(conf);
-	if (eline <= 0)
-	    ossl_raise(eConfigError, "wrong config format");
-	else
-	    ossl_raise(eConfigError, "error in line %d", eline);
+    entries = sk_CONF_VALUE_num(sk);
+    for (i = 0; i < entries; i++) {
+        CONF_VALUE *entry = sk_CONF_VALUE_value(sk, i);
+        rb_hash_aset(hash, rb_str_new_cstr(entry->name),
+                     rb_str_new_cstr(entry->value));
     }
-    BIO_free(bio);
+    return hash;
+}
 
-    return conf;
+static void
+get_conf_section_doall_arg(CONF_VALUE *cv, VALUE *aryp)
+{
+    if (cv->name)
+        return;
+    rb_ary_push(*aryp, rb_str_new_cstr(cv->section));
 }
 
-/* Document-const: DEFAULT_CONFIG_FILE
+/* IMPLEMENT_LHASH_DOALL_ARG_CONST() requires >= OpenSSL 1.1.0 */
+static IMPLEMENT_LHASH_DOALL_ARG_FN(get_conf_section, CONF_VALUE, VALUE)
+
+/*
+ * call-seq:
+ *    config.sections -> array of string
  *
- * The default system configuration file for openssl
+ * Get the names of all sections in the current configuration.
  */
+static VALUE
+config_get_sections(VALUE self)
+{
+    CONF *conf = GetConfig(self);
+    VALUE ary;
+
+    ary = rb_ary_new();
+    lh_doall_arg((_LHASH *)conf->data, LHASH_DOALL_ARG_FN(get_conf_section),
+                 &ary);
+    return ary;
+}
+
+static void
+dump_conf_value_doall_arg(CONF_VALUE *cv, VALUE *strp)
+{
+    VALUE str = *strp;
+    STACK_OF(CONF_VALUE) *sk;
+    int i, num;
+
+    if (cv->name)
+        return;
+    sk = (STACK_OF(CONF_VALUE) *)cv->value;
+    num = sk_CONF_VALUE_num(sk);
+    rb_str_cat_cstr(str, "[ ");
+    rb_str_cat_cstr(str, cv->section);
+    rb_str_cat_cstr(str, " ]\n");
+    for (i = 0; i < num; i++){
+        CONF_VALUE *v = sk_CONF_VALUE_value(sk, i);
+        rb_str_cat_cstr(str, v->name ? v->name : "None");
+        rb_str_cat_cstr(str, "=");
+        rb_str_cat_cstr(str, v->value ? v->value : "None");
+        rb_str_cat_cstr(str, "\n");
+    }
+    rb_str_cat_cstr(str, "\n");
+}
+
+static IMPLEMENT_LHASH_DOALL_ARG_FN(dump_conf_value, CONF_VALUE, VALUE)
 
 /*
- * INIT
+ * call-seq:
+ *    config.to_s -> string
+ *
+ *
+ * Gets the parsable form of the current configuration.
+ *
+ * Given the following configuration being created:
+ *
+ *   config = OpenSSL::Config.new
+ *     #=> #<OpenSSL::Config sections=[]>
+ *   config['default'] = {"foo"=>"bar","baz"=>"buz"}
+ *     #=> {"foo"=>"bar", "baz"=>"buz"}
+ *   puts config.to_s
+ *     #=> [ default ]
+ *     #   foo=bar
+ *     #   baz=buz
+ *
+ * You can parse get the serialized configuration using #to_s and then parse
+ * it later:
+ *
+ *   serialized_config = config.to_s
+ *   # much later...
+ *   new_config = OpenSSL::Config.parse(serialized_config)
+ *     #=> #<OpenSSL::Config sections=["default"]>
+ *   puts new_config
+ *     #=> [ default ]
+ *         foo=bar
+ *         baz=buz
  */
+static VALUE
+config_to_s(VALUE self)
+{
+    CONF *conf = GetConfig(self);
+    VALUE str;
+
+    str = rb_str_new(NULL, 0);
+    lh_doall_arg((_LHASH *)conf->data, LHASH_DOALL_ARG_FN(dump_conf_value),
+                 &str);
+    return str;
+}
+
+static void
+each_conf_value_doall_arg(CONF_VALUE *cv, void *unused)
+{
+    STACK_OF(CONF_VALUE) *sk;
+    VALUE section;
+    int i, num;
+
+    if (cv->name)
+        return;
+    sk = (STACK_OF(CONF_VALUE) *)cv->value;
+    num = sk_CONF_VALUE_num(sk);
+    section = rb_str_new_cstr(cv->section);
+    for (i = 0; i < num; i++){
+        CONF_VALUE *v = sk_CONF_VALUE_value(sk, i);
+        VALUE name = v->name ? rb_str_new_cstr(v->name) : Qnil;
+        VALUE value = v->value ? rb_str_new_cstr(v->value) : Qnil;
+        rb_yield(rb_ary_new3(3, section, name, value));
+    }
+}
+
+static IMPLEMENT_LHASH_DOALL_ARG_FN(each_conf_value, CONF_VALUE, void)
+
+/*
+ * call-seq:
+ *    config.each { |section, key, value| }
+ *
+ * Retrieves the section and its pairs for the current configuration.
+ *
+ *    config.each do |section, key, value|
+ *      # ...
+ *    end
+ */
+static VALUE
+config_each(VALUE self)
+{
+    CONF *conf = GetConfig(self);
+
+    RETURN_ENUMERATOR(self, 0, 0);
+
+    lh_doall_arg((_LHASH *)conf->data, LHASH_DOALL_ARG_FN(each_conf_value),
+                 NULL);
+    return self;
+}
+
+/*
+ * call-seq:
+ *    config.inspect -> string
+ *
+ * String representation of this configuration object, including the class
+ * name and its sections.
+ */
+static VALUE
+config_inspect(VALUE self)
+{
+    VALUE str, ary = config_get_sections(self);
+    const char *cname = rb_class2name(rb_obj_class(self));
+
+    str = rb_str_new_cstr("#<");
+    rb_str_cat_cstr(str, cname);
+    rb_str_cat_cstr(str, " sections=");
+    rb_str_append(str, rb_inspect(ary));
+    rb_str_cat_cstr(str, ">");
+
+    return str;
+}
+
 void
 Init_ossl_config(void)
 {
-    char *default_config_file;
+    char *path;
+    VALUE path_str;
 
 #if 0
     mOSSL = rb_define_module("OpenSSL");
     eOSSLError = rb_define_class_under(mOSSL, "OpenSSLError", rb_eStandardError);
 #endif
 
-    eConfigError = rb_define_class_under(mOSSL, "ConfigError", eOSSLError);
+    /* Document-class: OpenSSL::Config
+     *
+     * Configuration for the openssl library.
+     *
+     * Many system's installation of openssl library will depend on your system
+     * configuration. See the value of OpenSSL::Config::DEFAULT_CONFIG_FILE for
+     * the location of the file for your host.
+     *
+     * See also http://www.openssl.org/docs/apps/config.html
+     */
     cConfig = rb_define_class_under(mOSSL, "Config", rb_cObject);
 
-    default_config_file = CONF_get1_default_config_file();
-    rb_define_const(cConfig, "DEFAULT_CONFIG_FILE",
-		    rb_str_new2(default_config_file));
-    OPENSSL_free(default_config_file);
-    /* methods are defined by openssl/config.rb */
+    /* Document-class: OpenSSL::ConfigError
+     *
+     * General error for openssl library configuration files. Including formatting,
+     * parsing errors, etc.
+     */
+    eConfigError = rb_define_class_under(mOSSL, "ConfigError", eOSSLError);
+
+    rb_include_module(cConfig, rb_mEnumerable);
+    rb_define_singleton_method(cConfig, "parse", config_s_parse, 1);
+    rb_define_singleton_method(cConfig, "parse_config", config_s_parse_config, 1);
+    rb_define_alias(CLASS_OF(cConfig), "load", "new");
+    rb_define_alloc_func(cConfig, config_s_alloc);
+    rb_define_method(cConfig, "initialize", config_initialize, -1);
+    rb_define_method(cConfig, "initialize_copy", config_initialize_copy, 1);
+    rb_define_method(cConfig, "get_value", config_get_value, 2);
+    rb_define_method(cConfig, "[]", config_get_section, 1);
+    rb_define_method(cConfig, "sections", config_get_sections, 0);
+    rb_define_method(cConfig, "to_s", config_to_s, 0);
+    rb_define_method(cConfig, "each", config_each, 0);
+    rb_define_method(cConfig, "inspect", config_inspect, 0);
+
+    /* Document-const: DEFAULT_CONFIG_FILE
+     *
+     * The default system configuration file for OpenSSL.
+     */
+    path = CONF_get1_default_config_file();
+    path_str = ossl_buf2str(path, rb_long2int(strlen(path)));
+    rb_define_const(cConfig, "DEFAULT_CONFIG_FILE", path_str);
 }
diff --git a/ext/openssl/ossl_config.h b/ext/openssl/ossl_config.h
index 627d297..4e604f1 100644
--- a/ext/openssl/ossl_config.h
+++ b/ext/openssl/ossl_config.h
@@ -7,13 +7,10 @@
  * This program is licensed under the same licence as Ruby.
  * (See the file 'LICENCE'.)
  */
-#if !defined(_OSSL_CONFIG_H_)
-#define _OSSL_CONFIG_H_
+#ifndef OSSL_CONFIG_H
+#define OSSL_CONFIG_H
 
-extern VALUE cConfig;
-extern VALUE eConfigError;
-
-CONF* DupConfigPtr(VALUE obj);
+CONF *GetConfig(VALUE obj);
 void Init_ossl_config(void);
 
-#endif /* _OSSL_CONFIG_H_ */
+#endif /* OSSL_CONFIG_H */
diff --git a/ext/openssl/ossl_digest.c b/ext/openssl/ossl_digest.c
index 6294fa2..fc326ec 100644
--- a/ext/openssl/ossl_digest.c
+++ b/ext/openssl/ossl_digest.c
@@ -63,7 +63,7 @@ ossl_evp_get_digestbyname(VALUE obj)
 
         GetDigest(obj, ctx);
 
-        md = EVP_MD_CTX_md(ctx);
+        md = EVP_MD_CTX_get0_md(ctx);
     }
 
     return md;
@@ -176,7 +176,7 @@ ossl_digest_reset(VALUE self)
     EVP_MD_CTX *ctx;
 
     GetDigest(self, ctx);
-    if (EVP_DigestInit_ex(ctx, EVP_MD_CTX_md(ctx), NULL) != 1) {
+    if (EVP_DigestInit_ex(ctx, EVP_MD_CTX_get0_md(ctx), NULL) != 1) {
 	ossl_raise(eDigestError, "Digest initialization failed.");
     }
 
@@ -259,7 +259,7 @@ ossl_digest_name(VALUE self)
 
     GetDigest(self, ctx);
 
-    return rb_str_new2(EVP_MD_name(EVP_MD_CTX_md(ctx)));
+    return rb_str_new_cstr(EVP_MD_name(EVP_MD_CTX_get0_md(ctx)));
 }
 
 /*
@@ -370,15 +370,15 @@ Init_ossl_digest(void)
      *
      * === Hashing a file
      *
-     *   data = File.read('document')
+     *   data = File.binread('document')
      *   sha256 = OpenSSL::Digest.new('SHA256')
      *   digest = sha256.digest(data)
      *
      * === Hashing several pieces of data at once
      *
-     *   data1 = File.read('file1')
-     *   data2 = File.read('file2')
-     *   data3 = File.read('file3')
+     *   data1 = File.binread('file1')
+     *   data2 = File.binread('file2')
+     *   data3 = File.binread('file3')
      *   sha256 = OpenSSL::Digest.new('SHA256')
      *   sha256 << data1
      *   sha256 << data2
@@ -387,11 +387,11 @@ Init_ossl_digest(void)
      *
      * === Reuse a Digest instance
      *
-     *   data1 = File.read('file1')
+     *   data1 = File.binread('file1')
      *   sha256 = OpenSSL::Digest.new('SHA256')
      *   digest1 = sha256.digest(data1)
      *
-     *   data2 = File.read('file2')
+     *   data2 = File.binread('file2')
      *   sha256.reset
      *   digest2 = sha256.digest(data2)
      *
diff --git a/ext/openssl/ossl_engine.c b/ext/openssl/ossl_engine.c
index 9054693..1abde7f 100644
--- a/ext/openssl/ossl_engine.c
+++ b/ext/openssl/ossl_engine.c
@@ -9,7 +9,8 @@
  */
 #include "ossl.h"
 
-#if !defined(OPENSSL_NO_ENGINE)
+#ifdef OSSL_USE_ENGINE
+# include <openssl/engine.h>
 
 #define NewEngine(klass) \
     TypedData_Wrap_Struct((klass), &ossl_engine_type, 0)
@@ -101,48 +102,48 @@ ossl_engine_s_load(int argc, VALUE *argv, VALUE klass)
         return Qtrue;
     }
     StringValueCStr(name);
-#if HAVE_ENGINE_LOAD_DYNAMIC
+#ifdef HAVE_ENGINE_LOAD_DYNAMIC
     OSSL_ENGINE_LOAD_IF_MATCH(dynamic, DYNAMIC);
 #endif
 #ifndef OPENSSL_NO_STATIC_ENGINE
-#if HAVE_ENGINE_LOAD_4758CCA
+#ifdef HAVE_ENGINE_LOAD_4758CCA
     OSSL_ENGINE_LOAD_IF_MATCH(4758cca, 4758CCA);
 #endif
-#if HAVE_ENGINE_LOAD_AEP
+#ifdef HAVE_ENGINE_LOAD_AEP
     OSSL_ENGINE_LOAD_IF_MATCH(aep, AEP);
 #endif
-#if HAVE_ENGINE_LOAD_ATALLA
+#ifdef HAVE_ENGINE_LOAD_ATALLA
     OSSL_ENGINE_LOAD_IF_MATCH(atalla, ATALLA);
 #endif
-#if HAVE_ENGINE_LOAD_CHIL
+#ifdef HAVE_ENGINE_LOAD_CHIL
     OSSL_ENGINE_LOAD_IF_MATCH(chil, CHIL);
 #endif
-#if HAVE_ENGINE_LOAD_CSWIFT
+#ifdef HAVE_ENGINE_LOAD_CSWIFT
     OSSL_ENGINE_LOAD_IF_MATCH(cswift, CSWIFT);
 #endif
-#if HAVE_ENGINE_LOAD_NURON
+#ifdef HAVE_ENGINE_LOAD_NURON
     OSSL_ENGINE_LOAD_IF_MATCH(nuron, NURON);
 #endif
-#if HAVE_ENGINE_LOAD_SUREWARE
+#ifdef HAVE_ENGINE_LOAD_SUREWARE
     OSSL_ENGINE_LOAD_IF_MATCH(sureware, SUREWARE);
 #endif
-#if HAVE_ENGINE_LOAD_UBSEC
+#ifdef HAVE_ENGINE_LOAD_UBSEC
     OSSL_ENGINE_LOAD_IF_MATCH(ubsec, UBSEC);
 #endif
-#if HAVE_ENGINE_LOAD_PADLOCK
+#ifdef HAVE_ENGINE_LOAD_PADLOCK
     OSSL_ENGINE_LOAD_IF_MATCH(padlock, PADLOCK);
 #endif
-#if HAVE_ENGINE_LOAD_CAPI
+#ifdef HAVE_ENGINE_LOAD_CAPI
     OSSL_ENGINE_LOAD_IF_MATCH(capi, CAPI);
 #endif
-#if HAVE_ENGINE_LOAD_GMP
+#ifdef HAVE_ENGINE_LOAD_GMP
     OSSL_ENGINE_LOAD_IF_MATCH(gmp, GMP);
 #endif
-#if HAVE_ENGINE_LOAD_GOST
+#ifdef HAVE_ENGINE_LOAD_GOST
     OSSL_ENGINE_LOAD_IF_MATCH(gost, GOST);
 #endif
 #endif
-#if HAVE_ENGINE_LOAD_CRYPTODEV
+#ifdef HAVE_ENGINE_LOAD_CRYPTODEV
     OSSL_ENGINE_LOAD_IF_MATCH(cryptodev, CRYPTODEV);
 #endif
     OSSL_ENGINE_LOAD_IF_MATCH(openssl, OPENSSL);
diff --git a/ext/openssl/ossl_hmac.c b/ext/openssl/ossl_hmac.c
index e831cff..bfe3a74 100644
--- a/ext/openssl/ossl_hmac.c
+++ b/ext/openssl/ossl_hmac.c
@@ -7,14 +7,12 @@
  * This program is licensed under the same licence as Ruby.
  * (See the file 'LICENCE'.)
  */
-#if !defined(OPENSSL_NO_HMAC)
-
 #include "ossl.h"
 
 #define NewHMAC(klass) \
     TypedData_Wrap_Struct((klass), &ossl_hmac_type, 0)
 #define GetHMAC(obj, ctx) do { \
-    TypedData_Get_Struct((obj), HMAC_CTX, &ossl_hmac_type, (ctx)); \
+    TypedData_Get_Struct((obj), EVP_MD_CTX, &ossl_hmac_type, (ctx)); \
     if (!(ctx)) { \
 	ossl_raise(rb_eRuntimeError, "HMAC wasn't initialized"); \
     } \
@@ -36,7 +34,7 @@ VALUE eHMACError;
 static void
 ossl_hmac_free(void *ctx)
 {
-    HMAC_CTX_free(ctx);
+    EVP_MD_CTX_free(ctx);
 }
 
 static const rb_data_type_t ossl_hmac_type = {
@@ -51,12 +49,12 @@ static VALUE
 ossl_hmac_alloc(VALUE klass)
 {
     VALUE obj;
-    HMAC_CTX *ctx;
+    EVP_MD_CTX *ctx;
 
     obj = NewHMAC(klass);
-    ctx = HMAC_CTX_new();
+    ctx = EVP_MD_CTX_new();
     if (!ctx)
-	ossl_raise(eHMACError, NULL);
+        ossl_raise(eHMACError, "EVP_MD_CTX");
     RTYPEDDATA_DATA(obj) = ctx;
 
     return obj;
@@ -76,8 +74,7 @@ ossl_hmac_alloc(VALUE klass)
  * === Example
  *
  *	key = 'key'
- * 	digest = OpenSSL::Digest.new('sha1')
- * 	instance = OpenSSL::HMAC.new(key, digest)
+ * 	instance = OpenSSL::HMAC.new(key, 'SHA1')
  * 	#=> f42bb0eeb018ebbd4597ae7213711ec60760843f
  * 	instance.class
  * 	#=> OpenSSL::HMAC
@@ -86,7 +83,7 @@ ossl_hmac_alloc(VALUE klass)
  *
  * Two instances can be securely compared with #== in constant time:
  *
- *	other_instance = OpenSSL::HMAC.new('key', OpenSSL::Digest.new('sha1'))
+ *	other_instance = OpenSSL::HMAC.new('key', 'SHA1')
  *  #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
  *  instance == other_instance
  *  #=> true
@@ -95,12 +92,23 @@ ossl_hmac_alloc(VALUE klass)
 static VALUE
 ossl_hmac_initialize(VALUE self, VALUE key, VALUE digest)
 {
-    HMAC_CTX *ctx;
+    EVP_MD_CTX *ctx;
+    EVP_PKEY *pkey;
 
-    StringValue(key);
     GetHMAC(self, ctx);
-    HMAC_Init_ex(ctx, RSTRING_PTR(key), RSTRING_LENINT(key),
-		 ossl_evp_get_digestbyname(digest), NULL);
+    StringValue(key);
+    pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL,
+                                (unsigned char *)RSTRING_PTR(key),
+                                RSTRING_LENINT(key));
+    if (!pkey)
+        ossl_raise(eHMACError, "EVP_PKEY_new_mac_key");
+    if (EVP_DigestSignInit(ctx, NULL, ossl_evp_get_digestbyname(digest),
+                           NULL, pkey) != 1) {
+        EVP_PKEY_free(pkey);
+        ossl_raise(eHMACError, "EVP_DigestSignInit");
+    }
+    /* Decrement reference counter; EVP_MD_CTX still keeps it */
+    EVP_PKEY_free(pkey);
 
     return self;
 }
@@ -108,16 +116,15 @@ ossl_hmac_initialize(VALUE self, VALUE key, VALUE digest)
 static VALUE
 ossl_hmac_copy(VALUE self, VALUE other)
 {
-    HMAC_CTX *ctx1, *ctx2;
+    EVP_MD_CTX *ctx1, *ctx2;
 
     rb_check_frozen(self);
     if (self == other) return self;
 
     GetHMAC(self, ctx1);
     GetHMAC(other, ctx2);
-
-    if (!HMAC_CTX_copy(ctx1, ctx2))
-	ossl_raise(eHMACError, "HMAC_CTX_copy");
+    if (EVP_MD_CTX_copy(ctx1, ctx2) != 1)
+        ossl_raise(eHMACError, "EVP_MD_CTX_copy");
     return self;
 }
 
@@ -142,33 +149,16 @@ ossl_hmac_copy(VALUE self, VALUE other)
 static VALUE
 ossl_hmac_update(VALUE self, VALUE data)
 {
-    HMAC_CTX *ctx;
+    EVP_MD_CTX *ctx;
 
     StringValue(data);
     GetHMAC(self, ctx);
-    HMAC_Update(ctx, (unsigned char *)RSTRING_PTR(data), RSTRING_LEN(data));
+    if (EVP_DigestSignUpdate(ctx, RSTRING_PTR(data), RSTRING_LEN(data)) != 1)
+        ossl_raise(eHMACError, "EVP_DigestSignUpdate");
 
     return self;
 }
 
-static void
-hmac_final(HMAC_CTX *ctx, unsigned char *buf, unsigned int *buf_len)
-{
-    HMAC_CTX *final;
-
-    final = HMAC_CTX_new();
-    if (!final)
-	ossl_raise(eHMACError, "HMAC_CTX_new");
-
-    if (!HMAC_CTX_copy(final, ctx)) {
-	HMAC_CTX_free(final);
-	ossl_raise(eHMACError, "HMAC_CTX_copy");
-    }
-
-    HMAC_Final(final, buf, buf_len);
-    HMAC_CTX_free(final);
-}
-
 /*
  *  call-seq:
  *     hmac.digest -> string
@@ -176,7 +166,7 @@ hmac_final(HMAC_CTX *ctx, unsigned char *buf, unsigned int *buf_len)
  * Returns the authentication code an instance represents as a binary string.
  *
  * === Example
- *  instance = OpenSSL::HMAC.new('key', OpenSSL::Digest.new('sha1'))
+ *  instance = OpenSSL::HMAC.new('key', 'SHA1')
  *  #=> f42bb0eeb018ebbd4597ae7213711ec60760843f
  *  instance.digest
  *  #=> "\xF4+\xB0\xEE\xB0\x18\xEB\xBDE\x97\xAEr\x13q\x1E\xC6\a`\x84?"
@@ -184,15 +174,16 @@ hmac_final(HMAC_CTX *ctx, unsigned char *buf, unsigned int *buf_len)
 static VALUE
 ossl_hmac_digest(VALUE self)
 {
-    HMAC_CTX *ctx;
-    unsigned int buf_len;
+    EVP_MD_CTX *ctx;
+    size_t buf_len = EVP_MAX_MD_SIZE;
     VALUE ret;
 
     GetHMAC(self, ctx);
     ret = rb_str_new(NULL, EVP_MAX_MD_SIZE);
-    hmac_final(ctx, (unsigned char *)RSTRING_PTR(ret), &buf_len);
-    assert(buf_len <= EVP_MAX_MD_SIZE);
-    rb_str_set_len(ret, buf_len);
+    if (EVP_DigestSignFinal(ctx, (unsigned char *)RSTRING_PTR(ret),
+                            &buf_len) != 1)
+        ossl_raise(eHMACError, "EVP_DigestSignFinal");
+    rb_str_set_len(ret, (long)buf_len);
 
     return ret;
 }
@@ -207,13 +198,14 @@ ossl_hmac_digest(VALUE self)
 static VALUE
 ossl_hmac_hexdigest(VALUE self)
 {
-    HMAC_CTX *ctx;
+    EVP_MD_CTX *ctx;
     unsigned char buf[EVP_MAX_MD_SIZE];
-    unsigned int buf_len;
+    size_t buf_len = EVP_MAX_MD_SIZE;
     VALUE ret;
 
     GetHMAC(self, ctx);
-    hmac_final(ctx, buf, &buf_len);
+    if (EVP_DigestSignFinal(ctx, buf, &buf_len) != 1)
+        ossl_raise(eHMACError, "EVP_DigestSignFinal");
     ret = rb_str_new(NULL, buf_len * 2);
     ossl_bin2hex(buf, RSTRING_PTR(ret), buf_len);
 
@@ -230,7 +222,7 @@ ossl_hmac_hexdigest(VALUE self)
  * === Example
  *
  *	data = "The quick brown fox jumps over the lazy dog"
- * 	instance = OpenSSL::HMAC.new('key', OpenSSL::Digest.new('sha1'))
+ * 	instance = OpenSSL::HMAC.new('key', 'SHA1')
  * 	#=> f42bb0eeb018ebbd4597ae7213711ec60760843f
  *
  * 	instance.update(data)
@@ -242,84 +234,17 @@ ossl_hmac_hexdigest(VALUE self)
 static VALUE
 ossl_hmac_reset(VALUE self)
 {
-    HMAC_CTX *ctx;
+    EVP_MD_CTX *ctx;
+    EVP_PKEY *pkey;
 
     GetHMAC(self, ctx);
-    HMAC_Init_ex(ctx, NULL, 0, NULL, NULL);
+    pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_get_pkey_ctx(ctx));
+    if (EVP_DigestSignInit(ctx, NULL, EVP_MD_CTX_get0_md(ctx), NULL, pkey) != 1)
+        ossl_raise(eHMACError, "EVP_DigestSignInit");
 
     return self;
 }
 
-/*
- *  call-seq:
- *     HMAC.digest(digest, key, data) -> aString
- *
- * Returns the authentication code as a binary string. The _digest_ parameter
- * specifies the digest algorithm to use. This may be a String representing
- * the algorithm name or an instance of OpenSSL::Digest.
- *
- * === Example
- *
- *	key = 'key'
- * 	data = 'The quick brown fox jumps over the lazy dog'
- *
- * 	hmac = OpenSSL::HMAC.digest('sha1', key, data)
- * 	#=> "\xDE|\x9B\x85\xB8\xB7\x8A\xA6\xBC\x8Az6\xF7\n\x90p\x1C\x9D\xB4\xD9"
- *
- */
-static VALUE
-ossl_hmac_s_digest(VALUE klass, VALUE digest, VALUE key, VALUE data)
-{
-    unsigned char *buf;
-    unsigned int buf_len;
-
-    StringValue(key);
-    StringValue(data);
-    buf = HMAC(ossl_evp_get_digestbyname(digest), RSTRING_PTR(key),
-	       RSTRING_LENINT(key), (unsigned char *)RSTRING_PTR(data),
-	       RSTRING_LEN(data), NULL, &buf_len);
-
-    return rb_str_new((const char *)buf, buf_len);
-}
-
-/*
- *  call-seq:
- *     HMAC.hexdigest(digest, key, data) -> aString
- *
- * Returns the authentication code as a hex-encoded string. The _digest_
- * parameter specifies the digest algorithm to use. This may be a String
- * representing the algorithm name or an instance of OpenSSL::Digest.
- *
- * === Example
- *
- *	key = 'key'
- * 	data = 'The quick brown fox jumps over the lazy dog'
- *
- * 	hmac = OpenSSL::HMAC.hexdigest('sha1', key, data)
- * 	#=> "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9"
- *
- */
-static VALUE
-ossl_hmac_s_hexdigest(VALUE klass, VALUE digest, VALUE key, VALUE data)
-{
-    unsigned char buf[EVP_MAX_MD_SIZE];
-    unsigned int buf_len;
-    VALUE ret;
-
-    StringValue(key);
-    StringValue(data);
-
-    if (!HMAC(ossl_evp_get_digestbyname(digest), RSTRING_PTR(key),
-	      RSTRING_LENINT(key), (unsigned char *)RSTRING_PTR(data),
-	      RSTRING_LEN(data), buf, &buf_len))
-	ossl_raise(eHMACError, "HMAC");
-
-    ret = rb_str_new(NULL, buf_len * 2);
-    ossl_bin2hex(buf, RSTRING_PTR(ret), buf_len);
-
-    return ret;
-}
-
 /*
  * INIT
  */
@@ -350,11 +275,10 @@ Init_ossl_hmac(void)
      *
      * === HMAC-SHA256 using incremental interface
      *
-     *   data1 = File.read("file1")
-     *   data2 = File.read("file2")
+     *   data1 = File.binread("file1")
+     *   data2 = File.binread("file2")
      *   key = "key"
-     *   digest = OpenSSL::Digest.new('SHA256')
-     *   hmac = OpenSSL::HMAC.new(key, digest)
+     *   hmac = OpenSSL::HMAC.new(key, 'SHA256')
      *   hmac << data1
      *   hmac << data2
      *   mac = hmac.digest
@@ -364,8 +288,6 @@ Init_ossl_hmac(void)
     cHMAC = rb_define_class_under(mOSSL, "HMAC", rb_cObject);
 
     rb_define_alloc_func(cHMAC, ossl_hmac_alloc);
-    rb_define_singleton_method(cHMAC, "digest", ossl_hmac_s_digest, 3);
-    rb_define_singleton_method(cHMAC, "hexdigest", ossl_hmac_s_hexdigest, 3);
 
     rb_define_method(cHMAC, "initialize", ossl_hmac_initialize, 2);
     rb_define_method(cHMAC, "initialize_copy", ossl_hmac_copy, 1);
@@ -378,12 +300,3 @@ Init_ossl_hmac(void)
     rb_define_alias(cHMAC, "inspect", "hexdigest");
     rb_define_alias(cHMAC, "to_s", "hexdigest");
 }
-
-#else /* NO_HMAC */
-#  warning >>> OpenSSL is compiled without HMAC support <<<
-void
-Init_ossl_hmac(void)
-{
-    rb_warning("HMAC is not available: OpenSSL is compiled without HMAC.");
-}
-#endif /* NO_HMAC */
diff --git a/ext/openssl/ossl_kdf.c b/ext/openssl/ossl_kdf.c
index 486e789..7fa38b8 100644
--- a/ext/openssl/ossl_kdf.c
+++ b/ext/openssl/ossl_kdf.c
@@ -163,6 +163,14 @@ kdf_scrypt(int argc, VALUE *argv, VALUE self)
  *   HashLen is the length of the hash function output in octets.
  * _hash_::
  *   The hash function.
+ *
+ * === Example
+ *   # The values from https://datatracker.ietf.org/doc/html/rfc5869#appendix-A.1
+ *   ikm = ["0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"].pack("H*")
+ *   salt = ["000102030405060708090a0b0c"].pack("H*")
+ *   info = ["f0f1f2f3f4f5f6f7f8f9"].pack("H*")
+ *   p OpenSSL::KDF.hkdf(ikm, salt: salt, info: info, length: 42, hash: "SHA256").unpack1("H*")
+ *   # => "3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865"
  */
 static VALUE
 kdf_hkdf(int argc, VALUE *argv, VALUE self)
diff --git a/ext/openssl/ossl_ocsp.c b/ext/openssl/ossl_ocsp.c
index 7a92e5d..1e87484 100644
--- a/ext/openssl/ossl_ocsp.c
+++ b/ext/openssl/ossl_ocsp.c
@@ -157,7 +157,7 @@ ossl_ocspcertid_new(OCSP_CERTID *cid)
 }
 
 /*
- * OCSP::Resquest
+ * OCSP::Request
  */
 static VALUE
 ossl_ocspreq_alloc(VALUE klass)
@@ -803,7 +803,7 @@ add_status_convert_time(VALUE obj)
  * revocation, and must be one of OpenSSL::OCSP::REVOKED_STATUS_* constants.
  * _revocation_time_ is the time when the certificate is revoked.
  *
- * _this_update_ and _next_update_ indicate the time at which ths status is
+ * _this_update_ and _next_update_ indicate the time at which the status is
  * verified to be correct and the time at or before which newer information
  * will be available, respectively. _next_update_ is optional.
  *
@@ -1069,55 +1069,7 @@ ossl_ocspbres_verify(int argc, VALUE *argv, VALUE self)
     x509st = GetX509StorePtr(store);
     flg = NIL_P(flags) ? 0 : NUM2INT(flags);
     x509s = ossl_x509_ary2sk(certs);
-#if (OPENSSL_VERSION_NUMBER < 0x1000202fL) || defined(LIBRESSL_VERSION_NUMBER)
-    /*
-     * OpenSSL had a bug that it doesn't use the certificates in x509s for
-     * verifying the chain. This can be a problem when the response is signed by
-     * a certificate issued by an intermediate CA.
-     *
-     *       root_ca
-     *         |
-     *   intermediate_ca
-     *         |-------------|
-     *     end_entity    ocsp_signer
-     *
-     * When the certificate hierarchy is like this, and the response contains
-     * only ocsp_signer certificate, the following code wrongly fails.
-     *
-     *   store = OpenSSL::X509::Store.new; store.add_cert(root_ca)
-     *   basic_response.verify([intermediate_ca], store)
-     *
-     * So add the certificates in x509s to the embedded certificates list first.
-     *
-     * This is fixed in OpenSSL 0.9.8zg, 1.0.0s, 1.0.1n, 1.0.2b. But it still
-     * exists in LibreSSL 2.1.10, 2.2.9, 2.3.6, 2.4.1.
-     */
-    if (!(flg & (OCSP_NOCHAIN | OCSP_NOVERIFY)) &&
-	sk_X509_num(x509s) && sk_X509_num(bs->certs)) {
-	int i;
-
-	bs = ASN1_item_dup(ASN1_ITEM_rptr(OCSP_BASICRESP), bs);
-	if (!bs) {
-	    sk_X509_pop_free(x509s, X509_free);
-	    ossl_raise(eOCSPError, "ASN1_item_dup");
-	}
-
-	for (i = 0; i < sk_X509_num(x509s); i++) {
-	    if (!OCSP_basic_add1_cert(bs, sk_X509_value(x509s, i))) {
-		sk_X509_pop_free(x509s, X509_free);
-		OCSP_BASICRESP_free(bs);
-		ossl_raise(eOCSPError, "OCSP_basic_add1_cert");
-	    }
-	}
-	result = OCSP_basic_verify(bs, x509s, x509st, flg);
-	OCSP_BASICRESP_free(bs);
-    }
-    else {
-	result = OCSP_basic_verify(bs, x509s, x509st, flg);
-    }
-#else
     result = OCSP_basic_verify(bs, x509s, x509st, flg);
-#endif
     sk_X509_pop_free(x509s, X509_free);
     if (result <= 0)
 	ossl_clear_error();
@@ -1787,7 +1739,7 @@ Init_ossl_ocsp(void)
      *   single_response = basic_response.find_response(certificate_id)
      *
      *   unless single_response
-     *     raise 'basic_response does not have the status for the certificiate'
+     *     raise 'basic_response does not have the status for the certificate'
      *   end
      *
      * Then check the validity. A status issued in the future must be rejected.
diff --git a/ext/openssl/ossl_pkcs12.c b/ext/openssl/ossl_pkcs12.c
index 4566334..fb947df 100644
--- a/ext/openssl/ossl_pkcs12.c
+++ b/ext/openssl/ossl_pkcs12.c
@@ -149,6 +149,24 @@ ossl_pkcs12_s_create(int argc, VALUE *argv, VALUE self)
     return obj;
 }
 
+static VALUE
+ossl_pkey_new_i(VALUE arg)
+{
+    return ossl_pkey_new((EVP_PKEY *)arg);
+}
+
+static VALUE
+ossl_x509_new_i(VALUE arg)
+{
+    return ossl_x509_new((X509 *)arg);
+}
+
+static VALUE
+ossl_x509_sk2ary_i(VALUE arg)
+{
+    return ossl_x509_sk2ary((STACK_OF(X509) *)arg);
+}
+
 /*
  * call-seq:
  *    PKCS12.new -> pkcs12
@@ -186,15 +204,15 @@ ossl_pkcs12_initialize(int argc, VALUE *argv, VALUE self)
 	ossl_raise(ePKCS12Error, "PKCS12_parse");
     ERR_pop_to_mark();
     if (key) {
-	pkey = rb_protect((VALUE (*)(VALUE))ossl_pkey_new, (VALUE)key, &st);
+	pkey = rb_protect(ossl_pkey_new_i, (VALUE)key, &st);
 	if (st) goto err;
     }
     if (x509) {
-	cert = rb_protect((VALUE (*)(VALUE))ossl_x509_new, (VALUE)x509, &st);
+	cert = rb_protect(ossl_x509_new_i, (VALUE)x509, &st);
 	if (st) goto err;
     }
     if (x509s) {
-	ca = rb_protect((VALUE (*)(VALUE))ossl_x509_sk2ary, (VALUE)x509s, &st);
+	ca = rb_protect(ossl_x509_sk2ary_i, (VALUE)x509s, &st);
 	if (st) goto err;
     }
 
diff --git a/ext/openssl/ossl_pkcs7.c b/ext/openssl/ossl_pkcs7.c
index ea8e92d..dbe5347 100644
--- a/ext/openssl/ossl_pkcs7.c
+++ b/ext/openssl/ossl_pkcs7.c
@@ -101,19 +101,24 @@ static const rb_data_type_t ossl_pkcs7_recip_info_type = {
  * (MADE PRIVATE UNTIL SOMEBODY WILL NEED THEM)
  */
 static PKCS7_SIGNER_INFO *
-ossl_PKCS7_SIGNER_INFO_dup(const PKCS7_SIGNER_INFO *si)
+ossl_PKCS7_SIGNER_INFO_dup(PKCS7_SIGNER_INFO *si)
 {
-    return (PKCS7_SIGNER_INFO *)ASN1_dup((i2d_of_void *)i2d_PKCS7_SIGNER_INFO,
-					 (d2i_of_void *)d2i_PKCS7_SIGNER_INFO,
-					 (char *)si);
+    PKCS7_SIGNER_INFO *si_new = ASN1_dup((i2d_of_void *)i2d_PKCS7_SIGNER_INFO,
+                                         (d2i_of_void *)d2i_PKCS7_SIGNER_INFO,
+                                         si);
+    if (si_new && si->pkey) {
+        EVP_PKEY_up_ref(si->pkey);
+        si_new->pkey = si->pkey;
+    }
+    return si_new;
 }
 
 static PKCS7_RECIP_INFO *
-ossl_PKCS7_RECIP_INFO_dup(const PKCS7_RECIP_INFO *si)
+ossl_PKCS7_RECIP_INFO_dup(PKCS7_RECIP_INFO *si)
 {
-    return (PKCS7_RECIP_INFO *)ASN1_dup((i2d_of_void *)i2d_PKCS7_RECIP_INFO,
-					(d2i_of_void *)d2i_PKCS7_RECIP_INFO,
-					(char *)si);
+    return ASN1_dup((i2d_of_void *)i2d_PKCS7_RECIP_INFO,
+                    (d2i_of_void *)d2i_PKCS7_RECIP_INFO,
+                    si);
 }
 
 static VALUE
@@ -130,19 +135,6 @@ ossl_pkcs7si_new(PKCS7_SIGNER_INFO *p7si)
     return obj;
 }
 
-static PKCS7_SIGNER_INFO *
-DupPKCS7SignerPtr(VALUE obj)
-{
-    PKCS7_SIGNER_INFO *p7si, *pkcs7;
-
-    GetPKCS7si(obj, p7si);
-    if (!(pkcs7 = ossl_PKCS7_SIGNER_INFO_dup(p7si))) {
-	ossl_raise(ePKCS7Error, NULL);
-    }
-
-    return pkcs7;
-}
-
 static VALUE
 ossl_pkcs7ri_new(PKCS7_RECIP_INFO *p7ri)
 {
@@ -157,19 +149,6 @@ ossl_pkcs7ri_new(PKCS7_RECIP_INFO *p7ri)
     return obj;
 }
 
-static PKCS7_RECIP_INFO *
-DupPKCS7RecipientPtr(VALUE obj)
-{
-    PKCS7_RECIP_INFO *p7ri, *pkcs7;
-
-    GetPKCS7ri(obj, p7ri);
-    if (!(pkcs7 = ossl_PKCS7_RECIP_INFO_dup(p7ri))) {
-	ossl_raise(ePKCS7Error, NULL);
-    }
-
-    return pkcs7;
-}
-
 /*
  * call-seq:
  *    PKCS7.read_smime(string) => pkcs7
@@ -351,7 +330,7 @@ ossl_pkcs7_alloc(VALUE klass)
 static VALUE
 ossl_pkcs7_initialize(int argc, VALUE *argv, VALUE self)
 {
-    PKCS7 *p7, *pkcs = DATA_PTR(self);
+    PKCS7 *p7, *p7_orig = RTYPEDDATA_DATA(self);
     BIO *in;
     VALUE arg;
 
@@ -359,19 +338,17 @@ ossl_pkcs7_initialize(int argc, VALUE *argv, VALUE self)
 	return self;
     arg = ossl_to_der_if_possible(arg);
     in = ossl_obj2bio(&arg);
-    p7 = PEM_read_bio_PKCS7(in, &pkcs, NULL, NULL);
+    p7 = d2i_PKCS7_bio(in, NULL);
     if (!p7) {
-	OSSL_BIO_reset(in);
-        p7 = d2i_PKCS7_bio(in, &pkcs);
-	if (!p7) {
-	    BIO_free(in);
-	    PKCS7_free(pkcs);
-	    DATA_PTR(self) = NULL;
-	    ossl_raise(rb_eArgError, "Could not parse the PKCS7");
-	}
+        OSSL_BIO_reset(in);
+        p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);
     }
-    DATA_PTR(self) = pkcs;
     BIO_free(in);
+    if (!p7)
+        ossl_raise(rb_eArgError, "Could not parse the PKCS7");
+
+    RTYPEDDATA_DATA(self) = p7;
+    PKCS7_free(p7_orig);
     ossl_pkcs7_set_data(self, Qnil);
     ossl_pkcs7_set_err_string(self, Qnil);
 
@@ -521,17 +498,18 @@ static VALUE
 ossl_pkcs7_add_signer(VALUE self, VALUE signer)
 {
     PKCS7 *pkcs7;
-    PKCS7_SIGNER_INFO *p7si;
+    PKCS7_SIGNER_INFO *si, *si_new;
 
-    p7si = DupPKCS7SignerPtr(signer); /* NEED TO DUP */
     GetPKCS7(self, pkcs7);
-    if (!PKCS7_add_signer(pkcs7, p7si)) {
-	PKCS7_SIGNER_INFO_free(p7si);
-	ossl_raise(ePKCS7Error, "Could not add signer.");
-    }
-    if (PKCS7_type_is_signed(pkcs7)){
-	PKCS7_add_signed_attribute(p7si, NID_pkcs9_contentType,
-				   V_ASN1_OBJECT, OBJ_nid2obj(NID_pkcs7_data));
+    GetPKCS7si(signer, si);
+
+    si_new = ossl_PKCS7_SIGNER_INFO_dup(si);
+    if (!si_new)
+        ossl_raise(ePKCS7Error, "PKCS7_SIGNER_INFO_dup");
+
+    if (PKCS7_add_signer(pkcs7, si_new) != 1) {
+        PKCS7_SIGNER_INFO_free(si_new);
+        ossl_raise(ePKCS7Error, "PKCS7_add_signer");
     }
 
     return self;
@@ -567,13 +545,18 @@ static VALUE
 ossl_pkcs7_add_recipient(VALUE self, VALUE recip)
 {
     PKCS7 *pkcs7;
-    PKCS7_RECIP_INFO *ri;
+    PKCS7_RECIP_INFO *ri, *ri_new;
 
-    ri = DupPKCS7RecipientPtr(recip); /* NEED TO DUP */
     GetPKCS7(self, pkcs7);
-    if (!PKCS7_add_recipient_info(pkcs7, ri)) {
-	PKCS7_RECIP_INFO_free(ri);
-	ossl_raise(ePKCS7Error, "Could not add recipient.");
+    GetPKCS7ri(recip, ri);
+
+    ri_new = ossl_PKCS7_RECIP_INFO_dup(ri);
+    if (!ri_new)
+        ossl_raise(ePKCS7Error, "PKCS7_RECIP_INFO_dup");
+
+    if (PKCS7_add_recipient_info(pkcs7, ri_new) != 1) {
+        PKCS7_RECIP_INFO_free(ri_new);
+        ossl_raise(ePKCS7Error, "PKCS7_add_recipient_info");
     }
 
     return self;
diff --git a/ext/openssl/ossl_pkey.c b/ext/openssl/ossl_pkey.c
index 2320408..2a4835a 100644
--- a/ext/openssl/ossl_pkey.c
+++ b/ext/openssl/ossl_pkey.c
@@ -9,6 +9,10 @@
  */
 #include "ossl.h"
 
+#ifdef OSSL_USE_ENGINE
+# include <openssl/engine.h>
+#endif
+
 /*
  * Classes
  */
@@ -17,64 +21,6 @@ VALUE cPKey;
 VALUE ePKeyError;
 static ID id_private_q;
 
-/*
- * callback for generating keys
- */
-static VALUE
-call_check_ints0(VALUE arg)
-{
-    rb_thread_check_ints();
-    return Qnil;
-}
-
-static void *
-call_check_ints(void *arg)
-{
-    int state;
-    rb_protect(call_check_ints0, Qnil, &state);
-    return (void *)(VALUE)state;
-}
-
-int
-ossl_generate_cb_2(int p, int n, BN_GENCB *cb)
-{
-    VALUE ary;
-    struct ossl_generate_cb_arg *arg;
-    int state;
-
-    arg = (struct ossl_generate_cb_arg *)BN_GENCB_get_arg(cb);
-    if (arg->yield) {
-	ary = rb_ary_new2(2);
-	rb_ary_store(ary, 0, INT2NUM(p));
-	rb_ary_store(ary, 1, INT2NUM(n));
-
-	/*
-	* can be break by raising exception or 'break'
-	*/
-	rb_protect(rb_yield, ary, &state);
-	if (state) {
-	    arg->state = state;
-	    return 0;
-	}
-    }
-    if (arg->interrupted) {
-	arg->interrupted = 0;
-	state = (int)(VALUE)rb_thread_call_with_gvl(call_check_ints, NULL);
-	if (state) {
-	    arg->state = state;
-	    return 0;
-	}
-    }
-    return 1;
-}
-
-void
-ossl_generate_cb_stop(void *ptr)
-{
-    struct ossl_generate_cb_arg *arg = (struct ossl_generate_cb_arg *)ptr;
-    arg->interrupted = 1;
-}
-
 static void
 ossl_evp_pkey_free(void *ptr)
 {
@@ -93,36 +39,29 @@ const rb_data_type_t ossl_evp_pkey_type = {
 };
 
 static VALUE
-pkey_new0(EVP_PKEY *pkey)
+pkey_new0(VALUE arg)
 {
-    VALUE obj;
-    int type;
-
-    if (!pkey || (type = EVP_PKEY_base_id(pkey)) == EVP_PKEY_NONE)
-	ossl_raise(rb_eRuntimeError, "pkey is empty");
+    EVP_PKEY *pkey = (EVP_PKEY *)arg;
+    VALUE klass, obj;
 
-    switch (type) {
+    switch (EVP_PKEY_base_id(pkey)) {
 #if !defined(OPENSSL_NO_RSA)
-    case EVP_PKEY_RSA:
-	return ossl_rsa_new(pkey);
+      case EVP_PKEY_RSA: klass = cRSA; break;
 #endif
 #if !defined(OPENSSL_NO_DSA)
-    case EVP_PKEY_DSA:
-	return ossl_dsa_new(pkey);
+      case EVP_PKEY_DSA: klass = cDSA; break;
 #endif
 #if !defined(OPENSSL_NO_DH)
-    case EVP_PKEY_DH:
-	return ossl_dh_new(pkey);
+      case EVP_PKEY_DH:  klass = cDH; break;
 #endif
 #if !defined(OPENSSL_NO_EC)
-    case EVP_PKEY_EC:
-	return ossl_ec_new(pkey);
+      case EVP_PKEY_EC:  klass = cEC; break;
 #endif
-    default:
-	obj = NewPKey(cPKey);
-	SetPKey(obj, pkey);
-	return obj;
+      default:           klass = cPKey; break;
     }
+    obj = rb_obj_alloc(klass);
+    RTYPEDDATA_DATA(obj) = pkey;
+    return obj;
 }
 
 VALUE
@@ -131,7 +70,7 @@ ossl_pkey_new(EVP_PKEY *pkey)
     VALUE obj;
     int status;
 
-    obj = rb_protect((VALUE (*)(VALUE))pkey_new0, (VALUE)pkey, &status);
+    obj = rb_protect(pkey_new0, (VALUE)pkey, &status);
     if (status) {
 	EVP_PKEY_free(pkey);
 	rb_jump_tag(status);
@@ -140,6 +79,75 @@ ossl_pkey_new(EVP_PKEY *pkey)
     return obj;
 }
 
+#if OSSL_OPENSSL_PREREQ(3, 0, 0)
+# include <openssl/decoder.h>
+
+EVP_PKEY *
+ossl_pkey_read_generic(BIO *bio, VALUE pass)
+{
+    void *ppass = (void *)pass;
+    OSSL_DECODER_CTX *dctx;
+    EVP_PKEY *pkey = NULL;
+    int pos = 0, pos2;
+
+    dctx = OSSL_DECODER_CTX_new_for_pkey(&pkey, "DER", NULL, NULL, 0, NULL, NULL);
+    if (!dctx)
+        goto out;
+    if (OSSL_DECODER_CTX_set_pem_password_cb(dctx, ossl_pem_passwd_cb, ppass) != 1)
+        goto out;
+
+    /* First check DER */
+    if (OSSL_DECODER_from_bio(dctx, bio) == 1)
+        goto out;
+
+    /* Then check PEM; multiple OSSL_DECODER_from_bio() calls may be needed */
+    OSSL_BIO_reset(bio);
+    if (OSSL_DECODER_CTX_set_input_type(dctx, "PEM") != 1)
+        goto out;
+    while (OSSL_DECODER_from_bio(dctx, bio) != 1) {
+        if (BIO_eof(bio))
+            goto out;
+        pos2 = BIO_tell(bio);
+        if (pos2 < 0 || pos2 <= pos)
+            goto out;
+        pos = pos2;
+    }
+
+  out:
+    OSSL_DECODER_CTX_free(dctx);
+    return pkey;
+}
+#else
+EVP_PKEY *
+ossl_pkey_read_generic(BIO *bio, VALUE pass)
+{
+    void *ppass = (void *)pass;
+    EVP_PKEY *pkey;
+
+    if ((pkey = d2i_PrivateKey_bio(bio, NULL)))
+	goto out;
+    OSSL_BIO_reset(bio);
+    if ((pkey = d2i_PKCS8PrivateKey_bio(bio, NULL, ossl_pem_passwd_cb, ppass)))
+	goto out;
+    OSSL_BIO_reset(bio);
+    if ((pkey = d2i_PUBKEY_bio(bio, NULL)))
+	goto out;
+    OSSL_BIO_reset(bio);
+    /* PEM_read_bio_PrivateKey() also parses PKCS #8 formats */
+    if ((pkey = PEM_read_bio_PrivateKey(bio, NULL, ossl_pem_passwd_cb, ppass)))
+	goto out;
+    OSSL_BIO_reset(bio);
+    if ((pkey = PEM_read_bio_PUBKEY(bio, NULL, NULL, NULL)))
+	goto out;
+    OSSL_BIO_reset(bio);
+    if ((pkey = PEM_read_bio_Parameters(bio, NULL)))
+	goto out;
+
+  out:
+    return pkey;
+}
+#endif
+
 /*
  *  call-seq:
  *     OpenSSL::PKey.read(string [, pwd ]) -> PKey
@@ -149,7 +157,7 @@ ossl_pkey_new(EVP_PKEY *pkey)
  * instance of the appropriate PKey class.
  *
  * === Parameters
- * * _string+ is a DER- or PEM-encoded string containing an arbitrary private
+ * * _string_ is a DER- or PEM-encoded string containing an arbitrary private
  *   or public key.
  * * _io_ is an instance of IO containing a DER- or PEM-encoded
  *   arbitrary private or public key.
@@ -164,36 +172,282 @@ ossl_pkey_new_from_data(int argc, VALUE *argv, VALUE self)
     VALUE data, pass;
 
     rb_scan_args(argc, argv, "11", &data, &pass);
-    pass = ossl_pem_passwd_value(pass);
-
     bio = ossl_obj2bio(&data);
-    if ((pkey = d2i_PrivateKey_bio(bio, NULL)))
-	goto ok;
-    OSSL_BIO_reset(bio);
-    if ((pkey = d2i_PKCS8PrivateKey_bio(bio, NULL, ossl_pem_passwd_cb, (void *)pass)))
-	goto ok;
-    OSSL_BIO_reset(bio);
-    if ((pkey = d2i_PUBKEY_bio(bio, NULL)))
-	goto ok;
-    OSSL_BIO_reset(bio);
-    /* PEM_read_bio_PrivateKey() also parses PKCS #8 formats */
-    if ((pkey = PEM_read_bio_PrivateKey(bio, NULL, ossl_pem_passwd_cb, (void *)pass)))
-	goto ok;
-    OSSL_BIO_reset(bio);
-    if ((pkey = PEM_read_bio_PUBKEY(bio, NULL, NULL, NULL)))
-	goto ok;
-
-    BIO_free(bio);
-    ossl_raise(ePKeyError, "Could not parse PKey");
-
-ok:
+    pkey = ossl_pkey_read_generic(bio, ossl_pem_passwd_value(pass));
     BIO_free(bio);
+    if (!pkey)
+	ossl_raise(ePKeyError, "Could not parse PKey");
     return ossl_pkey_new(pkey);
 }
 
+static VALUE
+pkey_ctx_apply_options_i(RB_BLOCK_CALL_FUNC_ARGLIST(i, ctx_v))
+{
+    VALUE key = rb_ary_entry(i, 0), value = rb_ary_entry(i, 1);
+    EVP_PKEY_CTX *ctx = (EVP_PKEY_CTX *)ctx_v;
+
+    if (SYMBOL_P(key))
+        key = rb_sym2str(key);
+    value = rb_String(value);
+
+    if (EVP_PKEY_CTX_ctrl_str(ctx, StringValueCStr(key), StringValueCStr(value)) <= 0)
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_ctrl_str(ctx, %+"PRIsVALUE", %+"PRIsVALUE")",
+                   key, value);
+    return Qnil;
+}
+
+static VALUE
+pkey_ctx_apply_options0(VALUE args_v)
+{
+    VALUE *args = (VALUE *)args_v;
+
+    rb_block_call(args[1], rb_intern("each"), 0, NULL,
+                  pkey_ctx_apply_options_i, args[0]);
+    return Qnil;
+}
+
+static void
+pkey_ctx_apply_options(EVP_PKEY_CTX *ctx, VALUE options, int *state)
+{
+    VALUE args[2];
+    args[0] = (VALUE)ctx;
+    args[1] = options;
+
+    rb_protect(pkey_ctx_apply_options0, (VALUE)args, state);
+}
+
+struct pkey_blocking_generate_arg {
+    EVP_PKEY_CTX *ctx;
+    EVP_PKEY *pkey;
+    int state;
+    int yield: 1;
+    int genparam: 1;
+    int interrupted: 1;
+};
+
+static VALUE
+pkey_gen_cb_yield(VALUE ctx_v)
+{
+    EVP_PKEY_CTX *ctx = (void *)ctx_v;
+    int i, info_num;
+    VALUE *argv;
+
+    info_num = EVP_PKEY_CTX_get_keygen_info(ctx, -1);
+    argv = ALLOCA_N(VALUE, info_num);
+    for (i = 0; i < info_num; i++)
+        argv[i] = INT2NUM(EVP_PKEY_CTX_get_keygen_info(ctx, i));
+
+    return rb_yield_values2(info_num, argv);
+}
+
+static VALUE
+call_check_ints0(VALUE arg)
+{
+    rb_thread_check_ints();
+    return Qnil;
+}
+
+static void *
+call_check_ints(void *arg)
+{
+    int state;
+    rb_protect(call_check_ints0, Qnil, &state);
+    return (void *)(VALUE)state;
+}
+
+static int
+pkey_gen_cb(EVP_PKEY_CTX *ctx)
+{
+    struct pkey_blocking_generate_arg *arg = EVP_PKEY_CTX_get_app_data(ctx);
+    int state;
+
+    if (arg->yield) {
+        rb_protect(pkey_gen_cb_yield, (VALUE)ctx, &state);
+        if (state) {
+            arg->state = state;
+            return 0;
+        }
+    }
+    if (arg->interrupted) {
+        arg->interrupted = 0;
+        state = (int)(VALUE)rb_thread_call_with_gvl(call_check_ints, NULL);
+        if (state) {
+            arg->state = state;
+            return 0;
+        }
+    }
+    return 1;
+}
+
+static void
+pkey_blocking_gen_stop(void *ptr)
+{
+    struct pkey_blocking_generate_arg *arg = ptr;
+    arg->interrupted = 1;
+}
+
+static void *
+pkey_blocking_gen(void *ptr)
+{
+    struct pkey_blocking_generate_arg *arg = ptr;
+
+    if (arg->genparam && EVP_PKEY_paramgen(arg->ctx, &arg->pkey) <= 0)
+        return NULL;
+    if (!arg->genparam && EVP_PKEY_keygen(arg->ctx, &arg->pkey) <= 0)
+        return NULL;
+    return arg->pkey;
+}
+
+static VALUE
+pkey_generate(int argc, VALUE *argv, VALUE self, int genparam)
+{
+    EVP_PKEY_CTX *ctx;
+    VALUE alg, options;
+    struct pkey_blocking_generate_arg gen_arg = { 0 };
+    int state;
+
+    rb_scan_args(argc, argv, "11", &alg, &options);
+    if (rb_obj_is_kind_of(alg, cPKey)) {
+        EVP_PKEY *base_pkey;
+
+        GetPKey(alg, base_pkey);
+        ctx = EVP_PKEY_CTX_new(base_pkey, NULL/* engine */);
+        if (!ctx)
+            ossl_raise(ePKeyError, "EVP_PKEY_CTX_new");
+    }
+    else {
+#if OSSL_OPENSSL_PREREQ(3, 0, 0)
+        ctx = EVP_PKEY_CTX_new_from_name(NULL, StringValueCStr(alg), NULL);
+        if (!ctx)
+            ossl_raise(ePKeyError, "EVP_PKEY_CTX_new_from_name");
+#else
+        const EVP_PKEY_ASN1_METHOD *ameth;
+        ENGINE *tmpeng;
+        int pkey_id;
+
+        StringValue(alg);
+        ameth = EVP_PKEY_asn1_find_str(&tmpeng, RSTRING_PTR(alg),
+                                       RSTRING_LENINT(alg));
+        if (!ameth)
+            ossl_raise(ePKeyError, "algorithm %"PRIsVALUE" not found", alg);
+        EVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL, ameth);
+#if !defined(OPENSSL_NO_ENGINE)
+        if (tmpeng)
+            ENGINE_finish(tmpeng);
+#endif
+
+        ctx = EVP_PKEY_CTX_new_id(pkey_id, NULL/* engine */);
+        if (!ctx)
+            ossl_raise(ePKeyError, "EVP_PKEY_CTX_new_id");
+#endif
+    }
+
+    if (genparam && EVP_PKEY_paramgen_init(ctx) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_paramgen_init");
+    }
+    if (!genparam && EVP_PKEY_keygen_init(ctx) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_keygen_init");
+    }
+
+    if (!NIL_P(options)) {
+        pkey_ctx_apply_options(ctx, options, &state);
+        if (state) {
+            EVP_PKEY_CTX_free(ctx);
+            rb_jump_tag(state);
+        }
+    }
+
+    gen_arg.genparam = genparam;
+    gen_arg.ctx = ctx;
+    gen_arg.yield = rb_block_given_p();
+    EVP_PKEY_CTX_set_app_data(ctx, &gen_arg);
+    EVP_PKEY_CTX_set_cb(ctx, pkey_gen_cb);
+    if (gen_arg.yield)
+        pkey_blocking_gen(&gen_arg);
+    else
+        rb_thread_call_without_gvl(pkey_blocking_gen, &gen_arg,
+                                   pkey_blocking_gen_stop, &gen_arg);
+    EVP_PKEY_CTX_free(ctx);
+    if (!gen_arg.pkey) {
+        if (gen_arg.state) {
+            ossl_clear_error();
+            rb_jump_tag(gen_arg.state);
+        }
+        else {
+            ossl_raise(ePKeyError, genparam ? "EVP_PKEY_paramgen" : "EVP_PKEY_keygen");
+        }
+    }
+
+    return ossl_pkey_new(gen_arg.pkey);
+}
+
+/*
+ * call-seq:
+ *    OpenSSL::PKey.generate_parameters(algo_name [, options]) -> pkey
+ *
+ * Generates new parameters for the algorithm. _algo_name_ is a String that
+ * represents the algorithm. The optional argument _options_ is a Hash that
+ * specifies the options specific to the algorithm. The order of the options
+ * can be important.
+ *
+ * A block can be passed optionally. The meaning of the arguments passed to
+ * the block varies depending on the implementation of the algorithm. The block
+ * may be called once or multiple times, or may not even be called.
+ *
+ * For the supported options, see the documentation for the 'openssl genpkey'
+ * utility command.
+ *
+ * == Example
+ *   pkey = OpenSSL::PKey.generate_parameters("DSA", "dsa_paramgen_bits" => 2048)
+ *   p pkey.p.num_bits #=> 2048
+ */
+static VALUE
+ossl_pkey_s_generate_parameters(int argc, VALUE *argv, VALUE self)
+{
+    return pkey_generate(argc, argv, self, 1);
+}
+
+/*
+ * call-seq:
+ *    OpenSSL::PKey.generate_key(algo_name [, options]) -> pkey
+ *    OpenSSL::PKey.generate_key(pkey [, options]) -> pkey
+ *
+ * Generates a new key (pair).
+ *
+ * If a String is given as the first argument, it generates a new random key
+ * for the algorithm specified by the name just as ::generate_parameters does.
+ * If an OpenSSL::PKey::PKey is given instead, it generates a new random key
+ * for the same algorithm as the key, using the parameters the key contains.
+ *
+ * See ::generate_parameters for the details of _options_ and the given block.
+ *
+ * == Example
+ *   pkey_params = OpenSSL::PKey.generate_parameters("DSA", "dsa_paramgen_bits" => 2048)
+ *   pkey_params.priv_key #=> nil
+ *   pkey = OpenSSL::PKey.generate_key(pkey_params)
+ *   pkey.priv_key #=> #<OpenSSL::BN 6277...
+ */
+static VALUE
+ossl_pkey_s_generate_key(int argc, VALUE *argv, VALUE self)
+{
+    return pkey_generate(argc, argv, self, 0);
+}
+
+/*
+ * TODO: There is no convenient way to check the presence of public key
+ * components on OpenSSL 3.0. But since keys are immutable on 3.0, pkeys without
+ * these should only be created by OpenSSL::PKey.generate_parameters or by
+ * parsing DER-/PEM-encoded string. We would need another flag for that.
+ */
 void
 ossl_pkey_check_public_key(const EVP_PKEY *pkey)
 {
+#if OSSL_OPENSSL_PREREQ(3, 0, 0)
+    if (EVP_PKEY_missing_parameters(pkey))
+        ossl_raise(ePKeyError, "parameters missing");
+#else
     void *ptr;
     const BIGNUM *n, *e, *pubkey;
 
@@ -229,6 +483,7 @@ ossl_pkey_check_public_key(const EVP_PKEY *pkey)
 	return;
     }
     ossl_raise(ePKeyError, "public key missing");
+#endif
 }
 
 EVP_PKEY *
@@ -246,12 +501,19 @@ GetPrivPKeyPtr(VALUE obj)
 {
     EVP_PKEY *pkey;
 
-    if (rb_funcallv(obj, id_private_q, 0, NULL) != Qtrue) {
-	ossl_raise(rb_eArgError, "Private key is needed.");
-    }
     GetPKey(obj, pkey);
+    if (OSSL_PKEY_IS_PRIVATE(obj))
+        return pkey;
+    /*
+     * The EVP API does not provide a way to check if the EVP_PKEY has private
+     * components. Assuming it does...
+     */
+    if (!rb_respond_to(obj, id_private_q))
+        return pkey;
+    if (RTEST(rb_funcallv(obj, id_private_q, 0, NULL)))
+        return pkey;
 
-    return pkey;
+    rb_raise(rb_eArgError, "private key is needed");
 }
 
 EVP_PKEY *
@@ -271,16 +533,7 @@ DupPKeyPtr(VALUE obj)
 static VALUE
 ossl_pkey_alloc(VALUE klass)
 {
-    EVP_PKEY *pkey;
-    VALUE obj;
-
-    obj = NewPKey(klass);
-    if (!(pkey = EVP_PKEY_new())) {
-	ossl_raise(ePKeyError, NULL);
-    }
-    SetPKey(obj, pkey);
-
-    return obj;
+    return TypedData_Wrap_Struct(klass, &ossl_evp_pkey_type, NULL);
 }
 
 /*
@@ -299,6 +552,26 @@ ossl_pkey_initialize(VALUE self)
     return self;
 }
 
+#ifdef HAVE_EVP_PKEY_DUP
+static VALUE
+ossl_pkey_initialize_copy(VALUE self, VALUE other)
+{
+    EVP_PKEY *pkey, *pkey_other;
+
+    TypedData_Get_Struct(self, EVP_PKEY, &ossl_evp_pkey_type, pkey);
+    TypedData_Get_Struct(other, EVP_PKEY, &ossl_evp_pkey_type, pkey_other);
+    if (pkey)
+        rb_raise(rb_eTypeError, "pkey already initialized");
+    if (pkey_other) {
+        pkey = EVP_PKEY_dup(pkey_other);
+        if (!pkey)
+            ossl_raise(ePKeyError, "EVP_PKEY_dup");
+        RTYPEDDATA_DATA(self) = pkey;
+    }
+    return self;
+}
+#endif
+
 /*
  * call-seq:
  *    pkey.oid -> string
@@ -335,6 +608,89 @@ ossl_pkey_inspect(VALUE self)
                       OBJ_nid2sn(nid));
 }
 
+/*
+ * call-seq:
+ *    pkey.to_text -> string
+ *
+ * Dumps key parameters, public key, and private key components contained in
+ * the key into a human-readable text.
+ *
+ * This is intended for debugging purpose.
+ *
+ * See also the man page EVP_PKEY_print_private(3).
+ */
+static VALUE
+ossl_pkey_to_text(VALUE self)
+{
+    EVP_PKEY *pkey;
+    BIO *bio;
+
+    GetPKey(self, pkey);
+    if (!(bio = BIO_new(BIO_s_mem())))
+        ossl_raise(ePKeyError, "BIO_new");
+
+    if (EVP_PKEY_print_private(bio, pkey, 0, NULL) == 1)
+        goto out;
+    OSSL_BIO_reset(bio);
+    if (EVP_PKEY_print_public(bio, pkey, 0, NULL) == 1)
+        goto out;
+    OSSL_BIO_reset(bio);
+    if (EVP_PKEY_print_params(bio, pkey, 0, NULL) == 1)
+        goto out;
+
+    BIO_free(bio);
+    ossl_raise(ePKeyError, "EVP_PKEY_print_params");
+
+  out:
+    return ossl_membio2str(bio);
+}
+
+VALUE
+ossl_pkey_export_traditional(int argc, VALUE *argv, VALUE self, int to_der)
+{
+    EVP_PKEY *pkey;
+    VALUE cipher, pass;
+    const EVP_CIPHER *enc = NULL;
+    BIO *bio;
+
+    GetPKey(self, pkey);
+    rb_scan_args(argc, argv, "02", &cipher, &pass);
+    if (!NIL_P(cipher)) {
+	enc = ossl_evp_get_cipherbyname(cipher);
+	pass = ossl_pem_passwd_value(pass);
+    }
+
+    bio = BIO_new(BIO_s_mem());
+    if (!bio)
+	ossl_raise(ePKeyError, "BIO_new");
+    if (to_der) {
+	if (!i2d_PrivateKey_bio(bio, pkey)) {
+	    BIO_free(bio);
+	    ossl_raise(ePKeyError, "i2d_PrivateKey_bio");
+	}
+    }
+    else {
+#if OPENSSL_VERSION_NUMBER >= 0x10100000 && !defined(LIBRESSL_VERSION_NUMBER)
+	if (!PEM_write_bio_PrivateKey_traditional(bio, pkey, enc, NULL, 0,
+						  ossl_pem_passwd_cb,
+						  (void *)pass)) {
+#else
+	char pem_str[80];
+	const char *aname;
+
+	EVP_PKEY_asn1_get0_info(NULL, NULL, NULL, NULL, &aname, pkey->ameth);
+	snprintf(pem_str, sizeof(pem_str), "%s PRIVATE KEY", aname);
+	if (!PEM_ASN1_write_bio((i2d_of_void *)i2d_PrivateKey, pem_str, bio,
+				pkey, enc, NULL, 0, ossl_pem_passwd_cb,
+				(void *)pass)) {
+#endif
+	    BIO_free(bio);
+	    ossl_raise(ePKeyError, "PEM_write_bio_PrivateKey_traditional");
+	}
+    }
+    return ossl_membio2str(bio);
+}
+
 static VALUE
 do_pkcs8_export(int argc, VALUE *argv, VALUE self, int to_der)
 {
@@ -404,8 +760,8 @@ ossl_pkey_private_to_pem(int argc, VALUE *argv, VALUE self)
     return do_pkcs8_export(argc, argv, self, 0);
 }
 
-static VALUE
-do_spki_export(VALUE self, int to_der)
+VALUE
+ossl_pkey_export_spki(VALUE self, int to_der)
 {
     EVP_PKEY *pkey;
     BIO *bio;
@@ -438,7 +794,7 @@ do_spki_export(VALUE self, int to_der)
 static VALUE
 ossl_pkey_public_to_der(VALUE self)
 {
-    return do_spki_export(self, 1);
+    return ossl_pkey_export_spki(self, 1);
 }
 
 /*
@@ -450,121 +806,661 @@ ossl_pkey_public_to_der(VALUE self)
 static VALUE
 ossl_pkey_public_to_pem(VALUE self)
 {
-    return do_spki_export(self, 0);
+    return ossl_pkey_export_spki(self, 0);
 }
 
 /*
  *  call-seq:
- *      pkey.sign(digest, data) -> String
+ *      pkey.compare?(another_pkey) -> true | false
  *
- * To sign the String _data_, _digest_, an instance of OpenSSL::Digest, must
- * be provided. The return value is again a String containing the signature.
- * A PKeyError is raised should errors occur.
- * Any previous state of the Digest instance is irrelevant to the signature
- * outcome, the digest instance is reset to its initial state during the
- * operation.
+ * Used primarily to check if an OpenSSL::X509::Certificate#public_key compares to its private key.
  *
  * == Example
- *   data = 'Sign me!'
- *   digest = OpenSSL::Digest.new('SHA256')
- *   pkey = OpenSSL::PKey::RSA.new(2048)
- *   signature = pkey.sign(digest, data)
+ *   x509 = OpenSSL::X509::Certificate.new(pem_encoded_certificate)
+ *   rsa_key = OpenSSL::PKey::RSA.new(pem_encoded_private_key)
+ *
+ *   rsa_key.compare?(x509.public_key) => true | false
+ */
+static VALUE
+ossl_pkey_compare(VALUE self, VALUE other)
+{
+    int ret;
+    EVP_PKEY *selfPKey;
+    EVP_PKEY *otherPKey;
+
+    GetPKey(self, selfPKey);
+    GetPKey(other, otherPKey);
+
+    /* Explicitly check the key type given EVP_PKEY_ASN1_METHOD(3)
+     * docs param_cmp could return any negative number.
+     */
+    if (EVP_PKEY_id(selfPKey) != EVP_PKEY_id(otherPKey))
+        ossl_raise(rb_eTypeError, "cannot match different PKey types");
+
+    ret = EVP_PKEY_eq(selfPKey, otherPKey);
+
+    if (ret == 0)
+        return Qfalse;
+    else if (ret == 1)
+        return Qtrue;
+    else
+        ossl_raise(ePKeyError, "EVP_PKEY_eq");
+}
+
+/*
+ * call-seq:
+ *    pkey.sign(digest, data [, options]) -> string
+ *
+ * Hashes and signs the +data+ using a message digest algorithm +digest+ and
+ * a private key +pkey+.
+ *
+ * See #verify for the verification operation.
+ *
+ * See also the man page EVP_DigestSign(3).
+ *
+ * +digest+::
+ *   A String that represents the message digest algorithm name, or +nil+
+ *   if the PKey type requires no digest algorithm.
+ *   For backwards compatibility, this can be an instance of OpenSSL::Digest.
+ *   Its state will not affect the signature.
+ * +data+::
+ *   A String. The data to be hashed and signed.
+ * +options+::
+ *   A Hash that contains algorithm specific control operations to \OpenSSL.
+ *   See OpenSSL's man page EVP_PKEY_CTX_ctrl_str(3) for details.
+ *   +options+ parameter was added in version 3.0.
+ *
+ * Example:
+ *   data = "Sign me!"
+ *   pkey = OpenSSL::PKey.generate_key("RSA", rsa_keygen_bits: 2048)
+ *   signopts = { rsa_padding_mode: "pss" }
+ *   signature = pkey.sign("SHA256", data, signopts)
+ *
+ *   # Creates a copy of the RSA key pkey, but without the private components
+ *   pub_key = pkey.public_key
+ *   puts pub_key.verify("SHA256", signature, data, signopts) # => true
  */
 static VALUE
-ossl_pkey_sign(VALUE self, VALUE digest, VALUE data)
+ossl_pkey_sign(int argc, VALUE *argv, VALUE self)
 {
     EVP_PKEY *pkey;
-    const EVP_MD *md;
+    VALUE digest, data, options, sig;
+    const EVP_MD *md = NULL;
     EVP_MD_CTX *ctx;
-    unsigned int buf_len;
-    VALUE str;
-    int result;
+    EVP_PKEY_CTX *pctx;
+    size_t siglen;
+    int state;
 
     pkey = GetPrivPKeyPtr(self);
-    md = ossl_evp_get_digestbyname(digest);
+    rb_scan_args(argc, argv, "21", &digest, &data, &options);
+    if (!NIL_P(digest))
+        md = ossl_evp_get_digestbyname(digest);
     StringValue(data);
-    str = rb_str_new(0, EVP_PKEY_size(pkey));
 
     ctx = EVP_MD_CTX_new();
     if (!ctx)
-	ossl_raise(ePKeyError, "EVP_MD_CTX_new");
-    if (!EVP_SignInit_ex(ctx, md, NULL)) {
-	EVP_MD_CTX_free(ctx);
-	ossl_raise(ePKeyError, "EVP_SignInit_ex");
+        ossl_raise(ePKeyError, "EVP_MD_CTX_new");
+    if (EVP_DigestSignInit(ctx, &pctx, md, /* engine */NULL, pkey) < 1) {
+        EVP_MD_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_DigestSignInit");
+    }
+    if (!NIL_P(options)) {
+        pkey_ctx_apply_options(pctx, options, &state);
+        if (state) {
+            EVP_MD_CTX_free(ctx);
+            rb_jump_tag(state);
+        }
+    }
+#if OPENSSL_VERSION_NUMBER >= 0x10101000 && !defined(LIBRESSL_VERSION_NUMBER)
+    if (EVP_DigestSign(ctx, NULL, &siglen, (unsigned char *)RSTRING_PTR(data),
+                       RSTRING_LEN(data)) < 1) {
+        EVP_MD_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_DigestSign");
     }
-    if (!EVP_SignUpdate(ctx, RSTRING_PTR(data), RSTRING_LEN(data))) {
-	EVP_MD_CTX_free(ctx);
-	ossl_raise(ePKeyError, "EVP_SignUpdate");
+    if (siglen > LONG_MAX) {
+        EVP_MD_CTX_free(ctx);
+        rb_raise(ePKeyError, "signature would be too large");
     }
-    result = EVP_SignFinal(ctx, (unsigned char *)RSTRING_PTR(str), &buf_len, pkey);
+    sig = ossl_str_new(NULL, (long)siglen, &state);
+    if (state) {
+        EVP_MD_CTX_free(ctx);
+        rb_jump_tag(state);
+    }
+    if (EVP_DigestSign(ctx, (unsigned char *)RSTRING_PTR(sig), &siglen,
+                       (unsigned char *)RSTRING_PTR(data),
+                       RSTRING_LEN(data)) < 1) {
+        EVP_MD_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_DigestSign");
+    }
+#else
+    if (EVP_DigestSignUpdate(ctx, RSTRING_PTR(data), RSTRING_LEN(data)) < 1) {
+        EVP_MD_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_DigestSignUpdate");
+    }
+    if (EVP_DigestSignFinal(ctx, NULL, &siglen) < 1) {
+        EVP_MD_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_DigestSignFinal");
+    }
+    if (siglen > LONG_MAX) {
+        EVP_MD_CTX_free(ctx);
+        rb_raise(ePKeyError, "signature would be too large");
+    }
+    sig = ossl_str_new(NULL, (long)siglen, &state);
+    if (state) {
+        EVP_MD_CTX_free(ctx);
+        rb_jump_tag(state);
+    }
+    if (EVP_DigestSignFinal(ctx, (unsigned char *)RSTRING_PTR(sig),
+                            &siglen) < 1) {
+        EVP_MD_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_DigestSignFinal");
+    }
+#endif
     EVP_MD_CTX_free(ctx);
-    if (!result)
-	ossl_raise(ePKeyError, "EVP_SignFinal");
-    rb_str_set_len(str, buf_len);
-
-    return str;
+    rb_str_set_len(sig, siglen);
+    return sig;
 }
 
 /*
- *  call-seq:
- *      pkey.verify(digest, signature, data) -> String
+ * call-seq:
+ *    pkey.verify(digest, signature, data [, options]) -> true or false
  *
- * To verify the String _signature_, _digest_, an instance of
- * OpenSSL::Digest, must be provided to re-compute the message digest of the
- * original _data_, also a String. The return value is +true+ if the
- * signature is valid, +false+ otherwise. A PKeyError is raised should errors
- * occur.
- * Any previous state of the Digest instance is irrelevant to the validation
- * outcome, the digest instance is reset to its initial state during the
- * operation.
+ * Verifies the +signature+ for the +data+ using a message digest algorithm
+ * +digest+ and a public key +pkey+.
  *
- * == Example
- *   data = 'Sign me!'
- *   digest = OpenSSL::Digest.new('SHA256')
- *   pkey = OpenSSL::PKey::RSA.new(2048)
- *   signature = pkey.sign(digest, data)
- *   pub_key = pkey.public_key
- *   puts pub_key.verify(digest, signature, data) # => true
+ * Returns +true+ if the signature is successfully verified, +false+ otherwise.
+ * The caller must check the return value.
+ *
+ * See #sign for the signing operation and an example.
+ *
+ * See also the man page EVP_DigestVerify(3).
+ *
+ * +digest+::
+ *   See #sign.
+ * +signature+::
+ *   A String containing the signature to be verified.
+ * +data+::
+ *   See #sign.
+ * +options+::
+ *   See #sign. +options+ parameter was added in version 3.0.
  */
 static VALUE
-ossl_pkey_verify(VALUE self, VALUE digest, VALUE sig, VALUE data)
+ossl_pkey_verify(int argc, VALUE *argv, VALUE self)
 {
     EVP_PKEY *pkey;
-    const EVP_MD *md;
+    VALUE digest, sig, data, options;
+    const EVP_MD *md = NULL;
     EVP_MD_CTX *ctx;
-    int siglen, result;
+    EVP_PKEY_CTX *pctx;
+    int state, ret;
 
     GetPKey(self, pkey);
+    rb_scan_args(argc, argv, "31", &digest, &sig, &data, &options);
     ossl_pkey_check_public_key(pkey);
-    md = ossl_evp_get_digestbyname(digest);
+    if (!NIL_P(digest))
+        md = ossl_evp_get_digestbyname(digest);
     StringValue(sig);
-    siglen = RSTRING_LENINT(sig);
     StringValue(data);
 
     ctx = EVP_MD_CTX_new();
     if (!ctx)
-	ossl_raise(ePKeyError, "EVP_MD_CTX_new");
-    if (!EVP_VerifyInit_ex(ctx, md, NULL)) {
-	EVP_MD_CTX_free(ctx);
-	ossl_raise(ePKeyError, "EVP_VerifyInit_ex");
+        ossl_raise(ePKeyError, "EVP_MD_CTX_new");
+    if (EVP_DigestVerifyInit(ctx, &pctx, md, /* engine */NULL, pkey) < 1) {
+        EVP_MD_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_DigestVerifyInit");
     }
-    if (!EVP_VerifyUpdate(ctx, RSTRING_PTR(data), RSTRING_LEN(data))) {
-	EVP_MD_CTX_free(ctx);
-	ossl_raise(ePKeyError, "EVP_VerifyUpdate");
+    if (!NIL_P(options)) {
+        pkey_ctx_apply_options(pctx, options, &state);
+        if (state) {
+            EVP_MD_CTX_free(ctx);
+            rb_jump_tag(state);
+        }
     }
-    result = EVP_VerifyFinal(ctx, (unsigned char *)RSTRING_PTR(sig), siglen, pkey);
+#if OPENSSL_VERSION_NUMBER >= 0x10101000 && !defined(LIBRESSL_VERSION_NUMBER)
+    ret = EVP_DigestVerify(ctx, (unsigned char *)RSTRING_PTR(sig),
+                           RSTRING_LEN(sig), (unsigned char *)RSTRING_PTR(data),
+                           RSTRING_LEN(data));
     EVP_MD_CTX_free(ctx);
-    switch (result) {
-    case 0:
-	ossl_clear_error();
-	return Qfalse;
-    case 1:
-	return Qtrue;
-    default:
-	ossl_raise(ePKeyError, "EVP_VerifyFinal");
+    if (ret < 0)
+        ossl_raise(ePKeyError, "EVP_DigestVerify");
+#else
+    if (EVP_DigestVerifyUpdate(ctx, RSTRING_PTR(data), RSTRING_LEN(data)) < 1) {
+        EVP_MD_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_DigestVerifyUpdate");
+    }
+    ret = EVP_DigestVerifyFinal(ctx, (unsigned char *)RSTRING_PTR(sig),
+                                RSTRING_LEN(sig));
+    EVP_MD_CTX_free(ctx);
+    if (ret < 0)
+        ossl_raise(ePKeyError, "EVP_DigestVerifyFinal");
+#endif
+    if (ret)
+        return Qtrue;
+    else {
+        ossl_clear_error();
+        return Qfalse;
+    }
+}
+
+/*
+ * call-seq:
+ *    pkey.sign_raw(digest, data [, options]) -> string
+ *
+ * Signs +data+ using a private key +pkey+. Unlike #sign, +data+ will not be
+ * hashed by +digest+ automatically.
+ *
+ * See #verify_raw for the verification operation.
+ *
+ * Added in version 3.0. See also the man page EVP_PKEY_sign(3).
+ *
+ * +digest+::
+ *   A String that represents the message digest algorithm name, or +nil+
+ *   if the PKey type requires no digest algorithm.
+ *   Although this method will not hash +data+ with it, this parameter may still
+ *   be required depending on the signature algorithm.
+ * +data+::
+ *   A String. The data to be signed.
+ * +options+::
+ *   A Hash that contains algorithm specific control operations to \OpenSSL.
+ *   See OpenSSL's man page EVP_PKEY_CTX_ctrl_str(3) for details.
+ *
+ * Example:
+ *   data = "Sign me!"
+ *   hash = OpenSSL::Digest.digest("SHA256", data)
+ *   pkey = OpenSSL::PKey.generate_key("RSA", rsa_keygen_bits: 2048)
+ *   signopts = { rsa_padding_mode: "pss" }
+ *   signature = pkey.sign_raw("SHA256", hash, signopts)
+ *
+ *   # Creates a copy of the RSA key pkey, but without the private components
+ *   pub_key = pkey.public_key
+ *   puts pub_key.verify_raw("SHA256", signature, hash, signopts) # => true
+ */
+static VALUE
+ossl_pkey_sign_raw(int argc, VALUE *argv, VALUE self)
+{
+    EVP_PKEY *pkey;
+    VALUE digest, data, options, sig;
+    const EVP_MD *md = NULL;
+    EVP_PKEY_CTX *ctx;
+    size_t outlen;
+    int state;
+
+    GetPKey(self, pkey);
+    rb_scan_args(argc, argv, "21", &digest, &data, &options);
+    if (!NIL_P(digest))
+        md = ossl_evp_get_digestbyname(digest);
+    StringValue(data);
+
+    ctx = EVP_PKEY_CTX_new(pkey, /* engine */NULL);
+    if (!ctx)
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_new");
+    if (EVP_PKEY_sign_init(ctx) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_sign_init");
+    }
+    if (md && EVP_PKEY_CTX_set_signature_md(ctx, md) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_set_signature_md");
+    }
+    if (!NIL_P(options)) {
+        pkey_ctx_apply_options(ctx, options, &state);
+        if (state) {
+            EVP_PKEY_CTX_free(ctx);
+            rb_jump_tag(state);
+        }
+    }
+    if (EVP_PKEY_sign(ctx, NULL, &outlen, (unsigned char *)RSTRING_PTR(data),
+                      RSTRING_LEN(data)) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_sign");
+    }
+    if (outlen > LONG_MAX) {
+        EVP_PKEY_CTX_free(ctx);
+        rb_raise(ePKeyError, "signature would be too large");
+    }
+    sig = ossl_str_new(NULL, (long)outlen, &state);
+    if (state) {
+        EVP_PKEY_CTX_free(ctx);
+        rb_jump_tag(state);
+    }
+    if (EVP_PKEY_sign(ctx, (unsigned char *)RSTRING_PTR(sig), &outlen,
+                      (unsigned char *)RSTRING_PTR(data),
+                      RSTRING_LEN(data)) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_sign");
+    }
+    EVP_PKEY_CTX_free(ctx);
+    rb_str_set_len(sig, outlen);
+    return sig;
+}
+
+/*
+ * call-seq:
+ *    pkey.verify_raw(digest, signature, data [, options]) -> true or false
+ *
+ * Verifies the +signature+ for the +data+ using a public key +pkey+. Unlike
+ * #verify, this method will not hash +data+ with +digest+ automatically.
+ *
+ * Returns +true+ if the signature is successfully verified, +false+ otherwise.
+ * The caller must check the return value.
+ *
+ * See #sign_raw for the signing operation and an example code.
+ *
+ * Added in version 3.0. See also the man page EVP_PKEY_verify(3).
+ *
+ * +signature+::
+ *   A String containing the signature to be verified.
+ */
+static VALUE
+ossl_pkey_verify_raw(int argc, VALUE *argv, VALUE self)
+{
+    EVP_PKEY *pkey;
+    VALUE digest, sig, data, options;
+    const EVP_MD *md = NULL;
+    EVP_PKEY_CTX *ctx;
+    int state, ret;
+
+    GetPKey(self, pkey);
+    rb_scan_args(argc, argv, "31", &digest, &sig, &data, &options);
+    ossl_pkey_check_public_key(pkey);
+    if (!NIL_P(digest))
+        md = ossl_evp_get_digestbyname(digest);
+    StringValue(sig);
+    StringValue(data);
+
+    ctx = EVP_PKEY_CTX_new(pkey, /* engine */NULL);
+    if (!ctx)
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_new");
+    if (EVP_PKEY_verify_init(ctx) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_verify_init");
+    }
+    if (md && EVP_PKEY_CTX_set_signature_md(ctx, md) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_set_signature_md");
+    }
+    if (!NIL_P(options)) {
+        pkey_ctx_apply_options(ctx, options, &state);
+        if (state) {
+            EVP_PKEY_CTX_free(ctx);
+            rb_jump_tag(state);
+        }
+    }
+    ret = EVP_PKEY_verify(ctx, (unsigned char *)RSTRING_PTR(sig),
+                          RSTRING_LEN(sig),
+                          (unsigned char *)RSTRING_PTR(data),
+                          RSTRING_LEN(data));
+    EVP_PKEY_CTX_free(ctx);
+    if (ret < 0)
+        ossl_raise(ePKeyError, "EVP_PKEY_verify");
+
+    if (ret)
+        return Qtrue;
+    else {
+        ossl_clear_error();
+        return Qfalse;
     }
 }
 
+/*
+ * call-seq:
+ *    pkey.verify_recover(digest, signature [, options]) -> string
+ *
+ * Recovers the signed data from +signature+ using a public key +pkey+. Not all
+ * signature algorithms support this operation.
+ *
+ * Added in version 3.0. See also the man page EVP_PKEY_verify_recover(3).
+ *
+ * +signature+::
+ *   A String containing the signature to be verified.
+ */
+static VALUE
+ossl_pkey_verify_recover(int argc, VALUE *argv, VALUE self)
+{
+    EVP_PKEY *pkey;
+    VALUE digest, sig, options, out;
+    const EVP_MD *md = NULL;
+    EVP_PKEY_CTX *ctx;
+    int state;
+    size_t outlen;
+
+    GetPKey(self, pkey);
+    rb_scan_args(argc, argv, "21", &digest, &sig, &options);
+    ossl_pkey_check_public_key(pkey);
+    if (!NIL_P(digest))
+        md = ossl_evp_get_digestbyname(digest);
+    StringValue(sig);
+
+    ctx = EVP_PKEY_CTX_new(pkey, /* engine */NULL);
+    if (!ctx)
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_new");
+    if (EVP_PKEY_verify_recover_init(ctx) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_verify_recover_init");
+    }
+    if (md && EVP_PKEY_CTX_set_signature_md(ctx, md) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_set_signature_md");
+    }
+    if (!NIL_P(options)) {
+        pkey_ctx_apply_options(ctx, options, &state);
+        if (state) {
+            EVP_PKEY_CTX_free(ctx);
+            rb_jump_tag(state);
+        }
+    }
+    if (EVP_PKEY_verify_recover(ctx, NULL, &outlen,
+                                (unsigned char *)RSTRING_PTR(sig),
+                                RSTRING_LEN(sig)) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_verify_recover");
+    }
+    out = ossl_str_new(NULL, (long)outlen, &state);
+    if (state) {
+        EVP_PKEY_CTX_free(ctx);
+        rb_jump_tag(state);
+    }
+    if (EVP_PKEY_verify_recover(ctx, (unsigned char *)RSTRING_PTR(out), &outlen,
+                                (unsigned char *)RSTRING_PTR(sig),
+                                RSTRING_LEN(sig)) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_verify_recover");
+    }
+    EVP_PKEY_CTX_free(ctx);
+    rb_str_set_len(out, outlen);
+    return out;
+}
+
+/*
+ * call-seq:
+ *    pkey.derive(peer_pkey) -> string
+ *
+ * Derives a shared secret from _pkey_ and _peer_pkey_. _pkey_ must contain
+ * the private components, _peer_pkey_ must contain the public components.
+ */
+static VALUE
+ossl_pkey_derive(int argc, VALUE *argv, VALUE self)
+{
+    EVP_PKEY *pkey, *peer_pkey;
+    EVP_PKEY_CTX *ctx;
+    VALUE peer_pkey_obj, str;
+    size_t keylen;
+    int state;
+
+    GetPKey(self, pkey);
+    rb_scan_args(argc, argv, "1", &peer_pkey_obj);
+    GetPKey(peer_pkey_obj, peer_pkey);
+
+    ctx = EVP_PKEY_CTX_new(pkey, /* engine */NULL);
+    if (!ctx)
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_new");
+    if (EVP_PKEY_derive_init(ctx) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_derive_init");
+    }
+    if (EVP_PKEY_derive_set_peer(ctx, peer_pkey) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_derive_set_peer");
+    }
+    if (EVP_PKEY_derive(ctx, NULL, &keylen) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_derive");
+    }
+    if (keylen > LONG_MAX)
+        rb_raise(ePKeyError, "derived key would be too large");
+    str = ossl_str_new(NULL, (long)keylen, &state);
+    if (state) {
+        EVP_PKEY_CTX_free(ctx);
+        rb_jump_tag(state);
+    }
+    if (EVP_PKEY_derive(ctx, (unsigned char *)RSTRING_PTR(str), &keylen) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_derive");
+    }
+    EVP_PKEY_CTX_free(ctx);
+    rb_str_set_len(str, keylen);
+    return str;
+}
+
+/*
+ * call-seq:
+ *    pkey.encrypt(data [, options]) -> string
+ *
+ * Performs a public key encryption operation using +pkey+.
+ *
+ * See #decrypt for the reverse operation.
+ *
+ * Added in version 3.0. See also the man page EVP_PKEY_encrypt(3).
+ *
+ * +data+::
+ *   A String to be encrypted.
+ * +options+::
+ *   A Hash that contains algorithm specific control operations to \OpenSSL.
+ *   See OpenSSL's man page EVP_PKEY_CTX_ctrl_str(3) for details.
+ *
+ * Example:
+ *   pkey = OpenSSL::PKey.generate_key("RSA", rsa_keygen_bits: 2048)
+ *   data = "secret data"
+ *   encrypted = pkey.encrypt(data, rsa_padding_mode: "oaep")
+ *   decrypted = pkey.decrypt(data, rsa_padding_mode: "oaep")
+ *   p decrypted #=> "secret data"
+ */
+static VALUE
+ossl_pkey_encrypt(int argc, VALUE *argv, VALUE self)
+{
+    EVP_PKEY *pkey;
+    EVP_PKEY_CTX *ctx;
+    VALUE data, options, str;
+    size_t outlen;
+    int state;
+
+    GetPKey(self, pkey);
+    rb_scan_args(argc, argv, "11", &data, &options);
+    StringValue(data);
+
+    ctx = EVP_PKEY_CTX_new(pkey, /* engine */NULL);
+    if (!ctx)
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_new");
+    if (EVP_PKEY_encrypt_init(ctx) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_encrypt_init");
+    }
+    if (!NIL_P(options)) {
+        pkey_ctx_apply_options(ctx, options, &state);
+        if (state) {
+            EVP_PKEY_CTX_free(ctx);
+            rb_jump_tag(state);
+        }
+    }
+    if (EVP_PKEY_encrypt(ctx, NULL, &outlen,
+                         (unsigned char *)RSTRING_PTR(data),
+                         RSTRING_LEN(data)) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_encrypt");
+    }
+    if (outlen > LONG_MAX) {
+        EVP_PKEY_CTX_free(ctx);
+        rb_raise(ePKeyError, "encrypted data would be too large");
+    }
+    str = ossl_str_new(NULL, (long)outlen, &state);
+    if (state) {
+        EVP_PKEY_CTX_free(ctx);
+        rb_jump_tag(state);
+    }
+    if (EVP_PKEY_encrypt(ctx, (unsigned char *)RSTRING_PTR(str), &outlen,
+                         (unsigned char *)RSTRING_PTR(data),
+                         RSTRING_LEN(data)) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_encrypt");
+    }
+    EVP_PKEY_CTX_free(ctx);
+    rb_str_set_len(str, outlen);
+    return str;
+}
+
+/*
+ * call-seq:
+ *    pkey.decrypt(data [, options]) -> string
+ *
+ * Performs a public key decryption operation using +pkey+.
+ *
+ * See #encrypt for a description of the parameters and an example.
+ *
+ * Added in version 3.0. See also the man page EVP_PKEY_decrypt(3).
+ */
+static VALUE
+ossl_pkey_decrypt(int argc, VALUE *argv, VALUE self)
+{
+    EVP_PKEY *pkey;
+    EVP_PKEY_CTX *ctx;
+    VALUE data, options, str;
+    size_t outlen;
+    int state;
+
+    GetPKey(self, pkey);
+    rb_scan_args(argc, argv, "11", &data, &options);
+    StringValue(data);
+
+    ctx = EVP_PKEY_CTX_new(pkey, /* engine */NULL);
+    if (!ctx)
+        ossl_raise(ePKeyError, "EVP_PKEY_CTX_new");
+    if (EVP_PKEY_decrypt_init(ctx) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_decrypt_init");
+    }
+    if (!NIL_P(options)) {
+        pkey_ctx_apply_options(ctx, options, &state);
+        if (state) {
+            EVP_PKEY_CTX_free(ctx);
+            rb_jump_tag(state);
+        }
+    }
+    if (EVP_PKEY_decrypt(ctx, NULL, &outlen,
+                         (unsigned char *)RSTRING_PTR(data),
+                         RSTRING_LEN(data)) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_decrypt");
+    }
+    if (outlen > LONG_MAX) {
+        EVP_PKEY_CTX_free(ctx);
+        rb_raise(ePKeyError, "decrypted data would be too large");
+    }
+    str = ossl_str_new(NULL, (long)outlen, &state);
+    if (state) {
+        EVP_PKEY_CTX_free(ctx);
+        rb_jump_tag(state);
+    }
+    if (EVP_PKEY_decrypt(ctx, (unsigned char *)RSTRING_PTR(str), &outlen,
+                         (unsigned char *)RSTRING_PTR(data),
+                         RSTRING_LEN(data)) <= 0) {
+        EVP_PKEY_CTX_free(ctx);
+        ossl_raise(ePKeyError, "EVP_PKEY_decrypt");
+    }
+    EVP_PKEY_CTX_free(ctx);
+    rb_str_set_len(str, outlen);
+    return str;
+}
+
 /*
  * INIT
  */
@@ -648,18 +1544,33 @@ Init_ossl_pkey(void)
     cPKey = rb_define_class_under(mPKey, "PKey", rb_cObject);
 
     rb_define_module_function(mPKey, "read", ossl_pkey_new_from_data, -1);
+    rb_define_module_function(mPKey, "generate_parameters", ossl_pkey_s_generate_parameters, -1);
+    rb_define_module_function(mPKey, "generate_key", ossl_pkey_s_generate_key, -1);
 
     rb_define_alloc_func(cPKey, ossl_pkey_alloc);
     rb_define_method(cPKey, "initialize", ossl_pkey_initialize, 0);
+#ifdef HAVE_EVP_PKEY_DUP
+    rb_define_method(cPKey, "initialize_copy", ossl_pkey_initialize_copy, 1);
+#else
+    rb_undef_method(cPKey, "initialize_copy");
+#endif
     rb_define_method(cPKey, "oid", ossl_pkey_oid, 0);
     rb_define_method(cPKey, "inspect", ossl_pkey_inspect, 0);
+    rb_define_method(cPKey, "to_text", ossl_pkey_to_text, 0);
     rb_define_method(cPKey, "private_to_der", ossl_pkey_private_to_der, -1);
     rb_define_method(cPKey, "private_to_pem", ossl_pkey_private_to_pem, -1);
     rb_define_method(cPKey, "public_to_der", ossl_pkey_public_to_der, 0);
     rb_define_method(cPKey, "public_to_pem", ossl_pkey_public_to_pem, 0);
-
-    rb_define_method(cPKey, "sign", ossl_pkey_sign, 2);
-    rb_define_method(cPKey, "verify", ossl_pkey_verify, 3);
+    rb_define_method(cPKey, "compare?", ossl_pkey_compare, 1);
+
+    rb_define_method(cPKey, "sign", ossl_pkey_sign, -1);
+    rb_define_method(cPKey, "verify", ossl_pkey_verify, -1);
+    rb_define_method(cPKey, "sign_raw", ossl_pkey_sign_raw, -1);
+    rb_define_method(cPKey, "verify_raw", ossl_pkey_verify_raw, -1);
+    rb_define_method(cPKey, "verify_recover", ossl_pkey_verify_recover, -1);
+    rb_define_method(cPKey, "derive", ossl_pkey_derive, -1);
+    rb_define_method(cPKey, "encrypt", ossl_pkey_encrypt, -1);
+    rb_define_method(cPKey, "decrypt", ossl_pkey_decrypt, -1);
 
     id_private_q = rb_intern("private?");
 
diff --git a/ext/openssl/ossl_pkey.h b/ext/openssl/ossl_pkey.h
index 0db5930..38fb9fa 100644
--- a/ext/openssl/ossl_pkey.h
+++ b/ext/openssl/ossl_pkey.h
@@ -7,27 +7,18 @@
  * This program is licensed under the same licence as Ruby.
  * (See the file 'LICENCE'.)
  */
-#if !defined(_OSSL_PKEY_H_)
-#define _OSSL_PKEY_H_
+#if !defined(OSSL_PKEY_H)
+#define OSSL_PKEY_H
 
 extern VALUE mPKey;
 extern VALUE cPKey;
 extern VALUE ePKeyError;
 extern const rb_data_type_t ossl_evp_pkey_type;
 
-#define OSSL_PKEY_SET_PRIVATE(obj) rb_iv_set((obj), "private", Qtrue)
-#define OSSL_PKEY_SET_PUBLIC(obj)  rb_iv_set((obj), "private", Qfalse)
-#define OSSL_PKEY_IS_PRIVATE(obj)  (rb_iv_get((obj), "private") == Qtrue)
+/* For ENGINE */
+#define OSSL_PKEY_SET_PRIVATE(obj) rb_ivar_set((obj), rb_intern("private"), Qtrue)
+#define OSSL_PKEY_IS_PRIVATE(obj)  (rb_attr_get((obj), rb_intern("private")) == Qtrue)
 
-#define NewPKey(klass) \
-    TypedData_Wrap_Struct((klass), &ossl_evp_pkey_type, 0)
-#define SetPKey(obj, pkey) do { \
-    if (!(pkey)) { \
-	rb_raise(rb_eRuntimeError, "PKEY wasn't initialized!"); \
-    } \
-    RTYPEDDATA_DATA(obj) = (pkey); \
-    OSSL_PKEY_SET_PUBLIC(obj); \
-} while (0)
 #define GetPKey(obj, pkey) do {\
     TypedData_Get_Struct((obj), EVP_PKEY, &ossl_evp_pkey_type, (pkey)); \
     if (!(pkey)) { \
@@ -35,19 +26,27 @@ extern const rb_data_type_t ossl_evp_pkey_type;
     } \
 } while (0)
 
-struct ossl_generate_cb_arg {
-    int yield;
-    int interrupted;
-    int state;
-};
-int ossl_generate_cb_2(int p, int n, BN_GENCB *cb);
-void ossl_generate_cb_stop(void *ptr);
-
+/* Takes ownership of the EVP_PKEY */
 VALUE ossl_pkey_new(EVP_PKEY *);
 void ossl_pkey_check_public_key(const EVP_PKEY *);
+EVP_PKEY *ossl_pkey_read_generic(BIO *, VALUE);
 EVP_PKEY *GetPKeyPtr(VALUE);
 EVP_PKEY *DupPKeyPtr(VALUE);
 EVP_PKEY *GetPrivPKeyPtr(VALUE);
+
+/*
+ * Serializes _self_ in X.509 SubjectPublicKeyInfo format and returns the
+ * resulting String. Sub-classes use this when overriding #to_der.
+ */
+VALUE ossl_pkey_export_spki(VALUE self, int to_der);
+/*
+ * Serializes the private key _self_ in the traditional private key format
+ * and returns the resulting String. Sub-classes use this when overriding
+ * #to_der.
+ */
+VALUE ossl_pkey_export_traditional(int argc, VALUE *argv, VALUE self,
+				   int to_der);
+
 void Init_ossl_pkey(void);
 
 /*
@@ -56,7 +55,6 @@ void Init_ossl_pkey(void);
 extern VALUE cRSA;
 extern VALUE eRSAError;
 
-VALUE ossl_rsa_new(EVP_PKEY *);
 void Init_ossl_rsa(void);
 
 /*
@@ -65,7 +63,6 @@ void Init_ossl_rsa(void);
 extern VALUE cDSA;
 extern VALUE eDSAError;
 
-VALUE ossl_dsa_new(EVP_PKEY *);
 void Init_ossl_dsa(void);
 
 /*
@@ -74,7 +71,6 @@ void Init_ossl_dsa(void);
 extern VALUE cDH;
 extern VALUE eDHError;
 
-VALUE ossl_dh_new(EVP_PKEY *);
 void Init_ossl_dh(void);
 
 /*
@@ -120,6 +116,7 @@ static VALUE ossl_##_keytype##_get_##_name(VALUE self)			\
 	OSSL_PKEY_BN_DEF_GETTER0(_keytype, _type, a2,			\
 		_type##_get0_##_group(obj, NULL, &bn))
 
+#if !OSSL_OPENSSL_PREREQ(3, 0, 0)
 #define OSSL_PKEY_BN_DEF_SETTER3(_keytype, _type, _group, a1, a2, a3)	\
 /*									\
  *  call-seq:								\
@@ -177,36 +174,22 @@ static VALUE ossl_##_keytype##_set_##_group(VALUE self, VALUE v1, VALUE v2) \
 	}								\
 	return self;							\
 }
+#else
+#define OSSL_PKEY_BN_DEF_SETTER3(_keytype, _type, _group, a1, a2, a3)	\
+static VALUE ossl_##_keytype##_set_##_group(VALUE self, VALUE v1, VALUE v2, VALUE v3) \
+{									\
+        rb_raise(ePKeyError,						\
+                 #_keytype"#set_"#_group"= is incompatible with OpenSSL 3.0"); \
+}
 
-#define OSSL_PKEY_BN_DEF_SETTER_OLD(_keytype, _type, _group, _name)	\
-/*									\
- *  call-seq:								\
- *     _keytype##.##_name = bn -> bn					\
- */									\
-static VALUE ossl_##_keytype##_set_##_name(VALUE self, VALUE bignum)	\
+#define OSSL_PKEY_BN_DEF_SETTER2(_keytype, _type, _group, a1, a2)	\
+static VALUE ossl_##_keytype##_set_##_group(VALUE self, VALUE v1, VALUE v2) \
 {									\
-	_type *obj;							\
-	BIGNUM *bn;							\
-									\
-	rb_warning("#"#_name"= is deprecated; use #set_"#_group);	\
-	Get##_type(self, obj);						\
-	if (NIL_P(bignum)) {						\
-		BN_clear_free(obj->_name);				\
-		obj->_name = NULL;					\
-		return Qnil;						\
-	}								\
-									\
-	bn = GetBNPtr(bignum);						\
-	if (obj->_name == NULL)						\
-		obj->_name = BN_new();					\
-	if (obj->_name == NULL)						\
-		ossl_raise(eBNError, NULL);				\
-	if (BN_copy(obj->_name, bn) == NULL)				\
-		ossl_raise(eBNError, NULL);				\
-	return bignum;							\
+        rb_raise(ePKeyError,						\
+                 #_keytype"#set_"#_group"= is incompatible with OpenSSL 3.0"); \
 }
+#endif
 
-#if defined(HAVE_OPAQUE_OPENSSL) /* OpenSSL 1.1.0 */
 #define OSSL_PKEY_BN_DEF3(_keytype, _type, _group, a1, a2, a3)		\
 	OSSL_PKEY_BN_DEF_GETTER3(_keytype, _type, _group, a1, a2, a3)	\
 	OSSL_PKEY_BN_DEF_SETTER3(_keytype, _type, _group, a1, a2, a3)
@@ -218,24 +201,4 @@ static VALUE ossl_##_keytype##_set_##_name(VALUE self, VALUE bignum)	\
 #define DEF_OSSL_PKEY_BN(class, keytype, name)				\
 	rb_define_method((class), #name, ossl_##keytype##_get_##name, 0)
 
-#else
-#define OSSL_PKEY_BN_DEF3(_keytype, _type, _group, a1, a2, a3)		\
-	OSSL_PKEY_BN_DEF_GETTER3(_keytype, _type, _group, a1, a2, a3)	\
-	OSSL_PKEY_BN_DEF_SETTER3(_keytype, _type, _group, a1, a2, a3)	\
-	OSSL_PKEY_BN_DEF_SETTER_OLD(_keytype, _type, _group, a1)	\
-	OSSL_PKEY_BN_DEF_SETTER_OLD(_keytype, _type, _group, a2)	\
-	OSSL_PKEY_BN_DEF_SETTER_OLD(_keytype, _type, _group, a3)
-
-#define OSSL_PKEY_BN_DEF2(_keytype, _type, _group, a1, a2)		\
-	OSSL_PKEY_BN_DEF_GETTER2(_keytype, _type, _group, a1, a2)	\
-	OSSL_PKEY_BN_DEF_SETTER2(_keytype, _type, _group, a1, a2)	\
-	OSSL_PKEY_BN_DEF_SETTER_OLD(_keytype, _type, _group, a1)	\
-	OSSL_PKEY_BN_DEF_SETTER_OLD(_keytype, _type, _group, a2)
-
-#define DEF_OSSL_PKEY_BN(class, keytype, name) do {			\
-	rb_define_method((class), #name, ossl_##keytype##_get_##name, 0);\
-	rb_define_method((class), #name "=", ossl_##keytype##_set_##name, 1);\
-} while (0)
-#endif /* HAVE_OPAQUE_OPENSSL */
-
-#endif /* _OSSL_PKEY_H_ */
+#endif /* OSSL_PKEY_H */
diff --git a/ext/openssl/ossl_pkey_dh.c b/ext/openssl/ossl_pkey_dh.c
index bf4e3f9..696455d 100644
--- a/ext/openssl/ossl_pkey_dh.c
+++ b/ext/openssl/ossl_pkey_dh.c
@@ -29,217 +29,105 @@
 VALUE cDH;
 VALUE eDHError;
 
-/*
- * Public
- */
-static VALUE
-dh_instance(VALUE klass, DH *dh)
-{
-    EVP_PKEY *pkey;
-    VALUE obj;
-
-    if (!dh) {
-	return Qfalse;
-    }
-    obj = NewPKey(klass);
-    if (!(pkey = EVP_PKEY_new())) {
-	return Qfalse;
-    }
-    if (!EVP_PKEY_assign_DH(pkey, dh)) {
-	EVP_PKEY_free(pkey);
-	return Qfalse;
-    }
-    SetPKey(obj, pkey);
-
-    return obj;
-}
-
-VALUE
-ossl_dh_new(EVP_PKEY *pkey)
-{
-    VALUE obj;
-
-    if (!pkey) {
-	obj = dh_instance(cDH, DH_new());
-    } else {
-	obj = NewPKey(cDH);
-	if (EVP_PKEY_base_id(pkey) != EVP_PKEY_DH) {
-	    ossl_raise(rb_eTypeError, "Not a DH key!");
-	}
-	SetPKey(obj, pkey);
-    }
-    if (obj == Qfalse) {
-	ossl_raise(eDHError, NULL);
-    }
-
-    return obj;
-}
-
 /*
  * Private
  */
-struct dh_blocking_gen_arg {
-    DH *dh;
-    int size;
-    int gen;
-    BN_GENCB *cb;
-    int result;
-};
-
-static void *
-dh_blocking_gen(void *arg)
-{
-    struct dh_blocking_gen_arg *gen = (struct dh_blocking_gen_arg *)arg;
-    gen->result = DH_generate_parameters_ex(gen->dh, gen->size, gen->gen, gen->cb);
-    return 0;
-}
-
-static DH *
-dh_generate(int size, int gen)
-{
-    struct ossl_generate_cb_arg cb_arg = { 0 };
-    struct dh_blocking_gen_arg gen_arg;
-    DH *dh = DH_new();
-    BN_GENCB *cb = BN_GENCB_new();
-
-    if (!dh || !cb) {
-	DH_free(dh);
-	BN_GENCB_free(cb);
-	return NULL;
-    }
-
-    if (rb_block_given_p())
-	cb_arg.yield = 1;
-    BN_GENCB_set(cb, ossl_generate_cb_2, &cb_arg);
-    gen_arg.dh = dh;
-    gen_arg.size = size;
-    gen_arg.gen = gen;
-    gen_arg.cb = cb;
-    if (cb_arg.yield == 1) {
-	/* we cannot release GVL when callback proc is supplied */
-	dh_blocking_gen(&gen_arg);
-    } else {
-	/* there's a chance to unblock */
-	rb_thread_call_without_gvl(dh_blocking_gen, &gen_arg, ossl_generate_cb_stop, &cb_arg);
-    }
-
-    BN_GENCB_free(cb);
-    if (!gen_arg.result) {
-	DH_free(dh);
-	if (cb_arg.state) {
-	    /* Clear OpenSSL error queue before re-raising. */
-	    ossl_clear_error();
-	    rb_jump_tag(cb_arg.state);
-	}
-	return NULL;
-    }
-
-    if (!DH_generate_key(dh)) {
-        DH_free(dh);
-        return NULL;
-    }
-
-    return dh;
-}
-
-/*
- *  call-seq:
- *     DH.generate(size [, generator]) -> dh
- *
- * Creates a new DH instance from scratch by generating the private and public
- * components alike.
- *
- * === Parameters
- * * _size_ is an integer representing the desired key size. Keys smaller than 1024 bits should be considered insecure.
- * * _generator_ is a small number > 1, typically 2 or 5.
- *
- */
-static VALUE
-ossl_dh_s_generate(int argc, VALUE *argv, VALUE klass)
-{
-    DH *dh ;
-    int g = 2;
-    VALUE size, gen, obj;
-
-    if (rb_scan_args(argc, argv, "11", &size, &gen) == 2) {
-	g = NUM2INT(gen);
-    }
-    dh = dh_generate(NUM2INT(size), g);
-    obj = dh_instance(klass, dh);
-    if (obj == Qfalse) {
-	DH_free(dh);
-	ossl_raise(eDHError, NULL);
-    }
-
-    return obj;
-}
-
 /*
  * call-seq:
  *   DH.new -> dh
  *   DH.new(string) -> dh
  *   DH.new(size [, generator]) -> dh
  *
- * Either generates a DH instance from scratch or by reading already existing
- * DH parameters from _string_. Note that when reading a DH instance from
- * data that was encoded from a DH instance by using DH#to_pem or DH#to_der
- * the result will *not* contain a public/private key pair yet. This needs to
- * be generated using DH#generate_key! first.
+ * Creates a new instance of OpenSSL::PKey::DH.
+ *
+ * If called without arguments, an empty instance without any parameter or key
+ * components is created. Use #set_pqg to manually set the parameters afterwards
+ * (and optionally #set_key to set private and public key components).
+ *
+ * If a String is given, tries to parse it as a DER- or PEM- encoded parameters.
+ * See also OpenSSL::PKey.read which can parse keys of any kinds.
+ *
+ * The DH.new(size [, generator]) form is an alias of DH.generate.
+ *
+ * +string+::
+ *   A String that contains the DER or PEM encoded key.
+ * +size+::
+ *   See DH.generate.
+ * +generator+::
+ *   See DH.generate.
+ *
+ * Examples:
+ *   # Creating an instance from scratch
+ *   # Note that this is deprecated and will not work on OpenSSL 3.0 or later.
+ *   dh = OpenSSL::PKey::DH.new
+ *   dh.set_pqg(bn_p, nil, bn_g)
  *
- * === Parameters
- * * _size_ is an integer representing the desired key size. Keys smaller than 1024 bits should be considered insecure.
- * * _generator_ is a small number > 1, typically 2 or 5.
- * * _string_ contains the DER or PEM encoded key.
+ *   # Generating a parameters and a key pair
+ *   dh = OpenSSL::PKey::DH.new(2048) # An alias of OpenSSL::PKey::DH.generate(2048)
  *
- * === Examples
- *  DH.new # -> dh
- *  DH.new(1024) # -> dh
- *  DH.new(1024, 5) # -> dh
- *  #Reading DH parameters
- *  dh = DH.new(File.read('parameters.pem')) # -> dh, but no public/private key yet
- *  dh.generate_key! # -> dh with public and private key
+ *   # Reading DH parameters
+ *   dh_params = OpenSSL::PKey::DH.new(File.read('parameters.pem')) # loads parameters only
+ *   dh = OpenSSL::PKey.generate_key(dh_params) # generates a key pair
  */
 static VALUE
 ossl_dh_initialize(int argc, VALUE *argv, VALUE self)
 {
     EVP_PKEY *pkey;
+    int type;
     DH *dh;
-    int g = 2;
-    BIO *in;
-    VALUE arg, gen;
-
-    GetPKey(self, pkey);
-    if(rb_scan_args(argc, argv, "02", &arg, &gen) == 0) {
-      dh = DH_new();
-    }
-    else if (RB_INTEGER_TYPE_P(arg)) {
-	if (!NIL_P(gen)) {
-	    g = NUM2INT(gen);
-	}
-	if (!(dh = dh_generate(NUM2INT(arg), g))) {
-	    ossl_raise(eDHError, NULL);
-	}
+    BIO *in = NULL;
+    VALUE arg;
+
+    TypedData_Get_Struct(self, EVP_PKEY, &ossl_evp_pkey_type, pkey);
+    if (pkey)
+        rb_raise(rb_eTypeError, "pkey already initialized");
+
+    /* The DH.new(size, generator) form is handled by lib/openssl/pkey.rb */
+    if (rb_scan_args(argc, argv, "01", &arg) == 0) {
+        dh = DH_new();
+        if (!dh)
+            ossl_raise(eDHError, "DH_new");
+        goto legacy;
     }
-    else {
-	arg = ossl_to_der_if_possible(arg);
-	in = ossl_obj2bio(&arg);
-	dh = PEM_read_bio_DHparams(in, NULL, NULL, NULL);
-	if (!dh){
-	    OSSL_BIO_reset(in);
-	    dh = d2i_DHparams_bio(in, NULL);
-	}
-	BIO_free(in);
-	if (!dh) {
-	    ossl_raise(eDHError, NULL);
-	}
+
+    arg = ossl_to_der_if_possible(arg);
+    in = ossl_obj2bio(&arg);
+
+    /*
+     * On OpenSSL <= 1.1.1 and current versions of LibreSSL, the generic
+     * routine does not support DER-encoded parameters
+     */
+    dh = d2i_DHparams_bio(in, NULL);
+    if (dh)
+        goto legacy;
+    OSSL_BIO_reset(in);
+
+    pkey = ossl_pkey_read_generic(in, Qnil);
+    BIO_free(in);
+    if (!pkey)
+        ossl_raise(eDHError, "could not parse pkey");
+
+    type = EVP_PKEY_base_id(pkey);
+    if (type != EVP_PKEY_DH) {
+        EVP_PKEY_free(pkey);
+        rb_raise(eDHError, "incorrect pkey type: %s", OBJ_nid2sn(type));
     }
-    if (!EVP_PKEY_assign_DH(pkey, dh)) {
-	DH_free(dh);
-	ossl_raise(eDHError, NULL);
+    RTYPEDDATA_DATA(self) = pkey;
+    return self;
+
+  legacy:
+    BIO_free(in);
+    pkey = EVP_PKEY_new();
+    if (!pkey || EVP_PKEY_assign_DH(pkey, dh) != 1) {
+        EVP_PKEY_free(pkey);
+        DH_free(dh);
+        ossl_raise(eDHError, "EVP_PKEY_assign_DH");
     }
+    RTYPEDDATA_DATA(self) = pkey;
     return self;
 }
 
+#ifndef HAVE_EVP_PKEY_DUP
 static VALUE
 ossl_dh_initialize_copy(VALUE self, VALUE other)
 {
@@ -247,15 +135,14 @@ ossl_dh_initialize_copy(VALUE self, VALUE other)
     DH *dh, *dh_other;
     const BIGNUM *pub, *priv;
 
-    GetPKey(self, pkey);
-    if (EVP_PKEY_base_id(pkey) != EVP_PKEY_NONE)
-	ossl_raise(eDHError, "DH already initialized");
+    TypedData_Get_Struct(self, EVP_PKEY, &ossl_evp_pkey_type, pkey);
+    if (pkey)
+        rb_raise(rb_eTypeError, "pkey already initialized");
     GetDH(other, dh_other);
 
     dh = DHparams_dup(dh_other);
     if (!dh)
 	ossl_raise(eDHError, "DHparams_dup");
-    EVP_PKEY_assign_DH(pkey, dh);
 
     DH_get0_key(dh_other, &pub, &priv);
     if (pub) {
@@ -270,8 +157,16 @@ ossl_dh_initialize_copy(VALUE self, VALUE other)
 	DH_set0_key(dh, pub2, priv2);
     }
 
+    pkey = EVP_PKEY_new();
+    if (!pkey || EVP_PKEY_assign_DH(pkey, dh) != 1) {
+        EVP_PKEY_free(pkey);
+        DH_free(dh);
+        ossl_raise(eDHError, "EVP_PKEY_assign_DH");
+    }
+    RTYPEDDATA_DATA(self) = pkey;
     return self;
 }
+#endif
 
 /*
  *  call-seq:
@@ -403,72 +298,6 @@ ossl_dh_get_params(VALUE self)
     return hash;
 }
 
-/*
- *  call-seq:
- *     dh.to_text -> aString
- *
- * Prints all parameters of key to buffer
- * INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!!
- * Don't use :-)) (I's up to you)
- */
-static VALUE
-ossl_dh_to_text(VALUE self)
-{
-    DH *dh;
-    BIO *out;
-    VALUE str;
-
-    GetDH(self, dh);
-    if (!(out = BIO_new(BIO_s_mem()))) {
-	ossl_raise(eDHError, NULL);
-    }
-    if (!DHparams_print(out, dh)) {
-	BIO_free(out);
-	ossl_raise(eDHError, NULL);
-    }
-    str = ossl_membio2str(out);
-
-    return str;
-}
-
-/*
- *  call-seq:
- *     dh.public_key -> aDH
- *
- * Returns a new DH instance that carries just the public information, i.e.
- * the prime _p_ and the generator _g_, but no public/private key yet. Such
- * a pair may be generated using DH#generate_key!. The "public key" needed
- * for a key exchange with DH#compute_key is considered as per-session
- * information and may be retrieved with DH#pub_key once a key pair has
- * been generated.
- * If the current instance already contains private information (and thus a
- * valid public/private key pair), this information will no longer be present
- * in the new instance generated by DH#public_key. This feature is helpful for
- * publishing the Diffie-Hellman parameters without leaking any of the private
- * per-session information.
- *
- * === Example
- *  dh = OpenSSL::PKey::DH.new(2048) # has public and private key set
- *  public_key = dh.public_key # contains only prime and generator
- *  parameters = public_key.to_der # it's safe to publish this
- */
-static VALUE
-ossl_dh_to_public_key(VALUE self)
-{
-    DH *orig_dh, *dh;
-    VALUE obj;
-
-    GetDH(self, orig_dh);
-    dh = DHparams_dup(orig_dh); /* err check perfomed by dh_instance */
-    obj = dh_instance(rb_obj_class(self), dh);
-    if (obj == Qfalse) {
-	DH_free(dh);
-	ossl_raise(eDHError, NULL);
-    }
-
-    return obj;
-}
-
 /*
  *  call-seq:
  *     dh.params_ok? -> true | false
@@ -476,80 +305,38 @@ ossl_dh_to_public_key(VALUE self)
  * Validates the Diffie-Hellman parameters associated with this instance.
  * It checks whether a safe prime and a suitable generator are used. If this
  * is not the case, +false+ is returned.
+ *
+ * See also the man page EVP_PKEY_param_check(3).
  */
 static VALUE
 ossl_dh_check_params(VALUE self)
 {
-    DH *dh;
-    int codes;
-
-    GetDH(self, dh);
-    if (!DH_check(dh, &codes)) {
-	return Qfalse;
-    }
-
-    return codes == 0 ? Qtrue : Qfalse;
-}
+    int ret;
+#ifdef HAVE_EVP_PKEY_CHECK
+    EVP_PKEY *pkey;
+    EVP_PKEY_CTX *pctx;
 
-/*
- *  call-seq:
- *     dh.generate_key! -> self
- *
- * Generates a private and public key unless a private key already exists.
- * If this DH instance was generated from public DH parameters (e.g. by
- * encoding the result of DH#public_key), then this method needs to be
- * called first in order to generate the per-session keys before performing
- * the actual key exchange.
- *
- * === Example
- *   dh = OpenSSL::PKey::DH.new(2048)
- *   public_key = dh.public_key #contains no private/public key yet
- *   public_key.generate_key!
- *   puts public_key.private? # => true
- */
-static VALUE
-ossl_dh_generate_key(VALUE self)
-{
+    GetPKey(self, pkey);
+    pctx = EVP_PKEY_CTX_new(pkey, /* engine */NULL);
+    if (!pctx)
+        ossl_raise(eDHError, "EVP_PKEY_CTX_new");
+    ret = EVP_PKEY_param_check(pctx);
+    EVP_PKEY_CTX_free(pctx);
+#else
     DH *dh;
+    int codes;
 
     GetDH(self, dh);
-    if (!DH_generate_key(dh))
-	ossl_raise(eDHError, "Failed to generate key");
-    return self;
-}
-
-/*
- *  call-seq:
- *     dh.compute_key(pub_bn) -> aString
- *
- * Returns a String containing a shared secret computed from the other party's public value.
- * See DH_compute_key() for further information.
- *
- * === Parameters
- * * _pub_bn_ is a OpenSSL::BN, *not* the DH instance returned by
- *   DH#public_key as that contains the DH parameters only.
- */
-static VALUE
-ossl_dh_compute_key(VALUE self, VALUE pub)
-{
-    DH *dh;
-    const BIGNUM *pub_key, *dh_p;
-    VALUE str;
-    int len;
+    ret = DH_check(dh, &codes) == 1 && codes == 0;
+#endif
 
-    GetDH(self, dh);
-    DH_get0_pqg(dh, &dh_p, NULL, NULL);
-    if (!dh_p)
-	ossl_raise(eDHError, "incomplete DH");
-    pub_key = GetBNPtr(pub);
-    len = DH_size(dh);
-    str = rb_str_new(0, len);
-    if ((len = DH_compute_key((unsigned char *)RSTRING_PTR(str), pub_key, dh)) < 0) {
-	ossl_raise(eDHError, NULL);
+    if (ret == 1)
+        return Qtrue;
+    else {
+        /* DH_check_ex() will put error entry on failure */
+        ossl_clear_error();
+        return Qfalse;
     }
-    rb_str_set_len(str, len);
-
-    return str;
 }
 
 /*
@@ -606,30 +393,33 @@ Init_ossl_dh(void)
      *   The per-session private key, an OpenSSL::BN.
      *
      * === Example of a key exchange
-     *  dh1 = OpenSSL::PKey::DH.new(2048)
-     *  der = dh1.public_key.to_der #you may send this publicly to the participating party
-     *  dh2 = OpenSSL::PKey::DH.new(der)
-     *  dh2.generate_key! #generate the per-session key pair
-     *  symm_key1 = dh1.compute_key(dh2.pub_key)
-     *  symm_key2 = dh2.compute_key(dh1.pub_key)
+     *   # you may send the parameters (der) and own public key (pub1) publicly
+     *   # to the participating party
+     *   dh1 = OpenSSL::PKey::DH.new(2048)
+     *   der = dh1.to_der
+     *   pub1 = dh1.pub_key
      *
-     *  puts symm_key1 == symm_key2 # => true
+     *   # the other party generates its per-session key pair
+     *   dhparams = OpenSSL::PKey::DH.new(der)
+     *   dh2 = OpenSSL::PKey.generate_key(dhparams)
+     *   pub2 = dh2.pub_key
+     *
+     *   symm_key1 = dh1.compute_key(pub2)
+     *   symm_key2 = dh2.compute_key(pub1)
+     *   puts symm_key1 == symm_key2 # => true
      */
     cDH = rb_define_class_under(mPKey, "DH", cPKey);
-    rb_define_singleton_method(cDH, "generate", ossl_dh_s_generate, -1);
     rb_define_method(cDH, "initialize", ossl_dh_initialize, -1);
+#ifndef HAVE_EVP_PKEY_DUP
     rb_define_method(cDH, "initialize_copy", ossl_dh_initialize_copy, 1);
+#endif
     rb_define_method(cDH, "public?", ossl_dh_is_public, 0);
     rb_define_method(cDH, "private?", ossl_dh_is_private, 0);
-    rb_define_method(cDH, "to_text", ossl_dh_to_text, 0);
     rb_define_method(cDH, "export", ossl_dh_export, 0);
     rb_define_alias(cDH, "to_pem", "export");
     rb_define_alias(cDH, "to_s", "export");
     rb_define_method(cDH, "to_der", ossl_dh_to_der, 0);
-    rb_define_method(cDH, "public_key", ossl_dh_to_public_key, 0);
     rb_define_method(cDH, "params_ok?", ossl_dh_check_params, 0);
-    rb_define_method(cDH, "generate_key!", ossl_dh_generate_key, 0);
-    rb_define_method(cDH, "compute_key", ossl_dh_compute_key, 1);
 
     DEF_OSSL_PKEY_BN(cDH, dh, p);
     DEF_OSSL_PKEY_BN(cDH, dh, q);
diff --git a/ext/openssl/ossl_pkey_dsa.c b/ext/openssl/ossl_pkey_dsa.c
index 431c20e..25404aa 100644
--- a/ext/openssl/ossl_pkey_dsa.c
+++ b/ext/openssl/ossl_pkey_dsa.c
@@ -43,246 +43,131 @@ DSA_PRIVATE(VALUE obj, DSA *dsa)
 VALUE cDSA;
 VALUE eDSAError;
 
-/*
- * Public
- */
-static VALUE
-dsa_instance(VALUE klass, DSA *dsa)
-{
-    EVP_PKEY *pkey;
-    VALUE obj;
-
-    if (!dsa) {
-	return Qfalse;
-    }
-    obj = NewPKey(klass);
-    if (!(pkey = EVP_PKEY_new())) {
-	return Qfalse;
-    }
-    if (!EVP_PKEY_assign_DSA(pkey, dsa)) {
-	EVP_PKEY_free(pkey);
-	return Qfalse;
-    }
-    SetPKey(obj, pkey);
-
-    return obj;
-}
-
-VALUE
-ossl_dsa_new(EVP_PKEY *pkey)
-{
-    VALUE obj;
-
-    if (!pkey) {
-	obj = dsa_instance(cDSA, DSA_new());
-    } else {
-	obj = NewPKey(cDSA);
-	if (EVP_PKEY_base_id(pkey) != EVP_PKEY_DSA) {
-	    ossl_raise(rb_eTypeError, "Not a DSA key!");
-	}
-	SetPKey(obj, pkey);
-    }
-    if (obj == Qfalse) {
-	ossl_raise(eDSAError, NULL);
-    }
-
-    return obj;
-}
-
 /*
  * Private
  */
-struct dsa_blocking_gen_arg {
-    DSA *dsa;
-    int size;
-    int *counter;
-    unsigned long *h;
-    BN_GENCB *cb;
-    int result;
-};
-
-static void *
-dsa_blocking_gen(void *arg)
-{
-    struct dsa_blocking_gen_arg *gen = (struct dsa_blocking_gen_arg *)arg;
-    gen->result = DSA_generate_parameters_ex(gen->dsa, gen->size, NULL, 0,
-					     gen->counter, gen->h, gen->cb);
-    return 0;
-}
-
-static DSA *
-dsa_generate(int size)
-{
-    struct ossl_generate_cb_arg cb_arg = { 0 };
-    struct dsa_blocking_gen_arg gen_arg;
-    DSA *dsa = DSA_new();
-    BN_GENCB *cb = BN_GENCB_new();
-    int counter;
-    unsigned long h;
-
-    if (!dsa || !cb) {
-	DSA_free(dsa);
-	BN_GENCB_free(cb);
-	return NULL;
-    }
-
-    if (rb_block_given_p())
-	cb_arg.yield = 1;
-    BN_GENCB_set(cb, ossl_generate_cb_2, &cb_arg);
-    gen_arg.dsa = dsa;
-    gen_arg.size = size;
-    gen_arg.counter = &counter;
-    gen_arg.h = &h;
-    gen_arg.cb = cb;
-    if (cb_arg.yield == 1) {
-	/* we cannot release GVL when callback proc is supplied */
-	dsa_blocking_gen(&gen_arg);
-    } else {
-	/* there's a chance to unblock */
-	rb_thread_call_without_gvl(dsa_blocking_gen, &gen_arg, ossl_generate_cb_stop, &cb_arg);
-    }
-
-    BN_GENCB_free(cb);
-    if (!gen_arg.result) {
-	DSA_free(dsa);
-	if (cb_arg.state) {
-	    /* Clear OpenSSL error queue before re-raising. By the way, the
-	     * documentation of DSA_generate_parameters_ex() says the error code
-	     * can be obtained by ERR_get_error(), but the default
-	     * implementation, dsa_builtin_paramgen() doesn't put any error... */
-	    ossl_clear_error();
-	    rb_jump_tag(cb_arg.state);
-	}
-	return NULL;
-    }
-
-    if (!DSA_generate_key(dsa)) {
-	DSA_free(dsa);
-	return NULL;
-    }
-
-    return dsa;
-}
-
-/*
- *  call-seq:
- *    DSA.generate(size) -> dsa
- *
- * Creates a new DSA instance by generating a private/public key pair
- * from scratch.
- *
- * === Parameters
- * * _size_ is an integer representing the desired key size.
- *
- */
-static VALUE
-ossl_dsa_s_generate(VALUE klass, VALUE size)
-{
-    DSA *dsa = dsa_generate(NUM2INT(size)); /* err handled by dsa_instance */
-    VALUE obj = dsa_instance(klass, dsa);
-
-    if (obj == Qfalse) {
-	DSA_free(dsa);
-	ossl_raise(eDSAError, NULL);
-    }
-
-    return obj;
-}
-
 /*
  *  call-seq:
  *    DSA.new -> dsa
- *    DSA.new(size) -> dsa
  *    DSA.new(string [, pass]) -> dsa
+ *    DSA.new(size) -> dsa
  *
  * Creates a new DSA instance by reading an existing key from _string_.
  *
- * === Parameters
- * * _size_ is an integer representing the desired key size.
- * * _string_ contains a DER or PEM encoded key.
- * * _pass_ is a string that contains an optional password.
+ * If called without arguments, creates a new instance with no key components
+ * set. They can be set individually by #set_pqg and #set_key.
  *
- * === Examples
- *  DSA.new -> dsa
- *  DSA.new(1024) -> dsa
- *  DSA.new(File.read('dsa.pem')) -> dsa
- *  DSA.new(File.read('dsa.pem'), 'mypassword') -> dsa
+ * If called with a String, tries to parse as DER or PEM encoding of a \DSA key.
+ * See also OpenSSL::PKey.read which can parse keys of any kinds.
  *
+ * If called with a number, generates random parameters and a key pair. This
+ * form works as an alias of DSA.generate.
+ *
+ * +string+::
+ *   A String that contains a DER or PEM encoded key.
+ * +pass+::
+ *   A String that contains an optional password.
+ * +size+::
+ *   See DSA.generate.
+ *
+ * Examples:
+ *   p OpenSSL::PKey::DSA.new(1024)
+ *   #=> #<OpenSSL::PKey::DSA:0x000055a8d6025bf0 oid=DSA>
+ *
+ *   p OpenSSL::PKey::DSA.new(File.read('dsa.pem'))
+ *   #=> #<OpenSSL::PKey::DSA:0x000055555d6b8110 oid=DSA>
+ *
+ *   p OpenSSL::PKey::DSA.new(File.read('dsa.pem'), 'mypassword')
+ *   #=> #<OpenSSL::PKey::DSA:0x0000556f973c40b8 oid=DSA>
  */
 static VALUE
 ossl_dsa_initialize(int argc, VALUE *argv, VALUE self)
 {
     EVP_PKEY *pkey;
     DSA *dsa;
-    BIO *in;
+    BIO *in = NULL;
     VALUE arg, pass;
+    int type;
+
+    TypedData_Get_Struct(self, EVP_PKEY, &ossl_evp_pkey_type, pkey);
+    if (pkey)
+        rb_raise(rb_eTypeError, "pkey already initialized");
 
-    GetPKey(self, pkey);
-    if(rb_scan_args(argc, argv, "02", &arg, &pass) == 0) {
+    /* The DSA.new(size, generator) form is handled by lib/openssl/pkey.rb */
+    rb_scan_args(argc, argv, "02", &arg, &pass);
+    if (argc == 0) {
         dsa = DSA_new();
+        if (!dsa)
+            ossl_raise(eDSAError, "DSA_new");
+        goto legacy;
     }
-    else if (RB_INTEGER_TYPE_P(arg)) {
-	if (!(dsa = dsa_generate(NUM2INT(arg)))) {
-	    ossl_raise(eDSAError, NULL);
-	}
-    }
-    else {
-	pass = ossl_pem_passwd_value(pass);
-	arg = ossl_to_der_if_possible(arg);
-	in = ossl_obj2bio(&arg);
-	dsa = PEM_read_bio_DSAPrivateKey(in, NULL, ossl_pem_passwd_cb, (void *)pass);
-	if (!dsa) {
-	    OSSL_BIO_reset(in);
-	    dsa = PEM_read_bio_DSA_PUBKEY(in, NULL, NULL, NULL);
-	}
-	if (!dsa) {
-	    OSSL_BIO_reset(in);
-	    dsa = d2i_DSAPrivateKey_bio(in, NULL);
-	}
-	if (!dsa) {
-	    OSSL_BIO_reset(in);
-	    dsa = d2i_DSA_PUBKEY_bio(in, NULL);
-	}
-	if (!dsa) {
-	    OSSL_BIO_reset(in);
-#define PEM_read_bio_DSAPublicKey(bp,x,cb,u) (DSA *)PEM_ASN1_read_bio( \
-	(d2i_of_void *)d2i_DSAPublicKey, PEM_STRING_DSA_PUBLIC, (bp), (void **)(x), (cb), (u))
-	    dsa = PEM_read_bio_DSAPublicKey(in, NULL, NULL, NULL);
-#undef PEM_read_bio_DSAPublicKey
-	}
-	BIO_free(in);
-	if (!dsa) {
-	    ossl_clear_error();
-	    ossl_raise(eDSAError, "Neither PUB key nor PRIV key");
-	}
-    }
-    if (!EVP_PKEY_assign_DSA(pkey, dsa)) {
-	DSA_free(dsa);
-	ossl_raise(eDSAError, NULL);
+
+    pass = ossl_pem_passwd_value(pass);
+    arg = ossl_to_der_if_possible(arg);
+    in = ossl_obj2bio(&arg);
+
+    /* DER-encoded DSAPublicKey format isn't supported by the generic routine */
+    dsa = (DSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_DSAPublicKey,
+                                   PEM_STRING_DSA_PUBLIC,
+                                   in, NULL, NULL, NULL);
+    if (dsa)
+        goto legacy;
+    OSSL_BIO_reset(in);
+
+    pkey = ossl_pkey_read_generic(in, pass);
+    BIO_free(in);
+    if (!pkey)
+        ossl_raise(eDSAError, "Neither PUB key nor PRIV key");
+
+    type = EVP_PKEY_base_id(pkey);
+    if (type != EVP_PKEY_DSA) {
+        EVP_PKEY_free(pkey);
+        rb_raise(eDSAError, "incorrect pkey type: %s", OBJ_nid2sn(type));
     }
+    RTYPEDDATA_DATA(self) = pkey;
+    return self;
 
+  legacy:
+    BIO_free(in);
+    pkey = EVP_PKEY_new();
+    if (!pkey || EVP_PKEY_assign_DSA(pkey, dsa) != 1) {
+        EVP_PKEY_free(pkey);
+        DSA_free(dsa);
+        ossl_raise(eDSAError, "EVP_PKEY_assign_DSA");
+    }
+    RTYPEDDATA_DATA(self) = pkey;
     return self;
 }
 
+#ifndef HAVE_EVP_PKEY_DUP
 static VALUE
 ossl_dsa_initialize_copy(VALUE self, VALUE other)
 {
     EVP_PKEY *pkey;
     DSA *dsa, *dsa_new;
 
-    GetPKey(self, pkey);
-    if (EVP_PKEY_base_id(pkey) != EVP_PKEY_NONE)
-	ossl_raise(eDSAError, "DSA already initialized");
+    TypedData_Get_Struct(self, EVP_PKEY, &ossl_evp_pkey_type, pkey);
+    if (pkey)
+        rb_raise(rb_eTypeError, "pkey already initialized");
     GetDSA(other, dsa);
 
-    dsa_new = ASN1_dup((i2d_of_void *)i2d_DSAPrivateKey, (d2i_of_void *)d2i_DSAPrivateKey, (char *)dsa);
+    dsa_new = (DSA *)ASN1_dup((i2d_of_void *)i2d_DSAPrivateKey,
+                              (d2i_of_void *)d2i_DSAPrivateKey,
+                              (char *)dsa);
     if (!dsa_new)
 	ossl_raise(eDSAError, "ASN1_dup");
 
-    EVP_PKEY_assign_DSA(pkey, dsa_new);
+    pkey = EVP_PKEY_new();
+    if (!pkey || EVP_PKEY_assign_DSA(pkey, dsa_new) != 1) {
+        EVP_PKEY_free(pkey);
+        DSA_free(dsa_new);
+        ossl_raise(eDSAError, "EVP_PKEY_assign_DSA");
+    }
+    RTYPEDDATA_DATA(self) = pkey;
 
     return self;
 }
+#endif
 
 /*
  *  call-seq:
@@ -341,34 +226,12 @@ static VALUE
 ossl_dsa_export(int argc, VALUE *argv, VALUE self)
 {
     DSA *dsa;
-    BIO *out;
-    const EVP_CIPHER *ciph = NULL;
-    VALUE cipher, pass, str;
 
     GetDSA(self, dsa);
-    rb_scan_args(argc, argv, "02", &cipher, &pass);
-    if (!NIL_P(cipher)) {
-	ciph = ossl_evp_get_cipherbyname(cipher);
-	pass = ossl_pem_passwd_value(pass);
-    }
-    if (!(out = BIO_new(BIO_s_mem()))) {
-	ossl_raise(eDSAError, NULL);
-    }
-    if (DSA_HAS_PRIVATE(dsa)) {
-	if (!PEM_write_bio_DSAPrivateKey(out, dsa, ciph, NULL, 0,
-					 ossl_pem_passwd_cb, (void *)pass)){
-	    BIO_free(out);
-	    ossl_raise(eDSAError, NULL);
-	}
-    } else {
-	if (!PEM_write_bio_DSA_PUBKEY(out, dsa)) {
-	    BIO_free(out);
-	    ossl_raise(eDSAError, NULL);
-	}
-    }
-    str = ossl_membio2str(out);
-
-    return str;
+    if (DSA_HAS_PRIVATE(dsa))
+        return ossl_pkey_export_traditional(argc, argv, self, 0);
+    else
+        return ossl_pkey_export_spki(self, 0);
 }
 
 /*
@@ -382,25 +245,12 @@ static VALUE
 ossl_dsa_to_der(VALUE self)
 {
     DSA *dsa;
-    int (*i2d_func)(DSA *, unsigned char **);
-    unsigned char *p;
-    long len;
-    VALUE str;
 
     GetDSA(self, dsa);
-    if(DSA_HAS_PRIVATE(dsa))
-	i2d_func = (int (*)(DSA *,unsigned char **))i2d_DSAPrivateKey;
+    if (DSA_HAS_PRIVATE(dsa))
+        return ossl_pkey_export_traditional(0, NULL, self, 1);
     else
-	i2d_func = i2d_DSA_PUBKEY;
-    if((len = i2d_func(dsa, NULL)) <= 0)
-	ossl_raise(eDSAError, NULL);
-    str = rb_str_new(0, len);
-    p = (unsigned char *)RSTRING_PTR(str);
-    if(i2d_func(dsa, &p) < 0)
-	ossl_raise(eDSAError, NULL);
-    ossl_str_adjust(str, p);
-
-    return str;
+        return ossl_pkey_export_spki(self, 1);
 }
 
 
@@ -433,158 +283,6 @@ ossl_dsa_get_params(VALUE self)
     return hash;
 }
 
-/*
- *  call-seq:
- *    dsa.to_text -> aString
- *
- * Prints all parameters of key to buffer
- * INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!!
- * Don't use :-)) (I's up to you)
- */
-static VALUE
-ossl_dsa_to_text(VALUE self)
-{
-    DSA *dsa;
-    BIO *out;
-    VALUE str;
-
-    GetDSA(self, dsa);
-    if (!(out = BIO_new(BIO_s_mem()))) {
-	ossl_raise(eDSAError, NULL);
-    }
-    if (!DSA_print(out, dsa, 0)) { /* offset = 0 */
-	BIO_free(out);
-	ossl_raise(eDSAError, NULL);
-    }
-    str = ossl_membio2str(out);
-
-    return str;
-}
-
-/*
- *  call-seq:
- *    dsa.public_key -> aDSA
- *
- * Returns a new DSA instance that carries just the public key information.
- * If the current instance has also private key information, this will no
- * longer be present in the new instance. This feature is helpful for
- * publishing the public key information without leaking any of the private
- * information.
- *
- * === Example
- *  dsa = OpenSSL::PKey::DSA.new(2048) # has public and private information
- *  pub_key = dsa.public_key # has only the public part available
- *  pub_key_der = pub_key.to_der # it's safe to publish this
- *
- *
- */
-static VALUE
-ossl_dsa_to_public_key(VALUE self)
-{
-    EVP_PKEY *pkey;
-    DSA *dsa;
-    VALUE obj;
-
-    GetPKeyDSA(self, pkey);
-    /* err check performed by dsa_instance */
-#define DSAPublicKey_dup(dsa) (DSA *)ASN1_dup( \
-	(i2d_of_void *)i2d_DSAPublicKey, (d2i_of_void *)d2i_DSAPublicKey, (char *)(dsa))
-    dsa = DSAPublicKey_dup(EVP_PKEY_get0_DSA(pkey));
-#undef DSAPublicKey_dup
-    obj = dsa_instance(rb_obj_class(self), dsa);
-    if (obj == Qfalse) {
-	DSA_free(dsa);
-	ossl_raise(eDSAError, NULL);
-    }
-    return obj;
-}
-
-/*
- *  call-seq:
- *    dsa.syssign(string) -> aString
- *
- * Computes and returns the DSA signature of _string_, where _string_ is
- * expected to be an already-computed message digest of the original input
- * data. The signature is issued using the private key of this DSA instance.
- *
- * === Parameters
- * * _string_ is a message digest of the original input data to be signed.
- *
- * === Example
- *  dsa = OpenSSL::PKey::DSA.new(2048)
- *  doc = "Sign me"
- *  digest = OpenSSL::Digest.digest('SHA1', doc)
- *  sig = dsa.syssign(digest)
- *
- *
- */
-static VALUE
-ossl_dsa_sign(VALUE self, VALUE data)
-{
-    DSA *dsa;
-    const BIGNUM *dsa_q;
-    unsigned int buf_len;
-    VALUE str;
-
-    GetDSA(self, dsa);
-    DSA_get0_pqg(dsa, NULL, &dsa_q, NULL);
-    if (!dsa_q)
-	ossl_raise(eDSAError, "incomplete DSA");
-    if (!DSA_PRIVATE(self, dsa))
-	ossl_raise(eDSAError, "Private DSA key needed!");
-    StringValue(data);
-    str = rb_str_new(0, DSA_size(dsa));
-    if (!DSA_sign(0, (unsigned char *)RSTRING_PTR(data), RSTRING_LENINT(data),
-		  (unsigned char *)RSTRING_PTR(str),
-		  &buf_len, dsa)) { /* type is ignored (0) */
-	ossl_raise(eDSAError, NULL);
-    }
-    rb_str_set_len(str, buf_len);
-
-    return str;
-}
-
-/*
- *  call-seq:
- *    dsa.sysverify(digest, sig) -> true | false
- *
- * Verifies whether the signature is valid given the message digest input. It
- * does so by validating _sig_ using the public key of this DSA instance.
- *
- * === Parameters
- * * _digest_ is a message digest of the original input data to be signed
- * * _sig_ is a DSA signature value
- *
- * === Example
- *  dsa = OpenSSL::PKey::DSA.new(2048)
- *  doc = "Sign me"
- *  digest = OpenSSL::Digest.digest('SHA1', doc)
- *  sig = dsa.syssign(digest)
- *  puts dsa.sysverify(digest, sig) # => true
- *
- */
-static VALUE
-ossl_dsa_verify(VALUE self, VALUE digest, VALUE sig)
-{
-    DSA *dsa;
-    int ret;
-
-    GetDSA(self, dsa);
-    StringValue(digest);
-    StringValue(sig);
-    /* type is ignored (0) */
-    ret = DSA_verify(0, (unsigned char *)RSTRING_PTR(digest), RSTRING_LENINT(digest),
-		     (unsigned char *)RSTRING_PTR(sig), RSTRING_LENINT(sig), dsa);
-    if (ret < 0) {
-	ossl_raise(eDSAError, NULL);
-    }
-    else if (ret == 1) {
-	return Qtrue;
-    }
-
-    return Qfalse;
-}
-
 /*
  * Document-method: OpenSSL::PKey::DSA#set_pqg
  * call-seq:
@@ -630,20 +328,17 @@ Init_ossl_dsa(void)
      */
     cDSA = rb_define_class_under(mPKey, "DSA", cPKey);
 
-    rb_define_singleton_method(cDSA, "generate", ossl_dsa_s_generate, 1);
     rb_define_method(cDSA, "initialize", ossl_dsa_initialize, -1);
+#ifndef HAVE_EVP_PKEY_DUP
     rb_define_method(cDSA, "initialize_copy", ossl_dsa_initialize_copy, 1);
+#endif
 
     rb_define_method(cDSA, "public?", ossl_dsa_is_public, 0);
     rb_define_method(cDSA, "private?", ossl_dsa_is_private, 0);
-    rb_define_method(cDSA, "to_text", ossl_dsa_to_text, 0);
     rb_define_method(cDSA, "export", ossl_dsa_export, -1);
     rb_define_alias(cDSA, "to_pem", "export");
     rb_define_alias(cDSA, "to_s", "export");
     rb_define_method(cDSA, "to_der", ossl_dsa_to_der, 0);
-    rb_define_method(cDSA, "public_key", ossl_dsa_to_public_key, 0);
-    rb_define_method(cDSA, "syssign", ossl_dsa_sign, 1);
-    rb_define_method(cDSA, "sysverify", ossl_dsa_verify, 2);
 
     DEF_OSSL_PKEY_BN(cDSA, dsa, p);
     DEF_OSSL_PKEY_BN(cDSA, dsa, q);
diff --git a/ext/openssl/ossl_pkey_ec.c b/ext/openssl/ossl_pkey_ec.c
index 1d105ab..dee2154 100644
--- a/ext/openssl/ossl_pkey_ec.c
+++ b/ext/openssl/ossl_pkey_ec.c
@@ -47,12 +47,7 @@ VALUE eEC_GROUP;
 VALUE cEC_POINT;
 VALUE eEC_POINT;
 
-static ID s_GFp;
-static ID s_GFp_simple;
-static ID s_GFp_mont;
-static ID s_GFp_nist;
-static ID s_GF2m;
-static ID s_GF2m_simple;
+static ID s_GFp, s_GF2m;
 
 static ID ID_uncompressed;
 static ID ID_compressed;
@@ -63,47 +58,6 @@ static ID id_i_group;
 static VALUE ec_group_new(const EC_GROUP *group);
 static VALUE ec_point_new(const EC_POINT *point, const EC_GROUP *group);
 
-static VALUE ec_instance(VALUE klass, EC_KEY *ec)
-{
-    EVP_PKEY *pkey;
-    VALUE obj;
-
-    if (!ec) {
-	return Qfalse;
-    }
-    obj = NewPKey(klass);
-    if (!(pkey = EVP_PKEY_new())) {
-	return Qfalse;
-    }
-    if (!EVP_PKEY_assign_EC_KEY(pkey, ec)) {
-	EVP_PKEY_free(pkey);
-	return Qfalse;
-    }
-    SetPKey(obj, pkey);
-
-    return obj;
-}
-
-VALUE ossl_ec_new(EVP_PKEY *pkey)
-{
-    VALUE obj;
-
-    if (!pkey) {
-	obj = ec_instance(cEC, EC_KEY_new());
-    } else {
-	obj = NewPKey(cEC);
-	if (EVP_PKEY_base_id(pkey) != EVP_PKEY_EC) {
-	    ossl_raise(rb_eTypeError, "Not a EC key!");
-	}
-	SetPKey(obj, pkey);
-    }
-    if (obj == Qfalse) {
-	ossl_raise(eECError, NULL);
-    }
-
-    return obj;
-}
-
 /*
  * Creates a new EC_KEY on the EC group obj. arg can be an EC::Group or a String
  * representing an OID.
@@ -150,16 +104,20 @@ ec_key_new_from_group(VALUE arg)
 static VALUE
 ossl_ec_key_s_generate(VALUE klass, VALUE arg)
 {
+    EVP_PKEY *pkey;
     EC_KEY *ec;
     VALUE obj;
 
-    ec = ec_key_new_from_group(arg);
+    obj = rb_obj_alloc(klass);
 
-    obj = ec_instance(klass, ec);
-    if (obj == Qfalse) {
-	EC_KEY_free(ec);
-	ossl_raise(eECError, NULL);
+    ec = ec_key_new_from_group(arg);
+    pkey = EVP_PKEY_new();
+    if (!pkey || EVP_PKEY_assign_EC_KEY(pkey, ec) != 1) {
+        EVP_PKEY_free(pkey);
+        EC_KEY_free(ec);
+        ossl_raise(eECError, "EVP_PKEY_assign_EC_KEY");
     }
+    RTYPEDDATA_DATA(obj) = pkey;
 
     if (!EC_KEY_generate_key(ec))
 	ossl_raise(eECError, "EC_KEY_generate_key");
@@ -182,81 +140,82 @@ static VALUE ossl_ec_key_initialize(int argc, VALUE *argv, VALUE self)
 {
     EVP_PKEY *pkey;
     EC_KEY *ec;
+    BIO *in;
     VALUE arg, pass;
+    int type;
 
-    GetPKey(self, pkey);
-    if (EVP_PKEY_base_id(pkey) != EVP_PKEY_NONE)
-        ossl_raise(eECError, "EC_KEY already initialized");
+    TypedData_Get_Struct(self, EVP_PKEY, &ossl_evp_pkey_type, pkey);
+    if (pkey)
+        rb_raise(rb_eTypeError, "pkey already initialized");
 
     rb_scan_args(argc, argv, "02", &arg, &pass);
-
     if (NIL_P(arg)) {
         if (!(ec = EC_KEY_new()))
-	    ossl_raise(eECError, NULL);
-    } else if (rb_obj_is_kind_of(arg, cEC)) {
-	EC_KEY *other_ec = NULL;
-
-	GetEC(arg, other_ec);
-	if (!(ec = EC_KEY_dup(other_ec)))
-	    ossl_raise(eECError, NULL);
-    } else if (rb_obj_is_kind_of(arg, cEC_GROUP)) {
-	ec = ec_key_new_from_group(arg);
-    } else {
-	BIO *in;
+            ossl_raise(eECError, "EC_KEY_new");
+        goto legacy;
+    }
+    else if (rb_obj_is_kind_of(arg, cEC_GROUP)) {
+        ec = ec_key_new_from_group(arg);
+        goto legacy;
+    }
 
-	pass = ossl_pem_passwd_value(pass);
-	in = ossl_obj2bio(&arg);
+    pass = ossl_pem_passwd_value(pass);
+    arg = ossl_to_der_if_possible(arg);
+    in = ossl_obj2bio(&arg);
 
-	ec = PEM_read_bio_ECPrivateKey(in, NULL, ossl_pem_passwd_cb, (void *)pass);
-	if (!ec) {
-	    OSSL_BIO_reset(in);
-	    ec = PEM_read_bio_EC_PUBKEY(in, NULL, ossl_pem_passwd_cb, (void *)pass);
-	}
-	if (!ec) {
-	    OSSL_BIO_reset(in);
-	    ec = d2i_ECPrivateKey_bio(in, NULL);
-	}
-	if (!ec) {
-	    OSSL_BIO_reset(in);
-	    ec = d2i_EC_PUBKEY_bio(in, NULL);
-	}
-	BIO_free(in);
-
-	if (!ec) {
-	    ossl_clear_error();
-	    ec = ec_key_new_from_group(arg);
-	}
+    pkey = ossl_pkey_read_generic(in, pass);
+    BIO_free(in);
+    if (!pkey) {
+        ossl_clear_error();
+        ec = ec_key_new_from_group(arg);
+        goto legacy;
     }
 
-    if (!EVP_PKEY_assign_EC_KEY(pkey, ec)) {
-	EC_KEY_free(ec);
-	ossl_raise(eECError, "EVP_PKEY_assign_EC_KEY");
+    type = EVP_PKEY_base_id(pkey);
+    if (type != EVP_PKEY_EC) {
+        EVP_PKEY_free(pkey);
+        rb_raise(eDSAError, "incorrect pkey type: %s", OBJ_nid2sn(type));
     }
+    RTYPEDDATA_DATA(self) = pkey;
+    return self;
 
+  legacy:
+    pkey = EVP_PKEY_new();
+    if (!pkey || EVP_PKEY_assign_EC_KEY(pkey, ec) != 1) {
+        EVP_PKEY_free(pkey);
+        EC_KEY_free(ec);
+        ossl_raise(eECError, "EVP_PKEY_assign_EC_KEY");
+    }
+    RTYPEDDATA_DATA(self) = pkey;
     return self;
 }
 
+#ifndef HAVE_EVP_PKEY_DUP
 static VALUE
 ossl_ec_key_initialize_copy(VALUE self, VALUE other)
 {
     EVP_PKEY *pkey;
     EC_KEY *ec, *ec_new;
 
-    GetPKey(self, pkey);
-    if (EVP_PKEY_base_id(pkey) != EVP_PKEY_NONE)
-	ossl_raise(eECError, "EC already initialized");
+    TypedData_Get_Struct(self, EVP_PKEY, &ossl_evp_pkey_type, pkey);
+    if (pkey)
+        rb_raise(rb_eTypeError, "pkey already initialized");
     GetEC(other, ec);
 
     ec_new = EC_KEY_dup(ec);
     if (!ec_new)
 	ossl_raise(eECError, "EC_KEY_dup");
-    if (!EVP_PKEY_assign_EC_KEY(pkey, ec_new)) {
-	EC_KEY_free(ec_new);
-	ossl_raise(eECError, "EVP_PKEY_assign_EC_KEY");
+
+    pkey = EVP_PKEY_new();
+    if (!pkey || EVP_PKEY_assign_EC_KEY(pkey, ec_new) != 1) {
+        EC_KEY_free(ec_new);
+        ossl_raise(eECError, "EVP_PKEY_assign_EC_KEY");
     }
+    RTYPEDDATA_DATA(self) = pkey;
 
     return self;
 }
+#endif
 
 /*
  * call-seq:
@@ -289,6 +248,9 @@ ossl_ec_key_get_group(VALUE self)
 static VALUE
 ossl_ec_key_set_group(VALUE self, VALUE group_v)
 {
+#if OSSL_OPENSSL_PREREQ(3, 0, 0)
+    rb_raise(ePKeyError, "pkeys are immutable on OpenSSL 3.0");
+#else
     EC_KEY *ec;
     EC_GROUP *group;
 
@@ -299,6 +261,7 @@ ossl_ec_key_set_group(VALUE self, VALUE group_v)
         ossl_raise(eECError, "EC_KEY_set_group");
 
     return group_v;
+#endif
 }
 
 /*
@@ -327,6 +290,9 @@ static VALUE ossl_ec_key_get_private_key(VALUE self)
  */
 static VALUE ossl_ec_key_set_private_key(VALUE self, VALUE private_key)
 {
+#if OSSL_OPENSSL_PREREQ(3, 0, 0)
+    rb_raise(ePKeyError, "pkeys are immutable on OpenSSL 3.0");
+#else
     EC_KEY *ec;
     BIGNUM *bn = NULL;
 
@@ -340,11 +306,13 @@ static VALUE ossl_ec_key_set_private_key(VALUE self, VALUE private_key)
     case 0:
         if (bn == NULL)
             break;
+	/* fallthrough */
     default:
         ossl_raise(eECError, "EC_KEY_set_private_key");
     }
 
     return private_key;
+#endif
 }
 
 /*
@@ -373,6 +341,9 @@ static VALUE ossl_ec_key_get_public_key(VALUE self)
  */
 static VALUE ossl_ec_key_set_public_key(VALUE self, VALUE public_key)
 {
+#if OSSL_OPENSSL_PREREQ(3, 0, 0)
+    rb_raise(ePKeyError, "pkeys are immutable on OpenSSL 3.0");
+#else
     EC_KEY *ec;
     EC_POINT *point = NULL;
 
@@ -386,11 +357,13 @@ static VALUE ossl_ec_key_set_public_key(VALUE self, VALUE public_key)
     case 0:
         if (point == NULL)
             break;
+	/* fallthrough */
     default:
         ossl_raise(eECError, "EC_KEY_set_public_key");
     }
 
     return public_key;
+#endif
 }
 
 /*
@@ -425,66 +398,6 @@ static VALUE ossl_ec_key_is_private(VALUE self)
     return EC_KEY_get0_private_key(ec) ? Qtrue : Qfalse;
 }
 
-static VALUE ossl_ec_key_to_string(VALUE self, VALUE ciph, VALUE pass, int format)
-{
-    EC_KEY *ec;
-    BIO *out;
-    int i = -1;
-    int private = 0;
-    VALUE str;
-    const EVP_CIPHER *cipher = NULL;
-
-    GetEC(self, ec);
-
-    if (EC_KEY_get0_public_key(ec) == NULL)
-        ossl_raise(eECError, "can't export - no public key set");
-
-    if (EC_KEY_check_key(ec) != 1)
-	ossl_raise(eECError, "can't export - EC_KEY_check_key failed");
-
-    if (EC_KEY_get0_private_key(ec))
-        private = 1;
-
-    if (!NIL_P(ciph)) {
-	cipher = ossl_evp_get_cipherbyname(ciph);
-	pass = ossl_pem_passwd_value(pass);
-    }
-
-    if (!(out = BIO_new(BIO_s_mem())))
-        ossl_raise(eECError, "BIO_new(BIO_s_mem())");
-
-    switch(format) {
-    case EXPORT_PEM:
-    	if (private) {
-            i = PEM_write_bio_ECPrivateKey(out, ec, cipher, NULL, 0, ossl_pem_passwd_cb, (void *)pass);
-    	} else {
-            i = PEM_write_bio_EC_PUBKEY(out, ec);
-        }
-
-    	break;
-    case EXPORT_DER:
-        if (private) {
-            i = i2d_ECPrivateKey_bio(out, ec);
-        } else {
-            i = i2d_EC_PUBKEY_bio(out, ec);
-        }
-
-    	break;
-    default:
-        BIO_free(out);
-    	ossl_raise(rb_eRuntimeError, "unknown format (internal error)");
-    }
-
-    if (i != 1) {
-        BIO_free(out);
-        ossl_raise(eECError, "outlen=%d", i);
-    }
-
-    str = ossl_membio2str(out);
-
-    return str;
-}
-
 /*
  *  call-seq:
  *     key.export([cipher, pass_phrase]) => String
@@ -495,11 +408,16 @@ static VALUE ossl_ec_key_to_string(VALUE self, VALUE ciph, VALUE pass, int forma
  * instance. Note that encryption will only be effective for a private key,
  * public keys will always be encoded in plain text.
  */
-static VALUE ossl_ec_key_export(int argc, VALUE *argv, VALUE self)
+static VALUE
+ossl_ec_key_export(int argc, VALUE *argv, VALUE self)
 {
-    VALUE cipher, passwd;
-    rb_scan_args(argc, argv, "02", &cipher, &passwd);
-    return ossl_ec_key_to_string(self, cipher, passwd, EXPORT_PEM);
+    EC_KEY *ec;
+
+    GetEC(self, ec);
+    if (EC_KEY_get0_private_key(ec))
+        return ossl_pkey_export_traditional(argc, argv, self, 0);
+    else
+        return ossl_pkey_export_spki(self, 0);
 }
 
 /*
@@ -508,36 +426,17 @@ static VALUE ossl_ec_key_export(int argc, VALUE *argv, VALUE self)
  *
  *  See the OpenSSL documentation for i2d_ECPrivateKey_bio()
  */
-static VALUE ossl_ec_key_to_der(VALUE self)
-{
-    return ossl_ec_key_to_string(self, Qnil, Qnil, EXPORT_DER);
-}
-
-/*
- *  call-seq:
- *     key.to_text   => String
- *
- *  See the OpenSSL documentation for EC_KEY_print()
- */
-static VALUE ossl_ec_key_to_text(VALUE self)
+static VALUE
+ossl_ec_key_to_der(VALUE self)
 {
     EC_KEY *ec;
-    BIO *out;
-    VALUE str;
 
     GetEC(self, ec);
-    if (!(out = BIO_new(BIO_s_mem()))) {
-	ossl_raise(eECError, "BIO_new(BIO_s_mem())");
-    }
-    if (!EC_KEY_print(out, ec, 0)) {
-	BIO_free(out);
-	ossl_raise(eECError, "EC_KEY_print");
-    }
-    str = ossl_membio2str(out);
-
-    return str;
+    if (EC_KEY_get0_private_key(ec))
+        return ossl_pkey_export_traditional(0, NULL, self, 1);
+    else
+        return ossl_pkey_export_spki(self, 1);
 }
-
 /*
  *  call-seq:
  *     key.generate_key!   => self
@@ -554,6 +453,9 @@ static VALUE ossl_ec_key_to_text(VALUE self)
  */
 static VALUE ossl_ec_key_generate_key(VALUE self)
 {
+#if OSSL_OPENSSL_PREREQ(3, 0, 0)
+    rb_raise(ePKeyError, "pkeys are immutable on OpenSSL 3.0");
+#else
     EC_KEY *ec;
 
     GetEC(self, ec);
@@ -561,116 +463,50 @@ static VALUE ossl_ec_key_generate_key(VALUE self)
 	ossl_raise(eECError, "EC_KEY_generate_key");
 
     return self;
+#endif
 }
 
 /*
- *  call-seq:
- *     key.check_key   => true
+ * call-seq:
+ *    key.check_key   => true
  *
- *  Raises an exception if the key is invalid.
+ * Raises an exception if the key is invalid.
  *
- *  See the OpenSSL documentation for EC_KEY_check_key()
+ * See also the man page EVP_PKEY_public_check(3).
  */
 static VALUE ossl_ec_key_check_key(VALUE self)
 {
+#ifdef HAVE_EVP_PKEY_CHECK
+    EVP_PKEY *pkey;
+    EVP_PKEY_CTX *pctx;
+    int ret;
+
+    GetPKey(self, pkey);
+    pctx = EVP_PKEY_CTX_new(pkey, /* engine */NULL);
+    if (!pctx)
+        ossl_raise(eDHError, "EVP_PKEY_CTX_new");
+    ret = EVP_PKEY_public_check(pctx);
+    EVP_PKEY_CTX_free(pctx);
+    if (ret != 1)
+        ossl_raise(eECError, "EVP_PKEY_public_check");
+#else
     EC_KEY *ec;
 
     GetEC(self, ec);
     if (EC_KEY_check_key(ec) != 1)
 	ossl_raise(eECError, "EC_KEY_check_key");
+#endif
 
     return Qtrue;
 }
 
-/*
- *  call-seq:
- *     key.dh_compute_key(pubkey)   => String
- *
- *  See the OpenSSL documentation for ECDH_compute_key()
- */
-static VALUE ossl_ec_key_dh_compute_key(VALUE self, VALUE pubkey)
-{
-    EC_KEY *ec;
-    EC_POINT *point;
-    int buf_len;
-    VALUE str;
-
-    GetEC(self, ec);
-    GetECPoint(pubkey, point);
-
-/* BUG: need a way to figure out the maximum string size */
-    buf_len = 1024;
-    str = rb_str_new(0, buf_len);
-/* BUG: take KDF as a block */
-    buf_len = ECDH_compute_key(RSTRING_PTR(str), buf_len, point, ec, NULL);
-    if (buf_len < 0)
-         ossl_raise(eECError, "ECDH_compute_key");
-
-    rb_str_resize(str, buf_len);
-
-    return str;
-}
-
-/* sign_setup */
-
-/*
- *  call-seq:
- *     key.dsa_sign_asn1(data)   => String
- *
- *  See the OpenSSL documentation for ECDSA_sign()
- */
-static VALUE ossl_ec_key_dsa_sign_asn1(VALUE self, VALUE data)
-{
-    EC_KEY *ec;
-    unsigned int buf_len;
-    VALUE str;
-
-    GetEC(self, ec);
-    StringValue(data);
-
-    if (EC_KEY_get0_private_key(ec) == NULL)
-	ossl_raise(eECError, "Private EC key needed!");
-
-    str = rb_str_new(0, ECDSA_size(ec));
-    if (ECDSA_sign(0, (unsigned char *) RSTRING_PTR(data), RSTRING_LENINT(data), (unsigned char *) RSTRING_PTR(str), &buf_len, ec) != 1)
-	ossl_raise(eECError, "ECDSA_sign");
-    rb_str_set_len(str, buf_len);
-
-    return str;
-}
-
-/*
- *  call-seq:
- *     key.dsa_verify_asn1(data, sig)   => true or false
- *
- *  See the OpenSSL documentation for ECDSA_verify()
- */
-static VALUE ossl_ec_key_dsa_verify_asn1(VALUE self, VALUE data, VALUE sig)
-{
-    EC_KEY *ec;
-
-    GetEC(self, ec);
-    StringValue(data);
-    StringValue(sig);
-
-    switch (ECDSA_verify(0, (unsigned char *)RSTRING_PTR(data), RSTRING_LENINT(data),
-                         (unsigned char *)RSTRING_PTR(sig), RSTRING_LENINT(sig), ec)) {
-      case 1:
-        return Qtrue;
-      case 0:
-        return Qfalse;
-      default:
-        ossl_raise(eECError, "ECDSA_verify");
-    }
-}
-
 /*
  * OpenSSL::PKey::EC::Group
  */
 static void
 ossl_ec_group_free(void *ptr)
 {
-    EC_GROUP_clear_free(ptr);
+    EC_GROUP_free(ptr);
 }
 
 static const rb_data_type_t ossl_ec_group_type = {
@@ -706,20 +542,11 @@ ec_group_new(const EC_GROUP *group)
  * call-seq:
  *   OpenSSL::PKey::EC::Group.new(ec_group)
  *   OpenSSL::PKey::EC::Group.new(pem_or_der_encoded)
- *   OpenSSL::PKey::EC::Group.new(ec_method)
  *   OpenSSL::PKey::EC::Group.new(:GFp, bignum_p, bignum_a, bignum_b)
  *   OpenSSL::PKey::EC::Group.new(:GF2m, bignum_p, bignum_a, bignum_b)
  *
  * Creates a new EC::Group object.
  *
- * _ec_method_ is a symbol that represents an EC_METHOD. Currently the following
- * are supported:
- *
- * * :GFp_simple
- * * :GFp_mont
- * * :GFp_nist
- * * :GF2m_simple
- *
  * If the first argument is :GFp or :GF2m, creates a new curve with given
  * parameters.
  */
@@ -734,29 +561,7 @@ static VALUE ossl_ec_group_initialize(int argc, VALUE *argv, VALUE self)
 
     switch (rb_scan_args(argc, argv, "13", &arg1, &arg2, &arg3, &arg4)) {
     case 1:
-        if (SYMBOL_P(arg1)) {
-            const EC_METHOD *method = NULL;
-            ID id = SYM2ID(arg1);
-
-            if (id == s_GFp_simple) {
-                method = EC_GFp_simple_method();
-            } else if (id == s_GFp_mont) {
-                method = EC_GFp_mont_method();
-            } else if (id == s_GFp_nist) {
-                method = EC_GFp_nist_method();
-#if !defined(OPENSSL_NO_EC2M)
-            } else if (id == s_GF2m_simple) {
-                method = EC_GF2m_simple_method();
-#endif
-            }
-
-            if (method) {
-                if ((group = EC_GROUP_new(method)) == NULL)
-                    ossl_raise(eEC_GROUP, "EC_GROUP_new");
-            } else {
-                ossl_raise(rb_eArgError, "unknown symbol, must be :GFp_simple, :GFp_mont, :GFp_nist or :GF2m_simple");
-            }
-        } else if (rb_obj_is_kind_of(arg1, cEC_GROUP)) {
+        if (rb_obj_is_kind_of(arg1, cEC_GROUP)) {
             const EC_GROUP *arg1_group;
 
             GetECGroup(arg1, arg1_group);
@@ -820,8 +625,7 @@ static VALUE ossl_ec_group_initialize(int argc, VALUE *argv, VALUE self)
         ossl_raise(rb_eArgError, "wrong number of arguments");
     }
 
-    if (group == NULL)
-        ossl_raise(eEC_GROUP, "");
+    ASSUME(group);
     RTYPEDDATA_DATA(self) = group;
 
     return self;
@@ -1475,6 +1279,8 @@ static VALUE ossl_ec_point_is_on_curve(VALUE self)
 /*
  * call-seq:
  *   point.make_affine! => self
+ *
+ * This method is deprecated and should not be used. This is a no-op.
  */
 static VALUE ossl_ec_point_make_affine(VALUE self)
 {
@@ -1484,8 +1290,11 @@ static VALUE ossl_ec_point_make_affine(VALUE self)
     GetECPoint(self, point);
     GetECPointGroup(self, group);
 
+    rb_warn("OpenSSL::PKey::EC::Point#make_affine! is deprecated");
+#if !OSSL_OPENSSL_PREREQ(3, 0, 0)
     if (EC_POINT_make_affine(group, point, ossl_bn_ctx) != 1)
         ossl_raise(cEC_POINT, "EC_POINT_make_affine");
+#endif
 
     return self;
 }
@@ -1631,6 +1440,10 @@ static VALUE ossl_ec_point_mul(int argc, VALUE *argv, VALUE self)
 	if (EC_POINT_mul(group, point_result, bn_g, point_self, bn, ossl_bn_ctx) != 1)
 	    ossl_raise(eEC_POINT, NULL);
     } else {
+#if (defined(OPENSSL_VERSION_MAJOR) && OPENSSL_VERSION_MAJOR >= 3) || defined(LIBRESSL_VERSION_NUMBER)
+        rb_raise(rb_eNotImpError, "calling #mul with arrays is not" \
+                 "supported by this OpenSSL version");
+#else
 	/*
 	 * bignums | arg1[0] | arg1[1] | arg1[2] | ...
 	 * points  | self    | arg2[0] | arg2[1] | ...
@@ -1645,6 +1458,9 @@ static VALUE ossl_ec_point_mul(int argc, VALUE *argv, VALUE self)
 	if (RARRAY_LEN(arg1) != RARRAY_LEN(arg2) + 1) /* arg2 must be 1 larger */
 	    ossl_raise(rb_eArgError, "bns must be 1 longer than points; see the documentation");
 
+        rb_warning("OpenSSL::PKey::EC::Point#mul(ary, ary) is deprecated; " \
+                   "use #mul(bn) form instead");
+
 	num = RARRAY_LEN(arg1);
 	bns_tmp = rb_ary_tmp_new(num);
 	bignums = ALLOCV_N(const BIGNUM *, tmp_b, num);
@@ -1670,6 +1486,7 @@ static VALUE ossl_ec_point_mul(int argc, VALUE *argv, VALUE self)
 
 	ALLOCV_END(tmp_b);
 	ALLOCV_END(tmp_p);
+#endif
     }
 
     return result;
@@ -1710,10 +1527,6 @@ void Init_ossl_ec(void)
 
     s_GFp = rb_intern("GFp");
     s_GF2m = rb_intern("GF2m");
-    s_GFp_simple = rb_intern("GFp_simple");
-    s_GFp_mont = rb_intern("GFp_mont");
-    s_GFp_nist = rb_intern("GFp_nist");
-    s_GF2m_simple = rb_intern("GF2m_simple");
 
     ID_uncompressed = rb_intern("uncompressed");
     ID_compressed = rb_intern("compressed");
@@ -1728,8 +1541,9 @@ void Init_ossl_ec(void)
 
     rb_define_singleton_method(cEC, "generate", ossl_ec_key_s_generate, 1);
     rb_define_method(cEC, "initialize", ossl_ec_key_initialize, -1);
+#ifndef HAVE_EVP_PKEY_DUP
     rb_define_method(cEC, "initialize_copy", ossl_ec_key_initialize_copy, 1);
-/* copy/dup/cmp */
+#endif
 
     rb_define_method(cEC, "group", ossl_ec_key_get_group, 0);
     rb_define_method(cEC, "group=", ossl_ec_key_set_group, 1);
@@ -1752,15 +1566,9 @@ void Init_ossl_ec(void)
     rb_define_alias(cEC, "generate_key", "generate_key!");
     rb_define_method(cEC, "check_key", ossl_ec_key_check_key, 0);
 
-    rb_define_method(cEC, "dh_compute_key", ossl_ec_key_dh_compute_key, 1);
-    rb_define_method(cEC, "dsa_sign_asn1", ossl_ec_key_dsa_sign_asn1, 1);
-    rb_define_method(cEC, "dsa_verify_asn1", ossl_ec_key_dsa_verify_asn1, 2);
-/* do_sign/do_verify */
-
     rb_define_method(cEC, "export", ossl_ec_key_export, -1);
     rb_define_alias(cEC, "to_pem", "export");
     rb_define_method(cEC, "to_der", ossl_ec_key_to_der, 0);
-    rb_define_method(cEC, "to_text", ossl_ec_key_to_text, 0);
 
 
     rb_define_alloc_func(cEC_GROUP, ossl_ec_group_alloc);
diff --git a/ext/openssl/ossl_pkey_rsa.c b/ext/openssl/ossl_pkey_rsa.c
index 761866c..4d66010 100644
--- a/ext/openssl/ossl_pkey_rsa.c
+++ b/ext/openssl/ossl_pkey_rsa.c
@@ -44,175 +44,31 @@ RSA_PRIVATE(VALUE obj, RSA *rsa)
 VALUE cRSA;
 VALUE eRSAError;
 
-/*
- * Public
- */
-static VALUE
-rsa_instance(VALUE klass, RSA *rsa)
-{
-    EVP_PKEY *pkey;
-    VALUE obj;
-
-    if (!rsa) {
-	return Qfalse;
-    }
-    obj = NewPKey(klass);
-    if (!(pkey = EVP_PKEY_new())) {
-	return Qfalse;
-    }
-    if (!EVP_PKEY_assign_RSA(pkey, rsa)) {
-	EVP_PKEY_free(pkey);
-	return Qfalse;
-    }
-    SetPKey(obj, pkey);
-
-    return obj;
-}
-
-VALUE
-ossl_rsa_new(EVP_PKEY *pkey)
-{
-    VALUE obj;
-
-    if (!pkey) {
-	obj = rsa_instance(cRSA, RSA_new());
-    }
-    else {
-	obj = NewPKey(cRSA);
-	if (EVP_PKEY_base_id(pkey) != EVP_PKEY_RSA) {
-	    ossl_raise(rb_eTypeError, "Not a RSA key!");
-	}
-	SetPKey(obj, pkey);
-    }
-    if (obj == Qfalse) {
-	ossl_raise(eRSAError, NULL);
-    }
-
-    return obj;
-}
-
 /*
  * Private
  */
-struct rsa_blocking_gen_arg {
-    RSA *rsa;
-    BIGNUM *e;
-    int size;
-    BN_GENCB *cb;
-    int result;
-};
-
-static void *
-rsa_blocking_gen(void *arg)
-{
-    struct rsa_blocking_gen_arg *gen = (struct rsa_blocking_gen_arg *)arg;
-    gen->result = RSA_generate_key_ex(gen->rsa, gen->size, gen->e, gen->cb);
-    return 0;
-}
-
-static RSA *
-rsa_generate(int size, unsigned long exp)
-{
-    int i;
-    struct ossl_generate_cb_arg cb_arg = { 0 };
-    struct rsa_blocking_gen_arg gen_arg;
-    RSA *rsa = RSA_new();
-    BIGNUM *e = BN_new();
-    BN_GENCB *cb = BN_GENCB_new();
-
-    if (!rsa || !e || !cb) {
-	RSA_free(rsa);
-	BN_free(e);
-	BN_GENCB_free(cb);
-	return NULL;
-    }
-    for (i = 0; i < (int)sizeof(exp) * 8; ++i) {
-	if (exp & (1UL << i)) {
-	    if (BN_set_bit(e, i) == 0) {
-		BN_free(e);
-		RSA_free(rsa);
-		BN_GENCB_free(cb);
-		return NULL;
-	    }
-	}
-    }
-
-    if (rb_block_given_p())
-	cb_arg.yield = 1;
-    BN_GENCB_set(cb, ossl_generate_cb_2, &cb_arg);
-    gen_arg.rsa = rsa;
-    gen_arg.e = e;
-    gen_arg.size = size;
-    gen_arg.cb = cb;
-    if (cb_arg.yield == 1) {
-	/* we cannot release GVL when callback proc is supplied */
-	rsa_blocking_gen(&gen_arg);
-    } else {
-	/* there's a chance to unblock */
-	rb_thread_call_without_gvl(rsa_blocking_gen, &gen_arg, ossl_generate_cb_stop, &cb_arg);
-    }
-
-    BN_GENCB_free(cb);
-    BN_free(e);
-    if (!gen_arg.result) {
-	RSA_free(rsa);
-	if (cb_arg.state) {
-	    /* must clear OpenSSL error stack */
-	    ossl_clear_error();
-	    rb_jump_tag(cb_arg.state);
-	}
-	return NULL;
-    }
-
-    return rsa;
-}
-
 /*
  * call-seq:
- *   RSA.generate(size)           => RSA instance
- *   RSA.generate(size, exponent) => RSA instance
+ *   RSA.new -> rsa
+ *   RSA.new(encoded_key [, passphrase]) -> rsa
+ *   RSA.new(encoded_key) { passphrase } -> rsa
+ *   RSA.new(size [, exponent]) -> rsa
  *
- * Generates an RSA keypair.  _size_ is an integer representing the desired key
- * size.  Keys smaller than 1024 should be considered insecure.  _exponent_ is
- * an odd number normally 3, 17, or 65537.
- */
-static VALUE
-ossl_rsa_s_generate(int argc, VALUE *argv, VALUE klass)
-{
-/* why does this method exist?  why can't initialize take an optional exponent? */
-    RSA *rsa;
-    VALUE size, exp;
-    VALUE obj;
-
-    rb_scan_args(argc, argv, "11", &size, &exp);
-
-    rsa = rsa_generate(NUM2INT(size), NIL_P(exp) ? RSA_F4 : NUM2ULONG(exp)); /* err handled by rsa_instance */
-    obj = rsa_instance(klass, rsa);
-
-    if (obj == Qfalse) {
-	RSA_free(rsa);
-	ossl_raise(eRSAError, NULL);
-    }
-
-    return obj;
-}
-
-/*
- * call-seq:
- *   RSA.new(key_size)                 => RSA instance
- *   RSA.new(encoded_key)              => RSA instance
- *   RSA.new(encoded_key, pass_phrase) => RSA instance
+ * Generates or loads an \RSA keypair.
  *
- * Generates or loads an RSA keypair.  If an integer _key_size_ is given it
- * represents the desired key size.  Keys less than 1024 bits should be
- * considered insecure.
+ * If called without arguments, creates a new instance with no key components
+ * set. They can be set individually by #set_key, #set_factors, and
+ * #set_crt_params.
  *
- * A key can instead be loaded from an _encoded_key_ which must be PEM or DER
- * encoded.  A _pass_phrase_ can be used to decrypt the key.  If none is given
- * OpenSSL will prompt for the pass phrase.
+ * If called with a String, tries to parse as DER or PEM encoding of an \RSA key.
+ * Note that, if _passphrase_ is not specified but the key is encrypted with a
+ * passphrase, \OpenSSL will prompt for it.
+ * See also OpenSSL::PKey.read which can parse keys of any kinds.
  *
- * = Examples
+ * If called with a number, generates a new key pair. This form works as an
+ * alias of RSA.generate.
  *
+ * Examples:
  *   OpenSSL::PKey::RSA.new 2048
  *   OpenSSL::PKey::RSA.new File.read 'rsa.pem'
  *   OpenSSL::PKey::RSA.new File.read('rsa.pem'), 'my pass phrase'
@@ -222,74 +78,91 @@ ossl_rsa_initialize(int argc, VALUE *argv, VALUE self)
 {
     EVP_PKEY *pkey;
     RSA *rsa;
-    BIO *in;
+    BIO *in = NULL;
     VALUE arg, pass;
+    int type;
 
-    GetPKey(self, pkey);
-    if(rb_scan_args(argc, argv, "02", &arg, &pass) == 0) {
+    TypedData_Get_Struct(self, EVP_PKEY, &ossl_evp_pkey_type, pkey);
+    if (pkey)
+        rb_raise(rb_eTypeError, "pkey already initialized");
+
+    /* The RSA.new(size, generator) form is handled by lib/openssl/pkey.rb */
+    rb_scan_args(argc, argv, "02", &arg, &pass);
+    if (argc == 0) {
 	rsa = RSA_new();
+        if (!rsa)
+            ossl_raise(eRSAError, "RSA_new");
+        goto legacy;
     }
-    else if (RB_INTEGER_TYPE_P(arg)) {
-	rsa = rsa_generate(NUM2INT(arg), NIL_P(pass) ? RSA_F4 : NUM2ULONG(pass));
-	if (!rsa) ossl_raise(eRSAError, NULL);
-    }
-    else {
-	pass = ossl_pem_passwd_value(pass);
-	arg = ossl_to_der_if_possible(arg);
-	in = ossl_obj2bio(&arg);
-	rsa = PEM_read_bio_RSAPrivateKey(in, NULL, ossl_pem_passwd_cb, (void *)pass);
-	if (!rsa) {
-	    OSSL_BIO_reset(in);
-	    rsa = PEM_read_bio_RSA_PUBKEY(in, NULL, NULL, NULL);
-	}
-	if (!rsa) {
-	    OSSL_BIO_reset(in);
-	    rsa = d2i_RSAPrivateKey_bio(in, NULL);
-	}
-	if (!rsa) {
-	    OSSL_BIO_reset(in);
-	    rsa = d2i_RSA_PUBKEY_bio(in, NULL);
-	}
-	if (!rsa) {
-	    OSSL_BIO_reset(in);
-	    rsa = PEM_read_bio_RSAPublicKey(in, NULL, NULL, NULL);
-	}
-	if (!rsa) {
-	    OSSL_BIO_reset(in);
-	    rsa = d2i_RSAPublicKey_bio(in, NULL);
-	}
-	BIO_free(in);
-	if (!rsa) {
-	    ossl_raise(eRSAError, "Neither PUB key nor PRIV key");
-	}
-    }
-    if (!EVP_PKEY_assign_RSA(pkey, rsa)) {
-	RSA_free(rsa);
-	ossl_raise(eRSAError, NULL);
+
+    pass = ossl_pem_passwd_value(pass);
+    arg = ossl_to_der_if_possible(arg);
+    in = ossl_obj2bio(&arg);
+
+    /* First try RSAPublicKey format */
+    rsa = d2i_RSAPublicKey_bio(in, NULL);
+    if (rsa)
+        goto legacy;
+    OSSL_BIO_reset(in);
+    rsa = PEM_read_bio_RSAPublicKey(in, NULL, NULL, NULL);
+    if (rsa)
+        goto legacy;
+    OSSL_BIO_reset(in);
+
+    /* Use the generic routine */
+    pkey = ossl_pkey_read_generic(in, pass);
+    BIO_free(in);
+    if (!pkey)
+        ossl_raise(eRSAError, "Neither PUB key nor PRIV key");
+
+    type = EVP_PKEY_base_id(pkey);
+    if (type != EVP_PKEY_RSA) {
+        EVP_PKEY_free(pkey);
+        rb_raise(eRSAError, "incorrect pkey type: %s", OBJ_nid2sn(type));
     }
+    RTYPEDDATA_DATA(self) = pkey;
+    return self;
 
+  legacy:
+    BIO_free(in);
+    pkey = EVP_PKEY_new();
+    if (!pkey || EVP_PKEY_assign_RSA(pkey, rsa) != 1) {
+        EVP_PKEY_free(pkey);
+        RSA_free(rsa);
+        ossl_raise(eRSAError, "EVP_PKEY_assign_RSA");
+    }
+    RTYPEDDATA_DATA(self) = pkey;
     return self;
 }
 
+#ifndef HAVE_EVP_PKEY_DUP
 static VALUE
 ossl_rsa_initialize_copy(VALUE self, VALUE other)
 {
     EVP_PKEY *pkey;
     RSA *rsa, *rsa_new;
 
-    GetPKey(self, pkey);
-    if (EVP_PKEY_base_id(pkey) != EVP_PKEY_NONE)
-	ossl_raise(eRSAError, "RSA already initialized");
+    TypedData_Get_Struct(self, EVP_PKEY, &ossl_evp_pkey_type, pkey);
+    if (pkey)
+        rb_raise(rb_eTypeError, "pkey already initialized");
     GetRSA(other, rsa);
 
-    rsa_new = ASN1_dup((i2d_of_void *)i2d_RSAPrivateKey, (d2i_of_void *)d2i_RSAPrivateKey, (char *)rsa);
+    rsa_new = (RSA *)ASN1_dup((i2d_of_void *)i2d_RSAPrivateKey,
+                              (d2i_of_void *)d2i_RSAPrivateKey,
+                              (char *)rsa);
     if (!rsa_new)
 	ossl_raise(eRSAError, "ASN1_dup");
 
-    EVP_PKEY_assign_RSA(pkey, rsa_new);
+    pkey = EVP_PKEY_new();
+    if (!pkey || EVP_PKEY_assign_RSA(pkey, rsa_new) != 1) {
+        RSA_free(rsa_new);
+        ossl_raise(eRSAError, "EVP_PKEY_assign_RSA");
+    }
+    RTYPEDDATA_DATA(self) = pkey;
 
     return self;
 }
+#endif
 
 /*
  * call-seq:
@@ -327,221 +200,53 @@ ossl_rsa_is_private(VALUE self)
     return RSA_PRIVATE(self, rsa) ? Qtrue : Qfalse;
 }
 
-/*
- * call-seq:
- *   rsa.export([cipher, pass_phrase]) => PEM-format String
- *   rsa.to_pem([cipher, pass_phrase]) => PEM-format String
- *   rsa.to_s([cipher, pass_phrase]) => PEM-format String
- *
- * Outputs this keypair in PEM encoding.  If _cipher_ and _pass_phrase_ are
- * given they will be used to encrypt the key.  _cipher_ must be an
- * OpenSSL::Cipher instance.
- */
-static VALUE
-ossl_rsa_export(int argc, VALUE *argv, VALUE self)
+static int
+can_export_rsaprivatekey(VALUE self)
 {
     RSA *rsa;
     const BIGNUM *n, *e, *d, *p, *q, *dmp1, *dmq1, *iqmp;
-    BIO *out;
-    const EVP_CIPHER *ciph = NULL;
-    VALUE cipher, pass, str;
 
     GetRSA(self, rsa);
 
-    rb_scan_args(argc, argv, "02", &cipher, &pass);
-
-    if (!NIL_P(cipher)) {
-	ciph = ossl_evp_get_cipherbyname(cipher);
-	pass = ossl_pem_passwd_value(pass);
-    }
-    if (!(out = BIO_new(BIO_s_mem()))) {
-	ossl_raise(eRSAError, NULL);
-    }
     RSA_get0_key(rsa, &n, &e, &d);
     RSA_get0_factors(rsa, &p, &q);
     RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
-    if (n && e && d && p && q && dmp1 && dmq1 && iqmp) {
-	if (!PEM_write_bio_RSAPrivateKey(out, rsa, ciph, NULL, 0,
-					 ossl_pem_passwd_cb, (void *)pass)) {
-	    BIO_free(out);
-	    ossl_raise(eRSAError, NULL);
-	}
-    } else {
-	if (!PEM_write_bio_RSA_PUBKEY(out, rsa)) {
-	    BIO_free(out);
-	    ossl_raise(eRSAError, NULL);
-	}
-    }
-    str = ossl_membio2str(out);
 
-    return str;
+    return n && e && d && p && q && dmp1 && dmq1 && iqmp;
 }
 
 /*
  * call-seq:
- *   rsa.to_der => DER-format String
+ *   rsa.export([cipher, pass_phrase]) => PEM-format String
+ *   rsa.to_pem([cipher, pass_phrase]) => PEM-format String
+ *   rsa.to_s([cipher, pass_phrase]) => PEM-format String
  *
- * Outputs this keypair in DER encoding.
+ * Outputs this keypair in PEM encoding.  If _cipher_ and _pass_phrase_ are
+ * given they will be used to encrypt the key.  _cipher_ must be an
+ * OpenSSL::Cipher instance.
  */
 static VALUE
-ossl_rsa_to_der(VALUE self)
+ossl_rsa_export(int argc, VALUE *argv, VALUE self)
 {
-    RSA *rsa;
-    const BIGNUM *n, *e, *d, *p, *q, *dmp1, *dmq1, *iqmp;
-    int (*i2d_func)(const RSA *, unsigned char **);
-    unsigned char *ptr;
-    long len;
-    VALUE str;
-
-    GetRSA(self, rsa);
-    RSA_get0_key(rsa, &n, &e, &d);
-    RSA_get0_factors(rsa, &p, &q);
-    RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
-    if (n && e && d && p && q && dmp1 && dmq1 && iqmp)
-	i2d_func = i2d_RSAPrivateKey;
+    if (can_export_rsaprivatekey(self))
+        return ossl_pkey_export_traditional(argc, argv, self, 0);
     else
-	i2d_func = (int (*)(const RSA *, unsigned char **))i2d_RSA_PUBKEY;
-    if((len = i2d_func(rsa, NULL)) <= 0)
-	ossl_raise(eRSAError, NULL);
-    str = rb_str_new(0, len);
-    ptr = (unsigned char *)RSTRING_PTR(str);
-    if(i2d_func(rsa, &ptr) < 0)
-	ossl_raise(eRSAError, NULL);
-    ossl_str_adjust(str, ptr);
-
-    return str;
+        return ossl_pkey_export_spki(self, 0);
 }
 
 /*
  * call-seq:
- *   rsa.public_encrypt(string)          => String
- *   rsa.public_encrypt(string, padding) => String
- *
- * Encrypt _string_ with the public key.  _padding_ defaults to PKCS1_PADDING.
- * The encrypted string output can be decrypted using #private_decrypt.
- */
-static VALUE
-ossl_rsa_public_encrypt(int argc, VALUE *argv, VALUE self)
-{
-    RSA *rsa;
-    const BIGNUM *rsa_n;
-    int buf_len, pad;
-    VALUE str, buffer, padding;
-
-    GetRSA(self, rsa);
-    RSA_get0_key(rsa, &rsa_n, NULL, NULL);
-    if (!rsa_n)
-	ossl_raise(eRSAError, "incomplete RSA");
-    rb_scan_args(argc, argv, "11", &buffer, &padding);
-    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);
-    StringValue(buffer);
-    str = rb_str_new(0, RSA_size(rsa));
-    buf_len = RSA_public_encrypt(RSTRING_LENINT(buffer), (unsigned char *)RSTRING_PTR(buffer),
-				 (unsigned char *)RSTRING_PTR(str), rsa, pad);
-    if (buf_len < 0) ossl_raise(eRSAError, NULL);
-    rb_str_set_len(str, buf_len);
-
-    return str;
-}
-
-/*
- * call-seq:
- *   rsa.public_decrypt(string)          => String
- *   rsa.public_decrypt(string, padding) => String
- *
- * Decrypt _string_, which has been encrypted with the private key, with the
- * public key.  _padding_ defaults to PKCS1_PADDING.
- */
-static VALUE
-ossl_rsa_public_decrypt(int argc, VALUE *argv, VALUE self)
-{
-    RSA *rsa;
-    const BIGNUM *rsa_n;
-    int buf_len, pad;
-    VALUE str, buffer, padding;
-
-    GetRSA(self, rsa);
-    RSA_get0_key(rsa, &rsa_n, NULL, NULL);
-    if (!rsa_n)
-	ossl_raise(eRSAError, "incomplete RSA");
-    rb_scan_args(argc, argv, "11", &buffer, &padding);
-    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);
-    StringValue(buffer);
-    str = rb_str_new(0, RSA_size(rsa));
-    buf_len = RSA_public_decrypt(RSTRING_LENINT(buffer), (unsigned char *)RSTRING_PTR(buffer),
-				 (unsigned char *)RSTRING_PTR(str), rsa, pad);
-    if (buf_len < 0) ossl_raise(eRSAError, NULL);
-    rb_str_set_len(str, buf_len);
-
-    return str;
-}
-
-/*
- * call-seq:
- *   rsa.private_encrypt(string)          => String
- *   rsa.private_encrypt(string, padding) => String
- *
- * Encrypt _string_ with the private key.  _padding_ defaults to PKCS1_PADDING.
- * The encrypted string output can be decrypted using #public_decrypt.
- */
-static VALUE
-ossl_rsa_private_encrypt(int argc, VALUE *argv, VALUE self)
-{
-    RSA *rsa;
-    const BIGNUM *rsa_n;
-    int buf_len, pad;
-    VALUE str, buffer, padding;
-
-    GetRSA(self, rsa);
-    RSA_get0_key(rsa, &rsa_n, NULL, NULL);
-    if (!rsa_n)
-	ossl_raise(eRSAError, "incomplete RSA");
-    if (!RSA_PRIVATE(self, rsa))
-	ossl_raise(eRSAError, "private key needed.");
-    rb_scan_args(argc, argv, "11", &buffer, &padding);
-    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);
-    StringValue(buffer);
-    str = rb_str_new(0, RSA_size(rsa));
-    buf_len = RSA_private_encrypt(RSTRING_LENINT(buffer), (unsigned char *)RSTRING_PTR(buffer),
-				  (unsigned char *)RSTRING_PTR(str), rsa, pad);
-    if (buf_len < 0) ossl_raise(eRSAError, NULL);
-    rb_str_set_len(str, buf_len);
-
-    return str;
-}
-
-/*
- * call-seq:
- *   rsa.private_decrypt(string)          => String
- *   rsa.private_decrypt(string, padding) => String
+ *   rsa.to_der => DER-format String
  *
- * Decrypt _string_, which has been encrypted with the public key, with the
- * private key.  _padding_ defaults to PKCS1_PADDING.
+ * Outputs this keypair in DER encoding.
  */
 static VALUE
-ossl_rsa_private_decrypt(int argc, VALUE *argv, VALUE self)
+ossl_rsa_to_der(VALUE self)
 {
-    RSA *rsa;
-    const BIGNUM *rsa_n;
-    int buf_len, pad;
-    VALUE str, buffer, padding;
-
-    GetRSA(self, rsa);
-    RSA_get0_key(rsa, &rsa_n, NULL, NULL);
-    if (!rsa_n)
-	ossl_raise(eRSAError, "incomplete RSA");
-    if (!RSA_PRIVATE(self, rsa))
-	ossl_raise(eRSAError, "private key needed.");
-    rb_scan_args(argc, argv, "11", &buffer, &padding);
-    pad = (argc == 1) ? RSA_PKCS1_PADDING : NUM2INT(padding);
-    StringValue(buffer);
-    str = rb_str_new(0, RSA_size(rsa));
-    buf_len = RSA_private_decrypt(RSTRING_LENINT(buffer), (unsigned char *)RSTRING_PTR(buffer),
-				  (unsigned char *)RSTRING_PTR(str), rsa, pad);
-    if (buf_len < 0) ossl_raise(eRSAError, NULL);
-    rb_str_set_len(str, buf_len);
-
-    return str;
+    if (can_export_rsaprivatekey(self))
+        return ossl_pkey_export_traditional(0, NULL, self, 1);
+    else
+        return ossl_pkey_export_spki(self, 1);
 }
 
 /*
@@ -573,7 +278,7 @@ ossl_rsa_private_decrypt(int argc, VALUE *argv, VALUE self)
  *   data = "Sign me!"
  *   pkey = OpenSSL::PKey::RSA.new(2048)
  *   signature = pkey.sign_pss("SHA256", data, salt_length: :max, mgf1_hash: "SHA256")
- *   pub_key = pkey.public_key
+ *   pub_key = OpenSSL::PKey.read(pkey.public_to_der)
  *   puts pub_key.verify_pss("SHA256", signature, data,
  *                           salt_length: :auto, mgf1_hash: "SHA256") # => true
  */
@@ -770,88 +475,6 @@ ossl_rsa_get_params(VALUE self)
     return hash;
 }
 
-/*
- * call-seq:
- *   rsa.to_text => String
- *
- * THIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!
- *
- * Dumps all parameters of a keypair to a String
- *
- * Don't use :-)) (It's up to you)
- */
-static VALUE
-ossl_rsa_to_text(VALUE self)
-{
-    RSA *rsa;
-    BIO *out;
-    VALUE str;
-
-    GetRSA(self, rsa);
-    if (!(out = BIO_new(BIO_s_mem()))) {
-	ossl_raise(eRSAError, NULL);
-    }
-    if (!RSA_print(out, rsa, 0)) { /* offset = 0 */
-	BIO_free(out);
-	ossl_raise(eRSAError, NULL);
-    }
-    str = ossl_membio2str(out);
-
-    return str;
-}
-
-/*
- * call-seq:
- *    rsa.public_key -> RSA
- *
- * Makes new RSA instance containing the public key from the private key.
- */
-static VALUE
-ossl_rsa_to_public_key(VALUE self)
-{
-    EVP_PKEY *pkey;
-    RSA *rsa;
-    VALUE obj;
-
-    GetPKeyRSA(self, pkey);
-    /* err check performed by rsa_instance */
-    rsa = RSAPublicKey_dup(EVP_PKEY_get0_RSA(pkey));
-    obj = rsa_instance(rb_obj_class(self), rsa);
-    if (obj == Qfalse) {
-	RSA_free(rsa);
-	ossl_raise(eRSAError, NULL);
-    }
-    return obj;
-}
-
-/*
- * TODO: Test me
-
-static VALUE
-ossl_rsa_blinding_on(VALUE self)
-{
-    RSA *rsa;
-
-    GetRSA(self, rsa);
-
-    if (RSA_blinding_on(rsa, ossl_bn_ctx) != 1) {
-	ossl_raise(eRSAError, NULL);
-    }
-    return self;
-}
-
-static VALUE
-ossl_rsa_blinding_off(VALUE self)
-{
-    RSA *rsa;
-
-    GetRSA(self, rsa);
-    RSA_blinding_off(rsa);
-
-    return self;
-}
- */
-
 /*
  * Document-method: OpenSSL::PKey::RSA#set_key
  * call-seq:
@@ -913,22 +536,17 @@ Init_ossl_rsa(void)
      */
     cRSA = rb_define_class_under(mPKey, "RSA", cPKey);
 
-    rb_define_singleton_method(cRSA, "generate", ossl_rsa_s_generate, -1);
     rb_define_method(cRSA, "initialize", ossl_rsa_initialize, -1);
+#ifndef HAVE_EVP_PKEY_DUP
     rb_define_method(cRSA, "initialize_copy", ossl_rsa_initialize_copy, 1);
+#endif
 
     rb_define_method(cRSA, "public?", ossl_rsa_is_public, 0);
     rb_define_method(cRSA, "private?", ossl_rsa_is_private, 0);
-    rb_define_method(cRSA, "to_text", ossl_rsa_to_text, 0);
     rb_define_method(cRSA, "export", ossl_rsa_export, -1);
     rb_define_alias(cRSA, "to_pem", "export");
     rb_define_alias(cRSA, "to_s", "export");
     rb_define_method(cRSA, "to_der", ossl_rsa_to_der, 0);
-    rb_define_method(cRSA, "public_key", ossl_rsa_to_public_key, 0);
-    rb_define_method(cRSA, "public_encrypt", ossl_rsa_public_encrypt, -1);
-    rb_define_method(cRSA, "public_decrypt", ossl_rsa_public_decrypt, -1);
-    rb_define_method(cRSA, "private_encrypt", ossl_rsa_private_encrypt, -1);
-    rb_define_method(cRSA, "private_decrypt", ossl_rsa_private_decrypt, -1);
     rb_define_method(cRSA, "sign_pss", ossl_rsa_sign_pss, -1);
     rb_define_method(cRSA, "verify_pss", ossl_rsa_verify_pss, -1);
 
@@ -946,11 +564,6 @@ Init_ossl_rsa(void)
 
     rb_define_method(cRSA, "params", ossl_rsa_get_params, 0);
 
-    DefRSAConst(PKCS1_PADDING);
-    DefRSAConst(SSLV23_PADDING);
-    DefRSAConst(NO_PADDING);
-    DefRSAConst(PKCS1_OAEP_PADDING);
-
 /*
  * TODO: Test it
     rb_define_method(cRSA, "blinding_on!", ossl_rsa_blinding_on, 0);
diff --git a/ext/openssl/ossl_ssl.c b/ext/openssl/ossl_ssl.c
index 7654be1..9a0682a 100644
--- a/ext/openssl/ossl_ssl.c
+++ b/ext/openssl/ossl_ssl.c
@@ -38,14 +38,14 @@ VALUE cSSLSocket;
 static VALUE eSSLErrorWaitReadable;
 static VALUE eSSLErrorWaitWritable;
 
-static ID id_call, ID_callback_state, id_tmp_dh_callback, id_tmp_ecdh_callback,
+static ID id_call, ID_callback_state, id_tmp_dh_callback,
 	  id_npn_protocols_encoded, id_each;
 static VALUE sym_exception, sym_wait_readable, sym_wait_writable;
 
 static ID id_i_cert_store, id_i_ca_file, id_i_ca_path, id_i_verify_mode,
 	  id_i_verify_depth, id_i_verify_callback, id_i_client_ca,
 	  id_i_renegotiation_cb, id_i_cert, id_i_key, id_i_extra_chain_cert,
-	  id_i_client_cert_cb, id_i_tmp_ecdh_callback, id_i_timeout,
+	  id_i_client_cert_cb, id_i_timeout,
 	  id_i_session_id_context, id_i_session_get_cb, id_i_session_new_cb,
 	  id_i_session_remove_cb, id_i_npn_select_cb, id_i_npn_protocols,
 	  id_i_alpn_select_cb, id_i_alpn_protocols, id_i_servername_cb,
@@ -55,9 +55,6 @@ static ID id_i_io, id_i_context, id_i_hostname;
 static int ossl_ssl_ex_vcb_idx;
 static int ossl_ssl_ex_ptr_idx;
 static int ossl_sslctx_ex_ptr_idx;
-#if !defined(HAVE_X509_STORE_UP_REF)
-static int ossl_sslctx_ex_store_p;
-#endif
 
 static void
 ossl_sslctx_mark(void *ptr)
@@ -69,12 +66,7 @@ ossl_sslctx_mark(void *ptr)
 static void
 ossl_sslctx_free(void *ptr)
 {
-    SSL_CTX *ctx = ptr;
-#if !defined(HAVE_X509_STORE_UP_REF)
-    if (ctx && SSL_CTX_get_ex_data(ctx, ossl_sslctx_ex_store_p))
-	ctx->cert_store = NULL;
-#endif
-    SSL_CTX_free(ctx);
+    SSL_CTX_free(ptr);
 }
 
 static const rb_data_type_t ossl_sslctx_type = {
@@ -96,7 +88,7 @@ ossl_sslctx_s_alloc(VALUE klass)
     VALUE obj;
 
     obj = TypedData_Wrap_Struct(klass, &ossl_sslctx_type, 0);
-#if OPENSSL_VERSION_NUMBER >= 0x10100000 && !defined(LIBRESSL_VERSION_NUMBER)
+#if OPENSSL_VERSION_NUMBER >= 0x10100000 || defined(LIBRESSL_VERSION_NUMBER)
     ctx = SSL_CTX_new(TLS_method());
 #else
     ctx = SSL_CTX_new(SSLv23_method());
@@ -108,14 +100,15 @@ ossl_sslctx_s_alloc(VALUE klass)
     RTYPEDDATA_DATA(obj) = ctx;
     SSL_CTX_set_ex_data(ctx, ossl_sslctx_ex_ptr_idx, (void *)obj);
 
-#if !defined(OPENSSL_NO_EC) && defined(HAVE_SSL_CTX_SET_ECDH_AUTO)
+#if !defined(OPENSSL_NO_EC) && OPENSSL_VERSION_NUMBER < 0x10100000 && \
+    !defined(LIBRESSL_VERSION_NUMBER)
     /* We use SSL_CTX_set1_curves_list() to specify the curve used in ECDH. It
      * allows to specify multiple curve names and OpenSSL will select
      * automatically from them. In OpenSSL 1.0.2, the automatic selection has to
-     * be enabled explicitly. But OpenSSL 1.1.0 removed the knob and it is
-     * always enabled. To uniform the behavior, we enable the automatic
-     * selection also in 1.0.2. Users can still disable ECDH by removing ECDH
-     * cipher suites by SSLContext#ciphers=. */
+     * be enabled explicitly. OpenSSL 1.1.0 and LibreSSL 2.6.1 removed the knob
+     * and it is always enabled. To uniform the behavior, we enable the
+     * automatic selection also in 1.0.2. Users can still disable ECDH by
+     * removing ECDH cipher suites by SSLContext#ciphers=. */
     if (!SSL_CTX_set_ecdh_auto(ctx, 1))
 	ossl_raise(eSSLError, "SSL_CTX_set_ecdh_auto");
 #endif
@@ -244,8 +237,7 @@ ossl_client_cert_cb(SSL *ssl, X509 **x509, EVP_PKEY **pkey)
     return 1;
 }
 
-#if !defined(OPENSSL_NO_DH) || \
-    !defined(OPENSSL_NO_EC) && defined(HAVE_SSL_CTX_SET_TMP_ECDH_CALLBACK)
+#if !defined(OPENSSL_NO_DH)
 struct tmp_dh_callback_args {
     VALUE ssl_obj;
     ID id;
@@ -254,22 +246,23 @@ struct tmp_dh_callback_args {
     int keylength;
 };
 
-static EVP_PKEY *
-ossl_call_tmp_dh_callback(struct tmp_dh_callback_args *args)
+static VALUE
+ossl_call_tmp_dh_callback(VALUE arg)
 {
+    struct tmp_dh_callback_args *args = (struct tmp_dh_callback_args *)arg;
     VALUE cb, dh;
     EVP_PKEY *pkey;
 
     cb = rb_funcall(args->ssl_obj, args->id, 0);
     if (NIL_P(cb))
-	return NULL;
+	return (VALUE)NULL;
     dh = rb_funcall(cb, id_call, 3, args->ssl_obj, INT2NUM(args->is_export),
 		    INT2NUM(args->keylength));
     pkey = GetPKeyPtr(dh);
     if (EVP_PKEY_base_id(pkey) != args->type)
-	return NULL;
+	return (VALUE)NULL;
 
-    return pkey;
+    return (VALUE)pkey;
 }
 #endif
 
@@ -289,7 +282,7 @@ ossl_tmp_dh_callback(SSL *ssl, int is_export, int keylength)
     args.keylength = keylength;
     args.type = EVP_PKEY_DH;
 
-    pkey = (EVP_PKEY *)rb_protect((VALUE (*)(VALUE))ossl_call_tmp_dh_callback,
+    pkey = (EVP_PKEY *)rb_protect(ossl_call_tmp_dh_callback,
 				  (VALUE)&args, &state);
     if (state) {
 	rb_ivar_set(rb_ssl, ID_callback_state, INT2NUM(state));
@@ -302,35 +295,6 @@ ossl_tmp_dh_callback(SSL *ssl, int is_export, int keylength)
 }
 #endif /* OPENSSL_NO_DH */
 
-#if !defined(OPENSSL_NO_EC) && defined(HAVE_SSL_CTX_SET_TMP_ECDH_CALLBACK)
-static EC_KEY *
-ossl_tmp_ecdh_callback(SSL *ssl, int is_export, int keylength)
-{
-    VALUE rb_ssl;
-    EVP_PKEY *pkey;
-    struct tmp_dh_callback_args args;
-    int state;
-
-    rb_ssl = (VALUE)SSL_get_ex_data(ssl, ossl_ssl_ex_ptr_idx);
-    args.ssl_obj = rb_ssl;
-    args.id = id_tmp_ecdh_callback;
-    args.is_export = is_export;
-    args.keylength = keylength;
-    args.type = EVP_PKEY_EC;
-
-    pkey = (EVP_PKEY *)rb_protect((VALUE (*)(VALUE))ossl_call_tmp_dh_callback,
-				  (VALUE)&args, &state);
-    if (state) {
-	rb_ivar_set(rb_ssl, ID_callback_state, INT2NUM(state));
-	return NULL;
-    }
-    if (!pkey)
-	return NULL;
-
-    return EVP_PKEY_get0_EC_KEY(pkey);
-}
-#endif
-
 static VALUE
 call_verify_certificate_identity(VALUE ctx_v)
 {
@@ -400,7 +364,7 @@ ossl_call_session_get_cb(VALUE ary)
 }
 
 static SSL_SESSION *
-#if (!defined(LIBRESSL_VERSION_NUMBER) ? OPENSSL_VERSION_NUMBER >= 0x10100000 : LIBRESSL_VERSION_NUMBER >= 0x2080000f)
+#if defined(LIBRESSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER >= 0x10100000
 ossl_sslctx_session_get_cb(SSL *ssl, const unsigned char *buf, int len, int *copy)
 #else
 ossl_sslctx_session_get_cb(SSL *ssl, unsigned char *buf, int len, int *copy)
@@ -609,8 +573,6 @@ ssl_renegotiation_cb(const SSL *ssl)
     rb_funcallv(cb, id_call, 1, &ssl_obj);
 }
 
-#if !defined(OPENSSL_NO_NEXTPROTONEG) || \
-    defined(HAVE_SSL_CTX_SET_ALPN_SELECT_CB)
 static VALUE
 ssl_npn_encode_protocol_i(RB_BLOCK_CALL_FUNC_ARGLIST(cur, encoded))
 {
@@ -692,7 +654,6 @@ ssl_npn_select_cb_common(SSL *ssl, VALUE cb, const unsigned char **out,
 
     return SSL_TLSEXT_ERR_OK;
 }
-#endif
 
 #ifndef OPENSSL_NO_NEXTPROTONEG
 static int
@@ -721,7 +682,6 @@ ssl_npn_select_cb(SSL *ssl, unsigned char **out, unsigned char *outlen,
 }
 #endif
 
-#ifdef HAVE_SSL_CTX_SET_ALPN_SELECT_CB
 static int
 ssl_alpn_select_cb(SSL *ssl, const unsigned char **out, unsigned char *outlen,
 		   const unsigned char *in, unsigned int inlen, void *arg)
@@ -733,7 +693,6 @@ ssl_alpn_select_cb(SSL *ssl, const unsigned char **out, unsigned char *outlen,
 
     return ssl_npn_select_cb_common(ssl, cb, out, outlen, in, inlen);
 }
-#endif
 
 /* This function may serve as the entry point to support further callbacks. */
 static void
@@ -810,26 +769,6 @@ ossl_sslctx_setup(VALUE self)
     SSL_CTX_set_tmp_dh_callback(ctx, ossl_tmp_dh_callback);
 #endif
 
-#if !defined(OPENSSL_NO_EC)
-    /* We added SSLContext#tmp_ecdh_callback= in Ruby 2.3.0,
-     * but SSL_CTX_set_tmp_ecdh_callback() was removed in OpenSSL 1.1.0. */
-    if (RTEST(rb_attr_get(self, id_i_tmp_ecdh_callback))) {
-# if defined(HAVE_SSL_CTX_SET_TMP_ECDH_CALLBACK)
-	rb_warn("#tmp_ecdh_callback= is deprecated; use #ecdh_curves= instead");
-	SSL_CTX_set_tmp_ecdh_callback(ctx, ossl_tmp_ecdh_callback);
-#  if defined(HAVE_SSL_CTX_SET_ECDH_AUTO)
-	/* tmp_ecdh_callback and ecdh_auto conflict; OpenSSL ignores
-	 * tmp_ecdh_callback. So disable ecdh_auto. */
-	if (!SSL_CTX_set_ecdh_auto(ctx, 0))
-	    ossl_raise(eSSLError, "SSL_CTX_set_ecdh_auto");
-#  endif
-# else
-	ossl_raise(eSSLError, "OpenSSL does not support tmp_ecdh_callback; "
-		   "use #ecdh_curves= instead");
-# endif
-    }
-#endif /* OPENSSL_NO_EC */
-
 #ifdef HAVE_SSL_CTX_SET_POST_HANDSHAKE_AUTH
     SSL_CTX_set_post_handshake_auth(ctx, 1);
 #endif
@@ -838,17 +777,7 @@ ossl_sslctx_setup(VALUE self)
     if (!NIL_P(val)) {
 	X509_STORE *store = GetX509StorePtr(val); /* NO NEED TO DUP */
 	SSL_CTX_set_cert_store(ctx, store);
-#if !defined(HAVE_X509_STORE_UP_REF)
-	/*
-         * WORKAROUND:
-	 *   X509_STORE can count references, but
-	 *   X509_STORE_free() doesn't care it.
-	 *   So we won't increment it but mark it by ex_data.
-	 */
-        SSL_CTX_set_ex_data(ctx, ossl_sslctx_ex_store_p, ctx);
-#else /* Fixed in OpenSSL 1.0.2; bff9ce4db38b (master), 5b4b9ce976fc (1.0.2) */
 	X509_STORE_up_ref(store);
-#endif
     }
 
     val = rb_attr_get(self, id_i_extra_chain_cert);
@@ -899,10 +828,17 @@ ossl_sslctx_setup(VALUE self)
     ca_file = NIL_P(val) ? NULL : StringValueCStr(val);
     val = rb_attr_get(self, id_i_ca_path);
     ca_path = NIL_P(val) ? NULL : StringValueCStr(val);
+#ifdef HAVE_SSL_CTX_LOAD_VERIFY_FILE
+    if (ca_file && !SSL_CTX_load_verify_file(ctx, ca_file))
+        ossl_raise(eSSLError, "SSL_CTX_load_verify_file");
+    if (ca_path && !SSL_CTX_load_verify_dir(ctx, ca_path))
+        ossl_raise(eSSLError, "SSL_CTX_load_verify_dir");
+#else
     if(ca_file || ca_path){
 	if (!SSL_CTX_load_verify_locations(ctx, ca_file, ca_path))
 	    rb_warning("can't set verify locations");
     }
+#endif
 
     val = rb_attr_get(self, id_i_verify_mode);
     verify_mode = NIL_P(val) ? SSL_VERIFY_NONE : NUM2INT(val);
@@ -930,7 +866,6 @@ ossl_sslctx_setup(VALUE self)
     }
 #endif
 
-#ifdef HAVE_SSL_CTX_SET_ALPN_SELECT_CB
     val = rb_attr_get(self, id_i_alpn_protocols);
     if (!NIL_P(val)) {
 	VALUE rprotos = ssl_encode_npn_protocols(val);
@@ -945,7 +880,6 @@ ossl_sslctx_setup(VALUE self)
 	SSL_CTX_set_alpn_select_cb(ctx, ssl_alpn_select_cb, (void *) self);
 	OSSL_Debug("SSL ALPN select callback added");
     }
-#endif
 
     rb_obj_freeze(self);
 
@@ -1067,6 +1001,52 @@ ossl_sslctx_set_ciphers(VALUE self, VALUE v)
     return v;
 }
 
+#ifndef OPENSSL_NO_DH
+/*
+ * call-seq:
+ *    ctx.tmp_dh = pkey
+ *
+ * Sets DH parameters used for ephemeral DH key exchange. This is relevant for
+ * servers only.
+ *
+ * +pkey+ is an instance of OpenSSL::PKey::DH. Note that key components
+ * contained in the key object, if any, are ignored. The server will always
+ * generate a new key pair for each handshake.
+ *
+ * Added in version 3.0. See also the man page SSL_set0_tmp_dh_pkey(3).
+ *
+ * Example:
+ *   ctx = OpenSSL::SSL::SSLContext.new
+ *   ctx.tmp_dh = OpenSSL::DH.generate(2048)
+ *   svr = OpenSSL::SSL::SSLServer.new(tcp_svr, ctx)
+ *   Thread.new { svr.accept }
+ */
+static VALUE
+ossl_sslctx_set_tmp_dh(VALUE self, VALUE arg)
+{
+    SSL_CTX *ctx;
+    EVP_PKEY *pkey;
+
+    rb_check_frozen(self);
+    GetSSLCTX(self, ctx);
+    pkey = GetPKeyPtr(arg);
+
+    if (EVP_PKEY_base_id(pkey) != EVP_PKEY_DH)
+        rb_raise(eSSLError, "invalid pkey type %s (expected DH)",
+                 OBJ_nid2sn(EVP_PKEY_base_id(pkey)));
+#ifdef HAVE_SSL_SET0_TMP_DH_PKEY
+    if (!SSL_CTX_set0_tmp_dh_pkey(ctx, pkey))
+        ossl_raise(eSSLError, "SSL_CTX_set0_tmp_dh_pkey");
+    EVP_PKEY_up_ref(pkey);
+#else
+    if (!SSL_CTX_set_tmp_dh(ctx, EVP_PKEY_get0_DH(pkey)))
+        ossl_raise(eSSLError, "SSL_CTX_set_tmp_dh");
+#endif
+
+    return arg;
+}
+#endif
+
 #if !defined(OPENSSL_NO_EC)
 /*
  * call-seq:
@@ -1078,9 +1058,6 @@ ossl_sslctx_set_ciphers(VALUE self, VALUE v)
  * Extension. For a server, the list is used by OpenSSL to determine the set of
  * shared curves. OpenSSL will pick the most appropriate one from it.
  *
- * Note that this works differently with old OpenSSL (<= 1.0.1). Only one curve
- * can be set, and this has no effect for TLS clients.
- *
  * === Example
  *   ctx1 = OpenSSL::SSL::SSLContext.new
  *   ctx1.ecdh_curves = "X25519:P-256:P-224"
@@ -1104,48 +1081,8 @@ ossl_sslctx_set_ecdh_curves(VALUE self, VALUE arg)
     GetSSLCTX(self, ctx);
     StringValueCStr(arg);
 
-#if defined(HAVE_SSL_CTX_SET1_CURVES_LIST)
     if (!SSL_CTX_set1_curves_list(ctx, RSTRING_PTR(arg)))
 	ossl_raise(eSSLError, NULL);
-#else
-    /* OpenSSL does not have SSL_CTX_set1_curves_list()... Fallback to
-     * SSL_CTX_set_tmp_ecdh(). So only the first curve is used. */
-    {
-	VALUE curve, splitted;
-	EC_KEY *ec;
-	int nid;
-
-	splitted = rb_str_split(arg, ":");
-	if (!RARRAY_LEN(splitted))
-	    ossl_raise(eSSLError, "invalid input format");
-	curve = RARRAY_AREF(splitted, 0);
-	StringValueCStr(curve);
-
-	/* SSL_CTX_set1_curves_list() accepts NIST names */
-	nid = EC_curve_nist2nid(RSTRING_PTR(curve));
-	if (nid == NID_undef)
-	    nid = OBJ_txt2nid(RSTRING_PTR(curve));
-	if (nid == NID_undef)
-	    ossl_raise(eSSLError, "unknown curve name");
-
-	ec = EC_KEY_new_by_curve_name(nid);
-	if (!ec)
-	    ossl_raise(eSSLError, NULL);
-	EC_KEY_set_asn1_flag(ec, OPENSSL_EC_NAMED_CURVE);
-	if (!SSL_CTX_set_tmp_ecdh(ctx, ec)) {
-	    EC_KEY_free(ec);
-	    ossl_raise(eSSLError, "SSL_CTX_set_tmp_ecdh");
-	}
-	EC_KEY_free(ec);
-# if defined(HAVE_SSL_CTX_SET_ECDH_AUTO)
-	/* tmp_ecdh and ecdh_auto conflict. tmp_ecdh is ignored when ecdh_auto
-	 * is enabled. So disable ecdh_auto. */
-	if (!SSL_CTX_set_ecdh_auto(ctx, 0))
-	    ossl_raise(eSSLError, "SSL_CTX_set_ecdh_auto");
-# endif
-    }
-#endif
-
     return arg;
 }
 #else
@@ -1236,7 +1173,7 @@ ossl_sslctx_enable_fallback_scsv(VALUE self)
 
 /*
  * call-seq:
- *    ctx.add_certificate(certiticate, pkey [, extra_certs]) -> self
+ *    ctx.add_certificate(certificate, pkey [, extra_certs]) -> self
  *
  * Adds a certificate to the context. _pkey_ must be a corresponding private
  * key with _certificate_.
@@ -1268,10 +1205,6 @@ ossl_sslctx_enable_fallback_scsv(VALUE self)
  *   ecdsa_pkey = ...
  *   another_ca_cert = ...
  *   ctx.add_certificate(ecdsa_cert, ecdsa_pkey, [another_ca_cert])
- *
- * === Note
- * OpenSSL before the version 1.0.2 could handle only one extra chain across
- * all key types. Calling this method discards the chain set previously.
  */
 static VALUE
 ossl_sslctx_add_certificate(int argc, VALUE *argv, VALUE self)
@@ -1296,7 +1229,7 @@ ossl_sslctx_add_certificate(int argc, VALUE *argv, VALUE self)
     EVP_PKEY_free(pub_pkey);
     if (!pub_pkey)
 	rb_raise(rb_eArgError, "certificate does not contain public key");
-    if (EVP_PKEY_cmp(pub_pkey, pkey) != 1)
+    if (EVP_PKEY_eq(pub_pkey, pkey) != 1)
 	rb_raise(rb_eArgError, "public key mismatch");
 
     if (argc >= 3)
@@ -1310,34 +1243,9 @@ ossl_sslctx_add_certificate(int argc, VALUE *argv, VALUE self)
 	sk_X509_pop_free(extra_chain, X509_free);
 	ossl_raise(eSSLError, "SSL_CTX_use_PrivateKey");
     }
-
-    if (extra_chain) {
-#if OPENSSL_VERSION_NUMBER >= 0x10002000 && !defined(LIBRESSL_VERSION_NUMBER)
-	if (!SSL_CTX_set0_chain(ctx, extra_chain)) {
-	    sk_X509_pop_free(extra_chain, X509_free);
-	    ossl_raise(eSSLError, "SSL_CTX_set0_chain");
-	}
-#else
-	STACK_OF(X509) *orig_extra_chain;
-	X509 *x509_tmp;
-
-	/* First, clear the existing chain */
-	SSL_CTX_get_extra_chain_certs(ctx, &orig_extra_chain);
-	if (orig_extra_chain && sk_X509_num(orig_extra_chain)) {
-	    rb_warning("SSL_CTX_set0_chain() is not available; " \
-		       "clearing previously set certificate chain");
-	    SSL_CTX_clear_extra_chain_certs(ctx);
-	}
-	while ((x509_tmp = sk_X509_shift(extra_chain))) {
-	    /* Transfers ownership */
-	    if (!SSL_CTX_add_extra_chain_cert(ctx, x509_tmp)) {
-		X509_free(x509_tmp);
-		sk_X509_pop_free(extra_chain, X509_free);
-		ossl_raise(eSSLError, "SSL_CTX_add_extra_chain_cert");
-	    }
-	}
-	sk_X509_free(extra_chain);
-#endif
+    if (extra_chain && !SSL_CTX_set0_chain(ctx, extra_chain)) {
+        sk_X509_pop_free(extra_chain, X509_free);
+        ossl_raise(eSSLError, "SSL_CTX_set0_chain");
     }
     return self;
 }
@@ -1535,8 +1443,8 @@ ossl_sslctx_flush_sessions(int argc, VALUE *argv, VALUE self)
 static inline int
 ssl_started(SSL *ssl)
 {
-    /* the FD is set in ossl_ssl_setup(), called by #connect or #accept */
-    return SSL_get_fd(ssl) >= 0;
+    /* BIO is created through ossl_ssl_setup(), called by #connect or #accept */
+    return SSL_get_rbio(ssl) != NULL;
 }
 
 static void
@@ -1567,6 +1475,29 @@ ossl_ssl_s_alloc(VALUE klass)
     return TypedData_Wrap_Struct(klass, &ossl_ssl_type, NULL);
 }
 
+static VALUE
+peer_ip_address(VALUE self)
+{
+    VALUE remote_address = rb_funcall(rb_attr_get(self, id_i_io), rb_intern("remote_address"), 0);
+
+    return rb_funcall(remote_address, rb_intern("inspect_sockaddr"), 0);
+}
+
+static VALUE
+fallback_peer_ip_address(VALUE self, VALUE args)
+{
+    return rb_str_new_cstr("(null)");
+}
+
+static VALUE
+peeraddr_ip_str(VALUE self)
+{
+    VALUE rb_mErrno = rb_const_get(rb_cObject, rb_intern("Errno"));
+    VALUE rb_eSystemCallError = rb_const_get(rb_mErrno, rb_intern("SystemCallError"));
+
+    return rb_rescue2(peer_ip_address, self, fallback_peer_ip_address, (VALUE)0, rb_eSystemCallError, NULL);
+}
+
 /*
  * call-seq:
  *    SSLSocket.new(io) => aSSLSocket
@@ -1603,6 +1534,7 @@ ossl_ssl_initialize(int argc, VALUE *argv, VALUE self)
 
     if (rb_respond_to(io, rb_intern("nonblock=")))
 	rb_funcall(io, rb_intern("nonblock="), 1, Qtrue);
+    Check_Type(io, T_FILE);
     rb_ivar_set(self, id_i_io, io);
 
     ssl = SSL_new(ctx);
@@ -1670,6 +1602,26 @@ no_exception_p(VALUE opts)
     return 0;
 }
 
+static void
+io_wait_writable(rb_io_t *fptr)
+{
+#ifdef HAVE_RB_IO_MAYBE_WAIT
+    rb_io_maybe_wait_writable(errno, fptr->self, Qnil);
+#else
+    rb_io_wait_writable(fptr->fd);
+#endif
+}
+
+static void
+io_wait_readable(rb_io_t *fptr)
+{
+#ifdef HAVE_RB_IO_MAYBE_WAIT
+    rb_io_maybe_wait_readable(errno, fptr->self, Qnil);
+#else
+    rb_io_wait_readable(fptr->fd);
+#endif
+}
+
 static VALUE
 ossl_start_ssl(VALUE self, int (*func)(), const char *funcname, VALUE opts)
 {
@@ -1704,12 +1656,12 @@ ossl_start_ssl(VALUE self, int (*func)(), const char *funcname, VALUE opts)
 	case SSL_ERROR_WANT_WRITE:
             if (no_exception_p(opts)) { return sym_wait_writable; }
             write_would_block(nonblock);
-            rb_io_wait_writable(fptr->fd);
+            io_wait_writable(fptr);
             continue;
 	case SSL_ERROR_WANT_READ:
             if (no_exception_p(opts)) { return sym_wait_readable; }
             read_would_block(nonblock);
-            rb_io_wait_readable(fptr->fd);
+            io_wait_readable(fptr);
             continue;
 	case SSL_ERROR_SYSCALL:
 #ifdef __APPLE__
@@ -1718,7 +1670,9 @@ ossl_start_ssl(VALUE self, int (*func)(), const char *funcname, VALUE opts)
                 continue;
 #endif
 	    if (errno) rb_sys_fail(funcname);
-	    ossl_raise(eSSLError, "%s SYSCALL returned=%d errno=%d state=%s", funcname, ret2, errno, SSL_state_string_long(ssl));
+	    ossl_raise(eSSLError, "%s SYSCALL returned=%d errno=%d peeraddr=%"PRIsVALUE" state=%s",
+                funcname, ret2, errno, peeraddr_ip_str(self), SSL_state_string_long(ssl));
+
 #if defined(SSL_R_CERTIFICATE_VERIFY_FAILED)
 	case SSL_ERROR_SSL:
 	    err = ERR_peek_last_error();
@@ -1731,13 +1685,15 @@ ossl_start_ssl(VALUE self, int (*func)(), const char *funcname, VALUE opts)
 		if (!verify_msg)
 		    verify_msg = "(null)";
 		ossl_clear_error(); /* let ossl_raise() not append message */
-		ossl_raise(eSSLError, "%s returned=%d errno=%d state=%s: %s (%s)",
-			   funcname, ret2, errno, SSL_state_string_long(ssl),
+		ossl_raise(eSSLError, "%s returned=%d errno=%d peeraddr=%"PRIsVALUE" state=%s: %s (%s)",
+			   funcname, ret2, errno, peeraddr_ip_str(self), SSL_state_string_long(ssl),
 			   err_msg, verify_msg);
 	    }
 #endif
+	    /* fallthrough */
 	default:
-	    ossl_raise(eSSLError, "%s returned=%d errno=%d state=%s", funcname, ret2, errno, SSL_state_string_long(ssl));
+	    ossl_raise(eSSLError, "%s returned=%d errno=%d peeraddr=%"PRIsVALUE" state=%s",
+                funcname, ret2, errno, peeraddr_ip_str(self), SSL_state_string_long(ssl));
 	}
     }
 
@@ -1748,8 +1704,7 @@ ossl_start_ssl(VALUE self, int (*func)(), const char *funcname, VALUE opts)
  * call-seq:
  *    ssl.connect => self
  *
- * Initiates an SSL/TLS handshake with a server.  The handshake may be started
- * after unencrypted data has been sent over the socket.
+ * Initiates an SSL/TLS handshake with a server.
  */
 static VALUE
 ossl_ssl_connect(VALUE self)
@@ -1796,8 +1751,7 @@ ossl_ssl_connect_nonblock(int argc, VALUE *argv, VALUE self)
  * call-seq:
  *    ssl.accept => self
  *
- * Waits for a SSL/TLS client to initiate a handshake.  The handshake may be
- * started after unencrypted data has been sent over the socket.
+ * Waits for a SSL/TLS client to initiate a handshake.
  */
 static VALUE
 ossl_ssl_accept(VALUE self)
@@ -1844,7 +1798,7 @@ static VALUE
 ossl_ssl_read_internal(int argc, VALUE *argv, VALUE self, int nonblock)
 {
     SSL *ssl;
-    int ilen, nread = 0;
+    int ilen;
     VALUE len, str;
     rb_io_t *fptr;
     VALUE io, opts = Qnil;
@@ -1854,6 +1808,9 @@ ossl_ssl_read_internal(int argc, VALUE *argv, VALUE self, int nonblock)
     } else {
 	rb_scan_args(argc, argv, "11", &len, &str);
     }
+    GetSSL(self, ssl);
+    if (!ssl_started(ssl))
+        rb_raise(eSSLError, "SSL session is not started yet");
 
     ilen = NUM2INT(len);
     if (NIL_P(str))
@@ -1869,85 +1826,60 @@ ossl_ssl_read_internal(int argc, VALUE *argv, VALUE self, int nonblock)
     if (ilen == 0)
 	return str;
 
-    GetSSL(self, ssl);
     io = rb_attr_get(self, id_i_io);
     GetOpenFile(io, fptr);
-    if (ssl_started(ssl)) {
-        rb_str_locktmp(str);
-        for (;;) {
-	    nread = SSL_read(ssl, RSTRING_PTR(str), ilen);
-	    switch(ssl_get_error(ssl, nread)){
-	    case SSL_ERROR_NONE:
+
+    rb_str_locktmp(str);
+    for (;;) {
+        int nread = SSL_read(ssl, RSTRING_PTR(str), ilen);
+        switch (ssl_get_error(ssl, nread)) {
+          case SSL_ERROR_NONE:
+            rb_str_unlocktmp(str);
+            rb_str_set_len(str, nread);
+            return str;
+          case SSL_ERROR_ZERO_RETURN:
+            rb_str_unlocktmp(str);
+            if (no_exception_p(opts)) { return Qnil; }
+            rb_eof_error();
+          case SSL_ERROR_WANT_WRITE:
+            if (nonblock) {
                 rb_str_unlocktmp(str);
-		goto end;
-	    case SSL_ERROR_ZERO_RETURN:
+                if (no_exception_p(opts)) { return sym_wait_writable; }
+                write_would_block(nonblock);
+            }
+            io_wait_writable(fptr);
+            continue;
+          case SSL_ERROR_WANT_READ:
+            if (nonblock) {
                 rb_str_unlocktmp(str);
-		if (no_exception_p(opts)) { return Qnil; }
-		rb_eof_error();
-	    case SSL_ERROR_WANT_WRITE:
-                if (nonblock) {
-                    rb_str_unlocktmp(str);
-                    if (no_exception_p(opts)) { return sym_wait_writable; }
-                    write_would_block(nonblock);
-                }
-                rb_io_wait_writable(fptr->fd);
-                continue;
-	    case SSL_ERROR_WANT_READ:
-                if (nonblock) {
-                    rb_str_unlocktmp(str);
-                    if (no_exception_p(opts)) { return sym_wait_readable; }
-                    read_would_block(nonblock);
-                }
-                rb_io_wait_readable(fptr->fd);
-		continue;
-	    case SSL_ERROR_SYSCALL:
-		if (!ERR_peek_error()) {
-                    rb_str_unlocktmp(str);
-		    if (errno)
-			rb_sys_fail(0);
-		    else {
-			/*
-			 * The underlying BIO returned 0. This is actually a
-			 * protocol error. But unfortunately, not all
-			 * implementations cleanly shutdown the TLS connection
-			 * but just shutdown/close the TCP connection. So report
-			 * EOF for now...
-			 */
-			if (no_exception_p(opts)) { return Qnil; }
-			rb_eof_error();
-		    }
-		}
-                /* fall through */
-	    default:
+                if (no_exception_p(opts)) { return sym_wait_readable; }
+                read_would_block(nonblock);
+            }
+            io_wait_readable(fptr);
+            continue;
+          case SSL_ERROR_SYSCALL:
+            if (!ERR_peek_error()) {
                 rb_str_unlocktmp(str);
-		ossl_raise(eSSLError, "SSL_read");
-	    }
-        }
-    }
-    else {
-        ID meth = nonblock ? rb_intern("read_nonblock") : rb_intern("sysread");
-
-        rb_warning("SSL session is not started yet.");
-#if defined(RB_PASS_KEYWORDS)
-        if (nonblock) {
-            VALUE argv[3];
-            argv[0] = len;
-            argv[1] = str;
-            argv[2] = opts;
-            return rb_funcallv_kw(io, meth, 3, argv, RB_PASS_KEYWORDS);
-        }
-#else
-        if (nonblock) {
-            return rb_funcall(io, meth, 3, len, str, opts);
+                if (errno)
+                    rb_sys_fail(0);
+                else {
+                    /*
+                     * The underlying BIO returned 0. This is actually a
+                     * protocol error. But unfortunately, not all
+                     * implementations cleanly shutdown the TLS connection
+                     * but just shutdown/close the TCP connection. So report
+                     * EOF for now...
+                     */
+                    if (no_exception_p(opts)) { return Qnil; }
+                    rb_eof_error();
+                }
+            }
+            /* fall through */
+          default:
+            rb_str_unlocktmp(str);
+            ossl_raise(eSSLError, "SSL_read");
         }
-#endif
-        else
-            return rb_funcall(io, meth, 2, len, str);
     }
-
-  end:
-    rb_str_set_len(str, nread);
-    return str;
 }
 
 /*
@@ -1987,77 +1919,55 @@ static VALUE
 ossl_ssl_write_internal(VALUE self, VALUE str, VALUE opts)
 {
     SSL *ssl;
-    int nwrite = 0;
     rb_io_t *fptr;
-    int nonblock = opts != Qfalse;
+    int num, nonblock = opts != Qfalse;
     VALUE tmp, io;
 
-    tmp = rb_str_new_frozen(StringValue(str));
     GetSSL(self, ssl);
+    if (!ssl_started(ssl))
+        rb_raise(eSSLError, "SSL session is not started yet");
+
+    tmp = rb_str_new_frozen(StringValue(str));
     io = rb_attr_get(self, id_i_io);
     GetOpenFile(io, fptr);
-    if (ssl_started(ssl)) {
-	for (;;) {
-	    int num = RSTRING_LENINT(tmp);
-
-	    /* SSL_write(3ssl) manpage states num == 0 is undefined */
-	    if (num == 0)
-		goto end;
-
-	    nwrite = SSL_write(ssl, RSTRING_PTR(tmp), num);
-	    switch(ssl_get_error(ssl, nwrite)){
-	    case SSL_ERROR_NONE:
-		goto end;
-	    case SSL_ERROR_WANT_WRITE:
-		if (no_exception_p(opts)) { return sym_wait_writable; }
-                write_would_block(nonblock);
-                rb_io_wait_writable(fptr->fd);
-                continue;
-	    case SSL_ERROR_WANT_READ:
-		if (no_exception_p(opts)) { return sym_wait_readable; }
-                read_would_block(nonblock);
-                rb_io_wait_readable(fptr->fd);
-                continue;
-	    case SSL_ERROR_SYSCALL:
+
+    /* SSL_write(3ssl) manpage states num == 0 is undefined */
+    num = RSTRING_LENINT(tmp);
+    if (num == 0)
+        return INT2FIX(0);
+
+    for (;;) {
+        int nwritten = SSL_write(ssl, RSTRING_PTR(tmp), num);
+        switch (ssl_get_error(ssl, nwritten)) {
+          case SSL_ERROR_NONE:
+            return INT2NUM(nwritten);
+          case SSL_ERROR_WANT_WRITE:
+            if (no_exception_p(opts)) { return sym_wait_writable; }
+            write_would_block(nonblock);
+            io_wait_writable(fptr);
+            continue;
+          case SSL_ERROR_WANT_READ:
+            if (no_exception_p(opts)) { return sym_wait_readable; }
+            read_would_block(nonblock);
+            io_wait_readable(fptr);
+            continue;
+          case SSL_ERROR_SYSCALL:
 #ifdef __APPLE__
-                /*
-                 * It appears that send syscall can return EPROTOTYPE if the
-                 * socket is being torn down. Retry to get a proper errno to
-                 * make the error handling in line with the socket library.
-                 * [Bug #14713] https://bugs.ruby-lang.org/issues/14713
-                 */
-                if (errno == EPROTOTYPE)
-                    continue;
+            /*
+             * It appears that send syscall can return EPROTOTYPE if the
+             * socket is being torn down. Retry to get a proper errno to
+             * make the error handling in line with the socket library.
+             * [Bug #14713] https://bugs.ruby-lang.org/issues/14713
+             */
+            if (errno == EPROTOTYPE)
+                continue;
 #endif
-		if (errno) rb_sys_fail(0);
-	    default:
-		ossl_raise(eSSLError, "SSL_write");
-	    }
+            if (errno) rb_sys_fail(0);
+            /* fallthrough */
+          default:
+            ossl_raise(eSSLError, "SSL_write");
         }
     }
-    else {
-	ID meth = nonblock ?
-	    rb_intern("write_nonblock") : rb_intern("syswrite");
-
-        rb_warning("SSL session is not started yet.");
-#if defined(RB_PASS_KEYWORDS)
-        if (nonblock) {
-            VALUE argv[2];
-            argv[0] = str;
-            argv[1] = opts;
-            return rb_funcallv_kw(io, meth, 2, argv, RB_PASS_KEYWORDS);
-        }
-#else
-        if (nonblock) {
-            return rb_funcall(io, meth, 2, str, opts);
-        }
-#endif
-        else
-            return rb_funcall(io, meth, 1, str);
-    }
-
-  end:
-    return INT2NUM(nwrite);
 }
 
 /*
@@ -2457,7 +2367,6 @@ ossl_ssl_npn_protocol(VALUE self)
 }
 # endif
 
-# ifdef HAVE_SSL_CTX_SET_ALPN_SELECT_CB
 /*
  * call-seq:
  *    ssl.alpn_protocol => String | nil
@@ -2480,9 +2389,7 @@ ossl_ssl_alpn_protocol(VALUE self)
     else
 	return rb_str_new((const char *) out, outlen);
 }
-# endif
 
-# ifdef HAVE_SSL_GET_SERVER_TMP_KEY
 /*
  * call-seq:
  *    ssl.tmp_key => PKey or nil
@@ -2500,7 +2407,6 @@ ossl_ssl_tmp_key(VALUE self)
 	return Qnil;
     return ossl_pkey_new(key);
 }
-# endif /* defined(HAVE_SSL_GET_SERVER_TMP_KEY) */
 #endif /* !defined(OPENSSL_NO_SOCK) */
 
 void
@@ -2525,11 +2431,6 @@ Init_ossl_ssl(void)
     ossl_sslctx_ex_ptr_idx = SSL_CTX_get_ex_new_index(0, (void *)"ossl_sslctx_ex_ptr_idx", 0, 0, 0);
     if (ossl_sslctx_ex_ptr_idx < 0)
 	ossl_raise(rb_eRuntimeError, "SSL_CTX_get_ex_new_index");
-#if !defined(HAVE_X509_STORE_UP_REF)
-    ossl_sslctx_ex_store_p = SSL_CTX_get_ex_new_index(0, (void *)"ossl_sslctx_ex_store_p", 0, 0, 0);
-    if (ossl_sslctx_ex_store_p < 0)
-	ossl_raise(rb_eRuntimeError, "SSL_CTX_get_ex_new_index");
-#endif
 
     /* Document-module: OpenSSL::SSL
      *
@@ -2677,20 +2578,6 @@ Init_ossl_ssl(void)
      */
     rb_attr(cSSLContext, rb_intern_const("client_cert_cb"), 1, 1, Qfalse);
 
-#if !defined(OPENSSL_NO_EC) && defined(HAVE_SSL_CTX_SET_TMP_ECDH_CALLBACK)
-    /*
-     * A callback invoked when ECDH parameters are required.
-     *
-     * The callback is invoked with the Session for the key exchange, an
-     * flag indicating the use of an export cipher and the keylength
-     * required.
-     *
-     * The callback is deprecated. This does not work with recent versions of
-     * OpenSSL. Use OpenSSL::SSL::SSLContext#ecdh_curves= instead.
-     */
-    rb_attr(cSSLContext, rb_intern_const("tmp_ecdh_callback"), 1, 1, Qfalse);
-#endif
-
     /*
      * Sets the context in which a session can be reused.  This allows
      * sessions for multiple applications to be distinguished, for example, by
@@ -2780,7 +2667,6 @@ Init_ossl_ssl(void)
     rb_attr(cSSLContext, rb_intern_const("npn_select_cb"), 1, 1, Qfalse);
 #endif
 
-#ifdef HAVE_SSL_CTX_SET_ALPN_SELECT_CB
     /*
      * An Enumerable of Strings. Each String represents a protocol to be
      * advertised as the list of supported protocols for Application-Layer
@@ -2810,7 +2696,6 @@ Init_ossl_ssl(void)
      *   end
      */
     rb_attr(cSSLContext, rb_intern_const("alpn_select_cb"), 1, 1, Qfalse);
-#endif
 
     rb_define_alias(cSSLContext, "ssl_timeout", "timeout");
     rb_define_alias(cSSLContext, "ssl_timeout=", "timeout=");
@@ -2818,6 +2703,9 @@ Init_ossl_ssl(void)
 			     ossl_sslctx_set_minmax_proto_version, 2);
     rb_define_method(cSSLContext, "ciphers",     ossl_sslctx_get_ciphers, 0);
     rb_define_method(cSSLContext, "ciphers=",    ossl_sslctx_set_ciphers, 1);
+#ifndef OPENSSL_NO_DH
+    rb_define_method(cSSLContext, "tmp_dh=", ossl_sslctx_set_tmp_dh, 1);
+#endif
     rb_define_method(cSSLContext, "ecdh_curves=", ossl_sslctx_set_ecdh_curves, 1);
     rb_define_method(cSSLContext, "security_level", ossl_sslctx_get_security_level, 0);
     rb_define_method(cSSLContext, "security_level=", ossl_sslctx_set_security_level, 1);
@@ -2924,12 +2812,8 @@ Init_ossl_ssl(void)
     rb_define_method(cSSLSocket, "hostname=", ossl_ssl_set_hostname, 1);
     rb_define_method(cSSLSocket, "finished_message", ossl_ssl_get_finished, 0);
     rb_define_method(cSSLSocket, "peer_finished_message", ossl_ssl_get_peer_finished, 0);
-# ifdef HAVE_SSL_GET_SERVER_TMP_KEY
     rb_define_method(cSSLSocket, "tmp_key", ossl_ssl_tmp_key, 0);
-# endif
-# ifdef HAVE_SSL_CTX_SET_ALPN_SELECT_CB
     rb_define_method(cSSLSocket, "alpn_protocol", ossl_ssl_alpn_protocol, 0);
-# endif
 # ifndef OPENSSL_NO_NEXTPROTONEG
     rb_define_method(cSSLSocket, "npn_protocol", ossl_ssl_npn_protocol, 0);
 # endif
@@ -2941,12 +2825,23 @@ Init_ossl_ssl(void)
     rb_define_const(mSSL, "VERIFY_CLIENT_ONCE", INT2NUM(SSL_VERIFY_CLIENT_ONCE));
 
     rb_define_const(mSSL, "OP_ALL", ULONG2NUM(SSL_OP_ALL));
+#ifdef SSL_OP_CLEANSE_PLAINTEXT /* OpenSSL 3.0 */
+    rb_define_const(mSSL, "OP_CLEANSE_PLAINTEXT", ULONG2NUM(SSL_OP_CLEANSE_PLAINTEXT));
+#endif
     rb_define_const(mSSL, "OP_LEGACY_SERVER_CONNECT", ULONG2NUM(SSL_OP_LEGACY_SERVER_CONNECT));
-#ifdef SSL_OP_TLSEXT_PADDING /* OpenSSL 1.0.1h and OpenSSL 1.0.2 */
-    rb_define_const(mSSL, "OP_TLSEXT_PADDING", ULONG2NUM(SSL_OP_TLSEXT_PADDING));
+#ifdef SSL_OP_ENABLE_KTLS /* OpenSSL 3.0 */
+    rb_define_const(mSSL, "OP_ENABLE_KTLS", ULONG2NUM(SSL_OP_ENABLE_KTLS));
 #endif
-#ifdef SSL_OP_SAFARI_ECDHE_ECDSA_BUG /* OpenSSL 1.0.1f and OpenSSL 1.0.2 */
+    rb_define_const(mSSL, "OP_TLSEXT_PADDING", ULONG2NUM(SSL_OP_TLSEXT_PADDING));
     rb_define_const(mSSL, "OP_SAFARI_ECDHE_ECDSA_BUG", ULONG2NUM(SSL_OP_SAFARI_ECDHE_ECDSA_BUG));
+#ifdef SSL_OP_IGNORE_UNEXPECTED_EOF /* OpenSSL 3.0 */
+    rb_define_const(mSSL, "OP_IGNORE_UNEXPECTED_EOF", ULONG2NUM(SSL_OP_IGNORE_UNEXPECTED_EOF));
+#endif
+#ifdef SSL_OP_ALLOW_CLIENT_RENEGOTIATION /* OpenSSL 3.0 */
+    rb_define_const(mSSL, "OP_ALLOW_CLIENT_RENEGOTIATION", ULONG2NUM(SSL_OP_ALLOW_CLIENT_RENEGOTIATION));
+#endif
+#ifdef SSL_OP_DISABLE_TLSEXT_CA_NAMES /* OpenSSL 3.0 */
+    rb_define_const(mSSL, "OP_DISABLE_TLSEXT_CA_NAMES", ULONG2NUM(SSL_OP_DISABLE_TLSEXT_CA_NAMES));
 #endif
 #ifdef SSL_OP_ALLOW_NO_DHE_KEX /* OpenSSL 1.1.1 */
     rb_define_const(mSSL, "OP_ALLOW_NO_DHE_KEX", ULONG2NUM(SSL_OP_ALLOW_NO_DHE_KEX));
@@ -2959,13 +2854,15 @@ Init_ossl_ssl(void)
 #ifdef SSL_OP_NO_ENCRYPT_THEN_MAC /* OpenSSL 1.1.1 */
     rb_define_const(mSSL, "OP_NO_ENCRYPT_THEN_MAC", ULONG2NUM(SSL_OP_NO_ENCRYPT_THEN_MAC));
 #endif
-    rb_define_const(mSSL, "OP_CIPHER_SERVER_PREFERENCE", ULONG2NUM(SSL_OP_CIPHER_SERVER_PREFERENCE));
-    rb_define_const(mSSL, "OP_TLS_ROLLBACK_BUG", ULONG2NUM(SSL_OP_TLS_ROLLBACK_BUG));
-#ifdef SSL_OP_NO_RENEGOTIATION /* OpenSSL 1.1.1 */
-    rb_define_const(mSSL, "OP_NO_RENEGOTIATION", ULONG2NUM(SSL_OP_NO_RENEGOTIATION));
+#ifdef SSL_OP_ENABLE_MIDDLEBOX_COMPAT /* OpenSSL 1.1.1 */
+    rb_define_const(mSSL, "OP_ENABLE_MIDDLEBOX_COMPAT", ULONG2NUM(SSL_OP_ENABLE_MIDDLEBOX_COMPAT));
+#endif
+#ifdef SSL_OP_PRIORITIZE_CHACHA /* OpenSSL 1.1.1 */
+    rb_define_const(mSSL, "OP_PRIORITIZE_CHACHA", ULONG2NUM(SSL_OP_PRIORITIZE_CHACHA));
+#endif
+#ifdef SSL_OP_NO_ANTI_REPLAY /* OpenSSL 1.1.1 */
+    rb_define_const(mSSL, "OP_NO_ANTI_REPLAY", ULONG2NUM(SSL_OP_NO_ANTI_REPLAY));
 #endif
-    rb_define_const(mSSL, "OP_CRYPTOPRO_TLSEXT_BUG", ULONG2NUM(SSL_OP_CRYPTOPRO_TLSEXT_BUG));
-
     rb_define_const(mSSL, "OP_NO_SSLv3", ULONG2NUM(SSL_OP_NO_SSLv3));
     rb_define_const(mSSL, "OP_NO_TLSv1", ULONG2NUM(SSL_OP_NO_TLSv1));
     rb_define_const(mSSL, "OP_NO_TLSv1_1", ULONG2NUM(SSL_OP_NO_TLSv1_1));
@@ -2973,6 +2870,12 @@ Init_ossl_ssl(void)
 #ifdef SSL_OP_NO_TLSv1_3 /* OpenSSL 1.1.1 */
     rb_define_const(mSSL, "OP_NO_TLSv1_3", ULONG2NUM(SSL_OP_NO_TLSv1_3));
 #endif
+    rb_define_const(mSSL, "OP_CIPHER_SERVER_PREFERENCE", ULONG2NUM(SSL_OP_CIPHER_SERVER_PREFERENCE));
+    rb_define_const(mSSL, "OP_TLS_ROLLBACK_BUG", ULONG2NUM(SSL_OP_TLS_ROLLBACK_BUG));
+#ifdef SSL_OP_NO_RENEGOTIATION /* OpenSSL 1.1.1 */
+    rb_define_const(mSSL, "OP_NO_RENEGOTIATION", ULONG2NUM(SSL_OP_NO_RENEGOTIATION));
+#endif
+    rb_define_const(mSSL, "OP_CRYPTOPRO_TLSEXT_BUG", ULONG2NUM(SSL_OP_CRYPTOPRO_TLSEXT_BUG));
 
     /* SSL_OP_* flags for DTLS */
 #if 0
@@ -3042,7 +2945,6 @@ Init_ossl_ssl(void)
     sym_wait_writable = ID2SYM(rb_intern_const("wait_writable"));
 
     id_tmp_dh_callback = rb_intern_const("tmp_dh_callback");
-    id_tmp_ecdh_callback = rb_intern_const("tmp_ecdh_callback");
     id_npn_protocols_encoded = rb_intern_const("npn_protocols_encoded");
     id_each = rb_intern_const("each");
 
@@ -3061,7 +2963,6 @@ Init_ossl_ssl(void)
     DefIVarID(key);
     DefIVarID(extra_chain_cert);
     DefIVarID(client_cert_cb);
-    DefIVarID(tmp_ecdh_callback);
     DefIVarID(timeout);
     DefIVarID(session_id_context);
     DefIVarID(session_get_cb);
diff --git a/ext/openssl/ossl_ssl_session.c b/ext/openssl/ossl_ssl_session.c
index 5514087..92eb136 100644
--- a/ext/openssl/ossl_ssl_session.c
+++ b/ext/openssl/ossl_ssl_session.c
@@ -34,43 +34,38 @@ static VALUE ossl_ssl_session_alloc(VALUE klass)
  * Creates a new Session object from an instance of SSLSocket or DER/PEM encoded
  * String.
  */
-static VALUE ossl_ssl_session_initialize(VALUE self, VALUE arg1)
+static VALUE
+ossl_ssl_session_initialize(VALUE self, VALUE arg1)
 {
-	SSL_SESSION *ctx = NULL;
-
-	if (RDATA(self)->data)
-		ossl_raise(eSSLSession, "SSL Session already initialized");
-
-	if (rb_obj_is_instance_of(arg1, cSSLSocket)) {
-		SSL *ssl;
-
-		GetSSL(arg1, ssl);
-
-		if ((ctx = SSL_get1_session(ssl)) == NULL)
-			ossl_raise(eSSLSession, "no session available");
-	} else {
-		BIO *in = ossl_obj2bio(&arg1);
+    SSL_SESSION *ctx;
 
-		ctx = PEM_read_bio_SSL_SESSION(in, NULL, NULL, NULL);
+    if (RTYPEDDATA_DATA(self))
+        ossl_raise(eSSLSession, "SSL Session already initialized");
 
-		if (!ctx) {
-		        OSSL_BIO_reset(in);
-			ctx = d2i_SSL_SESSION_bio(in, NULL);
-		}
+    if (rb_obj_is_instance_of(arg1, cSSLSocket)) {
+        SSL *ssl;
 
-		BIO_free(in);
+        GetSSL(arg1, ssl);
 
-		if (!ctx)
-			ossl_raise(rb_eArgError, "unknown type");
-	}
+        if ((ctx = SSL_get1_session(ssl)) == NULL)
+            ossl_raise(eSSLSession, "no session available");
+    }
+    else {
+        BIO *in = ossl_obj2bio(&arg1);
 
-	/* should not happen */
-	if (ctx == NULL)
-		ossl_raise(eSSLSession, "ctx not set - internal error");
+        ctx = d2i_SSL_SESSION_bio(in, NULL);
+        if (!ctx) {
+            OSSL_BIO_reset(in);
+            ctx = PEM_read_bio_SSL_SESSION(in, NULL, NULL, NULL);
+        }
+        BIO_free(in);
+        if (!ctx)
+            ossl_raise(rb_eArgError, "unknown type");
+    }
 
-	RDATA(self)->data = ctx;
+    RTYPEDDATA_DATA(self) = ctx;
 
-	return self;
+    return self;
 }
 
 static VALUE
diff --git a/ext/openssl/ossl_ts.c b/ext/openssl/ossl_ts.c
index cff9b7b..b33ff10 100644
--- a/ext/openssl/ossl_ts.c
+++ b/ext/openssl/ossl_ts.c
@@ -145,6 +145,12 @@ obj_to_asn1obj(VALUE obj)
     return a1obj;
 }
 
+static VALUE
+obj_to_asn1obj_i(VALUE obj)
+{
+    return (VALUE)obj_to_asn1obj(obj);
+}
+
 static VALUE
 get_asn1obj(ASN1_OBJECT *obj)
 {
@@ -820,17 +826,14 @@ ossl_ts_resp_verify(int argc, VALUE *argv, VALUE self)
         X509_up_ref(cert);
     }
 
-    TS_VERIFY_CTS_set_certs(ctx, x509inter);
+    TS_VERIFY_CTX_set_certs(ctx, x509inter);
     TS_VERIFY_CTX_add_flags(ctx, TS_VFY_SIGNATURE);
     TS_VERIFY_CTX_set_store(ctx, x509st);
 
     ok = TS_RESP_verify_response(ctx, resp);
-
-    /* WORKAROUND:
-     *   X509_STORE can count references, but X509_STORE_free() doesn't check
-     *   this. To prevent our X509_STORE from being freed with our
-     *   TS_VERIFY_CTX we set the store to NULL first.
-     *   Fixed in OpenSSL 1.0.2; bff9ce4db38b (master), 5b4b9ce976fc (1.0.2)
+    /*
+     * TS_VERIFY_CTX_set_store() call above does not increment the reference
+     * counter, so it must be unset before TS_VERIFY_CTX_free() is called.
      */
     TS_VERIFY_CTX_set_store(ctx, NULL);
     TS_VERIFY_CTX_free(ctx);
@@ -1091,6 +1094,18 @@ ossl_tsfac_time_cb(struct TS_resp_ctx *ctx, void *data, time_t *sec, long *usec)
     return 1;
 }
 
+static VALUE
+ossl_evp_get_digestbyname_i(VALUE arg)
+{
+    return (VALUE)ossl_evp_get_digestbyname(arg);
+}
+
+static VALUE
+ossl_obj2bio_i(VALUE arg)
+{
+    return (VALUE)ossl_obj2bio((VALUE *)arg);
+}
+
 /*
  * Creates a Response with the help of an OpenSSL::PKey, an
  * OpenSSL::X509::Certificate and a Request.
@@ -1159,7 +1174,7 @@ ossl_tsfac_create_ts(VALUE self, VALUE key, VALUE certificate, VALUE request)
         goto end;
     }
     if (!NIL_P(def_policy_id) && !TS_REQ_get_policy_id(req)) {
-        def_policy_id_obj = (ASN1_OBJECT*)rb_protect((VALUE (*)(VALUE))obj_to_asn1obj, (VALUE)def_policy_id, &status);
+        def_policy_id_obj = (ASN1_OBJECT*)rb_protect(obj_to_asn1obj_i, (VALUE)def_policy_id, &status);
         if (status)
             goto end;
     }
@@ -1201,7 +1216,7 @@ ossl_tsfac_create_ts(VALUE self, VALUE key, VALUE certificate, VALUE request)
 
         for (i = 0; i < RARRAY_LEN(allowed_digests); i++) {
             rbmd = rb_ary_entry(allowed_digests, i);
-            md = (const EVP_MD *)rb_protect((VALUE (*)(VALUE))ossl_evp_get_digestbyname, rbmd, &status);
+            md = (const EVP_MD *)rb_protect(ossl_evp_get_digestbyname_i, rbmd, &status);
             if (status)
                 goto end;
             TS_RESP_CTX_add_md(ctx, md);
@@ -1212,7 +1227,7 @@ ossl_tsfac_create_ts(VALUE self, VALUE key, VALUE certificate, VALUE request)
     if (status)
         goto end;
 
-    req_bio = (BIO*)rb_protect((VALUE (*)(VALUE))ossl_obj2bio, (VALUE)&str, &status);
+    req_bio = (BIO*)rb_protect(ossl_obj2bio_i, (VALUE)&str, &status);
     if (status)
         goto end;
 
@@ -1236,7 +1251,7 @@ end:
     ASN1_OBJECT_free(def_policy_id_obj);
     TS_RESP_CTX_free(ctx);
     if (err_msg)
-        ossl_raise(eTimestampError, err_msg);
+        rb_exc_raise(ossl_make_error(eTimestampError, rb_str_new_cstr(err_msg)));
     if (status)
         rb_jump_tag(status);
     return ret;
@@ -1290,7 +1305,7 @@ Init_ossl_ts(void)
      * ===Create a Response:
      *      #Assumes ts.p12 is a PKCS#12-compatible file with a private key
      *      #and a certificate that has an extended key usage of 'timeStamping'
-     *      p12 = OpenSSL::PKCS12.new(File.open('ts.p12', 'rb'), 'pwd')
+     *      p12 = OpenSSL::PKCS12.new(File.binread('ts.p12'), 'pwd')
      *      md = OpenSSL::Digest.new('SHA1')
      *      hash = md.digest(data) #some binary data to be timestamped
      *      req = OpenSSL::Timestamp::Request.new
@@ -1305,16 +1320,16 @@ Init_ossl_ts(void)
      *
      * ===Verify a timestamp response:
      *      #Assume we have a timestamp token in a file called ts.der
-     *      ts = OpenSSL::Timestamp::Response.new(File.open('ts.der', 'rb')
+     *      ts = OpenSSL::Timestamp::Response.new(File.binread('ts.der'))
      *      #Assume we have the Request for this token in a file called req.der
-     *      req = OpenSSL::Timestamp::Request.new(File.open('req.der', 'rb')
+     *      req = OpenSSL::Timestamp::Request.new(File.binread('req.der'))
      *      # Assume the associated root CA certificate is contained in a
      *      # DER-encoded file named root.cer
-     *      root = OpenSSL::X509::Certificate.new(File.open('root.cer', 'rb')
+     *      root = OpenSSL::X509::Certificate.new(File.binread('root.cer'))
      *      # get the necessary intermediate certificates, available in
      *      # DER-encoded form in inter1.cer and inter2.cer
-     *      inter1 = OpenSSL::X509::Certificate.new(File.open('inter1.cer', 'rb')
-     *      inter2 = OpenSSL::X509::Certificate.new(File.open('inter2.cer', 'rb')
+     *      inter1 = OpenSSL::X509::Certificate.new(File.binread('inter1.cer'))
+     *      inter2 = OpenSSL::X509::Certificate.new(File.binread('inter2.cer'))
      *      ts.verify(req, root, inter1, inter2) -> ts or raises an exception if validation fails
      *
      */
@@ -1447,9 +1462,9 @@ Init_ossl_ts(void)
      * timestamping certificate.
      *
      *      req = OpenSSL::Timestamp::Request.new(raw_bytes)
-     *      p12 = OpenSSL::PKCS12.new(File.open('ts.p12', 'rb'), 'pwd')
-     *      inter1 = OpenSSL::X509::Certificate.new(File.open('inter1.cer', 'rb')
-     *      inter2 = OpenSSL::X509::Certificate.new(File.open('inter2.cer', 'rb')
+     *      p12 = OpenSSL::PKCS12.new(File.binread('ts.p12'), 'pwd')
+     *      inter1 = OpenSSL::X509::Certificate.new(File.binread('inter1.cer'))
+     *      inter2 = OpenSSL::X509::Certificate.new(File.binread('inter2.cer'))
      *      fac = OpenSSL::Timestamp::Factory.new
      *      fac.gen_time = Time.now
      *      fac.serial_number = 1
diff --git a/ext/openssl/ossl_x509.c b/ext/openssl/ossl_x509.c
index 4fc0648..f847070 100644
--- a/ext/openssl/ossl_x509.c
+++ b/ext/openssl/ossl_x509.c
@@ -115,11 +115,9 @@ Init_ossl_x509(void)
     DefX509Const(V_ERR_SUITE_B_LOS_NOT_ALLOWED);
     DefX509Const(V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256);
 #endif
-#if defined(X509_V_ERR_HOSTNAME_MISMATCH)
     DefX509Const(V_ERR_HOSTNAME_MISMATCH);
     DefX509Const(V_ERR_EMAIL_MISMATCH);
     DefX509Const(V_ERR_IP_ADDRESS_MISMATCH);
-#endif
 #if defined(X509_V_ERR_DANE_NO_MATCH)
     DefX509Const(V_ERR_DANE_NO_MATCH);
 #endif
@@ -187,12 +185,10 @@ Init_ossl_x509(void)
     /* Set by Store#flags= and StoreContext#flags=. Enables checking of the
      * signature of the root self-signed CA. */
     DefX509Const(V_FLAG_CHECK_SS_SIGNATURE);
-#if defined(X509_V_FLAG_TRUSTED_FIRST)
     /* Set by Store#flags= and StoreContext#flags=. When constructing a
      * certificate chain, search the Store first for the issuer certificate.
      * Enabled by default in OpenSSL >= 1.1.0. */
     DefX509Const(V_FLAG_TRUSTED_FIRST);
-#endif
 #if defined(X509_V_FLAG_SUITEB_128_LOS_ONLY)
     /* Set by Store#flags= and StoreContext#flags=.
      * Enables Suite B 128 bit only mode. */
@@ -208,11 +204,9 @@ Init_ossl_x509(void)
      * Enables Suite B 128 bit mode allowing 192 bit algorithms. */
     DefX509Const(V_FLAG_SUITEB_128_LOS);
 #endif
-#if defined(X509_V_FLAG_PARTIAL_CHAIN)
     /* Set by Store#flags= and StoreContext#flags=.
      * Allows partial chains if at least one certificate is in trusted store. */
     DefX509Const(V_FLAG_PARTIAL_CHAIN);
-#endif
 #if defined(X509_V_FLAG_NO_ALT_CHAINS)
     /* Set by Store#flags= and StoreContext#flags=. Suppresses searching for
      * a alternative chain. No effect in OpenSSL >= 1.1.0. */
diff --git a/ext/openssl/ossl_x509cert.c b/ext/openssl/ossl_x509cert.c
index e3766b1..996f184 100644
--- a/ext/openssl/ossl_x509cert.c
+++ b/ext/openssl/ossl_x509cert.c
@@ -115,24 +115,27 @@ static VALUE
 ossl_x509_initialize(int argc, VALUE *argv, VALUE self)
 {
     BIO *in;
-    X509 *x509, *x = DATA_PTR(self);
+    X509 *x509, *x509_orig = RTYPEDDATA_DATA(self);
     VALUE arg;
 
+    rb_check_frozen(self);
     if (rb_scan_args(argc, argv, "01", &arg) == 0) {
 	/* create just empty X509Cert */
 	return self;
     }
     arg = ossl_to_der_if_possible(arg);
     in = ossl_obj2bio(&arg);
-    x509 = PEM_read_bio_X509(in, &x, NULL, NULL);
-    DATA_PTR(self) = x;
+    x509 = d2i_X509_bio(in, NULL);
     if (!x509) {
-	OSSL_BIO_reset(in);
-	x509 = d2i_X509_bio(in, &x);
-	DATA_PTR(self) = x;
+        OSSL_BIO_reset(in);
+        x509 = PEM_read_bio_X509(in, NULL, NULL, NULL);
     }
     BIO_free(in);
-    if (!x509) ossl_raise(eX509CertError, NULL);
+    if (!x509)
+        ossl_raise(eX509CertError, "PEM_read_bio_X509");
+
+    RTYPEDDATA_DATA(self) = x509;
+    X509_free(x509_orig);
 
     return self;
 }
@@ -704,6 +707,157 @@ ossl_x509_eq(VALUE self, VALUE other)
     return !X509_cmp(a, b) ? Qtrue : Qfalse;
 }
 
+struct load_chained_certificates_arguments {
+    VALUE certificates;
+    X509 *certificate;
+};
+
+static VALUE
+load_chained_certificates_append_push(VALUE _arguments) {
+    struct load_chained_certificates_arguments *arguments = (struct load_chained_certificates_arguments*)_arguments;
+
+    if (arguments->certificates == Qnil) {
+        arguments->certificates = rb_ary_new();
+    }
+
+    rb_ary_push(arguments->certificates, ossl_x509_new(arguments->certificate));
+
+    return Qnil;
+}
+
+static VALUE
+load_chained_certificate_append_ensure(VALUE _arguments) {
+    struct load_chained_certificates_arguments *arguments = (struct load_chained_certificates_arguments*)_arguments;
+
+    X509_free(arguments->certificate);
+
+    return Qnil;
+}
+
+inline static VALUE
+load_chained_certificates_append(VALUE certificates, X509 *certificate) {
+    struct load_chained_certificates_arguments arguments;
+    arguments.certificates = certificates;
+    arguments.certificate = certificate;
+
+    rb_ensure(load_chained_certificates_append_push, (VALUE)&arguments, load_chained_certificate_append_ensure, (VALUE)&arguments);
+
+    return arguments.certificates;
+}
+
+static VALUE
+load_chained_certificates_PEM(BIO *in) {
+    VALUE certificates = Qnil;
+    X509 *certificate = PEM_read_bio_X509(in, NULL, NULL, NULL);
+
+    /* If we cannot read even one certificate: */
+    if (certificate == NULL) {
+        /* If we cannot read one certificate because we could not read the PEM encoding: */
+        if (ERR_GET_REASON(ERR_peek_last_error()) == PEM_R_NO_START_LINE) {
+            ossl_clear_error();
+        }
+
+        if (ERR_peek_last_error())
+            ossl_raise(eX509CertError, NULL);
+        else
+            return Qnil;
+    }
+
+    certificates = load_chained_certificates_append(Qnil, certificate);
+
+    while ((certificate = PEM_read_bio_X509(in, NULL, NULL, NULL))) {
+      load_chained_certificates_append(certificates, certificate);
+    }
+
+    /* We tried to read one more certificate but could not read start line: */
+    if (ERR_GET_REASON(ERR_peek_last_error()) == PEM_R_NO_START_LINE) {
+        /* This is not an error, it means we are finished: */
+        ossl_clear_error();
+
+        return certificates;
+    }
+
+    /* Alternatively, if we reached the end of the file and there was no error: */
+    if (BIO_eof(in) && !ERR_peek_last_error()) {
+        return certificates;
+    } else {
+        /* Otherwise, we tried to read a certificate but failed somewhere: */
+        ossl_raise(eX509CertError, NULL);
+    }
+}
+
+static VALUE
+load_chained_certificates_DER(BIO *in) {
+    X509 *certificate = d2i_X509_bio(in, NULL);
+
+    /* If we cannot read one certificate: */
+    if (certificate == NULL) {
+        /* Ignore error. We could not load. */
+        ossl_clear_error();
+
+        return Qnil;
+    }
+
+    return load_chained_certificates_append(Qnil, certificate);
+}
+
+static VALUE
+load_chained_certificates(VALUE _io) {
+    BIO *in = (BIO*)_io;
+    VALUE certificates = Qnil;
+
+    /*
+      DER is a binary format and it may contain octets within it that look like
+      PEM encoded certificates. So we need to check DER first.
+    */
+    certificates = load_chained_certificates_DER(in);
+
+    if (certificates != Qnil)
+        return certificates;
+
+    OSSL_BIO_reset(in);
+
+    certificates = load_chained_certificates_PEM(in);
+
+    if (certificates != Qnil)
+        return certificates;
+
+    /* Otherwise we couldn't read the output correctly so fail: */
+    ossl_raise(eX509CertError, "Could not detect format of certificate data!");
+}
+
+static VALUE
+load_chained_certificates_ensure(VALUE _io) {
+    BIO *in = (BIO*)_io;
+
+    BIO_free(in);
+
+    return Qnil;
+}
+
+/*
+ * call-seq:
+ *    OpenSSL::X509::Certificate.load(string) -> [certs...]
+ *    OpenSSL::X509::Certificate.load(file) -> [certs...]
+ *
+ * Read the chained certificates from the given input. Supports both PEM
+ * and DER encoded certificates.
+ *
+ * PEM is a text format and supports more than one certificate.
+ *
+ * DER is a binary format and only supports one certificate.
+ *
+ * If the file is empty, or contains only unrelated data, an
+ * +OpenSSL::X509::CertificateError+ exception will be raised.
+ */
+static VALUE
+ossl_x509_load(VALUE klass, VALUE buffer)
+{
+    BIO *in = ossl_obj2bio(&buffer);
+
+    return rb_ensure(load_chained_certificates, (VALUE)in, load_chained_certificates_ensure, (VALUE)in);
+}
+
 /*
  * INIT
  */
@@ -730,7 +884,7 @@ Init_ossl_x509cert(void)
      * Certificate is capable of handling DER-encoded certificates and
      * certificates encoded in OpenSSL's PEM format.
      *
-     *   raw = File.read "cert.cer" # DER- or PEM-encoded
+     *   raw = File.binread "cert.cer" # DER- or PEM-encoded
      *   certificate = OpenSSL::X509::Certificate.new raw
      *
      * === Saving a certificate to a file
@@ -812,6 +966,8 @@ Init_ossl_x509cert(void)
      */
     cX509Cert = rb_define_class_under(mX509, "Certificate", rb_cObject);
 
+    rb_define_singleton_method(cX509Cert, "load", ossl_x509_load, 1);
+
     rb_define_alloc_func(cX509Cert, ossl_x509_alloc);
     rb_define_method(cX509Cert, "initialize", ossl_x509_initialize, -1);
     rb_define_method(cX509Cert, "initialize_copy", ossl_x509_copy, 1);
diff --git a/ext/openssl/ossl_x509crl.c b/ext/openssl/ossl_x509crl.c
index b0badf4..863f028 100644
--- a/ext/openssl/ossl_x509crl.c
+++ b/ext/openssl/ossl_x509crl.c
@@ -93,23 +93,26 @@ static VALUE
 ossl_x509crl_initialize(int argc, VALUE *argv, VALUE self)
 {
     BIO *in;
-    X509_CRL *crl, *x = DATA_PTR(self);
+    X509_CRL *crl, *crl_orig = RTYPEDDATA_DATA(self);
     VALUE arg;
 
+    rb_check_frozen(self);
     if (rb_scan_args(argc, argv, "01", &arg) == 0) {
 	return self;
     }
     arg = ossl_to_der_if_possible(arg);
     in = ossl_obj2bio(&arg);
-    crl = PEM_read_bio_X509_CRL(in, &x, NULL, NULL);
-    DATA_PTR(self) = x;
+    crl = d2i_X509_CRL_bio(in, NULL);
     if (!crl) {
-	OSSL_BIO_reset(in);
-	crl = d2i_X509_CRL_bio(in, &x);
-	DATA_PTR(self) = x;
+        OSSL_BIO_reset(in);
+        crl = PEM_read_bio_X509_CRL(in, NULL, NULL, NULL);
     }
     BIO_free(in);
-    if (!crl) ossl_raise(eX509CRLError, NULL);
+    if (!crl)
+        ossl_raise(eX509CRLError, "PEM_read_bio_X509_CRL");
+
+    RTYPEDDATA_DATA(self) = crl;
+    X509_CRL_free(crl_orig);
 
     return self;
 }
diff --git a/ext/openssl/ossl_x509ext.c b/ext/openssl/ossl_x509ext.c
index 5eb9bd7..e54102c 100644
--- a/ext/openssl/ossl_x509ext.c
+++ b/ext/openssl/ossl_x509ext.c
@@ -226,11 +226,10 @@ ossl_x509extfactory_create_ext(int argc, VALUE *argv, VALUE self)
     GetX509ExtFactory(self, ctx);
     obj = NewX509Ext(cX509Ext);
     rconf = rb_iv_get(self, "@config");
-    conf = NIL_P(rconf) ? NULL : DupConfigPtr(rconf);
+    conf = NIL_P(rconf) ? NULL : GetConfig(rconf);
     X509V3_set_nconf(ctx, conf);
     ext = X509V3_EXT_nconf_nid(conf, ctx, nid, RSTRING_PTR(valstr));
     X509V3_set_ctx_nodb(ctx);
-    NCONF_free(conf);
     if (!ext){
 	ossl_raise(eX509ExtError, "%"PRIsVALUE" = %"PRIsVALUE, oid, valstr);
     }
diff --git a/ext/openssl/ossl_x509name.c b/ext/openssl/ossl_x509name.c
index 1522c3d..13a2b2c 100644
--- a/ext/openssl/ossl_x509name.c
+++ b/ext/openssl/ossl_x509name.c
@@ -291,7 +291,14 @@ x509name_print(VALUE self, unsigned long iflag)
  * * OpenSSL::X509::Name::MULTILINE
  *
  * If _format_ is omitted, the largely broken and traditional OpenSSL format
- * is used.
+ * (<tt>X509_NAME_oneline()</tt> format) is chosen.
+ *
+ * <b>Use of this method is discouraged.</b> None of the formats other than
+ * OpenSSL::X509::Name::RFC2253 is standardized and may show an inconsistent
+ * behavior through \OpenSSL versions.
+ *
+ * It is recommended to use #to_utf8 instead, which is equivalent to calling
+ * <tt>name.to_s(OpenSSL::X509::Name::RFC2253).force_encoding("UTF-8")</tt>.
  */
 static VALUE
 ossl_x509name_to_s(int argc, VALUE *argv, VALUE self)
@@ -498,7 +505,7 @@ ossl_x509name_to_der(VALUE self)
  * You can create a Name by parsing a distinguished name String or by
  * supplying the distinguished name as an Array.
  *
- *   name = OpenSSL::X509::Name.parse '/CN=nobody/DC=example'
+ *   name = OpenSSL::X509::Name.parse_rfc2253 'DC=example,CN=nobody'
  *
  *   name = OpenSSL::X509::Name.new [['CN', 'nobody'], ['DC', 'example']]
  */
diff --git a/ext/openssl/ossl_x509req.c b/ext/openssl/ossl_x509req.c
index 2c20042..6eb91e9 100644
--- a/ext/openssl/ossl_x509req.c
+++ b/ext/openssl/ossl_x509req.c
@@ -79,23 +79,26 @@ static VALUE
 ossl_x509req_initialize(int argc, VALUE *argv, VALUE self)
 {
     BIO *in;
-    X509_REQ *req, *x = DATA_PTR(self);
+    X509_REQ *req, *req_orig = RTYPEDDATA_DATA(self);
     VALUE arg;
 
+    rb_check_frozen(self);
     if (rb_scan_args(argc, argv, "01", &arg) == 0) {
 	return self;
     }
     arg = ossl_to_der_if_possible(arg);
     in = ossl_obj2bio(&arg);
-    req = PEM_read_bio_X509_REQ(in, &x, NULL, NULL);
-    DATA_PTR(self) = x;
+    req = d2i_X509_REQ_bio(in, NULL);
     if (!req) {
-	OSSL_BIO_reset(in);
-	req = d2i_X509_REQ_bio(in, &x);
-	DATA_PTR(self) = x;
+        OSSL_BIO_reset(in);
+        req = PEM_read_bio_X509_REQ(in, NULL, NULL, NULL);
     }
     BIO_free(in);
-    if (!req) ossl_raise(eX509ReqError, NULL);
+    if (!req)
+        ossl_raise(eX509ReqError, "PEM_read_bio_X509_REQ");
+
+    RTYPEDDATA_DATA(self) = req;
+    X509_REQ_free(req_orig);
 
     return self;
 }
diff --git a/ext/openssl/ossl_x509store.c b/ext/openssl/ossl_x509store.c
index 9035a70..7c54618 100644
--- a/ext/openssl/ossl_x509store.c
+++ b/ext/openssl/ossl_x509store.c
@@ -52,8 +52,15 @@ struct ossl_verify_cb_args {
 };
 
 static VALUE
-call_verify_cb_proc(struct ossl_verify_cb_args *args)
+ossl_x509stctx_new_i(VALUE arg)
 {
+    return ossl_x509stctx_new((X509_STORE_CTX *)arg);
+}
+
+static VALUE
+call_verify_cb_proc(VALUE arg)
+{
+    struct ossl_verify_cb_args *args = (struct ossl_verify_cb_args *)arg;
     return rb_funcall(args->proc, rb_intern("call"), 2,
 		      args->preverify_ok, args->store_ctx);
 }
@@ -69,7 +76,7 @@ ossl_verify_cb_call(VALUE proc, int ok, X509_STORE_CTX *ctx)
 	return ok;
 
     ret = Qfalse;
-    rctx = rb_protect((VALUE(*)(VALUE))ossl_x509stctx_new, (VALUE)ctx, &state);
+    rctx = rb_protect(ossl_x509stctx_new_i, (VALUE)ctx, &state);
     if (state) {
 	rb_set_errinfo(Qnil);
 	rb_warn("StoreContext initialization failure");
@@ -78,7 +85,7 @@ ossl_verify_cb_call(VALUE proc, int ok, X509_STORE_CTX *ctx)
 	args.proc = proc;
 	args.preverify_ok = ok ? Qtrue : Qfalse;
 	args.store_ctx = rctx;
-	ret = rb_protect((VALUE(*)(VALUE))call_verify_cb_proc, (VALUE)&args, &state);
+	ret = rb_protect(call_verify_cb_proc, (VALUE)&args, &state);
 	if (state) {
 	    rb_set_errinfo(Qnil);
 	    rb_warn("exception in verify_callback is ignored");
@@ -164,9 +171,8 @@ ossl_x509store_alloc(VALUE klass)
     VALUE obj;
 
     obj = NewX509Store(klass);
-    if((store = X509_STORE_new()) == NULL){
-        ossl_raise(eX509StoreError, NULL);
-    }
+    if ((store = X509_STORE_new()) == NULL)
+        ossl_raise(eX509StoreError, "X509_STORE_new");
     SetX509Store(obj, store);
 
     return obj;
@@ -199,8 +205,9 @@ ossl_x509store_initialize(int argc, VALUE *argv, VALUE self)
 {
     X509_STORE *store;
 
-/* BUG: This method takes any number of arguments but appears to ignore them. */
     GetX509Store(self, store);
+    if (argc != 0)
+        rb_warn("OpenSSL::X509::Store.new does not take any arguments");
 #if !defined(HAVE_OPAQUE_OPENSSL)
     /* [Bug #405] [Bug #1678] [Bug #3000]; already fixed? */
     store->ex_data.sk = NULL;
@@ -221,8 +228,16 @@ ossl_x509store_initialize(int argc, VALUE *argv, VALUE self)
  * call-seq:
  *   store.flags = flags
  *
- * Sets _flags_ to the Store. _flags_ consists of zero or more of the constants
- * defined in with name V_FLAG_* or'ed together.
+ * Sets the default flags used by certificate chain verification performed with
+ * the Store.
+ *
+ * _flags_ consists of zero or more of the constants defined in OpenSSL::X509
+ * with name V_FLAG_* or'ed together.
+ *
+ * OpenSSL::X509::StoreContext#flags= can be used to change the flags for a
+ * single verification operation.
+ *
+ * See also the man page X509_VERIFY_PARAM_set_flags(3).
  */
 static VALUE
 ossl_x509store_set_flags(VALUE self, VALUE flags)
@@ -240,9 +255,9 @@ ossl_x509store_set_flags(VALUE self, VALUE flags)
  * call-seq:
  *   store.purpose = purpose
  *
- * Sets the store's purpose to _purpose_. If specified, the verifications on
- * the store will check every untrusted certificate's extensions are consistent
- * with the purpose. The purpose is specified by constants:
+ * Sets the store's default verification purpose. If specified,
+ * the verifications on the store will check every certificate's extensions are
+ * consistent with the purpose. The purpose is specified by constants:
  *
  * * X509::PURPOSE_SSL_CLIENT
  * * X509::PURPOSE_SSL_SERVER
@@ -253,6 +268,11 @@ ossl_x509store_set_flags(VALUE self, VALUE flags)
  * * X509::PURPOSE_ANY
  * * X509::PURPOSE_OCSP_HELPER
  * * X509::PURPOSE_TIMESTAMP_SIGN
+ *
+ * OpenSSL::X509::StoreContext#purpose= can be used to change the value for a
+ * single verification operation.
+ *
+ * See also the man page X509_VERIFY_PARAM_set_purpose(3).
  */
 static VALUE
 ossl_x509store_set_purpose(VALUE self, VALUE purpose)
@@ -269,6 +289,14 @@ ossl_x509store_set_purpose(VALUE self, VALUE purpose)
 /*
  * call-seq:
  *   store.trust = trust
+ *
+ * Sets the default trust settings used by the certificate verification with
+ * the store.
+ *
+ * OpenSSL::X509::StoreContext#trust= can be used to change the value for a
+ * single verification operation.
+ *
+ * See also the man page X509_VERIFY_PARAM_set_trust(3).
  */
 static VALUE
 ossl_x509store_set_trust(VALUE self, VALUE trust)
@@ -286,7 +314,13 @@ ossl_x509store_set_trust(VALUE self, VALUE trust)
  * call-seq:
  *   store.time = time
  *
- * Sets the time to be used in verifications.
+ * Sets the time to be used in the certificate verifications with the store.
+ * By default, if not specified, the current system time is used.
+ *
+ * OpenSSL::X509::StoreContext#time= can be used to change the value for a
+ * single verification operation.
+ *
+ * See also the man page X509_VERIFY_PARAM_set_time(3).
  */
 static VALUE
 ossl_x509store_set_time(VALUE self, VALUE time)
@@ -302,23 +336,23 @@ ossl_x509store_set_time(VALUE self, VALUE time)
  * Adds the certificates in _file_ to the certificate store. _file_ is the path
  * to the file, and the file contains one or more certificates in PEM format
  * concatenated together.
+ *
+ * See also the man page X509_LOOKUP_file(3).
  */
 static VALUE
 ossl_x509store_add_file(VALUE self, VALUE file)
 {
     X509_STORE *store;
     X509_LOOKUP *lookup;
-    char *path = NULL;
+    const char *path;
 
-    if(file != Qnil){
-	path = StringValueCStr(file);
-    }
     GetX509Store(self, store);
+    path = StringValueCStr(file);
     lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());
-    if(lookup == NULL) ossl_raise(eX509StoreError, NULL);
-    if(X509_LOOKUP_load_file(lookup, path, X509_FILETYPE_PEM) != 1){
-        ossl_raise(eX509StoreError, NULL);
-    }
+    if (!lookup)
+        ossl_raise(eX509StoreError, "X509_STORE_add_lookup");
+    if (X509_LOOKUP_load_file(lookup, path, X509_FILETYPE_PEM) != 1)
+        ossl_raise(eX509StoreError, "X509_LOOKUP_load_file");
 #if OPENSSL_VERSION_NUMBER < 0x10101000 || defined(LIBRESSL_VERSION_NUMBER)
     /*
      * X509_load_cert_crl_file() which is called from X509_LOOKUP_load_file()
@@ -337,23 +371,23 @@ ossl_x509store_add_file(VALUE self, VALUE file)
  *   store.add_path(path) -> self
  *
  * Adds _path_ as the hash dir to be looked up by the store.
+ *
+ * See also the man page X509_LOOKUP_hash_dir(3).
  */
 static VALUE
 ossl_x509store_add_path(VALUE self, VALUE dir)
 {
     X509_STORE *store;
     X509_LOOKUP *lookup;
-    char *path = NULL;
+    const char *path;
 
-    if(dir != Qnil){
-	path = StringValueCStr(dir);
-    }
     GetX509Store(self, store);
+    path = StringValueCStr(dir);
     lookup = X509_STORE_add_lookup(store, X509_LOOKUP_hash_dir());
-    if(lookup == NULL) ossl_raise(eX509StoreError, NULL);
-    if(X509_LOOKUP_add_dir(lookup, path, X509_FILETYPE_PEM) != 1){
-        ossl_raise(eX509StoreError, NULL);
-    }
+    if (!lookup)
+        ossl_raise(eX509StoreError, "X509_STORE_add_lookup");
+    if (X509_LOOKUP_add_dir(lookup, path, X509_FILETYPE_PEM) != 1)
+        ossl_raise(eX509StoreError, "X509_LOOKUP_add_dir");
 
     return self;
 }
@@ -368,6 +402,8 @@ ossl_x509store_add_path(VALUE self, VALUE dir)
  *
  * * OpenSSL::X509::DEFAULT_CERT_FILE
  * * OpenSSL::X509::DEFAULT_CERT_DIR
+ *
+ * See also the man page X509_STORE_set_default_paths(3).
  */
 static VALUE
 ossl_x509store_set_default_paths(VALUE self)
@@ -375,18 +411,19 @@ ossl_x509store_set_default_paths(VALUE self)
     X509_STORE *store;
 
     GetX509Store(self, store);
-    if (X509_STORE_set_default_paths(store) != 1){
-        ossl_raise(eX509StoreError, NULL);
-    }
+    if (X509_STORE_set_default_paths(store) != 1)
+        ossl_raise(eX509StoreError, "X509_STORE_set_default_paths");
 
     return Qnil;
 }
 
 /*
  * call-seq:
- *   store.add_cert(cert)
+ *   store.add_cert(cert) -> self
  *
  * Adds the OpenSSL::X509::Certificate _cert_ to the certificate store.
+ *
+ * See also the man page X509_STORE_add_cert(3).
  */
 static VALUE
 ossl_x509store_add_cert(VALUE self, VALUE arg)
@@ -396,9 +433,8 @@ ossl_x509store_add_cert(VALUE self, VALUE arg)
 
     cert = GetX509CertPtr(arg); /* NO NEED TO DUP */
     GetX509Store(self, store);
-    if (X509_STORE_add_cert(store, cert) != 1){
-        ossl_raise(eX509StoreError, NULL);
-    }
+    if (X509_STORE_add_cert(store, cert) != 1)
+        ossl_raise(eX509StoreError, "X509_STORE_add_cert");
 
     return self;
 }
@@ -408,6 +444,8 @@ ossl_x509store_add_cert(VALUE self, VALUE arg)
  *   store.add_crl(crl) -> self
  *
  * Adds the OpenSSL::X509::CRL _crl_ to the store.
+ *
+ * See also the man page X509_STORE_add_crl(3).
  */
 static VALUE
 ossl_x509store_add_crl(VALUE self, VALUE arg)
@@ -417,9 +455,8 @@ ossl_x509store_add_crl(VALUE self, VALUE arg)
 
     crl = GetX509CRLPtr(arg); /* NO NEED TO DUP */
     GetX509Store(self, store);
-    if (X509_STORE_add_crl(store, crl) != 1){
-        ossl_raise(eX509StoreError, NULL);
-    }
+    if (X509_STORE_add_crl(store, crl) != 1)
+        ossl_raise(eX509StoreError, "X509_STORE_add_crl");
 
     return self;
 }
@@ -499,9 +536,8 @@ ossl_x509stctx_alloc(VALUE klass)
     VALUE obj;
 
     obj = NewX509StCtx(klass);
-    if((ctx = X509_STORE_CTX_new()) == NULL){
-        ossl_raise(eX509StoreError, NULL);
-    }
+    if ((ctx = X509_STORE_CTX_new()) == NULL)
+        ossl_raise(eX509StoreError, "X509_STORE_CTX_new");
     SetX509StCtx(obj, ctx);
 
     return obj;
@@ -567,6 +603,10 @@ ossl_x509stctx_initialize(int argc, VALUE *argv, VALUE self)
 /*
  * call-seq:
  *   stctx.verify -> true | false
+ *
+ * Performs the certificate verification using the parameters set to _stctx_.
+ *
+ * See also the man page X509_verify_cert(3).
  */
 static VALUE
 ossl_x509stctx_verify(VALUE self)
@@ -579,48 +619,45 @@ ossl_x509stctx_verify(VALUE self)
 
     switch (X509_verify_cert(ctx)) {
       case 1:
-	return Qtrue;
+        return Qtrue;
       case 0:
-	ossl_clear_error();
-	return Qfalse;
+        ossl_clear_error();
+        return Qfalse;
       default:
-	ossl_raise(eX509CertError, NULL);
+        ossl_raise(eX509CertError, "X509_verify_cert");
     }
 }
 
 /*
  * call-seq:
- *   stctx.chain -> Array of X509::Certificate
+ *   stctx.chain -> nil | Array of X509::Certificate
+ *
+ * Returns the verified chain.
+ *
+ * See also the man page X509_STORE_CTX_set0_verified_chain(3).
  */
 static VALUE
 ossl_x509stctx_get_chain(VALUE self)
 {
     X509_STORE_CTX *ctx;
-    STACK_OF(X509) *chain;
-    X509 *x509;
-    int i, num;
-    VALUE ary;
+    const STACK_OF(X509) *chain;
 
     GetX509StCtx(self, ctx);
-    if((chain = X509_STORE_CTX_get0_chain(ctx)) == NULL){
-        return Qnil;
-    }
-    if((num = sk_X509_num(chain)) < 0){
-	OSSL_Debug("certs in chain < 0???");
-	return rb_ary_new();
-    }
-    ary = rb_ary_new2(num);
-    for(i = 0; i < num; i++) {
-	x509 = sk_X509_value(chain, i);
-	rb_ary_push(ary, ossl_x509_new(x509));
-    }
-
-    return ary;
+    chain = X509_STORE_CTX_get0_chain(ctx);
+    if (!chain)
+        return Qnil; /* Could be an empty array instead? */
+    return ossl_x509_sk2ary(chain);
 }
 
 /*
  * call-seq:
  *   stctx.error -> Integer
+ *
+ * Returns the error code of _stctx_. This is typically called after #verify
+ * is done, or from the verification callback set to
+ * OpenSSL::X509::Store#verify_callback=.
+ *
+ * See also the man page X509_STORE_CTX_get_error(3).
  */
 static VALUE
 ossl_x509stctx_get_err(VALUE self)
@@ -635,6 +672,11 @@ ossl_x509stctx_get_err(VALUE self)
 /*
  * call-seq:
  *   stctx.error = error_code
+ *
+ * Sets the error code of _stctx_. This is used by the verification callback
+ * set to OpenSSL::X509::Store#verify_callback=.
+ *
+ * See also the man page X509_STORE_CTX_set_error(3).
  */
 static VALUE
 ossl_x509stctx_set_error(VALUE self, VALUE err)
@@ -651,7 +693,10 @@ ossl_x509stctx_set_error(VALUE self, VALUE err)
  * call-seq:
  *   stctx.error_string -> String
  *
- * Returns the error string corresponding to the error code retrieved by #error.
+ * Returns the human readable error string corresponding to the error code
+ * retrieved by #error.
+ *
+ * See also the man page X509_verify_cert_error_string(3).
  */
 static VALUE
 ossl_x509stctx_get_err_string(VALUE self)
@@ -668,6 +713,10 @@ ossl_x509stctx_get_err_string(VALUE self)
 /*
  * call-seq:
  *   stctx.error_depth -> Integer
+ *
+ * Returns the depth of the chain. This is used in combination with #error.
+ *
+ * See also the man page X509_STORE_CTX_get_error_depth(3).
  */
 static VALUE
 ossl_x509stctx_get_err_depth(VALUE self)
@@ -682,6 +731,10 @@ ossl_x509stctx_get_err_depth(VALUE self)
 /*
  * call-seq:
  *   stctx.current_cert -> X509::Certificate
+ *
+ * Returns the certificate which caused the error.
+ *
+ * See also the man page X509_STORE_CTX_get_current_cert(3).
  */
 static VALUE
 ossl_x509stctx_get_curr_cert(VALUE self)
@@ -696,6 +749,10 @@ ossl_x509stctx_get_curr_cert(VALUE self)
 /*
  * call-seq:
  *   stctx.current_crl -> X509::CRL
+ *
+ * Returns the CRL which caused the error.
+ *
+ * See also the man page X509_STORE_CTX_get_current_crl(3).
  */
 static VALUE
 ossl_x509stctx_get_curr_crl(VALUE self)
@@ -715,7 +772,10 @@ ossl_x509stctx_get_curr_crl(VALUE self)
  * call-seq:
  *   stctx.flags = flags
  *
- * Sets the verification flags to the context. See Store#flags=.
+ * Sets the verification flags to the context. This overrides the default value
+ * set by Store#flags=.
+ *
+ * See also the man page X509_VERIFY_PARAM_set_flags(3).
  */
 static VALUE
 ossl_x509stctx_set_flags(VALUE self, VALUE flags)
@@ -733,7 +793,10 @@ ossl_x509stctx_set_flags(VALUE self, VALUE flags)
  * call-seq:
  *   stctx.purpose = purpose
  *
- * Sets the purpose of the context. See Store#purpose=.
+ * Sets the purpose of the context. This overrides the default value set by
+ * Store#purpose=.
+ *
+ * See also the man page X509_VERIFY_PARAM_set_purpose(3).
  */
 static VALUE
 ossl_x509stctx_set_purpose(VALUE self, VALUE purpose)
@@ -750,6 +813,11 @@ ossl_x509stctx_set_purpose(VALUE self, VALUE purpose)
 /*
  * call-seq:
  *   stctx.trust = trust
+ *
+ * Sets the trust settings of the context. This overrides the default value set
+ * by Store#trust=.
+ *
+ * See also the man page X509_VERIFY_PARAM_set_trust(3).
  */
 static VALUE
 ossl_x509stctx_set_trust(VALUE self, VALUE trust)
@@ -768,6 +836,8 @@ ossl_x509stctx_set_trust(VALUE self, VALUE trust)
  *   stctx.time = time
  *
  * Sets the time used in the verification. If not set, the current time is used.
+ *
+ * See also the man page X509_VERIFY_PARAM_set_time(3).
  */
 static VALUE
 ossl_x509stctx_set_time(VALUE self, VALUE time)
@@ -843,23 +913,37 @@ Init_ossl_x509store(void)
     cX509Store = rb_define_class_under(mX509, "Store", rb_cObject);
     /*
      * The callback for additional certificate verification. It is invoked for
-     * each untrusted certificate in the chain.
+     * each certificate in the chain and can be used to implement custom
+     * certificate verification conditions.
      *
      * The callback is invoked with two values, a boolean that indicates if the
      * pre-verification by OpenSSL has succeeded or not, and the StoreContext in
-     * use. The callback must return either true or false.
+     * use.
+     *
+     * The callback can use StoreContext#error= to change the error code as
+     * needed. The callback must return either true or false.
+     *
+     * NOTE: any exception raised within the callback will be ignored.
+     *
+     * See also the man page X509_STORE_CTX_set_verify_cb(3).
      */
     rb_attr(cX509Store, rb_intern("verify_callback"), 1, 0, Qfalse);
     /*
      * The error code set by the last call of #verify.
+     *
+     * See also StoreContext#error.
      */
     rb_attr(cX509Store, rb_intern("error"), 1, 0, Qfalse);
     /*
      * The description for the error code set by the last call of #verify.
+     *
+     * See also StoreContext#error_string.
      */
     rb_attr(cX509Store, rb_intern("error_string"), 1, 0, Qfalse);
     /*
      * The certificate chain constructed by the last call of #verify.
+     *
+     * See also StoreContext#chain.
      */
     rb_attr(cX509Store, rb_intern("chain"), 1, 0, Qfalse);
     rb_define_alloc_func(cX509Store, ossl_x509store_alloc);
diff --git a/ext/openssl/ruby_missing.h b/ext/openssl/ruby_missing.h
index 069acc8..e69de29 100644
--- a/ext/openssl/ruby_missing.h
+++ b/ext/openssl/ruby_missing.h
@@ -1,24 +0,0 @@
-/*
- * 'OpenSSL for Ruby' project
- * Copyright (C) 2001-2003  Michal Rokos <m.rokos@sh.cvut.cz>
- * All rights reserved.
- */
-/*
- * This program is licensed under the same licence as Ruby.
- * (See the file 'LICENCE'.)
- */
-#if !defined(_OSSL_RUBY_MISSING_H_)
-#define _OSSL_RUBY_MISSING_H_
-
-/* Ruby 2.4 */
-#ifndef RB_INTEGER_TYPE_P
-# define RB_INTEGER_TYPE_P(obj) (RB_FIXNUM_P(obj) || RB_TYPE_P(obj, T_BIGNUM))
-#endif
-
-/* Ruby 2.5 */
-#ifndef ST2FIX
-# define RB_ST2FIX(h) LONG2FIX((long)(h))
-# define ST2FIX(h) RB_ST2FIX(h)
-#endif
-
-#endif /* _OSSL_RUBY_MISSING_H_ */
diff --git a/test/openssl/fixtures/pkey/dh-1.pem b/test/openssl/fixtures/pkey/dh-1.pem
deleted file mode 100644
index 3340a6a..0000000
--- a/test/openssl/fixtures/pkey/dh-1.pem
+++ /dev/null
@@ -1,13 +0,0 @@
------BEGIN DH PARAMETERS-----
-MIICCAKCAgEAvRzXYxY6L2DjeYmm1eowtMDu1it3j+VwFr6s6PRWzc1apMtztr9G
-xZ2mYndUAJLgNLO3n2fUDCYVMB6ZkcekW8Siocof3xWiMA6wqZ6uw0dsE3q7ZX+6
-TLjgSjaXeGvjutvuEwVrFeaUi83bMgfXN8ToxIQVprIF35sYFt6fpbFATKfW7qqi
-P1pQkjmCskU4tztaWvlLh0qg85wuQGnpJaQT3gS30378i0IGbA0EBvJcSpTHYbLa
-nsdI9bfN/ZVgeolVMNMU9/n8R8vRhNPcHuciFwaqS656q+HavCIyxw/LfjSwwFvR
-TngCn0wytRErkzFIXnRKckh8/BpI4S+0+l1NkOwG4WJ55KJ/9OOdZW5o/QCp2bDi
-E0JN1EP/gkSom/prq8JR/yEqtsy99uc5nUxPmzv0IgdcFHZEfiQU7iRggEbx7qfQ
-Ve55XksmmJInmpCy1bSabAEgIKp8Ckt5KLYZ0RgTXUhcEpsxEo6cuAwoSJT5o4Rp
-yG3xow2ozPcqZkvb+d2CHj1sc54w9BVFAjVANEKmRil/9WKz14bu3wxEhOPqC54n
-QojjLcoXSoT66ZUOQnYxTSiLtzoKGPy8cAVPbkBrXz2u2sj5gcvr1JjoGjdHm9/3
-qnqC8fsTz8UndKNIQC337o4K0833bQMzRGl1/qjbAPit2B7E3b6xTZMCAQI=
------END DH PARAMETERS-----
diff --git a/test/openssl/fixtures/pkey/dh1024.pem b/test/openssl/fixtures/pkey/dh1024.pem
deleted file mode 100644
index f99c757..0000000
--- a/test/openssl/fixtures/pkey/dh1024.pem
+++ /dev/null
@@ -1,5 +0,0 @@
------BEGIN DH PARAMETERS-----
-MIGHAoGBAKnKQ8MNK6nYZzLrrcuTsLxuiJGXoOO5gT+tljOTbHBuiktdMTITzIY0
-pFxIvjG05D7HoBZQfrR0c92NGWPkAiCkhQKB8JCbPVzwNLDy6DZ0pmofDKrEsYHG
-AQjjxMXhwULlmuR/K+WwlaZPiLIBYalLAZQ7ZbOPeVkJ8ePao0eLAgEC
------END DH PARAMETERS-----
diff --git a/test/openssl/fixtures/pkey/dsa1024.pem b/test/openssl/fixtures/pkey/dsa1024.pem
deleted file mode 100644
index 1bf4988..0000000
--- a/test/openssl/fixtures/pkey/dsa1024.pem
+++ /dev/null
@@ -1,12 +0,0 @@
------BEGIN DSA PRIVATE KEY-----
-MIIBugIBAAKBgQCH9aAoXvWWThIjkA6D+nI1F9ksF9iDq594rkiGNOT9sPDOdB+n
-D+qeeeeloRlj19ymCSADPI0ZLRgkchkAEnY2RnqnhHOjVf/roGgRbW+iQDMbQ9wa
-/pvc6/fAbsu1goE1hBYjm98/sZEeXavj8tR56IXnjF1b6Nx0+sgeUKFKEQIVAMiz
-4BJUFeTtddyM4uadBM7HKLPRAoGAZdLBSYNGiij7vAjesF5mGUKTIgPd+JKuBEDx
-OaBclsgfdoyoF/TMOkIty+PVlYD+//Vl2xnoUEIRaMXHwHfm0r2xUX++oeRaSScg
-YizJdUxe5jvBuBszGPRc/mGpb9YvP0sB+FL1KmuxYmdODfCe51zl8uM/CVhouJ3w
-DjmRGscCgYAuFlfC7p+e8huCKydfcv/beftqjewiOPpQ3u5uI6KPCtCJPpDhs3+4
-IihH2cPsAlqwGF4tlibW1+/z/OZ1AZinPK3y7b2jSJASEaPeEltVzB92hcd1khk2
-jTYcmSsV4VddplOPK9czytR/GbbibxsrhhgZUbd8LPbvIgaiadJ1PgIUBnJ/5vN2
-CVArsEzlPUCbohPvZnE=
------END DSA PRIVATE KEY-----
diff --git a/test/openssl/fixtures/pkey/dsa256.pem b/test/openssl/fixtures/pkey/dsa256.pem
deleted file mode 100644
index d9a407f..0000000
--- a/test/openssl/fixtures/pkey/dsa256.pem
+++ /dev/null
@@ -1,8 +0,0 @@
------BEGIN DSA PRIVATE KEY-----
-MIH3AgEAAkEAhk2libbY2a8y2Pt21+YPYGZeW6wzaW2yfj5oiClXro9XMR7XWLkE
-9B7XxLNFCS2gmCCdMsMW1HulaHtLFQmB2wIVAM43JZrcgpu6ajZ01VkLc93gu/Ed
-AkAOhujZrrKV5CzBKutKLb0GVyVWmdC7InoNSMZEeGU72rT96IjM59YzoqmD0pGM
-3I1o4cGqg1D1DfM1rQlnN1eSAkBq6xXfEDwJ1mLNxF6q8Zm/ugFYWR5xcX/3wFiT
-b4+EjHP/DbNh9Vm5wcfnDBJ1zKvrMEf2xqngYdrV/3CiGJeKAhRvL57QvJZcQGvn
-ISNX5cMzFHRW3Q==
------END DSA PRIVATE KEY-----
diff --git a/test/openssl/fixtures/pkey/dsa512.pem b/test/openssl/fixtures/pkey/dsa512.pem
deleted file mode 100644
index 962c41c..0000000
--- a/test/openssl/fixtures/pkey/dsa512.pem
+++ /dev/null
@@ -1,8 +0,0 @@
------BEGIN DSA PRIVATE KEY-----
-MIH4AgEAAkEA5lB4GvEwjrsMlGDqGsxrbqeFRh6o9OWt6FgTYiEEHaOYhkIxv0Ok
-RZPDNwOG997mDjBnvDJ1i56OmS3MbTnovwIVAJgub/aDrSDB4DZGH7UyarcaGy6D
-AkB9HdFw/3td8K4l1FZHv7TCZeJ3ZLb7dF3TWoGUP003RCqoji3/lHdKoVdTQNuR
-S/m6DlCwhjRjiQ/lBRgCLCcaAkEAjN891JBjzpMj4bWgsACmMggFf57DS0Ti+5++
-Q1VB8qkJN7rA7/2HrCR3gTsWNb1YhAsnFsoeRscC+LxXoXi9OAIUBG98h4tilg6S
-55jreJD3Se3slps=
------END DSA PRIVATE KEY-----
diff --git a/test/openssl/fixtures/pkey/p256.pem b/test/openssl/fixtures/pkey/p256.pem
deleted file mode 100644
index 97c97d9..0000000
--- a/test/openssl/fixtures/pkey/p256.pem
+++ /dev/null
@@ -1,5 +0,0 @@
------BEGIN EC PRIVATE KEY-----
-MHcCAQEEIID49FDqcf1O1eO8saTgG70UbXQw9Fqwseliit2aWhH1oAoGCCqGSM49
-AwEHoUQDQgAEFglk2c+oVUIKQ64eZG9bhLNPWB7lSZ/ArK41eGy5wAzU/0G51Xtt
-CeBUl+MahZtn9fO1JKdF4qJmS39dXnpENg==
------END EC PRIVATE KEY-----
diff --git a/test/openssl/fixtures/pkey/rsa-1.pem b/test/openssl/fixtures/pkey/rsa-1.pem
deleted file mode 100644
index bd5a624..0000000
--- a/test/openssl/fixtures/pkey/rsa-1.pem
+++ /dev/null
@@ -1,51 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIIJJwIBAAKCAgEArIEJUYZrXhMfUXXdl2gLcXrRB4ciWNEeXt5UVLG0nPhygZwJ
-xis8tOrjXOJEpUXUsfgF35pQiJLD4T9/Vp3zLFtMOOQjOR3AxjIelbH9KPyGFEr9
-TcPtsJ24zhcG7RbwOGXR4iIcDaTx+bCLSAd7BjG3XHQtyeepGGRZkGyGUvXjPorH
-XP+dQjQnMd09wv0GMZSqQ06PedUUKQ4PJRfMCP+mwjFP+rB3NZuThF0CsNmpoixg
-GdoQ591Yrf5rf2Bs848JrYdqJlKlBL6rTFf2glHiC+mE5YRny7RZtv/qIkyUNotV
-ce1cE0GFrRmCpw9bqulDDcgKjFkhihTg4Voq0UYdJ6Alg7Ur4JerKTfyCaRGF27V
-fh/g2A2/6Vu8xKYYwTAwLn+Tvkx9OTVZ1t15wM7Ma8hHowNoO0g/lWkeltgHLMji
-rmeuIYQ20BQmdx2RRgWKl57D0wO/N0HIR+Bm4vcBoNPgMlk9g5WHA6idHR8TLxOr
-dMMmTiWfefB0/FzGXBv7DuuzHN3+urdCvG1QIMFQ06kHXhr4rC28KbWIxg+PJGM8
-oGNEGtGWAOvi4Ov+BVsIdbD5Sfyb4nY3L9qqPl6TxRxMWTKsYCYx11jC8civCzOu
-yL1z+wgIICJ6iGzrfYf6C2BiNV3BC1YCtp2XsG+AooIxCwjL2CP/54MuRnUCAwEA
-AQKCAgAP4+8M0HoRd2d6JIZeDRqIwIyCygLy9Yh7qrVP+/KsRwKdR9dqps73x29c
-Pgeexdj67+Lynw9uFT7v/95mBzTAUESsNO+9sizw1OsWVQgB/4kGU4YT5Ml/bHf6
-nApqSqOkPlTgJM46v4f+vTGHWBEQGAJRBO62250q/wt1D1osSDQ/rZ8BxRYiZBV8
-NWocDRzF8nDgtFrpGSS7R21DuHZ2Gb6twscgS6MfkA49sieuTM6gfr/3gavu/+fM
-V1Rlrmc65GE61++CSjijQEEdTjkJ9isBd+hjEBhTnnBpOBfEQxOgFqOvU/MYXv/G
-W0Q6yWJjUwt3OIcoOImrY5L3j0vERneA1Alweqsbws3fXXMjA+jhLxlJqjPvSAKc
-POi7xu7QCJjSSLAzHSDPdmGmfzlrbdWS1h0mrC5YZYOyToLajfnmAlXNNrytnePg
-JV9/1136ZFrJyEi1JVN3kyrC+1iVd1E+lWK0U1UQ6/25tJvKFc1I+xToaUbK10UN
-ycXib7p2Zsc/+ZMlPRgCxWmpIHmKhnwbO7vtRunnnc6wzhvlQQNHWlIvkyQukV50
-6k/bzWw0M6A98B4oCICIcxcpS3njDlHyL7NlkCD+/OfZp6X3RZF/m4grmA2doebz
-glsaNMyGHFrpHkHq19Y63Y4jtBdW/XuBv06Cnr4r3BXdjEzzwQKCAQEA5bj737Nk
-ZLA0UgzVVvY67MTserTOECIt4i37nULjRQwsSFiz0AWFOBwUCBJ5N2qDEelbf0Fa
-t4VzrphryEgzLz/95ZXi+oxw1liqCHi8iHeU2wSclDtx2jKv2q7bFvFSaH4CKC4N
-zBJNfP92kdXuAjXkbK/jWwr64fLNh/2KFWUAmrYmtGfnOjjyL+yZhPxBatztE58q
-/T61pkvP9NiLfrr7Xq8fnzrwqGERhXKueyoK6ig9ZJPZ2VTykMUUvNYJJ7OYQZru
-EYA3zkuEZifqmjgF57Bgg7dkkIh285TzH3CNf3MCMTmjlWVyHjlyeSPYgISB9Mys
-VKKQth+SvYcChQKCAQEAwDyCcolA7+bQBfECs6GXi7RYy2YSlx562S5vhjSlY9Ko
-WiwVJWviF7uSBdZRnGUKoPv4K4LV34o2lJpSSTi5Xgp7FH986VdGePe3p4hcXSIZ
-NtsKImLVLnEjrmkZExfQl7p0MkcU/LheCf/eEZVp0Z84O54WCs6GRm9wHYIUyrag
-9FREqqxTRVNhQQ2EDVGq1slREdwB+aygE76axK/qosk0RaoLzGZiMn4Sb8bpJxXO
-mee+ftq5bayVltfR0DhC8eHkcPPFeQMll1g+ML7HbINwHTr01ONm3cFUO4zOLBOO
-ws/+vtNfiv6S/lO1RQSRoiApbENBLdSc3V8Cy70PMQKCAQBOcZN4uP5gL5c+KWm0
-T1KhxUDnSdRPyAwY/xC7i7qlullovvlv4GK0XUot03kXBkUJmcEHvF5o6qYtCZlM
-g/MOgHCHtF4Upl5lo1M0n13pz8PB4lpBd+cR1lscdrcTp4Y3bkf4RnmppNpXA7kO
-ZZnnoVWGE620ShSPkWTDuj0rvxisu+SNmClqRUXWPZnSwnzoK9a86443efF3fs3d
-UxCXTuxFUdGfgvXo2XStOBMCtcGSYflM3fv27b4C13mUXhY0O2yTgn8m9LyZsknc
-xGalENpbWmwqrjYl8KOF2+gFZV68FZ67Bm6otkJ4ta80VJw6joT9/eIe6IA34KIw
-G+ktAoIBAFRuPxzvC4ZSaasyX21l25mQbC9pdWDKEkqxCmp3VOyy6R4xnlgBOhwS
-VeAacV2vQyvRfv4dSLIVkkNSRDHEqCWVlNk75TDXFCytIAyE54xAHbLqIVlY7yim
-qHVB07F/FC6PxdkPPziAAU2DA5XVedSHibslg6jbbD4jU6qiJ1+hNrAZEs+jQC+C
-n4Ri20y+Qbp0URb2+icemnARlwgr+3HjzQGL3gK4NQjYNmDBjEWOXl9aWWB90FNL
-KahGwfAhxcVW4W56opCzwR7nsujV4eDXGba83itidRuQfd5pyWOyc1E86TYGwD/b
-79OkEElv6Ea8uXTDVS075GmWATRapQECggEAd9ZAbyT+KouTfi2e6yLOosxSZfns
-eF06QAJi5n9GOtdfK5fqdmHJqJI7wbubCnd0oxPeL71lRjrOAMXufaQRdZtfXSMn
-B1TljteNrh1en5xF451rCPR/Y6tNKBvIKnhy1waO27/vA+ovXrm17iR9rRuGZ29i
-IurlKA6z/96UdrSdpqITTCyTjSOBYg34f49ueGjlpL4+8HJq2wor4Cb1Sbv8ErqA
-bsQ/Jz+KIGUiuFCfNa6d6McPRXIrGgzpprXgfimkV3nj49QyrnuCF/Pc4psGgIaN
-l3EiGXzRt/55K7DQVadtbcjo9zREac8QnDD6dS/gOfJ82L7frQfMpNWgQA==
------END RSA PRIVATE KEY-----
diff --git a/test/openssl/fixtures/pkey/rsa-2.pem b/test/openssl/fixtures/pkey/rsa-2.pem
deleted file mode 100644
index e4fd4f4..0000000
--- a/test/openssl/fixtures/pkey/rsa-2.pem
+++ /dev/null
@@ -1,51 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIIJKAIBAAKCAgEA1HUbx825tG7+/ulC5DpDogzXqM2/KmeCwGXZY4XjiWa+Zj7b
-ECkZwQh7zxFUsPixGqQKJSyFwCogdaPzYTRNtqKKaw/IWS0um1PTn4C4/9atbIsf
-HVKu/fWg4VrZL+ixFIZxa8Z6pvTB2omMcx+uEzbXPsO01i1pHf7MaWBxUDGFyC9P
-lASJBfFZAf2Ar1H99OTS4SP+gxM9Kk5tcc22r8uFiqqbhJmQNSDApdHvT1zSZxAc
-T1BFEZqfmR0B0UegPyJc/9hW0dYpB9JjR29UaZRSta3LUMpqltoOF5bzaKVgMuBm
-Qy79xJ71LjGp8bKhgRaWXyPsDzAC0MQlOW6En0v8LK8fntivJEvw9PNOMcZ8oMTn
-no0NeVt32HiQJW8LIVo7dOLVFtguSBMWUVe8mdKbuIIULD6JlSYke9Ob6andUhzO
-U79m/aRWs2yjD6o5QAktjFBARdPgcpTdWfppc8xpJUkQgRmVhINoIMT9W6Wl898E
-P4aPx6mRV/k05ellN3zRgd9tx5dyNuj3RBaNmR47cAVvGYRQgtH9bQYs6jtf0oer
-A5yIYEKspNRlZZJKKrQdLflQFOEwjQJyZnTk7Mp0y21wOuEGgZBexew55/hUJDC2
-mQ8CqjV4ki/Mm3z6Cw3jXIMNBJkH7oveBGSX0S9bF8A/73oOCU3W/LkORxECAwEA
-AQKCAgBLK7RMmYmfQbaPUtEMF2FesNSNMV72DfHBSUgFYpYDQ4sSeiLgMOqf1fSY
-azVf+F4RYwED7iDUwRMDDKNMPUlR2WjIQKlOhCH9a0dxJAZQ3xA1W3QC2AJ6cLIf
-ihlWTip5bKgszekPsYH1ZL2A7jCVM84ssuoE7cRHjKOelTUCfsMq9TJe2MvyglZP
-0fX6EjSctWm3pxiiH+iAU4d9wJ9my8fQLFUiMYNIiPIguYrGtbzsIlMh7PDDLcZS
-UmUWOxWDwRDOpSjyzadu0Q23dLiVMpmhFoDdcQENptFdn1c4K2tCFQuZscKwEt4F
-HiVXEzD5j5hcyUT4irA0VXImQ+hAH3oSDmn7wyHvyOg0bDZpUZXEHXb83Vvo54/d
-Fb4AOUva1dwhjci8CTEMxCENMy/CLilRv46AeHbOX8KMPM7BnRSJPptvTTh/qB9C
-HI5hxfkO+EOYnu0kUlxhJfrqG86H4IS+zA8HWiSEGxQteMjUQfgJoBzJ94YChpzo
-ePpKSpjxxl1PNNWKxWM3yUvlKmI2lNl6YNC8JpF2wVg4VvYkG7iVjleeRg21ay89
-NCVMF98n3MI5jdzfDKACnuYxg7sw+gjMy8PSoFvQ5pvHuBBOpa8tho6vk7bLJixT
-QY5uXMNQaO6OwpkBssKpnuXhIJzDhO48nSjJ5nUEuadPH1nGwQKCAQEA7twrUIMi
-Vqze/X6VyfEBnX+n3ZyQHLGqUv/ww1ZOOHmSW5ceC4GxHa8EPDjoh9NEjYffwGq9
-bfQh9Gntjk5gFipT/SfPrIhbPt59HthUqVvOGgSErCmn0vhsa0+ROpVi4K2WHS7O
-7SEwnoCWd6p1omon2olVY0ODlMH4neCx/ZuKV8SRMREubABlL8/MLp37AkgKarTY
-tewd0lpaZMvsjOhr1zVCGUUBxy87Fc7OKAcoQY8//0r8VMH7Jlga7F2PKVPzqRKf
-tjeW5jMAuRxTqtEdIeclJZwvUMxvb23BbBE+mtvKpXv69TB3DK8T1YIkhW2CidZW
-lad4MESC+QFNbQKCAQEA47PtULM/0ZFdE+PDDHOa2kJ2arm94sVIqF2168ZLXR69
-NkvCWfjkUPDeejINCx7XQgk0d/+5BCvrJpcM7lE4XfnYVNtPpct1el6eTfaOcPU8
-wAMsnq5n9Mxt02U+XRPtEqGk+lt0KLPDDSG88Z7jPmfftigLyPH6i/ZJyRUETlGk
-rGnWSx/LFUxQU5aBa2jUCjKOKa+OOk2jGg50A5Cmk26v9sA/ksOHisMjfdIpZc9P
-r4R0IteDDD5awlkWTF++5u1GpgU2yav4uan0wzY8OWYFzVyceA6+wffEcoplLm82
-CPd/qJOB5HHkjoM+CJgfumFxlNtdowKvKNUxpoQNtQKCAQEAh3ugofFPp+Q0M4r6
-gWnPZbuDxsLIR05K8vszYEjy4zup1YO4ygQNJ24fM91/n5Mo/jJEqwqgWd6w58ax
-tRclj00BCMXtGMrbHqTqSXWhR9LH66AGdPTHuXWpYZDnKliTlic/z1u+iWhbAHyl
-XEj2omIeKunc4gnod5cyYrKRouz3omLfi/pX33C19FGkWgjH2HpuViowBbhhDfCr
-9yJoEWC/0njl/hlTMdzLYcpEyxWMMuuC/FZXG+hPgWdWFh3XVzTEL3Fd3+hWEkp5
-rYWwu2ITaSiHvHaDrAvZZVXW8WoynXnvzr+tECgmTq57zI4eEwSTl4VY5VfxZ0dl
-FsIzXQKCAQBC07GYd6MJPGJWzgeWhe8yk0Lxu6WRAll6oFYd5kqD/9uELePSSAup
-/actsbbGRrziMpVlinWgVctjvf0bjFbArezhqqPLgtTtnwtS0kOnvzGfIM9dms4D
-uGObISGWa5yuVSZ4G5MRxwA9wGMVfo4u6Iltin868FmZ7iRlkXd8DNYJi95KmgAe
-NhF1FrzQ6ykf/QpgDZfuYI63vPorea6JonieMHn39s622OJ3sNBZguheGL+E4j8h
-vsMgOskijQ8X8xdC7lDQC1qqEsk06ZvvNJQLW1zIl3tArhjHjPp5EEaJhym+Ldx3
-UT3E3Zu9JfhZ2PNevqrShp0lnLw/pI3pAoIBAAUMz5Lj6V9ftsl1pTa8WDFeBJW0
-Wa5AT1BZg/ip2uq2NLPnA5JWcD+v682fRSvIj1pU0DRi6VsXlzhs+1q3+sgqiXGz
-u2ArFylh8TvC1gXUctXKZz/M3Rqr6aSNoejUGLmvHre+ja/k6Zwmu6ePtB7dL50d
-6+xMTYquS4gLbrbSLcEu3iBAAnvRLreXK4KguPxaBdICB7v7epdpAKe3Z7hp/sst
-eJj1+6KRdlcmt8fh5MPkBBXa6I/9XGmX5UEo7q4wAxeM9nuFWY3watz/EO9LiO6P
-LmqUSWL65m4cX0VZPvhYEsHppKi1eoWGlHqS4Af5+aIXi2alu2iljQFeA+Q=
------END RSA PRIVATE KEY-----
diff --git a/test/openssl/fixtures/pkey/rsa-3.pem b/test/openssl/fixtures/pkey/rsa-3.pem
deleted file mode 100644
index 6c9c9ce..0000000
--- a/test/openssl/fixtures/pkey/rsa-3.pem
+++ /dev/null
@@ -1,51 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIIJKAIBAAKCAgEAzn+YCcOh7BIRzrb7TEuhQLD545+/Fx/zCYO3l+y/8ogUxMTg
-LG5HrcXlX3JP796ie90/GHIf8/lwczVhP1jk/keYjkwoTYDt477R7KRcJPyGqHRr
-qLp7AnZxtz3JLNboTgO3bAYzlvtsSKU/R3oehBbGHzEWCP2UEYj/Kky0zpcjkhZU
-jiErr9ARPq8+dOGqBf+CE2NLKYC1bu8hZe9AddvvN2SvfMN6uhJtEGZO1k8tScwf
-AyvPJ1Po/6z08pzMAgfBUCE95waAVeYJWIOlnNB4eEievzlXdPB9vEt8OOwtWfQX
-V8xyMsoKeAW05s413E0eTYx1aulFXdWwG2mWEBRtNzKF1iBudlg1a3x1zThWi1pY
-jW5vROvoWZMCbl9bYQ/LxOCVqDoUl86+NPEGeuESMzm5NvOQA2e0Ty5wphnt9M19
-Wcc8neBhb6iCGqYzxWNvUYXZWUv1+/MrPHKyJuv7MSivwtctfp8SacUGxkd6T+u6
-V6ntHf3qtN/5pAmni6nzUTgjC65MS0LEhi/RTzwafkIfifeJH7/LqFtjrursuwua
-+p9lkACck/J5TpzaAfLroFQuepP8qgeq1cpD5Iii56IJ+FPSnkvesHuRUmZIkhtR
-VVsVqMaNPv/Uzc02bOaRXWP4auUY91mDKx/FDmORa9YCDQxMkKke05SWQ90CAwEA
-AQKCAgA0+B/c6VTgxGXS+7cMhB3yBTOkgva2jNh/6Uyv6Of345ZIPyQt4X/7gFbt
-G9qLcjWFxmQH9kZiA+snclrmr/vVijIE1l5EOz1KfUlGBYcpaal1DqALIQKqyA01
-buDq4pmmYWesiw6yvP2yyMipohav1VOu7p1zYvCXaufhRtneYICcWaQI7VNSfvHd
-fYBs5PIDJd6M8Jx4Ie7obOjJSAzl7qu3LtmhDFev4Ugeu8+fQ6IfWv/dhWBW+zw6
-UXhnv3bJUonw7wX8+/rxjdd54BMcXZF5cU9fR+s6MPJf2ZEc3OBpQaa3O9dTVeZH
-kVctGVpRj2qlg9EewoWro0PQVE5Mjah+mdFhPAHWoGl1xht6xJmg0uHYxMCzbUSz
-7NSS3knR0qieFvsp5ESY72i7DnQsbhbn6mTuYdVtm9bphxifAWCP3jFdft/bjtSF
-4yuPI7Qga+3m0B8QhtbWhEzPVon6NyiY7qfa6qllp0opEbw2hE22uGFFNJo2mpPa
-pe9VwARtD0IyfeklE7KrBEwV8NjTaAipZTZODw0w/dt4K3dOiePDl3pPWjmERpVg
-Lkw7XSCMtu5X87I1BbfOYbQhOXksPY+W9Asf6ETBeIZ8bD6Iypuk2ssool1lukqv
-yq1Y8gbR9B2x91ftYwXgzqBSvd8PFNsaXWLD3nrai2G1vb81lQKCAQEA6W02eZcN
-7wJfkqNokcuqhc5OKXH14gVIRV+KocG6f3vg88wrCg5J2GqNhBFuwVrafJjRenm6
-C8zWdneeyrl6cztgbaySw7kXnqFdTBiuOT8bhiG5NTPjDQ109EucaTbZU9KUXk6k
-ChPlr4G6IPrONpvi/9BvDDZLZkwR6uIg1kFWBy9kZaxFUEIug02hrbkTpPtnEUrO
-r3nG0QL/D0vf+bm4YHIVRMH2O2ZTTWexMw9XlfCe1+WjbJ+PS35QRCRDcRdWHXDb
-HnIFIAajtH5LtaJLgWUYq3B25WkQYtbHmFkm94sp/G4trb8JIJGzVO8cj9t6KeAT
-LG+tk8OqplqsYwKCAQEA4ne81KXx8VNwsKVFqwmiDIoi1q3beNa2hoXdzAMrnYdj
-iLxbfCVgrKPav9hdfXPBncHaNlGsd2G5W1a1UsOr128lTdfBsgm1RVPhVMKvo3fl
-yUnWajtAR1q3tVEUhuFlbJ/RHEtxJaGrzudYCPWQiYhydpDgSckbxD8PuElEgFBX
-O91vnWZEjMsxrABWiZNBxmtBUEv+fjUU/9USYzO4sN79UeD1+ZuBxPFwscsRcjLr
-bPgZWOwiywH6UmQ+DJTzeu0wJ6jgPoy/pgEujsbPDz1wNos6NhA/RQv31QeX33/B
-7/F5XKNmbJ2AFb/B+xTaTQPg0pjT5Exm+HrNU5OivwKCAQEAsLLVi9FG4OiBBHXi
-UItFuChljoYPxVqOTMV4Id6OmLZjoOmqouASElsGaTTxDDkEL1FXMUk4Bnq21dLT
-R06EXPpTknISX0qbkJ9CCrqcGAWnhi+9DYMLmvPW1p7t9c9pUESVv5X0IxTQx7yB
-8zkoJLp4aYGUrj/jb7qhzZYDmWy3/JRpgXWYupp+rzJy8xiowDj22mYwczDRyaJl
-BWVAVL+7zHZPl07kYC6jXHLj9mzktkIBXBkfTriyNkmV5R82VkN+Eqc9l5xkOMwN
-3DHGieYjFf47YHuv5RVVLBy91puWHckgrU+SEHYOKLNidybSDivsHArdOMQJN1Pk
-uCznVQKCAQAYY7DQbfa6eLQAMixomSb8lrvdxueGAgmyPyR93jGKS5Rqm2521ket
-EBB07MZUxmyposDvbKhYSwv9TD9G5I/TKcMouP3BQM5m4vu3dygXQMhcfzk6Q5tO
-k/SI8Gx3gjq8EhIhK/bJiLnKFJwkit3AEhPRtRSSnbgB0JDO1gUslHpwlg55MxRa
-3V9CGN84/cTtq4tjLGwCB5F1Y+sRB/byBXHeqY2UDi1Rmnb6jtYYKGe2WpnQO84b
-cuEUknskO75lFLpE6ykLU3koVaQ/+CVAjOtS1He2btWBiCJurNysU0P9pVHeqjJT
-rDqpHPe1JK/F74783zyir5+/Tuph/9pdAoIBAANPdFRQkJVH8K6iuhxQk6vFqiYB
-MUxpIVeLonD0p9TgMdezVNESht/AIutc0+5wabM45XuDWFRTuonvcE8lckv2Ux3a
-AvSsamjuesxw2YmkEtzZouVqDU0+oxppQJiwBG3MiaHX9F5IfnK6YmQ6xPwZ6MXi
-9feq1jR4KOc1ZrHtRMNgjnBWEFWroGe3FHgV7O133hpMSshRFmwcbE0nAaDr82U9
-sl8dclDjEKBxaqjAeNajOr+BU0w0AAwWXL7dt/ctG2QClcj9wqbEfsXnOR10h4AI
-rqkcvQrOLbTwcrOD/6R1rQfQXtEHKf1maThxosootAQZXdf6jxU3oonx3tU=
------END RSA PRIVATE KEY-----
diff --git a/test/openssl/fixtures/pkey/rsa1024.pem b/test/openssl/fixtures/pkey/rsa1024.pem
deleted file mode 100644
index 464de07..0000000
--- a/test/openssl/fixtures/pkey/rsa1024.pem
+++ /dev/null
@@ -1,15 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIICXgIBAAKBgQDLwsSw1ECnPtT+PkOgHhcGA71nwC2/nL85VBGnRqDxOqjVh7Cx
-aKPERYHsk4BPCkE3brtThPWc9kjHEQQ7uf9Y1rbCz0layNqHyywQEVLFmp1cpIt/
-Q3geLv8ZD9pihowKJDyMDiN6ArYUmZczvW4976MU3+l54E6lF/JfFEU5hwIDAQAB
-AoGBAKSl/MQarye1yOysqX6P8fDFQt68VvtXkNmlSiKOGuzyho0M+UVSFcs6k1L0
-maDE25AMZUiGzuWHyaU55d7RXDgeskDMakD1v6ZejYtxJkSXbETOTLDwUWTn618T
-gnb17tU1jktUtU67xK/08i/XodlgnQhs6VoHTuCh3Hu77O6RAkEA7+gxqBuZR572
-74/akiW/SuXm0SXPEviyO1MuSRwtI87B02D0qgV8D1UHRm4AhMnJ8MCs1809kMQE
-JiQUCrp9mQJBANlt2ngBO14us6NnhuAseFDTBzCHXwUUu1YKHpMMmxpnGqaldGgX
-sOZB3lgJsT9VlGf3YGYdkLTNVbogQKlKpB8CQQDiSwkb4vyQfDe8/NpU5Not0fII
-8jsDUCb+opWUTMmfbxWRR3FBNu8wnym/m19N4fFj8LqYzHX4KY0oVPu6qvJxAkEA
-wa5snNekFcqONLIE4G5cosrIrb74sqL8GbGb+KuTAprzj5z1K8Bm0UW9lTjVDjDi
-qRYgZfZSL+x1P/54+xTFSwJAY1FxA/N3QPCXCjPh5YqFxAMQs2VVYTfg+t0MEcJD
-dPMQD5JX6g5HKnHFg2mZtoXQrWmJSn7p8GJK8yNTopEErA==
------END RSA PRIVATE KEY-----
diff --git a/test/openssl/fixtures/pkey/rsa2048.pem b/test/openssl/fixtures/pkey/rsa2048.pem
deleted file mode 100644
index ac89cd8..0000000
--- a/test/openssl/fixtures/pkey/rsa2048.pem
+++ /dev/null
@@ -1,27 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIIEpAIBAAKCAQEAuV9ht9J7k4NBs38jOXvvTKY9gW8nLICSno5EETR1cuF7i4pN
-s9I1QJGAFAX0BEO4KbzXmuOvfCpD3CU+Slp1enenfzq/t/e/1IRW0wkJUJUFQign
-4CtrkJL+P07yx18UjyPlBXb81ApEmAB5mrJVSrWmqbjs07JbuS4QQGGXLc+Su96D
-kYKmSNVjBiLxVVSpyZfAY3hD37d60uG+X8xdW5v68JkRFIhdGlb6JL8fllf/A/bl
-NwdJOhVr9mESHhwGjwfSeTDPfd8ZLE027E5lyAVX9KZYcU00mOX+fdxOSnGqS/8J
-DRh0EPHDL15RcJjV2J6vZjPb0rOYGDoMcH+94wIDAQABAoIBAAzsamqfYQAqwXTb
-I0CJtGg6msUgU7HVkOM+9d3hM2L791oGHV6xBAdpXW2H8LgvZHJ8eOeSghR8+dgq
-PIqAffo4x1Oma+FOg3A0fb0evyiACyrOk+EcBdbBeLo/LcvahBtqnDfiUMQTpy6V
-seSoFCwuN91TSCeGIsDpRjbG1vxZgtx+uI+oH5+ytqJOmfCksRDCkMglGkzyfcl0
-Xc5CUhIJ0my53xijEUQl19rtWdMnNnnkdbG8PT3LZlOta5Do86BElzUYka0C6dUc
-VsBDQ0Nup0P6rEQgy7tephHoRlUGTYamsajGJaAo1F3IQVIrRSuagi7+YpSpCqsW
-wORqorkCgYEA7RdX6MDVrbw7LePnhyuaqTiMK+055/R1TqhB1JvvxJ1CXk2rDL6G
-0TLHQ7oGofd5LYiemg4ZVtWdJe43BPZlVgT6lvL/iGo8JnrncB9Da6L7nrq/+Rvj
-XGjf1qODCK+LmreZWEsaLPURIoR/Ewwxb9J2zd0CaMjeTwafJo1CZvcCgYEAyCgb
-aqoWvUecX8VvARfuA593Lsi50t4MEArnOXXcd1RnXoZWhbx5rgO8/ATKfXr0BK/n
-h2GF9PfKzHFm/4V6e82OL7gu/kLy2u9bXN74vOvWFL5NOrOKPM7Kg+9I131kNYOw
-Ivnr/VtHE5s0dY7JChYWE1F3vArrOw3T00a4CXUCgYEA0SqY+dS2LvIzW4cHCe9k
-IQqsT0yYm5TFsUEr4sA3xcPfe4cV8sZb9k/QEGYb1+SWWZ+AHPV3UW5fl8kTbSNb
-v4ng8i8rVVQ0ANbJO9e5CUrepein2MPL0AkOATR8M7t7dGGpvYV0cFk8ZrFx0oId
-U0PgYDotF/iueBWlbsOM430CgYEAqYI95dFyPI5/AiSkY5queeb8+mQH62sdcCCr
-vd/w/CZA/K5sbAo4SoTj8dLk4evU6HtIa0DOP63y071eaxvRpTNqLUOgmLh+D6gS
-Cc7TfLuFrD+WDBatBd5jZ+SoHccVrLR/4L8jeodo5FPW05A+9gnKXEXsTxY4LOUC
-9bS4e1kCgYAqVXZh63JsMwoaxCYmQ66eJojKa47VNrOeIZDZvd2BPVf30glBOT41
-gBoDG3WMPZoQj9pb7uMcrnvs4APj2FIhMU8U15LcPAj59cD6S6rWnAxO8NFK7HQG
-4Jxg3JNNf8ErQoCHb1B3oVdXJkmbJkARoDpBKmTCgKtP8ADYLmVPQw==
------END RSA PRIVATE KEY-----
diff --git a/test/openssl/test_asn1.rb b/test/openssl/test_asn1.rb
deleted file mode 100644
index af069ca..0000000
--- a/test/openssl/test_asn1.rb
+++ /dev/null
@@ -1,720 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class  OpenSSL::TestASN1 < OpenSSL::TestCase
-  def test_decode_x509_certificate
-    subj = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=TestCA")
-    key = Fixtures.pkey("rsa1024")
-    now = Time.at(Time.now.to_i) # suppress usec
-    s = 0xdeadbeafdeadbeafdeadbeafdeadbeaf
-    exts = [
-      ["basicConstraints","CA:TRUE,pathlen:1",true],
-      ["keyUsage","keyCertSign, cRLSign",true],
-      ["subjectKeyIdentifier","hash",false],
-    ]
-    dgst = OpenSSL::Digest.new('SHA1')
-    cert = OpenSSL::TestUtils.issue_cert(
-      subj, key, s, exts, nil, nil, digest: dgst, not_before: now, not_after: now+3600)
-
-
-    asn1 = OpenSSL::ASN1.decode(cert)
-    assert_equal(OpenSSL::ASN1::Sequence, asn1.class)
-    assert_equal(3, asn1.value.size)
-    tbs_cert, sig_alg, sig_val = *asn1.value
-
-    assert_equal(OpenSSL::ASN1::Sequence, tbs_cert.class)
-    assert_equal(8, tbs_cert.value.size)
-
-    version = tbs_cert.value[0]
-    assert_equal(:CONTEXT_SPECIFIC, version.tag_class)
-    assert_equal(0, version.tag)
-    assert_equal(1, version.value.size)
-    assert_equal(OpenSSL::ASN1::Integer, version.value[0].class)
-    assert_equal(2, version.value[0].value)
-
-    serial = tbs_cert.value[1]
-    assert_equal(OpenSSL::ASN1::Integer, serial.class)
-    assert_equal(0xdeadbeafdeadbeafdeadbeafdeadbeaf, serial.value)
-
-    sig = tbs_cert.value[2]
-    assert_equal(OpenSSL::ASN1::Sequence, sig.class)
-    assert_equal(2, sig.value.size)
-    assert_equal(OpenSSL::ASN1::ObjectId, sig.value[0].class)
-    assert_equal("1.2.840.113549.1.1.5", sig.value[0].oid)
-    assert_equal(OpenSSL::ASN1::Null, sig.value[1].class)
-
-    dn = tbs_cert.value[3] # issuer
-    assert_equal(subj.hash, OpenSSL::X509::Name.new(dn).hash)
-    assert_equal(OpenSSL::ASN1::Sequence, dn.class)
-    assert_equal(3, dn.value.size)
-    assert_equal(OpenSSL::ASN1::Set, dn.value[0].class)
-    assert_equal(OpenSSL::ASN1::Set, dn.value[1].class)
-    assert_equal(OpenSSL::ASN1::Set, dn.value[2].class)
-    assert_equal(1, dn.value[0].value.size)
-    assert_equal(1, dn.value[1].value.size)
-    assert_equal(1, dn.value[2].value.size)
-    assert_equal(OpenSSL::ASN1::Sequence, dn.value[0].value[0].class)
-    assert_equal(OpenSSL::ASN1::Sequence, dn.value[1].value[0].class)
-    assert_equal(OpenSSL::ASN1::Sequence, dn.value[2].value[0].class)
-    assert_equal(2, dn.value[0].value[0].value.size)
-    assert_equal(2, dn.value[1].value[0].value.size)
-    assert_equal(2, dn.value[2].value[0].value.size)
-    oid, value = *dn.value[0].value[0].value
-    assert_equal(OpenSSL::ASN1::ObjectId, oid.class)
-    assert_equal("0.9.2342.19200300.100.1.25", oid.oid)
-    assert_equal(OpenSSL::ASN1::IA5String, value.class)
-    assert_equal("org", value.value)
-    oid, value = *dn.value[1].value[0].value
-    assert_equal(OpenSSL::ASN1::ObjectId, oid.class)
-    assert_equal("0.9.2342.19200300.100.1.25", oid.oid)
-    assert_equal(OpenSSL::ASN1::IA5String, value.class)
-    assert_equal("ruby-lang", value.value)
-    oid, value = *dn.value[2].value[0].value
-    assert_equal(OpenSSL::ASN1::ObjectId, oid.class)
-    assert_equal("2.5.4.3", oid.oid)
-    assert_equal(OpenSSL::ASN1::UTF8String, value.class)
-    assert_equal("TestCA", value.value)
-
-    validity = tbs_cert.value[4]
-    assert_equal(OpenSSL::ASN1::Sequence, validity.class)
-    assert_equal(2, validity.value.size)
-    assert_equal(OpenSSL::ASN1::UTCTime, validity.value[0].class)
-    assert_equal(now, validity.value[0].value)
-    assert_equal(OpenSSL::ASN1::UTCTime, validity.value[1].class)
-    assert_equal(now+3600, validity.value[1].value)
-
-    dn = tbs_cert.value[5] # subject
-    assert_equal(subj.hash, OpenSSL::X509::Name.new(dn).hash)
-    assert_equal(OpenSSL::ASN1::Sequence, dn.class)
-    assert_equal(3, dn.value.size)
-    assert_equal(OpenSSL::ASN1::Set, dn.value[0].class)
-    assert_equal(OpenSSL::ASN1::Set, dn.value[1].class)
-    assert_equal(OpenSSL::ASN1::Set, dn.value[2].class)
-    assert_equal(1, dn.value[0].value.size)
-    assert_equal(1, dn.value[1].value.size)
-    assert_equal(1, dn.value[2].value.size)
-    assert_equal(OpenSSL::ASN1::Sequence, dn.value[0].value[0].class)
-    assert_equal(OpenSSL::ASN1::Sequence, dn.value[1].value[0].class)
-    assert_equal(OpenSSL::ASN1::Sequence, dn.value[2].value[0].class)
-    assert_equal(2, dn.value[0].value[0].value.size)
-    assert_equal(2, dn.value[1].value[0].value.size)
-    assert_equal(2, dn.value[2].value[0].value.size)
-    oid, value = *dn.value[0].value[0].value
-    assert_equal(OpenSSL::ASN1::ObjectId, oid.class)
-    assert_equal("0.9.2342.19200300.100.1.25", oid.oid)
-    assert_equal(OpenSSL::ASN1::IA5String, value.class)
-    assert_equal("org", value.value)
-    oid, value = *dn.value[1].value[0].value
-    assert_equal(OpenSSL::ASN1::ObjectId, oid.class)
-    assert_equal("0.9.2342.19200300.100.1.25", oid.oid)
-    assert_equal(OpenSSL::ASN1::IA5String, value.class)
-    assert_equal("ruby-lang", value.value)
-    oid, value = *dn.value[2].value[0].value
-    assert_equal(OpenSSL::ASN1::ObjectId, oid.class)
-    assert_equal("2.5.4.3", oid.oid)
-    assert_equal(OpenSSL::ASN1::UTF8String, value.class)
-    assert_equal("TestCA", value.value)
-
-    pkey = tbs_cert.value[6]
-    assert_equal(OpenSSL::ASN1::Sequence, pkey.class)
-    assert_equal(2, pkey.value.size)
-    assert_equal(OpenSSL::ASN1::Sequence, pkey.value[0].class)
-    assert_equal(2, pkey.value[0].value.size)
-    assert_equal(OpenSSL::ASN1::ObjectId, pkey.value[0].value[0].class)
-    assert_equal("1.2.840.113549.1.1.1", pkey.value[0].value[0].oid)
-    assert_equal(OpenSSL::ASN1::BitString, pkey.value[1].class)
-    assert_equal(0, pkey.value[1].unused_bits)
-    spkey = OpenSSL::ASN1.decode(pkey.value[1].value)
-    assert_equal(OpenSSL::ASN1::Sequence, spkey.class)
-    assert_equal(2, spkey.value.size)
-    assert_equal(OpenSSL::ASN1::Integer, spkey.value[0].class)
-    assert_equal(cert.public_key.n, spkey.value[0].value)
-    assert_equal(OpenSSL::ASN1::Integer, spkey.value[1].class)
-    assert_equal(cert.public_key.e, spkey.value[1].value)
-
-    extensions = tbs_cert.value[7]
-    assert_equal(:CONTEXT_SPECIFIC, extensions.tag_class)
-    assert_equal(3, extensions.tag)
-    assert_equal(1, extensions.value.size)
-    assert_equal(OpenSSL::ASN1::Sequence, extensions.value[0].class)
-    assert_equal(3, extensions.value[0].value.size)
-
-    ext = extensions.value[0].value[0]  # basicConstraints
-    assert_equal(OpenSSL::ASN1::Sequence, ext.class)
-    assert_equal(3, ext.value.size)
-    assert_equal(OpenSSL::ASN1::ObjectId, ext.value[0].class)
-    assert_equal("2.5.29.19",  ext.value[0].oid)
-    assert_equal(OpenSSL::ASN1::Boolean, ext.value[1].class)
-    assert_equal(true, ext.value[1].value)
-    assert_equal(OpenSSL::ASN1::OctetString, ext.value[2].class)
-    extv = OpenSSL::ASN1.decode(ext.value[2].value)
-    assert_equal(OpenSSL::ASN1::Sequence, extv.class)
-    assert_equal(2, extv.value.size)
-    assert_equal(OpenSSL::ASN1::Boolean, extv.value[0].class)
-    assert_equal(true, extv.value[0].value)
-    assert_equal(OpenSSL::ASN1::Integer, extv.value[1].class)
-    assert_equal(1, extv.value[1].value)
-
-    ext = extensions.value[0].value[1]  # keyUsage
-    assert_equal(OpenSSL::ASN1::Sequence, ext.class)
-    assert_equal(3, ext.value.size)
-    assert_equal(OpenSSL::ASN1::ObjectId, ext.value[0].class)
-    assert_equal("2.5.29.15",  ext.value[0].oid)
-    assert_equal(OpenSSL::ASN1::Boolean, ext.value[1].class)
-    assert_equal(true, ext.value[1].value)
-    assert_equal(OpenSSL::ASN1::OctetString, ext.value[2].class)
-    extv = OpenSSL::ASN1.decode(ext.value[2].value)
-    assert_equal(OpenSSL::ASN1::BitString, extv.class)
-    str = +"\000"; str[0] = 0b00000110.chr
-    assert_equal(str, extv.value)
-
-    ext = extensions.value[0].value[2]  # subjetKeyIdentifier
-    assert_equal(OpenSSL::ASN1::Sequence, ext.class)
-    assert_equal(2, ext.value.size)
-    assert_equal(OpenSSL::ASN1::ObjectId, ext.value[0].class)
-    assert_equal("2.5.29.14",  ext.value[0].oid)
-    assert_equal(OpenSSL::ASN1::OctetString, ext.value[1].class)
-    extv = OpenSSL::ASN1.decode(ext.value[1].value)
-    assert_equal(OpenSSL::ASN1::OctetString, extv.class)
-    sha1 = OpenSSL::Digest.new('SHA1')
-    sha1.update(pkey.value[1].value)
-    assert_equal(sha1.digest, extv.value)
-
-    assert_equal(OpenSSL::ASN1::Sequence, sig_alg.class)
-    assert_equal(2, sig_alg.value.size)
-    assert_equal(OpenSSL::ASN1::ObjectId, pkey.value[0].value[0].class)
-    assert_equal("1.2.840.113549.1.1.1", pkey.value[0].value[0].oid)
-    assert_equal(OpenSSL::ASN1::Null, pkey.value[0].value[1].class)
-
-    assert_equal(OpenSSL::ASN1::BitString, sig_val.class)
-    cululated_sig = key.sign(OpenSSL::Digest.new('SHA1'), tbs_cert.to_der)
-    assert_equal(cululated_sig, sig_val.value)
-  end
-
-  def test_decode_all
-    raw = B(%w{ 02 01 01 02 01 02 02 01 03 })
-    ary = OpenSSL::ASN1.decode_all(raw)
-    assert_equal(3, ary.size)
-    ary.each_with_index do |asn1, i|
-      assert_universal(OpenSSL::ASN1::INTEGER, asn1)
-      assert_equal(i + 1, asn1.value)
-    end
-  end
-
-  def test_object_id_register
-    oid = "1.2.34.56789"
-    pend "OID 1.2.34.56789 is already registered" if OpenSSL::ASN1::ObjectId(oid).sn
-    assert_equal true, OpenSSL::ASN1::ObjectId.register(oid, "ossl-test-sn", "ossl-test-ln")
-    obj = OpenSSL::ASN1::ObjectId(oid)
-    assert_equal oid, obj.oid
-    assert_equal "ossl-test-sn", obj.sn
-    assert_equal "ossl-test-ln", obj.ln
-    obj = encode_decode_test B(%w{ 06 05 2A 22 83 BB 55 }), OpenSSL::ASN1::ObjectId("ossl-test-ln")
-    assert_equal "ossl-test-sn", obj.value
-  end
-
-  def test_end_of_content
-    encode_decode_test B(%w{ 00 00 }), OpenSSL::ASN1::EndOfContent.new
-    assert_raise(OpenSSL::ASN1::ASN1Error) {
-      OpenSSL::ASN1.decode(B(%w{ 00 01 00 }))
-    }
-  end
-
-  def test_boolean
-    encode_decode_test B(%w{ 01 01 00 }), OpenSSL::ASN1::Boolean.new(false)
-    encode_decode_test B(%w{ 01 01 FF }), OpenSSL::ASN1::Boolean.new(true)
-    decode_test B(%w{ 01 01 01 }), OpenSSL::ASN1::Boolean.new(true)
-    assert_raise(OpenSSL::ASN1::ASN1Error) {
-      OpenSSL::ASN1.decode(B(%w{ 01 02 00 00 }))
-    }
-  end
-
-  def test_integer
-    encode_decode_test B(%w{ 02 01 00 }), OpenSSL::ASN1::Integer.new(0)
-    encode_decode_test B(%w{ 02 01 48 }), OpenSSL::ASN1::Integer.new(72)
-    encode_decode_test B(%w{ 02 02 00 80 }), OpenSSL::ASN1::Integer.new(128)
-    encode_decode_test B(%w{ 02 01 81 }), OpenSSL::ASN1::Integer.new(-127)
-    encode_decode_test B(%w{ 02 01 80 }), OpenSSL::ASN1::Integer.new(-128)
-    encode_decode_test B(%w{ 02 01 FF }), OpenSSL::ASN1::Integer.new(-1)
-    encode_decode_test B(%w{ 02 09 01 00 00 00 00 00 00 00 00 }), OpenSSL::ASN1::Integer.new(2 ** 64)
-    encode_decode_test B(%w{ 02 09 FF 00 00 00 00 00 00 00 00 }), OpenSSL::ASN1::Integer.new(-(2 ** 64))
-    # FIXME: OpenSSL < 1.1.0 does not fail
-    # assert_raise(OpenSSL::ASN1::ASN1Error) {
-    #   OpenSSL::ASN1.decode(B(%w{ 02 02 00 7F }))
-    # }
-    # assert_raise(OpenSSL::ASN1::ASN1Error) {
-    #   OpenSSL::ASN1.decode(B(%w{ 02 02 FF 80 }))
-    # }
-  end
-
-  def test_enumerated
-    encode_decode_test B(%w{ 0A 01 00 }), OpenSSL::ASN1::Enumerated.new(0)
-    encode_decode_test B(%w{ 0A 01 48 }), OpenSSL::ASN1::Enumerated.new(72)
-    encode_decode_test B(%w{ 0A 02 00 80 }), OpenSSL::ASN1::Enumerated.new(128)
-    encode_decode_test B(%w{ 0A 09 01 00 00 00 00 00 00 00 00 }), OpenSSL::ASN1::Enumerated.new(2 ** 64)
-  end
-
-  def test_bitstring
-    encode_decode_test B(%w{ 03 01 00 }), OpenSSL::ASN1::BitString.new(B(%w{}))
-    encode_decode_test B(%w{ 03 02 00 01 }), OpenSSL::ASN1::BitString.new(B(%w{ 01 }))
-    obj = OpenSSL::ASN1::BitString.new(B(%w{ F0 }))
-    obj.unused_bits = 4
-    encode_decode_test B(%w{ 03 02 04 F0 }), obj
-    assert_raise(OpenSSL::ASN1::ASN1Error) {
-      OpenSSL::ASN1.decode(B(%w{ 03 00 }))
-    }
-    # OpenSSL < OpenSSL_1_0_1k and LibreSSL ignore the error
-    # assert_raise(OpenSSL::ASN1::ASN1Error) {
-    #   OpenSSL::ASN1.decode(B(%w{ 03 03 08 FF 00 }))
-    # }
-    # OpenSSL does not seem to prohibit this, though X.690 8.6.2.3 (15/08) does
-    # assert_raise(OpenSSL::ASN1::ASN1Error) {
-    #   OpenSSL::ASN1.decode(B(%w{ 03 01 04 }))
-    # }
-    assert_raise(OpenSSL::ASN1::ASN1Error) {
-      obj = OpenSSL::ASN1::BitString.new(B(%w{ FF FF }))
-      obj.unused_bits = 8
-      obj.to_der
-    }
-  end
-
-  def test_string_basic
-    test = -> (tag, klass) {
-      encode_decode_test tag.chr + B(%w{ 00 }), klass.new(B(%w{}))
-      encode_decode_test tag.chr + B(%w{ 02 00 01 }), klass.new(B(%w{ 00 01 }))
-    }
-    test.(4, OpenSSL::ASN1::OctetString)
-    test.(12, OpenSSL::ASN1::UTF8String)
-    test.(18, OpenSSL::ASN1::NumericString)
-    test.(19, OpenSSL::ASN1::PrintableString)
-    test.(20, OpenSSL::ASN1::T61String)
-    test.(21, OpenSSL::ASN1::VideotexString)
-    test.(22, OpenSSL::ASN1::IA5String)
-    test.(25, OpenSSL::ASN1::GraphicString)
-    test.(26, OpenSSL::ASN1::ISO64String)
-    test.(27, OpenSSL::ASN1::GeneralString)
-    test.(28, OpenSSL::ASN1::UniversalString)
-    test.(30, OpenSSL::ASN1::BMPString)
-  end
-
-  def test_null
-    encode_decode_test B(%w{ 05 00 }), OpenSSL::ASN1::Null.new(nil)
-    assert_raise(OpenSSL::ASN1::ASN1Error) {
-      OpenSSL::ASN1.decode(B(%w{ 05 01 00 }))
-    }
-  end
-
-  def test_object_identifier
-    encode_decode_test B(%w{ 06 01 00 }), OpenSSL::ASN1::ObjectId.new("0.0".b)
-    encode_decode_test B(%w{ 06 01 28 }), OpenSSL::ASN1::ObjectId.new("1.0".b)
-    encode_decode_test B(%w{ 06 03 88 37 03 }), OpenSSL::ASN1::ObjectId.new("2.999.3".b)
-    encode_decode_test B(%w{ 06 05 2A 22 83 BB 55 }), OpenSSL::ASN1::ObjectId.new("1.2.34.56789".b)
-    obj = encode_decode_test B(%w{ 06 09 60 86 48 01 65 03 04 02 01 }), OpenSSL::ASN1::ObjectId.new("sha256")
-    assert_equal "2.16.840.1.101.3.4.2.1", obj.oid
-    assert_equal "SHA256", obj.sn
-    assert_equal "sha256", obj.ln
-    assert_raise(OpenSSL::ASN1::ASN1Error) {
-      OpenSSL::ASN1.decode(B(%w{ 06 00 }))
-    }
-    assert_raise(OpenSSL::ASN1::ASN1Error) {
-      OpenSSL::ASN1.decode(B(%w{ 06 01 80 }))
-    }
-    assert_raise(OpenSSL::ASN1::ASN1Error) { OpenSSL::ASN1::ObjectId.new("3.0".b).to_der }
-    assert_raise(OpenSSL::ASN1::ASN1Error) { OpenSSL::ASN1::ObjectId.new("0.40".b).to_der }
-
-    begin
-      oid = (0...100).to_a.join(".").b
-      obj = OpenSSL::ASN1::ObjectId.new(oid)
-      assert_equal oid, obj.oid
-    rescue OpenSSL::ASN1::ASN1Error
-      pend "OBJ_obj2txt() not working (LibreSSL?)" if $!.message =~ /OBJ_obj2txt/
-      raise
-    end
-
-    aki = [
-      OpenSSL::ASN1::ObjectId.new("authorityKeyIdentifier"),
-      OpenSSL::ASN1::ObjectId.new("X509v3 Authority Key Identifier"),
-      OpenSSL::ASN1::ObjectId.new("2.5.29.35")
-    ]
-
-    ski = [
-      OpenSSL::ASN1::ObjectId.new("subjectKeyIdentifier"),
-      OpenSSL::ASN1::ObjectId.new("X509v3 Subject Key Identifier"),
-      OpenSSL::ASN1::ObjectId.new("2.5.29.14")
-    ]
-
-    aki.each do |a|
-      aki.each do |b|
-        assert a == b
-      end
-
-      ski.each do |b|
-        refute a == b
-      end
-    end
-
-    assert_raise(TypeError) {
-      OpenSSL::ASN1::ObjectId.new("authorityKeyIdentifier") == nil
-    }
-  end
-
-  def test_sequence
-    encode_decode_test B(%w{ 30 00 }), OpenSSL::ASN1::Sequence.new([])
-    encode_decode_test B(%w{ 30 07 05 00 30 00 04 01 00 }), OpenSSL::ASN1::Sequence.new([
-      OpenSSL::ASN1::Null.new(nil),
-      OpenSSL::ASN1::Sequence.new([]),
-      OpenSSL::ASN1::OctetString.new(B(%w{ 00 }))
-    ])
-
-    expected = OpenSSL::ASN1::Sequence.new([OpenSSL::ASN1::OctetString.new(B(%w{ 00 }))])
-    expected.indefinite_length = true
-    encode_decode_test B(%w{ 30 80 04 01 00 00 00 }), expected
-
-    # OpenSSL::ASN1::EndOfContent can only be at the end
-    obj = OpenSSL::ASN1::Sequence.new([
-      OpenSSL::ASN1::EndOfContent.new,
-      OpenSSL::ASN1::OctetString.new(B(%w{ 00 })),
-      OpenSSL::ASN1::EndOfContent.new,
-    ])
-    obj.indefinite_length = true
-    assert_raise(OpenSSL::ASN1::ASN1Error) { obj.to_der }
-
-    # The last EOC in value is ignored if indefinite length form is used
-    expected = OpenSSL::ASN1::Sequence.new([
-      OpenSSL::ASN1::OctetString.new(B(%w{ 00 })),
-      OpenSSL::ASN1::EndOfContent.new
-    ])
-    expected.indefinite_length = true
-    encode_test B(%w{ 30 80 04 01 00 00 00 }), expected
-  end
-
-  def test_set
-    encode_decode_test B(%w{ 31 00 }), OpenSSL::ASN1::Set.new([])
-    encode_decode_test B(%w{ 31 07 05 00 30 00 04 01 00 }), OpenSSL::ASN1::Set.new([
-      OpenSSL::ASN1::Null.new(nil),
-      OpenSSL::ASN1::Sequence.new([]),
-      OpenSSL::ASN1::OctetString.new(B(%w{ 00 }))
-    ])
-    expected = OpenSSL::ASN1::Set.new([OpenSSL::ASN1::OctetString.new(B(%w{ 00 }))])
-    expected.indefinite_length = true
-    encode_decode_test B(%w{ 31 80 04 01 00 00 00 }), expected
-  end
-
-  def test_utctime
-    encode_decode_test B(%w{ 17 0D }) + "160908234339Z".b,
-      OpenSSL::ASN1::UTCTime.new(Time.utc(2016, 9, 8, 23, 43, 39))
-    # Seconds is omitted
-    decode_test B(%w{ 17 0B }) + "1609082343Z".b,
-      OpenSSL::ASN1::UTCTime.new(Time.utc(2016, 9, 8, 23, 43, 0))
-    begin
-      # possible range of UTCTime is 1969-2068 currently
-      encode_decode_test B(%w{ 17 0D }) + "690908234339Z".b,
-        OpenSSL::ASN1::UTCTime.new(Time.utc(1969, 9, 8, 23, 43, 39))
-    rescue OpenSSL::ASN1::ASN1Error
-      pend "No negative time_t support?"
-    end
-    # not implemented
-    # decode_test B(%w{ 17 11 }) + "500908234339+0930".b,
-    #   OpenSSL::ASN1::UTCTime.new(Time.new(1950, 9, 8, 23, 43, 39, "+09:30"))
-    # decode_test B(%w{ 17 0F }) + "5009082343-0930".b,
-    #   OpenSSL::ASN1::UTCTime.new(Time.new(1950, 9, 8, 23, 43, 0, "-09:30"))
-    # assert_raise(OpenSSL::ASN1::ASN1Error) {
-    #   OpenSSL::ASN1.decode(B(%w{ 17 0C }) + "500908234339".b)
-    # }
-    # assert_raise(OpenSSL::ASN1::ASN1Error) {
-    #   OpenSSL::ASN1.decode(B(%w{ 17 0D }) + "500908234339Y".b)
-    # }
-  end
-
-  def test_generalizedtime
-    encode_decode_test B(%w{ 18 0F }) + "20161208193429Z".b,
-      OpenSSL::ASN1::GeneralizedTime.new(Time.utc(2016, 12, 8, 19, 34, 29))
-    encode_decode_test B(%w{ 18 0F }) + "99990908234339Z".b,
-      OpenSSL::ASN1::GeneralizedTime.new(Time.utc(9999, 9, 8, 23, 43, 39))
-    decode_test B(%w{ 18 0D }) + "201612081934Z".b,
-      OpenSSL::ASN1::GeneralizedTime.new(Time.utc(2016, 12, 8, 19, 34, 0))
-    # not implemented
-    # decode_test B(%w{ 18 13 }) + "20161208193439+0930".b,
-    #   OpenSSL::ASN1::GeneralizedTime.new(Time.new(2016, 12, 8, 19, 34, 39, "+09:30"))
-    # decode_test B(%w{ 18 11 }) + "201612081934-0930".b,
-    #   OpenSSL::ASN1::GeneralizedTime.new(Time.new(2016, 12, 8, 19, 34, 0, "-09:30"))
-    # decode_test B(%w{ 18 11 }) + "201612081934-09".b,
-    #   OpenSSL::ASN1::GeneralizedTime.new(Time.new(2016, 12, 8, 19, 34, 0, "-09:00"))
-    # decode_test B(%w{ 18 0D }) + "2016120819.5Z".b,
-    #   OpenSSL::ASN1::GeneralizedTime.new(Time.utc(2016, 12, 8, 19, 30, 0))
-    # decode_test B(%w{ 18 0D }) + "2016120819,5Z".b,
-    #   OpenSSL::ASN1::GeneralizedTime.new(Time.utc(2016, 12, 8, 19, 30, 0))
-    # decode_test B(%w{ 18 0F }) + "201612081934.5Z".b,
-    #   OpenSSL::ASN1::GeneralizedTime.new(Time.utc(2016, 12, 8, 19, 34, 30))
-    # decode_test B(%w{ 18 11 }) + "20161208193439.5Z".b,
-    #   OpenSSL::ASN1::GeneralizedTime.new(Time.utc(2016, 12, 8, 19, 34, 39.5))
-    # assert_raise(OpenSSL::ASN1::ASN1Error) {
-    #   OpenSSL::ASN1.decode(B(%w{ 18 0D }) + "201612081934Y".b)
-    # }
-  end
-
-  def test_basic_asn1data
-    encode_test B(%w{ 00 00 }), OpenSSL::ASN1::ASN1Data.new(B(%w{}), 0, :UNIVERSAL)
-    encode_test B(%w{ 01 00 }), OpenSSL::ASN1::ASN1Data.new(B(%w{}), 1, :UNIVERSAL)
-    encode_decode_test B(%w{ 41 00 }), OpenSSL::ASN1::ASN1Data.new(B(%w{}), 1, :APPLICATION)
-    encode_decode_test B(%w{ 81 00 }), OpenSSL::ASN1::ASN1Data.new(B(%w{}), 1, :CONTEXT_SPECIFIC)
-    encode_decode_test B(%w{ C1 00 }), OpenSSL::ASN1::ASN1Data.new(B(%w{}), 1, :PRIVATE)
-    encode_decode_test B(%w{ 1F 20 00 }), OpenSSL::ASN1::ASN1Data.new(B(%w{}), 32, :UNIVERSAL)
-    encode_decode_test B(%w{ 1F C0 20 00 }), OpenSSL::ASN1::ASN1Data.new(B(%w{}), 8224, :UNIVERSAL)
-    encode_decode_test B(%w{ 41 02 AB CD }), OpenSSL::ASN1::ASN1Data.new(B(%w{ AB CD }), 1, :APPLICATION)
-    encode_decode_test B(%w{ 41 81 80 } + %w{ AB CD } * 64), OpenSSL::ASN1::ASN1Data.new(B(%w{ AB CD } * 64), 1, :APPLICATION)
-    encode_decode_test B(%w{ 41 82 01 00 } + %w{ AB CD } * 128), OpenSSL::ASN1::ASN1Data.new(B(%w{ AB CD } * 128), 1, :APPLICATION)
-    encode_decode_test B(%w{ 61 00 }), OpenSSL::ASN1::ASN1Data.new([], 1, :APPLICATION)
-    obj = OpenSSL::ASN1::ASN1Data.new([OpenSSL::ASN1::ASN1Data.new(B(%w{ AB CD }), 2, :PRIVATE)], 1, :APPLICATION)
-    obj.indefinite_length = true
-    encode_decode_test B(%w{ 61 80 C2 02 AB CD 00 00 }), obj
-    obj = OpenSSL::ASN1::ASN1Data.new([
-      OpenSSL::ASN1::ASN1Data.new(B(%w{ AB CD }), 2, :PRIVATE),
-      OpenSSL::ASN1::EndOfContent.new
-    ], 1, :APPLICATION)
-    obj.indefinite_length = true
-    encode_test B(%w{ 61 80 C2 02 AB CD 00 00 }), obj
-    obj = OpenSSL::ASN1::ASN1Data.new(B(%w{ AB CD }), 1, :UNIVERSAL)
-    obj.indefinite_length = true
-    assert_raise(OpenSSL::ASN1::ASN1Error) { obj.to_der }
-  end
-
-  def test_basic_primitive
-    encode_test B(%w{ 00 00 }), OpenSSL::ASN1::Primitive.new(B(%w{}), 0)
-    encode_test B(%w{ 01 00 }), OpenSSL::ASN1::Primitive.new(B(%w{}), 1, nil, :UNIVERSAL)
-    encode_test B(%w{ 81 00 }), OpenSSL::ASN1::Primitive.new(B(%w{}), 1, nil, :CONTEXT_SPECIFIC)
-    encode_test B(%w{ 01 02 AB CD }), OpenSSL::ASN1::Primitive.new(B(%w{ AB CD }), 1)
-    assert_raise(TypeError) { OpenSSL::ASN1::Primitive.new([], 1).to_der }
-
-    prim = OpenSSL::ASN1::Integer.new(50)
-    assert_equal false, prim.indefinite_length
-    assert_not_respond_to prim, :indefinite_length=
-  end
-
-  def test_basic_constructed
-    octet_string = OpenSSL::ASN1::OctetString.new(B(%w{ AB CD }))
-    encode_test B(%w{ 20 00 }), OpenSSL::ASN1::Constructive.new([], 0)
-    encode_test B(%w{ 21 00 }), OpenSSL::ASN1::Constructive.new([], 1, nil, :UNIVERSAL)
-    encode_test B(%w{ A1 00 }), OpenSSL::ASN1::Constructive.new([], 1, nil, :CONTEXT_SPECIFIC)
-    encode_test B(%w{ 21 04 04 02 AB CD }), OpenSSL::ASN1::Constructive.new([octet_string], 1)
-    obj = OpenSSL::ASN1::Constructive.new([octet_string], 1)
-    obj.indefinite_length = true
-    encode_decode_test B(%w{ 21 80 04 02 AB CD 00 00 }), obj
-    obj = OpenSSL::ASN1::Constructive.new([octet_string, OpenSSL::ASN1::EndOfContent.new], 1)
-    obj.indefinite_length = true
-    encode_test B(%w{ 21 80 04 02 AB CD 00 00 }), obj
-  end
-
-  def test_prim_explicit_tagging
-    oct_str = OpenSSL::ASN1::OctetString.new("a", 0, :EXPLICIT)
-    encode_test B(%w{ A0 03 04 01 61 }), oct_str
-    oct_str2 = OpenSSL::ASN1::OctetString.new("a", 1, :EXPLICIT, :APPLICATION)
-    encode_test B(%w{ 61 03 04 01 61 }), oct_str2
-
-    decoded = OpenSSL::ASN1.decode(oct_str2.to_der)
-    assert_equal :APPLICATION, decoded.tag_class
-    assert_equal 1, decoded.tag
-    assert_equal 1, decoded.value.size
-    inner = decoded.value[0]
-    assert_equal OpenSSL::ASN1::OctetString, inner.class
-    assert_equal B(%w{ 61 }), inner.value
-  end
-
-  def test_prim_implicit_tagging
-    int = OpenSSL::ASN1::Integer.new(1, 0, :IMPLICIT)
-    encode_test B(%w{ 80 01 01 }), int
-    int2 = OpenSSL::ASN1::Integer.new(1, 1, :IMPLICIT, :APPLICATION)
-    encode_test B(%w{ 41 01 01 }), int2
-    decoded = OpenSSL::ASN1.decode(int2.to_der)
-    assert_equal :APPLICATION, decoded.tag_class
-    assert_equal 1, decoded.tag
-    assert_equal B(%w{ 01 }), decoded.value
-
-    # Special behavior: Encoding universal types with non-default 'tag'
-    # attribute and nil tagging method.
-    int3 = OpenSSL::ASN1::Integer.new(1, 1)
-    encode_test B(%w{ 01 01 01 }), int3
-  end
-
-  def test_cons_explicit_tagging
-    content = [ OpenSSL::ASN1::PrintableString.new('abc') ]
-    seq = OpenSSL::ASN1::Sequence.new(content, 2, :EXPLICIT)
-    encode_test B(%w{ A2 07 30 05 13 03 61 62 63 }), seq
-    seq2 = OpenSSL::ASN1::Sequence.new(content, 3, :EXPLICIT, :APPLICATION)
-    encode_test B(%w{ 63 07 30 05 13 03 61 62 63 }), seq2
-
-    content3 = [ OpenSSL::ASN1::PrintableString.new('abc'),
-                 OpenSSL::ASN1::EndOfContent.new() ]
-    seq3 = OpenSSL::ASN1::Sequence.new(content3, 2, :EXPLICIT)
-    seq3.indefinite_length = true
-    encode_test B(%w{ A2 80 30 80 13 03 61 62 63 00 00 00 00 }), seq3
-  end
-
-  def test_cons_implicit_tagging
-    content = [ OpenSSL::ASN1::Null.new(nil) ]
-    seq = OpenSSL::ASN1::Sequence.new(content, 1, :IMPLICIT)
-    encode_test B(%w{ A1 02 05 00 }), seq
-    seq2 = OpenSSL::ASN1::Sequence.new(content, 1, :IMPLICIT, :APPLICATION)
-    encode_test B(%w{ 61 02 05 00 }), seq2
-
-    content3 = [ OpenSSL::ASN1::Null.new(nil),
-                 OpenSSL::ASN1::EndOfContent.new() ]
-    seq3 = OpenSSL::ASN1::Sequence.new(content3, 1, :IMPLICIT)
-    seq3.indefinite_length = true
-    encode_test B(%w{ A1 80 05 00 00 00 }), seq3
-
-    # Special behavior: Encoding universal types with non-default 'tag'
-    # attribute and nil tagging method.
-    seq4 = OpenSSL::ASN1::Sequence.new([], 1)
-    encode_test B(%w{ 21 00 }), seq4
-  end
-
-  def test_octet_string_constructed_tagging
-    octets = [ OpenSSL::ASN1::OctetString.new('aaa') ]
-    cons = OpenSSL::ASN1::Constructive.new(octets, 0, :IMPLICIT)
-    encode_test B(%w{ A0 05 04 03 61 61 61 }), cons
-
-    octets = [ OpenSSL::ASN1::OctetString.new('aaa'),
-               OpenSSL::ASN1::EndOfContent.new() ]
-    cons = OpenSSL::ASN1::Constructive.new(octets, 0, :IMPLICIT)
-    cons.indefinite_length = true
-    encode_test B(%w{ A0 80 04 03 61 61 61 00 00 }), cons
-  end
-
-  def test_recursive_octet_string_indefinite_length
-    octets_sub1 = [ OpenSSL::ASN1::OctetString.new("\x01"),
-                    OpenSSL::ASN1::EndOfContent.new() ]
-    octets_sub2 = [ OpenSSL::ASN1::OctetString.new("\x02"),
-                    OpenSSL::ASN1::EndOfContent.new() ]
-    container1 = OpenSSL::ASN1::Constructive.new(octets_sub1, OpenSSL::ASN1::OCTET_STRING, nil, :UNIVERSAL)
-    container1.indefinite_length = true
-    container2 = OpenSSL::ASN1::Constructive.new(octets_sub2, OpenSSL::ASN1::OCTET_STRING, nil, :UNIVERSAL)
-    container2.indefinite_length = true
-    octets3 = OpenSSL::ASN1::OctetString.new("\x03")
-
-    octets = [ container1, container2, octets3,
-               OpenSSL::ASN1::EndOfContent.new() ]
-    cons = OpenSSL::ASN1::Constructive.new(octets, OpenSSL::ASN1::OCTET_STRING, nil, :UNIVERSAL)
-    cons.indefinite_length = true
-    raw = B(%w{ 24 80 24 80 04 01 01 00 00 24 80 04 01 02 00 00 04 01 03 00 00 })
-    assert_equal(raw, cons.to_der)
-    assert_equal(raw, OpenSSL::ASN1.decode(raw).to_der)
-  end
-
-  def test_recursive_octet_string_parse
-    raw = B(%w{ 24 80 24 80 04 01 01 00 00 24 80 04 01 02 00 00 04 01 03 00 00 })
-    asn1 = OpenSSL::ASN1.decode(raw)
-    assert_equal(OpenSSL::ASN1::Constructive, asn1.class)
-    assert_universal(OpenSSL::ASN1::OCTET_STRING, asn1)
-    assert_equal(true, asn1.indefinite_length)
-    assert_equal(3, asn1.value.size)
-    nested1 = asn1.value[0]
-    assert_equal(OpenSSL::ASN1::Constructive, nested1.class)
-    assert_universal(OpenSSL::ASN1::OCTET_STRING, nested1)
-    assert_equal(true, nested1.indefinite_length)
-    assert_equal(1, nested1.value.size)
-    oct1 = nested1.value[0]
-    assert_universal(OpenSSL::ASN1::OCTET_STRING, oct1)
-    assert_equal(false, oct1.indefinite_length)
-    nested2 = asn1.value[1]
-    assert_equal(OpenSSL::ASN1::Constructive, nested2.class)
-    assert_universal(OpenSSL::ASN1::OCTET_STRING, nested2)
-    assert_equal(true, nested2.indefinite_length)
-    assert_equal(1, nested2.value.size)
-    oct2 = nested2.value[0]
-    assert_universal(OpenSSL::ASN1::OCTET_STRING, oct2)
-    assert_equal(false, oct2.indefinite_length)
-    oct3 = asn1.value[2]
-    assert_universal(OpenSSL::ASN1::OCTET_STRING, oct3)
-    assert_equal(false, oct3.indefinite_length)
-  end
-
-  def test_decode_constructed_overread
-    test = %w{ 31 06 31 02 30 02 05 00 }
-    #                          ^ <- invalid
-    raw = [test.join].pack("H*")
-    ret = []
-    assert_raise(OpenSSL::ASN1::ASN1Error) {
-      OpenSSL::ASN1.traverse(raw) { |x| ret << x }
-    }
-    assert_equal 2, ret.size
-    assert_equal 17, ret[0][6]
-    assert_equal 17, ret[1][6]
-
-    test = %w{ 31 80 30 03 00 00 }
-    #                    ^ <- invalid
-    raw = [test.join].pack("H*")
-    ret = []
-    assert_raise(OpenSSL::ASN1::ASN1Error) {
-      OpenSSL::ASN1.traverse(raw) { |x| ret << x }
-    }
-    assert_equal 1, ret.size
-    assert_equal 17, ret[0][6]
-  end
-
-  def test_constructive_each
-    data = [OpenSSL::ASN1::Integer.new(0), OpenSSL::ASN1::Integer.new(1)]
-    seq = OpenSSL::ASN1::Sequence.new data
-
-    assert_equal data, seq.entries
-  end
-
-  # Very time consuming test.
-  # def test_gc_stress
-  #   assert_ruby_status(['--disable-gems', '-eGC.stress=true', '-erequire "openssl.so"'])
-  # end
-
-  private
-
-  def B(ary)
-    [ary.join].pack("H*")
-  end
-
-  def assert_asn1_equal(a, b)
-    assert_equal a.class, b.class
-    assert_equal a.tag, b.tag
-    assert_equal a.tag_class, b.tag_class
-    assert_equal a.indefinite_length, b.indefinite_length
-    assert_equal a.unused_bits, b.unused_bits if a.respond_to?(:unused_bits)
-    case a.value
-    when Array
-      a.value.each_with_index { |ai, i|
-        assert_asn1_equal ai, b.value[i]
-      }
-    else
-      if OpenSSL::ASN1::ObjectId === a
-        assert_equal a.oid, b.oid
-      else
-        assert_equal a.value, b.value
-      end
-    end
-    assert_equal a.to_der, b.to_der
-  end
-
-  def encode_test(der, obj)
-    assert_equal der, obj.to_der
-  end
-
-  def decode_test(der, obj)
-    decoded = OpenSSL::ASN1.decode(der)
-    assert_asn1_equal obj, decoded
-    decoded
-  end
-
-  def encode_decode_test(der, obj)
-    encode_test(der, obj)
-    decode_test(der, obj)
-  end
-
-  def assert_universal(tag, asn1)
-    assert_equal(tag, asn1.tag)
-    if asn1.respond_to?(:tagging)
-      assert_nil(asn1.tagging)
-    end
-    assert_equal(:UNIVERSAL, asn1.tag_class)
-  end
-end
-
-end
diff --git a/test/openssl/test_bn.rb b/test/openssl/test_bn.rb
deleted file mode 100644
index 547d334..0000000
--- a/test/openssl/test_bn.rb
+++ /dev/null
@@ -1,286 +0,0 @@
-# coding: us-ascii
-# frozen_string_literal: true
-require_relative 'utils'
-require "prime"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestBN < OpenSSL::TestCase
-  def setup
-    super
-    @e1 = OpenSSL::BN.new(999.to_s(16), 16) # OpenSSL::BN.new(str, 16) must be most stable
-    @e2 = OpenSSL::BN.new("-" + 999.to_s(16), 16)
-    @e3 = OpenSSL::BN.new((2**107-1).to_s(16), 16)
-    @e4 = OpenSSL::BN.new("-" + (2**107-1).to_s(16), 16)
-  end
-
-  def test_new
-    assert_raise(ArgumentError) { OpenSSL::BN.new }
-    assert_raise(ArgumentError) { OpenSSL::BN.new(nil) }
-    assert_raise(ArgumentError) { OpenSSL::BN.new(nil, 2) }
-
-    assert_equal(@e1, OpenSSL::BN.new("999"))
-    assert_equal(@e1, OpenSSL::BN.new("999", 10))
-    assert_equal(@e1, OpenSSL::BN.new("\x03\xE7", 2))
-    assert_equal(@e1, OpenSSL::BN.new("\x00\x00\x00\x02\x03\xE7", 0))
-    assert_equal(@e2, OpenSSL::BN.new("-999"))
-    assert_equal(@e2, OpenSSL::BN.new("-999", 10))
-    assert_equal(@e2, OpenSSL::BN.new("\x00\x00\x00\x02\x83\xE7", 0))
-    assert_equal(@e3, OpenSSL::BN.new((2**107-1).to_s))
-    assert_equal(@e3, OpenSSL::BN.new((2**107-1).to_s, 10))
-    assert_equal(@e3, OpenSSL::BN.new("\a\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 2))
-    assert_equal(@e3, OpenSSL::BN.new("\x00\x00\x00\x0E\a\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 0))
-    assert_equal(@e4, OpenSSL::BN.new("-" + (2**107-1).to_s))
-    assert_equal(@e4, OpenSSL::BN.new("-" + (2**107-1).to_s, 10))
-    assert_equal(@e4, OpenSSL::BN.new("\x00\x00\x00\x0E\x87\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 0))
-
-    e1copy = OpenSSL::BN.new(@e1)
-    assert_equal(@e1, e1copy)
-    e1copy.clear_bit!(0) #=> 998
-    assert_not_equal(@e1, e1copy)
-
-    assert_equal(@e1, OpenSSL::BN.new(999))
-    assert_equal(@e2, OpenSSL::BN.new(-999))
-    assert_equal(@e3, OpenSSL::BN.new(2**107-1))
-    assert_equal(@e4, OpenSSL::BN.new(-(2**107-1)))
-
-    assert_equal(@e1, 999.to_bn)
-    assert_equal(@e2, -999.to_bn)
-    assert_equal(@e3, (2**107-1).to_bn)
-    assert_equal(@e4, (-(2**107-1)).to_bn)
-  end
-
-  def test_to_str
-    assert_equal("999", @e1.to_s(10))
-    assert_equal("-999", @e2.to_s(10))
-    assert_equal((2**107-1).to_s, @e3.to_s(10))
-    assert_equal((-(2**107-1)).to_s, @e4.to_s(10))
-    assert_equal("999", @e1.to_s)
-
-    assert_equal("03E7", @e1.to_s(16))
-    assert_equal("-03E7", @e2.to_s(16))
-    assert_equal("07FFFFFFFFFFFFFFFFFFFFFFFFFF", @e3.to_s(16))
-    assert_equal("-07FFFFFFFFFFFFFFFFFFFFFFFFFF", @e4.to_s(16))
-
-    assert_equal("\x03\xe7", @e1.to_s(2))
-    assert_equal("\x03\xe7", @e2.to_s(2))
-    assert_equal("\x07\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff", @e3.to_s(2))
-    assert_equal("\x07\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff", @e4.to_s(2))
-
-    assert_equal("\x00\x00\x00\x02\x03\xe7", @e1.to_s(0))
-    assert_equal("\x00\x00\x00\x02\x83\xe7", @e2.to_s(0))
-    assert_equal("\x00\x00\x00\x0e\x07\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff", @e3.to_s(0))
-    assert_equal("\x00\x00\x00\x0e\x87\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff", @e4.to_s(0))
-  end
-
-  def test_to_int
-    assert_equal(999, @e1.to_i)
-    assert_equal(-999, @e2.to_i)
-    assert_equal(2**107-1, @e3.to_i)
-    assert_equal(-(2**107-1), @e4.to_i)
-
-    assert_equal(999, @e1.to_int)
-  end
-
-  def test_coerce
-    assert_equal(["", "-999"], @e2.coerce(""))
-    assert_equal([1000, -999], @e2.coerce(1000))
-    assert_raise(TypeError) { @e2.coerce(Class.new.new) }
-  end
-
-  def test_zero_p
-    assert_equal(true, 0.to_bn.zero?)
-    assert_equal(false, 1.to_bn.zero?)
-  end
-
-  def test_one_p
-    assert_equal(true, 1.to_bn.one?)
-    assert_equal(false, 2.to_bn.one?)
-  end
-
-  def test_odd_p
-    assert_equal(true, 1.to_bn.odd?)
-    assert_equal(false, 2.to_bn.odd?)
-  end
-
-  def test_negative_p
-    assert_equal(false, 0.to_bn.negative?)
-    assert_equal(false, @e1.negative?)
-    assert_equal(true, @e2.negative?)
-  end
-
-  def test_sqr
-    assert_equal(1, 1.to_bn.sqr)
-    assert_equal(100, 10.to_bn.sqr)
-  end
-
-  def test_four_ops
-    assert_equal(3, 1.to_bn + 2)
-    assert_equal(-1, 1.to_bn + -2)
-    assert_equal(-1, 1.to_bn - 2)
-    assert_equal(3, 1.to_bn - -2)
-    assert_equal(2, 1.to_bn * 2)
-    assert_equal(-2, 1.to_bn * -2)
-    assert_equal([0, 1], 1.to_bn / 2)
-    assert_equal([2, 0], 2.to_bn / 1)
-    assert_raise(OpenSSL::BNError) { 1.to_bn / 0 }
-  end
-
-  def test_unary_plus_minus
-    assert_equal(999, +@e1)
-    assert_equal(-999, +@e2)
-    assert_equal(-999, -@e1)
-    assert_equal(+999, -@e2)
-  end
-
-  def test_mod
-    assert_equal(1, 1.to_bn % 2)
-    assert_equal(0, 2.to_bn % 1)
-    assert_equal(-2, -2.to_bn % 7)
-  end
-
-  def test_exp
-    assert_equal(1, 1.to_bn ** 5)
-    assert_equal(32, 2.to_bn ** 5)
-  end
-
-  def test_gcd
-    assert_equal(1, 7.to_bn.gcd(5))
-    assert_equal(8, 24.to_bn.gcd(16))
-  end
-
-  def test_mod_sqr
-    assert_equal(4, 3.to_bn.mod_sqr(5))
-    assert_equal(0, 59.to_bn.mod_sqr(59))
-  end
-
-  def test_mod_inverse
-    assert_equal(2, 3.to_bn.mod_inverse(5))
-    assert_raise(OpenSSL::BNError) { 3.to_bn.mod_inverse(6) }
-  end
-
-  def test_mod_add
-    assert_equal(1, 3.to_bn.mod_add(5, 7))
-    assert_equal(2, 3.to_bn.mod_add(5, 3))
-    assert_equal(5, 3.to_bn.mod_add(-5, 7))
-  end
-
-  def test_mod_sub
-    assert_equal(1, 11.to_bn.mod_sub(3, 7))
-    assert_equal(2, 11.to_bn.mod_sub(3, 3))
-    assert_equal(5, 3.to_bn.mod_sub(5, 7))
-  end
-
-  def test_mod_mul
-    assert_equal(1, 2.to_bn.mod_mul(4, 7))
-    assert_equal(5, 2.to_bn.mod_mul(-1, 7))
-  end
-
-  def test_mod_exp
-    assert_equal(1, 3.to_bn.mod_exp(2, 8))
-    assert_equal(4, 2.to_bn.mod_exp(5, 7))
-  end
-
-  def test_bit_operations
-    e = 0b10010010.to_bn
-    assert_equal(0b10010011, e.set_bit!(0))
-    assert_equal(0b10010011, e.set_bit!(1))
-    assert_equal(0b1010010011, e.set_bit!(9))
-
-    e = 0b10010010.to_bn
-    assert_equal(0b10010010, e.clear_bit!(0))
-    assert_equal(0b10010000, e.clear_bit!(1))
-
-    e = 0b10010010.to_bn
-    assert_equal(0b10010010, e.mask_bits!(8))
-    assert_equal(0b10, e.mask_bits!(3))
-
-    e = 0b10010010.to_bn
-    assert_equal(false, e.bit_set?(0))
-    assert_equal(true, e.bit_set?(1))
-    assert_equal(false, e.bit_set?(1000))
-
-    e = 0b10010010.to_bn
-    assert_equal(0b1001001000, e << 2)
-    assert_equal(0b10010010, e)
-    assert_equal(0b1001001000, e.lshift!(2))
-    assert_equal(0b1001001000, e)
-
-    e = 0b10010010.to_bn
-    assert_equal(0b100100, e >> 2)
-    assert_equal(0b10010010, e)
-    assert_equal(0b100100, e.rshift!(2))
-    assert_equal(0b100100, e)
-  end
-
-  def test_random
-    10.times {
-      r1 = OpenSSL::BN.rand(8)
-      assert_include(128..255, r1)
-      r2 = OpenSSL::BN.rand(8, -1)
-      assert_include(0..255, r2)
-      r3 = OpenSSL::BN.rand(8, 1)
-      assert_include(192..255, r3)
-      r4 = OpenSSL::BN.rand(8, 1, true)
-      assert_include(192..255, r4)
-      assert_equal(true, r4.odd?)
-
-      r5 = OpenSSL::BN.rand_range(256)
-      assert_include(0..255, r5)
-    }
-  end
-
-  def test_prime
-    p1 = OpenSSL::BN.generate_prime(32)
-    assert_include(0...2**32, p1)
-    assert_equal(true, Prime.prime?(p1.to_i))
-    p2 = OpenSSL::BN.generate_prime(32, true)
-    assert_equal(true, Prime.prime?((p2.to_i - 1) / 2))
-    p3 = OpenSSL::BN.generate_prime(32, false, 4)
-    assert_equal(1, p3 % 4)
-    p4 = OpenSSL::BN.generate_prime(32, false, 4, 3)
-    assert_equal(3, p4 % 4)
-
-    assert_equal(true, p1.prime?)
-    assert_equal(true, p2.prime?)
-    assert_equal(true, p3.prime?)
-    assert_equal(true, p4.prime?)
-    assert_equal(true, @e3.prime?)
-    assert_equal(true, @e3.prime_fasttest?)
-  end
-
-  def test_num_bits_bytes
-    assert_equal(10, @e1.num_bits)
-    assert_equal(2, @e1.num_bytes)
-    assert_equal(107, @e3.num_bits)
-    assert_equal(14, @e3.num_bytes)
-    assert_equal(0, 0.to_bn.num_bits)
-    assert_equal(0, 0.to_bn.num_bytes)
-    assert_equal(9, -256.to_bn.num_bits)
-    assert_equal(2, -256.to_bn.num_bytes)
-  end
-
-  def test_comparison
-    assert_equal(false, @e1 == nil)
-    assert_equal(false, @e1 == -999)
-    assert_equal(true, @e1 == 999)
-    assert_equal(true, @e1 == 999.to_bn)
-    assert_equal(false, @e1.eql?(nil))
-    assert_equal(false, @e1.eql?(999))
-    assert_equal(true, @e1.eql?(999.to_bn))
-    assert_equal(@e1.hash, 999.to_bn.hash)
-    assert_not_equal(@e1.hash, @e3.hash)
-    assert_equal(0, @e1.cmp(999))
-    assert_equal(1, @e1.cmp(-999))
-    assert_equal(0, @e1.ucmp(999))
-    assert_equal(0, @e1.ucmp(-999))
-    assert_instance_of(String, @e1.hash.to_s)
-  end
-
-  def test_argument_error
-    bug15760 = '[ruby-core:92231] [Bug #15760]'
-    assert_raise(ArgumentError, bug15760) { OpenSSL::BN.new(nil, 2) }
-  end
-end
-
-end
diff --git a/test/openssl/test_buffering.rb b/test/openssl/test_buffering.rb
deleted file mode 100644
index 7575c5b..0000000
--- a/test/openssl/test_buffering.rb
+++ /dev/null
@@ -1,97 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestBuffering < OpenSSL::TestCase
-  class IO
-    include OpenSSL::Buffering
-
-    attr_accessor :sync
-
-    def initialize
-      @io = Buffer.new
-      def @io.sync
-        true
-      end
-
-      super
-
-      @sync = false
-    end
-
-    def string
-      @io
-    end
-
-    def sysread(size)
-      str = @io.slice!(0, size)
-      raise EOFError if str.empty?
-      str
-    end
-
-    def syswrite(str)
-      @io << str
-      str.size
-    end
-  end
-
-  def setup
-    super
-    @io = IO.new
-  end
-
-  def test_encoding
-    @io.write '😊'
-    @io.flush
-
-    assert_equal @io.string.encoding, Encoding::BINARY
-  end
-
-  def test_flush
-    @io.write 'a'
-
-    assert_not_predicate @io, :sync
-    assert_empty @io.string
-
-    assert_equal @io, @io.flush
-
-    assert_not_predicate @io, :sync
-    assert_equal 'a', @io.string
-  end
-
-  def test_flush_error
-    @io.write 'a'
-
-    assert_not_predicate @io, :sync
-    assert_empty @io.string
-
-    def @io.syswrite *a
-      raise SystemCallError, 'fail'
-    end
-
-    assert_raise SystemCallError do
-      @io.flush
-    end
-
-    assert_not_predicate @io, :sync, 'sync must not change'
-  end
-
-  def test_getc
-    @io.syswrite('abc')
-    assert_equal(?a, @io.getc)
-    assert_equal(?b, @io.getc)
-    assert_equal(?c, @io.getc)
-  end
-
-  def test_each_byte
-    @io.syswrite('abc')
-    res = []
-    @io.each_byte do |c|
-      res << c
-    end
-    assert_equal([97, 98, 99], res)
-  end
-end
-
-end
diff --git a/test/openssl/test_cipher.rb b/test/openssl/test_cipher.rb
deleted file mode 100644
index ef8c4f3..0000000
--- a/test/openssl/test_cipher.rb
+++ /dev/null
@@ -1,388 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestCipher < OpenSSL::TestCase
-  module Helper
-    def has_cipher?(name)
-      @ciphers ||= OpenSSL::Cipher.ciphers
-      @ciphers.include?(name)
-    end
-  end
-  include Helper
-  extend Helper
-
-  def test_encrypt_decrypt
-    # NIST SP 800-38A F.2.1
-    key = ["2b7e151628aed2a6abf7158809cf4f3c"].pack("H*")
-    iv =  ["000102030405060708090a0b0c0d0e0f"].pack("H*")
-    pt =  ["6bc1bee22e409f96e93d7e117393172a" \
-           "ae2d8a571e03ac9c9eb76fac45af8e51"].pack("H*")
-    ct =  ["7649abac8119b246cee98e9b12e9197d" \
-           "5086cb9b507219ee95db113a917678b2"].pack("H*")
-    cipher = new_encryptor("aes-128-cbc", key: key, iv: iv, padding: 0)
-    assert_equal ct, cipher.update(pt) << cipher.final
-    cipher = new_decryptor("aes-128-cbc", key: key, iv: iv, padding: 0)
-    assert_equal pt, cipher.update(ct) << cipher.final
-  end
-
-  def test_pkcs5_keyivgen
-    pass = "\x00" * 8
-    salt = "\x01" * 8
-    num = 2048
-    pt = "data to be encrypted"
-    cipher = OpenSSL::Cipher.new("DES-EDE3-CBC").encrypt
-    cipher.pkcs5_keyivgen(pass, salt, num, "MD5")
-    s1 = cipher.update(pt) << cipher.final
-
-    d1 = num.times.inject(pass + salt) {|out, _| OpenSSL::Digest.digest('MD5', out) }
-    d2 = num.times.inject(d1 + pass + salt) {|out, _| OpenSSL::Digest.digest('MD5', out) }
-    key = (d1 + d2)[0, 24]
-    iv = (d1 + d2)[24, 8]
-    cipher = new_encryptor("DES-EDE3-CBC", key: key, iv: iv)
-    s2 = cipher.update(pt) << cipher.final
-
-    assert_equal s1, s2
-
-    cipher2 = OpenSSL::Cipher.new("DES-EDE3-CBC").encrypt
-    assert_raise(ArgumentError) { cipher2.pkcs5_keyivgen(pass, salt, -1, "MD5") }
-  end
-
-  def test_info
-    cipher = OpenSSL::Cipher.new("DES-EDE3-CBC").encrypt
-    assert_equal "DES-EDE3-CBC", cipher.name
-    assert_equal 24, cipher.key_len
-    assert_equal 8, cipher.iv_len
-  end
-
-  def test_dup
-    cipher = OpenSSL::Cipher.new("aes-128-cbc").encrypt
-    assert_equal cipher.name, cipher.dup.name
-    cipher.encrypt
-    cipher.random_key
-    cipher.random_iv
-    tmpc = cipher.dup
-    s1 = cipher.update("data") + cipher.final
-    s2 = tmpc.update("data") + tmpc.final
-    assert_equal(s1, s2, "encrypt dup")
-  end
-
-  def test_reset
-    cipher = OpenSSL::Cipher.new("aes-128-cbc").encrypt
-    cipher.encrypt
-    cipher.random_key
-    cipher.random_iv
-    s1 = cipher.update("data") + cipher.final
-    cipher.reset
-    s2 = cipher.update("data") + cipher.final
-    assert_equal(s1, s2, "encrypt reset")
-  end
-
-  def test_key_iv_set
-    cipher = OpenSSL::Cipher.new("DES-EDE3-CBC").encrypt
-    assert_raise(ArgumentError) { cipher.key = "\x01" * 23 }
-    assert_nothing_raised { cipher.key = "\x01" * 24 }
-    assert_raise(ArgumentError) { cipher.key = "\x01" * 25 }
-    assert_raise(ArgumentError) { cipher.iv = "\x01" * 7 }
-    assert_nothing_raised { cipher.iv = "\x01" * 8 }
-    assert_raise(ArgumentError) { cipher.iv = "\x01" * 9 }
-  end
-
-  def test_random_key_iv
-    data = "data"
-    s1, s2 = 2.times.map do
-      cipher = OpenSSL::Cipher.new("aes-128-cbc").encrypt
-      cipher.random_key
-      cipher.iv = "\x01" * 16
-      cipher.update(data) << cipher.final
-    end
-    assert_not_equal s1, s2
-
-    s1, s2 = 2.times.map do
-      cipher = OpenSSL::Cipher.new("aes-128-cbc").encrypt
-      cipher.key = "\x01" * 16
-      cipher.random_iv
-      cipher.update(data) << cipher.final
-    end
-    assert_not_equal s1, s2
-  end
-
-  def test_empty_data
-    cipher = OpenSSL::Cipher.new("DES-EDE3-CBC").encrypt
-    cipher.random_key
-    assert_raise(ArgumentError) { cipher.update("") }
-  end
-
-  def test_initialize
-    cipher = OpenSSL::Cipher.new("DES-EDE3-CBC")
-    assert_raise(RuntimeError) { cipher.__send__(:initialize, "DES-EDE3-CBC") }
-    assert_raise(RuntimeError) { OpenSSL::Cipher.allocate.final }
-  end
-
-  def test_ctr_if_exists
-    # NIST SP 800-38A F.5.1
-    key = ["2b7e151628aed2a6abf7158809cf4f3c"].pack("H*")
-    iv =  ["f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff"].pack("H*")
-    pt =  ["6bc1bee22e409f96e93d7e117393172a" \
-           "ae2d8a571e03ac9c9eb76fac45af8e51"].pack("H*")
-    ct =  ["874d6191b620e3261bef6864990db6ce" \
-           "9806f66b7970fdff8617187bb9fffdff"].pack("H*")
-    cipher = new_encryptor("aes-128-ctr", key: key, iv: iv, padding: 0)
-    assert_equal ct, cipher.update(pt) << cipher.final
-    cipher = new_decryptor("aes-128-ctr", key: key, iv: iv, padding: 0)
-    assert_equal pt, cipher.update(ct) << cipher.final
-  end
-
-  def test_ciphers
-    OpenSSL::Cipher.ciphers.each{|name|
-      next if /netbsd/ =~ RUBY_PLATFORM && /idea|rc5/i =~ name
-      begin
-        assert_kind_of(OpenSSL::Cipher, OpenSSL::Cipher.new(name))
-      rescue OpenSSL::Cipher::CipherError => e
-        raise unless /wrap/ =~ name and /wrap mode not allowed/ =~ e.message
-      end
-    }
-  end
-
-  def test_AES
-    pt = File.read(__FILE__)
-    %w(ECB CBC CFB OFB).each{|mode|
-      c1 = OpenSSL::Cipher.new("AES-256-#{mode}")
-      c1.encrypt
-      c1.pkcs5_keyivgen("passwd")
-      ct = c1.update(pt) + c1.final
-
-      c2 = OpenSSL::Cipher.new("AES-256-#{mode}")
-      c2.decrypt
-      c2.pkcs5_keyivgen("passwd")
-      assert_equal(pt, c2.update(ct) + c2.final)
-    }
-  end
-
-  def test_update_raise_if_key_not_set
-    assert_raise(OpenSSL::Cipher::CipherError) do
-      # it caused OpenSSL SEGV by uninitialized key [Bug #2768]
-      OpenSSL::Cipher.new("AES-128-ECB").update "." * 17
-    end
-  end
-
-  def test_authenticated
-    cipher = OpenSSL::Cipher.new('aes-128-gcm')
-    assert_predicate(cipher, :authenticated?)
-    cipher = OpenSSL::Cipher.new('aes-128-cbc')
-    assert_not_predicate(cipher, :authenticated?)
-  end
-
-  def test_aes_ccm
-    # RFC 3610 Section 8, Test Case 1
-    key = ["c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"].pack("H*")
-    iv =  ["00000003020100a0a1a2a3a4a5"].pack("H*")
-    aad = ["0001020304050607"].pack("H*")
-    pt =  ["08090a0b0c0d0e0f101112131415161718191a1b1c1d1e"].pack("H*")
-    ct =  ["588c979a61c663d2f066d0c2c0f989806d5f6b61dac384"].pack("H*")
-    tag = ["17e8d12cfdf926e0"].pack("H*")
-
-    kwargs = {auth_tag_len: 8, iv_len: 13, key: key, iv: iv}
-    cipher = new_encryptor("aes-128-ccm", **kwargs, ccm_data_len: pt.length, auth_data: aad)
-    assert_equal ct, cipher.update(pt) << cipher.final
-    assert_equal tag, cipher.auth_tag
-    cipher = new_decryptor("aes-128-ccm", **kwargs, ccm_data_len: ct.length, auth_tag: tag, auth_data: aad)
-    assert_equal pt, cipher.update(ct) << cipher.final
-
-    # truncated tag is accepted
-    cipher = new_encryptor("aes-128-ccm", **kwargs, ccm_data_len: pt.length, auth_data: aad)
-    assert_equal ct, cipher.update(pt) << cipher.final
-    assert_equal tag[0, 8], cipher.auth_tag(8)
-    cipher = new_decryptor("aes-128-ccm", **kwargs, ccm_data_len: ct.length, auth_tag: tag[0, 8], auth_data: aad)
-    assert_equal pt, cipher.update(ct) << cipher.final
-
-    # wrong tag is rejected
-    tag2 = tag.dup
-    tag2.setbyte(-1, (tag2.getbyte(-1) + 1) & 0xff)
-    cipher = new_decryptor("aes-128-ccm", **kwargs, ccm_data_len: ct.length, auth_tag: tag2, auth_data: aad)
-    assert_raise(OpenSSL::Cipher::CipherError) { cipher.update(ct) }
-
-    # wrong aad is rejected
-    aad2 = aad[0..-2] << aad[-1].succ
-    cipher = new_decryptor("aes-128-ccm", **kwargs, ccm_data_len: ct.length, auth_tag: tag, auth_data: aad2)
-    assert_raise(OpenSSL::Cipher::CipherError) { cipher.update(ct) }
-
-    # wrong ciphertext is rejected
-    ct2 = ct[0..-2] << ct[-1].succ
-    cipher = new_decryptor("aes-128-ccm", **kwargs, ccm_data_len: ct2.length, auth_tag: tag, auth_data: aad)
-    assert_raise(OpenSSL::Cipher::CipherError) { cipher.update(ct2) }
-  rescue OpenSSL::Cipher::CipherError
-    if /mingw/i =~ RUBY_PLATFORM
-      omit "skip on OpenSSL::Cipher::CipherError from 'ccm_data_len=': Maybe it's because of OpenSSL in MinGW"
-    else
-      raise
-    end
-  end if has_cipher?("aes-128-ccm") &&
-         OpenSSL::Cipher.new("aes-128-ccm").authenticated? &&
-         OpenSSL::OPENSSL_VERSION_NUMBER >= 0x1010103f # version >= 1.1.1c
-
-  def test_aes_gcm
-    # GCM spec Appendix B Test Case 4
-    key = ["feffe9928665731c6d6a8f9467308308"].pack("H*")
-    iv =  ["cafebabefacedbaddecaf888"].pack("H*")
-    aad = ["feedfacedeadbeeffeedfacedeadbeef" \
-           "abaddad2"].pack("H*")
-    pt =  ["d9313225f88406e5a55909c5aff5269a" \
-           "86a7a9531534f7da2e4c303d8a318a72" \
-           "1c3c0c95956809532fcf0e2449a6b525" \
-           "b16aedf5aa0de657ba637b39"].pack("H*")
-    ct =  ["42831ec2217774244b7221b784d0d49c" \
-           "e3aa212f2c02a4e035c17e2329aca12e" \
-           "21d514b25466931c7d8f6a5aac84aa05" \
-           "1ba30b396a0aac973d58e091"].pack("H*")
-    tag = ["5bc94fbc3221a5db94fae95ae7121a47"].pack("H*")
-
-    cipher = new_encryptor("aes-128-gcm", key: key, iv: iv, auth_data: aad)
-    assert_equal ct, cipher.update(pt) << cipher.final
-    assert_equal tag, cipher.auth_tag
-    cipher = new_decryptor("aes-128-gcm", key: key, iv: iv, auth_tag: tag, auth_data: aad)
-    assert_equal pt, cipher.update(ct) << cipher.final
-
-    # truncated tag is accepted
-    cipher = new_encryptor("aes-128-gcm", key: key, iv: iv, auth_data: aad)
-    assert_equal ct, cipher.update(pt) << cipher.final
-    assert_equal tag[0, 8], cipher.auth_tag(8)
-    cipher = new_decryptor("aes-128-gcm", key: key, iv: iv, auth_tag: tag[0, 8], auth_data: aad)
-    assert_equal pt, cipher.update(ct) << cipher.final
-
-    # wrong tag is rejected
-    tag2 = tag.dup
-    tag2.setbyte(-1, (tag2.getbyte(-1) + 1) & 0xff)
-    cipher = new_decryptor("aes-128-gcm", key: key, iv: iv, auth_tag: tag2, auth_data: aad)
-    cipher.update(ct)
-    assert_raise(OpenSSL::Cipher::CipherError) { cipher.final }
-
-    # wrong aad is rejected
-    aad2 = aad[0..-2] << aad[-1].succ
-    cipher = new_decryptor("aes-128-gcm", key: key, iv: iv, auth_tag: tag, auth_data: aad2)
-    cipher.update(ct)
-    assert_raise(OpenSSL::Cipher::CipherError) { cipher.final }
-
-    # wrong ciphertext is rejected
-    ct2 = ct[0..-2] << ct[-1].succ
-    cipher = new_decryptor("aes-128-gcm", key: key, iv: iv, auth_tag: tag, auth_data: aad)
-    cipher.update(ct2)
-    assert_raise(OpenSSL::Cipher::CipherError) { cipher.final }
-  end
-
-  def test_aes_gcm_variable_iv_len
-    # GCM spec Appendix B Test Case 5
-    key = ["feffe9928665731c6d6a8f9467308308"].pack("H*")
-    iv  = ["cafebabefacedbad"].pack("H*")
-    aad = ["feedfacedeadbeeffeedfacedeadbeef" \
-           "abaddad2"].pack("H*")
-    pt =  ["d9313225f88406e5a55909c5aff5269a" \
-           "86a7a9531534f7da2e4c303d8a318a72" \
-           "1c3c0c95956809532fcf0e2449a6b525" \
-           "b16aedf5aa0de657ba637b39"].pack("H*")
-    ct =  ["61353b4c2806934a777ff51fa22a4755" \
-           "699b2a714fcdc6f83766e5f97b6c7423" \
-           "73806900e49f24b22b097544d4896b42" \
-           "4989b5e1ebac0f07c23f4598"].pack("H*")
-    tag = ["3612d2e79e3b0785561be14aaca2fccb"].pack("H*")
-
-    cipher = new_encryptor("aes-128-gcm", key: key, iv_len: 8, iv: iv, auth_data: aad)
-    assert_equal ct, cipher.update(pt) << cipher.final
-    assert_equal tag, cipher.auth_tag
-    cipher = new_decryptor("aes-128-gcm", key: key, iv_len: 8, iv: iv, auth_tag: tag, auth_data: aad)
-    assert_equal pt, cipher.update(ct) << cipher.final
-  end
-
-  def test_aes_ocb_tag_len
-    # RFC 7253 Appendix A; the second sample
-    key = ["000102030405060708090A0B0C0D0E0F"].pack("H*")
-    iv  = ["BBAA99887766554433221101"].pack("H*")
-    aad = ["0001020304050607"].pack("H*")
-    pt =  ["0001020304050607"].pack("H*")
-    ct =  ["6820B3657B6F615A"].pack("H*")
-    tag = ["5725BDA0D3B4EB3A257C9AF1F8F03009"].pack("H*")
-
-    cipher = new_encryptor("aes-128-ocb", key: key, iv: iv, auth_data: aad)
-    assert_equal ct, cipher.update(pt) << cipher.final
-    assert_equal tag, cipher.auth_tag
-    cipher = new_decryptor("aes-128-ocb", key: key, iv: iv, auth_tag: tag, auth_data: aad)
-    assert_equal pt, cipher.update(ct) << cipher.final
-
-    # RFC 7253 Appendix A; with 96 bits tag length
-    key = ["0F0E0D0C0B0A09080706050403020100"].pack("H*")
-    iv  = ["BBAA9988776655443322110D"].pack("H*")
-    aad = ["000102030405060708090A0B0C0D0E0F1011121314151617" \
-           "18191A1B1C1D1E1F2021222324252627"].pack("H*")
-    pt =  ["000102030405060708090A0B0C0D0E0F1011121314151617" \
-           "18191A1B1C1D1E1F2021222324252627"].pack("H*")
-    ct =  ["1792A4E31E0755FB03E31B22116E6C2DDF9EFD6E33D536F1" \
-           "A0124B0A55BAE884ED93481529C76B6A"].pack("H*")
-    tag = ["D0C515F4D1CDD4FDAC4F02AA"].pack("H*")
-
-    cipher = new_encryptor("aes-128-ocb", auth_tag_len: 12, key: key, iv: iv, auth_data: aad)
-    assert_equal ct, cipher.update(pt) << cipher.final
-    assert_equal tag, cipher.auth_tag
-    cipher = new_decryptor("aes-128-ocb", auth_tag_len: 12, key: key, iv: iv, auth_tag: tag, auth_data: aad)
-    assert_equal pt, cipher.update(ct) << cipher.final
-
-  end if has_cipher?("aes-128-ocb")
-
-  def test_aes_gcm_key_iv_order_issue
-    pt = "[ruby/openssl#49]"
-    cipher = OpenSSL::Cipher.new("aes-128-gcm").encrypt
-    cipher.key = "x" * 16
-    cipher.iv = "a" * 12
-    ct1 = cipher.update(pt) << cipher.final
-    tag1 = cipher.auth_tag
-
-    cipher = OpenSSL::Cipher.new("aes-128-gcm").encrypt
-    cipher.iv = "a" * 12
-    cipher.key = "x" * 16
-    ct2 = cipher.update(pt) << cipher.final
-    tag2 = cipher.auth_tag
-
-    assert_equal ct1, ct2
-    assert_equal tag1, tag2
-  end
-
-  def test_non_aead_cipher_set_auth_data
-    assert_raise(OpenSSL::Cipher::CipherError) {
-      cipher = OpenSSL::Cipher.new("aes-128-cfb").encrypt
-      cipher.auth_data = "123"
-    }
-  end
-
-  def test_crypt_after_key
-    key = ["2b7e151628aed2a6abf7158809cf4f3c"].pack("H*")
-    %w'ecb cbc cfb ctr gcm'.each do |c|
-      cipher = OpenSSL::Cipher.new("aes-128-#{c}")
-      cipher.key = key
-      cipher.encrypt
-      assert_raise(OpenSSL::Cipher::CipherError) { cipher.update("") }
-
-      cipher = OpenSSL::Cipher.new("aes-128-#{c}")
-      cipher.key = key
-      cipher.decrypt
-      assert_raise(OpenSSL::Cipher::CipherError) { cipher.update("") }
-    end
-  end
-
-  private
-
-  def new_encryptor(algo, **kwargs)
-    OpenSSL::Cipher.new(algo).tap do |cipher|
-      cipher.encrypt
-      kwargs.each {|k, v| cipher.send(:"#{k}=", v) }
-    end
-  end
-
-  def new_decryptor(algo, **kwargs)
-    OpenSSL::Cipher.new(algo).tap do |cipher|
-      cipher.decrypt
-      kwargs.each {|k, v| cipher.send(:"#{k}=", v) }
-    end
-  end
-end
-
-end
diff --git a/test/openssl/test_config.rb b/test/openssl/test_config.rb
deleted file mode 100644
index e041c1a..0000000
--- a/test/openssl/test_config.rb
+++ /dev/null
@@ -1,374 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestConfig < OpenSSL::TestCase
-  def setup
-    super
-    file = Tempfile.open("openssl.cnf")
-    file << <<__EOD__
-HOME = .
-[ ca ]
-default_ca = CA_default
-[ CA_default ]
-dir = ./demoCA
-certs                =                  ./certs
-__EOD__
-    file.close
-    @tmpfile = file
-    @it = OpenSSL::Config.new(file.path)
-  end
-
-  def teardown
-    super
-    @tmpfile.close!
-  end
-
-  def test_constants
-    assert(defined?(OpenSSL::Config::DEFAULT_CONFIG_FILE))
-    config_file = OpenSSL::Config::DEFAULT_CONFIG_FILE
-    pend "DEFAULT_CONFIG_FILE may return a wrong path on your platforms. [Bug #6830]" unless File.readable?(config_file)
-    assert_nothing_raised do
-      OpenSSL::Config.load(config_file)
-    end
-  end
-
-  def test_s_parse
-    c = OpenSSL::Config.parse('')
-    assert_equal("[ default ]\n\n", c.to_s)
-    c = OpenSSL::Config.parse(@it.to_s)
-    assert_equal(['CA_default', 'ca', 'default'], c.sections.sort)
-  end
-
-  def test_s_parse_format
-    c = OpenSSL::Config.parse(<<__EOC__)
- baz =qx\t                # "baz = qx"
-
-foo::bar = baz            # shortcut section::key format
-  default::bar = baz      # ditto
-a=\t \t                   # "a = ": trailing spaces are ignored
- =b                       # " = b": empty key
- =c                       # " = c": empty key (override the above line)
-    d=                    # "c = ": trailing comment is ignored
-
-sq = 'foo''b\\'ar'
-    dq ="foo""''\\""
-    dq2 = foo""bar
-esc=a\\r\\n\\b\\tb
-foo\\bar = foo\\b\\\\ar
-foo\\bar::foo\\bar = baz
-[default1  default2]\t\t  # space is allowed in section name
-          fo =b  ar       # space allowed in value
-[emptysection]
- [dollar ]
-foo=bar
-bar = $(foo)
-baz = 123$(default::bar)456${foo}798
-qux = ${baz}
-quxx = $qux.$qux
-__EOC__
-    assert_equal(['default', 'default1  default2', 'dollar', 'emptysection', 'foo', 'foo\\bar'], c.sections.sort)
-    assert_equal(['', 'a', 'bar', 'baz', 'd', 'dq', 'dq2', 'esc', 'foo\\bar', 'sq'], c['default'].keys.sort)
-    assert_equal('c', c['default'][''])
-    assert_equal('', c['default']['a'])
-    assert_equal('qx', c['default']['baz'])
-    assert_equal('', c['default']['d'])
-    assert_equal('baz', c['default']['bar'])
-    assert_equal("foob'ar", c['default']['sq'])
-    assert_equal("foo''\"", c['default']['dq'])
-    assert_equal("foobar", c['default']['dq2'])
-    assert_equal("a\r\n\b\tb", c['default']['esc'])
-    assert_equal("foo\b\\ar", c['default']['foo\\bar'])
-    assert_equal('baz', c['foo']['bar'])
-    assert_equal('baz', c['foo\\bar']['foo\\bar'])
-    assert_equal('b  ar', c['default1  default2']['fo'])
-
-    # dollar
-    assert_equal('bar', c['dollar']['foo'])
-    assert_equal('bar', c['dollar']['bar'])
-    assert_equal('123baz456bar798', c['dollar']['baz'])
-    assert_equal('123baz456bar798', c['dollar']['qux'])
-    assert_equal('123baz456bar798.123baz456bar798', c['dollar']['quxx'])
-
-    excn = assert_raise(OpenSSL::ConfigError) do
-      OpenSSL::Config.parse("foo = $bar")
-    end
-    assert_equal("error in line 1: variable has no value", excn.message)
-
-    excn = assert_raise(OpenSSL::ConfigError) do
-      OpenSSL::Config.parse("foo = $(bar")
-    end
-    assert_equal("error in line 1: no close brace", excn.message)
-
-    excn = assert_raise(OpenSSL::ConfigError) do
-      OpenSSL::Config.parse("f o =b  ar      # no space in key")
-    end
-    assert_equal("error in line 1: missing equal sign", excn.message)
-
-    excn = assert_raise(OpenSSL::ConfigError) do
-      OpenSSL::Config.parse(<<__EOC__)
-# comment 1               # comments
-
-#
- # comment 2
-\t#comment 3
-  [second    ]\t
-[third                    # section not terminated
-__EOC__
-    end
-    assert_equal("error in line 7: missing close square bracket", excn.message)
-  end
-
-  def test_s_parse_include
-    in_tmpdir("ossl-config-include-test") do |dir|
-      Dir.mkdir("child")
-      File.write("child/a.conf", <<~__EOC__)
-        [default]
-        file-a = a.conf
-        [sec-a]
-        a = 123
-      __EOC__
-      File.write("child/b.cnf", <<~__EOC__)
-        [default]
-        file-b = b.cnf
-        [sec-b]
-        b = 123
-      __EOC__
-      File.write("include-child.conf", <<~__EOC__)
-        key_outside_section = value_a
-        .include child
-      __EOC__
-
-      include_file = <<~__EOC__
-        [default]
-        file-main = unnamed
-        [sec-main]
-        main = 123
-        .include = include-child.conf
-      __EOC__
-
-      # Include a file by relative path
-      c1 = OpenSSL::Config.parse(include_file)
-      assert_equal(["default", "sec-a", "sec-b", "sec-main"], c1.sections.sort)
-      assert_equal(["file-main", "file-a", "file-b"], c1["default"].keys)
-      assert_equal({"a" => "123"}, c1["sec-a"])
-      assert_equal({"b" => "123"}, c1["sec-b"])
-      assert_equal({"main" => "123", "key_outside_section" => "value_a"}, c1["sec-main"])
-
-      # Relative paths are from the working directory
-      assert_raise(OpenSSL::ConfigError) do
-        Dir.chdir("child") { OpenSSL::Config.parse(include_file) }
-      end
-    end
-  end
-
-  def test_s_load
-    # alias of new
-    c = OpenSSL::Config.load
-    assert_equal("", c.to_s)
-    assert_equal([], c.sections)
-    #
-    Tempfile.create("openssl.cnf") {|file|
-      file.close
-      c = OpenSSL::Config.load(file.path)
-      assert_equal("[ default ]\n\n", c.to_s)
-      assert_equal(['default'], c.sections)
-    }
-  end
-
-  def test_initialize
-    c = OpenSSL::Config.new
-    assert_equal("", c.to_s)
-    assert_equal([], c.sections)
-  end
-
-  def test_initialize_with_empty_file
-    Tempfile.create("openssl.cnf") {|file|
-      file.close
-      c = OpenSSL::Config.new(file.path)
-      assert_equal("[ default ]\n\n", c.to_s)
-      assert_equal(['default'], c.sections)
-    }
-  end
-
-  def test_initialize_with_example_file
-    assert_equal(['CA_default', 'ca', 'default'], @it.sections.sort)
-  end
-
-  def test_get_value
-    assert_equal('CA_default', @it.get_value('ca', 'default_ca'))
-    assert_equal(nil, @it.get_value('ca', 'no such key'))
-    assert_equal(nil, @it.get_value('no such section', 'no such key'))
-    assert_equal('.', @it.get_value('', 'HOME'))
-    assert_raise(TypeError) do
-      @it.get_value(nil, 'HOME') # not allowed unlike Config#value
-    end
-    # fallback to 'default' ugly...
-    assert_equal('.', @it.get_value('unknown', 'HOME'))
-  end
-
-  def test_get_value_ENV
-    key = ENV.keys.first
-    assert_not_nil(key) # make sure we have at least one ENV var.
-    assert_equal(ENV[key], @it.get_value('ENV', key))
-  end
-
-  def test_value
-    # suppress deprecation warnings
-    EnvUtil.suppress_warning do
-      assert_equal('CA_default', @it.value('ca', 'default_ca'))
-      assert_equal(nil, @it.value('ca', 'no such key'))
-      assert_equal(nil, @it.value('no such section', 'no such key'))
-      assert_equal('.', @it.value('', 'HOME'))
-      assert_equal('.', @it.value(nil, 'HOME'))
-      assert_equal('.', @it.value('HOME'))
-      # fallback to 'default' ugly...
-      assert_equal('.', @it.value('unknown', 'HOME'))
-    end
-  end
-
-  def test_value_ENV
-    EnvUtil.suppress_warning do
-      key = ENV.keys.first
-      assert_not_nil(key) # make sure we have at least one ENV var.
-      assert_equal(ENV[key], @it.value('ENV', key))
-    end
-  end
-
-  def test_aref
-    assert_equal({'HOME' => '.'}, @it['default'])
-    assert_equal({'dir' => './demoCA', 'certs' => './certs'}, @it['CA_default'])
-    assert_equal({}, @it['no_such_section'])
-    assert_equal({}, @it[''])
-  end
-
-  def test_section
-    EnvUtil.suppress_warning do
-      assert_equal({'HOME' => '.'}, @it.section('default'))
-      assert_equal({'dir' => './demoCA', 'certs' => './certs'}, @it.section('CA_default'))
-      assert_equal({}, @it.section('no_such_section'))
-      assert_equal({}, @it.section(''))
-    end
-  end
-
-  def test_sections
-    assert_equal(['CA_default', 'ca', 'default'], @it.sections.sort)
-    # OpenSSL::Config#[]= is deprecated
-    EnvUtil.suppress_warning do
-      @it['new_section'] = {'foo' => 'bar'}
-      assert_equal(['CA_default', 'ca', 'default', 'new_section'], @it.sections.sort)
-      @it['new_section'] = {}
-      assert_equal(['CA_default', 'ca', 'default', 'new_section'], @it.sections.sort)
-    end
-  end
-
-  def test_add_value
-    # OpenSSL::Config#add_value is deprecated
-    EnvUtil.suppress_warning do
-      c = OpenSSL::Config.new
-      assert_equal("", c.to_s)
-      # add key
-      c.add_value('default', 'foo', 'bar')
-      assert_equal("[ default ]\nfoo=bar\n\n", c.to_s)
-      # add another key
-      c.add_value('default', 'baz', 'qux')
-      assert_equal('bar', c['default']['foo'])
-      assert_equal('qux', c['default']['baz'])
-      # update the value
-      c.add_value('default', 'baz', 'quxxx')
-      assert_equal('bar', c['default']['foo'])
-      assert_equal('quxxx', c['default']['baz'])
-      # add section and key
-      c.add_value('section', 'foo', 'bar')
-      assert_equal('bar', c['default']['foo'])
-      assert_equal('quxxx', c['default']['baz'])
-      assert_equal('bar', c['section']['foo'])
-    end
-  end
-
-  def test_aset
-    # OpenSSL::Config#[]= is deprecated
-    EnvUtil.suppress_warning do
-      @it['foo'] = {'bar' => 'baz'}
-      assert_equal({'bar' => 'baz'}, @it['foo'])
-      @it['foo'] = {'bar' => 'qux', 'baz' => 'quxx'}
-      assert_equal({'bar' => 'qux', 'baz' => 'quxx'}, @it['foo'])
-
-      # OpenSSL::Config is add only for now.
-      @it['foo'] = {'foo' => 'foo'}
-      assert_equal({'foo' => 'foo', 'bar' => 'qux', 'baz' => 'quxx'}, @it['foo'])
-      # you cannot override or remove any section and key.
-      @it['foo'] = {}
-      assert_equal({'foo' => 'foo', 'bar' => 'qux', 'baz' => 'quxx'}, @it['foo'])
-    end
-  end
-
-  def test_each
-    # each returns [section, key, value] array.
-    ary = @it.map { |e| e }.sort { |a, b| a[0] <=> b[0] }
-    assert_equal(4, ary.size)
-    assert_equal('CA_default', ary[0][0])
-    assert_equal('CA_default', ary[1][0])
-    assert_equal(["ca", "default_ca", "CA_default"], ary[2])
-    assert_equal(["default", "HOME", "."], ary[3])
-  end
-
-  def test_to_s
-    c = OpenSSL::Config.parse("[empty]\n")
-    assert_equal("[ default ]\n\n[ empty ]\n\n", c.to_s)
-  end
-
-  def test_inspect
-    assert_match(/#<OpenSSL::Config sections=\[.*\]>/, @it.inspect)
-  end
-
-  def test_freeze
-    @it.freeze
-
-    # Modifying OpenSSL::Config produces a warning
-    EnvUtil.suppress_warning do
-      bug = '[ruby-core:18377]'
-      # RuntimeError for 1.9, TypeError for 1.8
-      e = assert_raise(TypeError, bug) do
-        @it['foo'] = [['key', 'wrong']]
-      end
-      assert_match(/can't modify/, e.message, bug)
-    end
-  end
-
-  def test_dup
-    assert(!@it.sections.empty?)
-    c = @it.dup
-    assert_equal(@it.sections.sort, c.sections.sort)
-    # OpenSSL::Config#[]= is deprecated
-    EnvUtil.suppress_warning do
-      @it['newsection'] = {'a' => 'b'}
-      assert_not_equal(@it.sections.sort, c.sections.sort)
-    end
-  end
-
-  def test_clone
-    assert(!@it.sections.empty?)
-    c = @it.clone
-    assert_equal(@it.sections.sort, c.sections.sort)
-    # OpenSSL::Config#[]= is deprecated
-    EnvUtil.suppress_warning do
-      @it['newsection'] = {'a' => 'b'}
-      assert_not_equal(@it.sections.sort, c.sections.sort)
-    end
-  end
-
-  private
-
-  def in_tmpdir(*args)
-    Dir.mktmpdir(*args) do |dir|
-      dir = File.realpath(dir)
-      Dir.chdir(dir) do
-        yield dir
-      end
-    end
-  end
-end
-
-end
diff --git a/test/openssl/test_digest.rb b/test/openssl/test_digest.rb
deleted file mode 100644
index 8d7046e..0000000
--- a/test/openssl/test_digest.rb
+++ /dev/null
@@ -1,149 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestDigest < OpenSSL::TestCase
-  def setup
-    super
-    @d1 = OpenSSL::Digest.new("MD5")
-    @d2 = OpenSSL::Digest::MD5.new
-  end
-
-  def test_digest
-    null_hex = "d41d8cd98f00b204e9800998ecf8427e"
-    null_bin = [null_hex].pack("H*")
-    data = "DATA"
-    hex = "e44f9e348e41cb272efa87387728571b"
-    bin = [hex].pack("H*")
-    assert_equal(null_bin, @d1.digest)
-    assert_equal(null_hex, @d1.hexdigest)
-    @d1 << data
-    assert_equal(bin, @d1.digest)
-    assert_equal(hex, @d1.hexdigest)
-    assert_equal(bin, OpenSSL::Digest.digest('MD5', data))
-    assert_equal(hex, OpenSSL::Digest.hexdigest('MD5', data))
-  end
-
-  def test_eql
-    assert(@d1 == @d2, "==")
-    d = @d1.clone
-    assert(d == @d1, "clone")
-  end
-
-  def test_info
-    assert_equal("MD5", @d1.name, "name")
-    assert_equal("MD5", @d2.name, "name")
-    assert_equal(16, @d1.size, "size")
-  end
-
-  def test_dup
-    @d1.update("DATA")
-    assert_equal(@d1.name, @d1.dup.name, "dup")
-    assert_equal(@d1.name, @d1.clone.name, "clone")
-    assert_equal(@d1.digest, @d1.clone.digest, "clone .digest")
-  end
-
-  def test_reset
-    @d1.update("DATA")
-    dig1 = @d1.digest
-    @d1.reset
-    @d1.update("DATA")
-    dig2 = @d1.digest
-    assert_equal(dig1, dig2, "reset")
-  end
-
-  def test_digest_constants
-    %w{MD4 MD5 RIPEMD160 SHA1 SHA224 SHA256 SHA384 SHA512}.each do |name|
-      assert_not_nil(OpenSSL::Digest.new(name))
-      klass = OpenSSL::Digest.const_get(name.tr('-', '_'))
-      assert_not_nil(klass.new)
-    end
-  end
-
-  def test_digest_by_oid_and_name
-    check_digest(OpenSSL::ASN1::ObjectId.new("MD5"))
-    check_digest(OpenSSL::ASN1::ObjectId.new("SHA1"))
-  end
-
-  def encode16(str)
-    str.unpack("H*").first
-  end
-
-  def test_sha2
-    sha224_a = "abd37534c7d9a2efb9465de931cd7055ffdb8879563ae98078d6d6d5"
-    sha256_a = "ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb"
-    sha384_a = "54a59b9f22b0b80880d8427e548b7c23abd873486e1f035dce9cd697e85175033caa88e6d57bc35efae0b5afd3145f31"
-    sha512_a = "1f40fc92da241694750979ee6cf582f2d5d7d28e18335de05abc54d0560e0f5302860c652bf08d560252aa5e74210546f369fbbbce8c12cfc7957b2652fe9a75"
-
-    assert_equal(sha224_a, OpenSSL::Digest.hexdigest('SHA224', "a"))
-    assert_equal(sha256_a, OpenSSL::Digest.hexdigest('SHA256', "a"))
-    assert_equal(sha384_a, OpenSSL::Digest.hexdigest('SHA384', "a"))
-    assert_equal(sha512_a, OpenSSL::Digest.hexdigest('SHA512', "a"))
-
-    assert_equal(sha224_a, encode16(OpenSSL::Digest.digest('SHA224', "a")))
-    assert_equal(sha256_a, encode16(OpenSSL::Digest.digest('SHA256', "a")))
-    assert_equal(sha384_a, encode16(OpenSSL::Digest.digest('SHA384', "a")))
-    assert_equal(sha512_a, encode16(OpenSSL::Digest.digest('SHA512', "a")))
-  end
-
-  def test_sha512_truncate
-    pend "SHA512_224 is not implemented" unless digest_available?('SHA512-224')
-    sha512_224_a = "d5cdb9ccc769a5121d4175f2bfdd13d6310e0d3d361ea75d82108327"
-    sha512_256_a = "455e518824bc0601f9fb858ff5c37d417d67c2f8e0df2babe4808858aea830f8"
-
-    assert_equal(sha512_224_a, OpenSSL::Digest.hexdigest('SHA512-224', "a"))
-    assert_equal(sha512_256_a, OpenSSL::Digest.hexdigest('SHA512-256', "a"))
-
-    assert_equal(sha512_224_a, encode16(OpenSSL::Digest.digest('SHA512-224', "a")))
-    assert_equal(sha512_256_a, encode16(OpenSSL::Digest.digest('SHA512-256', "a")))
-  end
-
-  def test_sha3
-    pend "SHA3 is not implemented" unless digest_available?('SHA3-224')
-    s224 = '6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7'
-    s256 = 'a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a'
-    s384 = '0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004'
-    s512 = 'a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26'
-    assert_equal(OpenSSL::Digest.hexdigest('SHA3-224', ""), s224)
-    assert_equal(OpenSSL::Digest.hexdigest('SHA3-256', ""), s256)
-    assert_equal(OpenSSL::Digest.hexdigest('SHA3-384', ""), s384)
-    assert_equal(OpenSSL::Digest.hexdigest('SHA3-512', ""), s512)
-  end
-
-  def test_digest_by_oid_and_name_sha2
-    check_digest(OpenSSL::ASN1::ObjectId.new("SHA224"))
-    check_digest(OpenSSL::ASN1::ObjectId.new("SHA256"))
-    check_digest(OpenSSL::ASN1::ObjectId.new("SHA384"))
-    check_digest(OpenSSL::ASN1::ObjectId.new("SHA512"))
-  end
-
-  def test_openssl_digest
-    assert_equal OpenSSL::Digest::MD5, OpenSSL::Digest("MD5")
-
-    assert_raise NameError do
-      OpenSSL::Digest("no such digest")
-    end
-  end
-
-  private
-
-  def check_digest(oid)
-    d = OpenSSL::Digest.new(oid.sn)
-    assert_not_nil(d)
-    d = OpenSSL::Digest.new(oid.ln)
-    assert_not_nil(d)
-    d = OpenSSL::Digest.new(oid.oid)
-    assert_not_nil(d)
-  end
-
-  def digest_available?(name)
-    begin
-      OpenSSL::Digest.new(name)
-    rescue RuntimeError
-      false
-    end
-  end
-end
-
-end
diff --git a/test/openssl/test_engine.rb b/test/openssl/test_engine.rb
deleted file mode 100644
index 1ede6ed..0000000
--- a/test/openssl/test_engine.rb
+++ /dev/null
@@ -1,97 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL) && defined?(OpenSSL::Engine)
-
-class OpenSSL::TestEngine < OpenSSL::TestCase
-  def test_engines_free # [ruby-dev:44173]
-    with_openssl <<-'end;'
-      OpenSSL::Engine.load("openssl")
-      OpenSSL::Engine.engines
-      OpenSSL::Engine.engines
-    end;
-  end
-
-  def test_openssl_engine_builtin
-    with_openssl <<-'end;'
-      orig = OpenSSL::Engine.engines
-      pend "'openssl' is already loaded" if orig.any? { |e| e.id == "openssl" }
-      engine = OpenSSL::Engine.load("openssl")
-      assert_equal(true, engine)
-      assert_equal(1, OpenSSL::Engine.engines.size - orig.size)
-    end;
-  end
-
-  def test_openssl_engine_by_id_string
-    with_openssl <<-'end;'
-      orig = OpenSSL::Engine.engines
-      pend "'openssl' is already loaded" if orig.any? { |e| e.id == "openssl" }
-      engine = get_engine
-      assert_not_nil(engine)
-      assert_equal(1, OpenSSL::Engine.engines.size - orig.size)
-    end;
-  end
-
-  def test_openssl_engine_id_name_inspect
-    with_openssl <<-'end;'
-      engine = get_engine
-      assert_equal("openssl", engine.id)
-      assert_not_nil(engine.name)
-      assert_not_nil(engine.inspect)
-    end;
-  end
-
-  def test_openssl_engine_digest_sha1
-    with_openssl <<-'end;'
-      engine = get_engine
-      digest = engine.digest("SHA1")
-      assert_not_nil(digest)
-      data = "test"
-      assert_equal(OpenSSL::Digest.digest('SHA1', data), digest.digest(data))
-    end;
-  end
-
-  def test_openssl_engine_cipher_rc4
-    begin
-      OpenSSL::Cipher.new("rc4")
-    rescue OpenSSL::Cipher::CipherError
-      pend "RC4 is not supported"
-    end
-
-    with_openssl(<<-'end;', ignore_stderr: true)
-      engine = get_engine
-      algo = "RC4"
-      data = "a" * 1000
-      key = OpenSSL::Random.random_bytes(16)
-      encrypted = crypt_data(data, key, :encrypt) { engine.cipher(algo) }
-      decrypted = crypt_data(encrypted, key, :decrypt) { OpenSSL::Cipher.new(algo) }
-      assert_equal(data, decrypted)
-    end;
-  end
-
-  private
-
-  # this is required because OpenSSL::Engine methods change global state
-  def with_openssl(code, **opts)
-    assert_separately([{ "OSSL_MDEBUG" => nil }, "-ropenssl"], <<~"end;", **opts)
-      require #{__FILE__.dump}
-      include OpenSSL::TestEngine::Utils
-      #{code}
-    end;
-  end
-
-  module Utils
-    def get_engine
-      OpenSSL::Engine.by_id("openssl")
-    end
-
-    def crypt_data(data, key, mode)
-      cipher = yield
-      cipher.send mode
-      cipher.key = key
-      cipher.update(data) + cipher.final
-    end
-  end
-end
-
-end
diff --git a/test/openssl/test_fips.rb b/test/openssl/test_fips.rb
deleted file mode 100644
index 8cd474f..0000000
--- a/test/openssl/test_fips.rb
+++ /dev/null
@@ -1,30 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestFIPS < OpenSSL::TestCase
-  def test_fips_mode_is_reentrant
-    OpenSSL.fips_mode = false
-    OpenSSL.fips_mode = false
-  end
-
-  def test_fips_mode_get
-    return unless OpenSSL::OPENSSL_FIPS
-    assert_separately([{ "OSSL_MDEBUG" => nil }, "-ropenssl"], <<~"end;")
-      require #{__FILE__.dump}
-
-      begin
-        OpenSSL.fips_mode = true
-        assert OpenSSL.fips_mode == true, ".fips_mode returns true when .fips_mode=true"
-
-        OpenSSL.fips_mode = false
-        assert OpenSSL.fips_mode == false, ".fips_mode returns false when .fips_mode=false"
-      rescue OpenSSL::OpenSSLError
-        pend "Could not set FIPS mode (OpenSSL::OpenSSLError: \#$!); skipping"
-      end
-    end;
-  end
-end
-
-end
diff --git a/test/openssl/test_hmac.rb b/test/openssl/test_hmac.rb
deleted file mode 100644
index 9cb3c5a..0000000
--- a/test/openssl/test_hmac.rb
+++ /dev/null
@@ -1,54 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestHMAC < OpenSSL::TestCase
-  def test_hmac
-    # RFC 2202 2. Test Cases for HMAC-MD5
-    hmac = OpenSSL::HMAC.new(["0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"].pack("H*"), "MD5")
-    hmac.update("Hi There")
-    assert_equal ["9294727a3638bb1c13f48ef8158bfc9d"].pack("H*"), hmac.digest
-    assert_equal "9294727a3638bb1c13f48ef8158bfc9d", hmac.hexdigest
-
-    # RFC 4231 4.2. Test Case 1
-    hmac = OpenSSL::HMAC.new(["0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"].pack("H*"), "SHA224")
-    hmac.update("Hi There")
-    assert_equal ["896fb1128abbdf196832107cd49df33f47b4b1169912ba4f53684b22"].pack("H*"), hmac.digest
-    assert_equal "896fb1128abbdf196832107cd49df33f47b4b1169912ba4f53684b22", hmac.hexdigest
-  end
-
-  def test_dup
-    h1 = OpenSSL::HMAC.new("KEY", "MD5")
-    h1.update("DATA")
-    h = h1.dup
-    assert_equal(h1.digest, h.digest, "dup digest")
-  end
-
-  def test_binary_update
-    data = "Lücíllé: Bût... yøü sáîd hé wås âlrîght.\nDr. Físhmån: Yés. Hé's løst hîs léft hånd, sø hé's gøîng tø bé åll rîght"
-    hmac = OpenSSL::HMAC.new("qShkcwN92rsM9nHfdnP4ugcVU2iI7iM/trovs01ZWok", "SHA256")
-    result = hmac.update(data).hexdigest
-    assert_equal "a13984b929a07912e4e21c5720876a8e150d6f67f854437206e7f86547248396", result
-  end
-
-  def test_reset_keep_key
-    h1 = OpenSSL::HMAC.new("KEY", "MD5")
-    first = h1.update("test").hexdigest
-    h1.reset
-    second = h1.update("test").hexdigest
-    assert_equal first, second
-  end
-
-  def test_eq
-    h1 = OpenSSL::HMAC.new("KEY", "MD5")
-    h2 = OpenSSL::HMAC.new("KEY", OpenSSL::Digest.new("MD5"))
-    h3 = OpenSSL::HMAC.new("FOO", "MD5")
-
-    assert_equal h1, h2
-    refute_equal h1, h2.digest
-    refute_equal h1, h3
-  end
-end
-
-end
diff --git a/test/openssl/test_kdf.rb b/test/openssl/test_kdf.rb
deleted file mode 100644
index f4790c9..0000000
--- a/test/openssl/test_kdf.rb
+++ /dev/null
@@ -1,183 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestKDF < OpenSSL::TestCase
-  def test_pkcs5_pbkdf2_hmac_compatibility
-    expected = OpenSSL::KDF.pbkdf2_hmac("password", salt: "salt", iterations: 1, length: 20, hash: "sha1")
-    assert_equal(expected, OpenSSL::PKCS5.pbkdf2_hmac("password", "salt", 1, 20, "sha1"))
-    assert_equal(expected, OpenSSL::PKCS5.pbkdf2_hmac_sha1("password", "salt", 1, 20))
-  end
-
-  def test_pbkdf2_hmac_sha1_rfc6070_c_1_len_20
-    p ="password"
-    s = "salt"
-    c = 1
-    dk_len = 20
-    raw = %w{ 0c 60 c8 0f 96 1f 0e 71
-              f3 a9 b5 24 af 60 12 06
-              2f e0 37 a6 }
-    expected = [raw.join('')].pack('H*')
-    value = OpenSSL::KDF.pbkdf2_hmac(p, salt: s, iterations: c, length: dk_len, hash: "sha1")
-    assert_equal(expected, value)
-  end
-
-  def test_pbkdf2_hmac_sha1_rfc6070_c_2_len_20
-    p ="password"
-    s = "salt"
-    c = 2
-    dk_len = 20
-    raw = %w{ ea 6c 01 4d c7 2d 6f 8c
-              cd 1e d9 2a ce 1d 41 f0
-              d8 de 89 57 }
-    expected = [raw.join('')].pack('H*')
-    value = OpenSSL::KDF.pbkdf2_hmac(p, salt: s, iterations: c, length: dk_len, hash: "sha1")
-    assert_equal(expected, value)
-  end
-
-  def test_pbkdf2_hmac_sha1_rfc6070_c_4096_len_20
-    p ="password"
-    s = "salt"
-    c = 4096
-    dk_len = 20
-    raw = %w{ 4b 00 79 01 b7 65 48 9a
-              be ad 49 d9 26 f7 21 d0
-              65 a4 29 c1 }
-    expected = [raw.join('')].pack('H*')
-    value = OpenSSL::KDF.pbkdf2_hmac(p, salt: s, iterations: c, length: dk_len, hash: "sha1")
-    assert_equal(expected, value)
-  end
-
-# takes too long!
-#  def test_pbkdf2_hmac_sha1_rfc6070_c_16777216_len_20
-#    p ="password"
-#    s = "salt"
-#    c = 16777216
-#    dk_len = 20
-#    raw = %w{ ee fe 3d 61 cd 4d a4 e4
-#              e9 94 5b 3d 6b a2 15 8c
-#              26 34 e9 84 }
-#    expected = [raw.join('')].pack('H*')
-#    value = OpenSSL::KDF.pbkdf2_hmac(p, salt: s, iterations: c, length: dk_len, hash: "sha1")
-#    assert_equal(expected, value)
-#  end
-
-  def test_pbkdf2_hmac_sha1_rfc6070_c_4096_len_25
-    p ="passwordPASSWORDpassword"
-    s = "saltSALTsaltSALTsaltSALTsaltSALTsalt"
-    c = 4096
-    dk_len = 25
-
-    raw = %w{ 3d 2e ec 4f e4 1c 84 9b
-              80 c8 d8 36 62 c0 e4 4a
-              8b 29 1a 96 4c f2 f0 70
-              38 }
-    expected = [raw.join('')].pack('H*')
-    value = OpenSSL::KDF.pbkdf2_hmac(p, salt: s, iterations: c, length: dk_len, hash: "sha1")
-    assert_equal(expected, value)
-  end
-
-  def test_pbkdf2_hmac_sha1_rfc6070_c_4096_len_16
-    p ="pass\0word"
-    s = "sa\0lt"
-    c = 4096
-    dk_len = 16
-    raw = %w{ 56 fa 6a a7 55 48 09 9d
-              cc 37 d7 f0 34 25 e0 c3 }
-    expected = [raw.join('')].pack('H*')
-    value = OpenSSL::KDF.pbkdf2_hmac(p, salt: s, iterations: c, length: dk_len, hash: "sha1")
-    assert_equal(expected, value)
-  end
-
-  def test_pbkdf2_hmac_sha256_c_20000_len_32
-    #unfortunately no official test vectors available yet for SHA-2
-    p ="password"
-    s = OpenSSL::Random.random_bytes(16)
-    c = 20000
-    dk_len = 32
-    value1 = OpenSSL::KDF.pbkdf2_hmac(p, salt: s, iterations: c, length: dk_len, hash: "sha256")
-    value2 = OpenSSL::KDF.pbkdf2_hmac(p, salt: s, iterations: c, length: dk_len, hash: "sha256")
-    assert_equal(value1, value2)
-  end
-
-  def test_scrypt_rfc7914_first
-    pend "scrypt is not implemented" unless OpenSSL::KDF.respond_to?(:scrypt) # OpenSSL >= 1.1.0
-    pass = ""
-    salt = ""
-    n = 16
-    r = 1
-    p = 1
-    dklen = 64
-    expected = B(%w{ 77 d6 57 62 38 65 7b 20 3b 19 ca 42 c1 8a 04 97
-                     f1 6b 48 44 e3 07 4a e8 df df fa 3f ed e2 14 42
-                     fc d0 06 9d ed 09 48 f8 32 6a 75 3a 0f c8 1f 17
-                     e8 d3 e0 fb 2e 0d 36 28 cf 35 e2 0c 38 d1 89 06 })
-    assert_equal(expected, OpenSSL::KDF.scrypt(pass, salt: salt, N: n, r: r, p: p, length: dklen))
-  end
-
-  def test_scrypt_rfc7914_second
-    pend "scrypt is not implemented" unless OpenSSL::KDF.respond_to?(:scrypt) # OpenSSL >= 1.1.0
-    pass = "password"
-    salt = "NaCl"
-    n = 1024
-    r = 8
-    p = 16
-    dklen = 64
-    expected = B(%w{ fd ba be 1c 9d 34 72 00 78 56 e7 19 0d 01 e9 fe
-                     7c 6a d7 cb c8 23 78 30 e7 73 76 63 4b 37 31 62
-                     2e af 30 d9 2e 22 a3 88 6f f1 09 27 9d 98 30 da
-                     c7 27 af b9 4a 83 ee 6d 83 60 cb df a2 cc 06 40 })
-    assert_equal(expected, OpenSSL::KDF.scrypt(pass, salt: salt, N: n, r: r, p: p, length: dklen))
-  end
-
-  def test_hkdf_rfc5869_test_case_1
-    pend "HKDF is not implemented" unless OpenSSL::KDF.respond_to?(:hkdf) # OpenSSL >= 1.1.0
-    hash = "sha256"
-    ikm = B("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b")
-    salt = B("000102030405060708090a0b0c")
-    info = B("f0f1f2f3f4f5f6f7f8f9")
-    l = 42
-
-    okm = B("3cb25f25faacd57a90434f64d0362f2a" \
-            "2d2d0a90cf1a5a4c5db02d56ecc4c5bf" \
-            "34007208d5b887185865")
-    assert_equal(okm, OpenSSL::KDF.hkdf(ikm, salt: salt, info: info, length: l, hash: hash))
-  end
-
-  def test_hkdf_rfc5869_test_case_3
-    pend "HKDF is not implemented" unless OpenSSL::KDF.respond_to?(:hkdf) # OpenSSL >= 1.1.0
-    hash = "sha256"
-    ikm = B("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b")
-    salt = B("")
-    info = B("")
-    l = 42
-
-    okm = B("8da4e775a563c18f715f802a063c5a31" \
-            "b8a11f5c5ee1879ec3454e5f3c738d2d" \
-            "9d201395faa4b61a96c8")
-    assert_equal(okm, OpenSSL::KDF.hkdf(ikm, salt: salt, info: info, length: l, hash: hash))
-  end
-
-  def test_hkdf_rfc5869_test_case_4
-    pend "HKDF is not implemented" unless OpenSSL::KDF.respond_to?(:hkdf) # OpenSSL >= 1.1.0
-    hash = "sha1"
-    ikm = B("0b0b0b0b0b0b0b0b0b0b0b")
-    salt = B("000102030405060708090a0b0c")
-    info = B("f0f1f2f3f4f5f6f7f8f9")
-    l = 42
-
-    okm = B("085a01ea1b10f36933068b56efa5ad81" \
-            "a4f14b822f5b091568a9cdd4f155fda2" \
-            "c22e422478d305f3f896")
-    assert_equal(okm, OpenSSL::KDF.hkdf(ikm, salt: salt, info: info, length: l, hash: hash))
-  end
-
-  private
-
-  def B(ary)
-    [Array(ary).join].pack("H*")
-  end
-end
-
-end
diff --git a/test/openssl/test_ns_spki.rb b/test/openssl/test_ns_spki.rb
deleted file mode 100644
index ed3be86..0000000
--- a/test/openssl/test_ns_spki.rb
+++ /dev/null
@@ -1,53 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestNSSPI < OpenSSL::TestCase
-  def setup
-    super
-    # This request data is adopt from the specification of
-    # "Netscape Extensions for User Key Generation".
-    # -- http://wp.netscape.com/eng/security/comm4-keygen.html
-    @b64 = +"MIHFMHEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAnX0TILJrOMUue+PtwBRE6XfV"
-    @b64 << "WtKQbsshxk5ZhcUwcwyvcnIq9b82QhJdoACdD34rqfCAIND46fXKQUnb0mvKzQID"
-    @b64 << "AQABFhFNb3ppbGxhSXNNeUZyaWVuZDANBgkqhkiG9w0BAQQFAANBAAKv2Eex2n/S"
-    @b64 << "r/7iJNroWlSzSMtTiQTEB+ADWHGj9u1xrUrOilq/o2cuQxIfZcNZkYAkWP4DubqW"
-    @b64 << "i0//rgBvmco="
-  end
-
-  def test_build_data
-    key1 = Fixtures.pkey("rsa1024")
-    key2 = Fixtures.pkey("rsa2048")
-    spki = OpenSSL::Netscape::SPKI.new
-    spki.challenge = "RandomString"
-    spki.public_key = key1.public_key
-    spki.sign(key1, OpenSSL::Digest.new('SHA1'))
-    assert(spki.verify(spki.public_key))
-    assert(spki.verify(key1.public_key))
-    assert(!spki.verify(key2.public_key))
-
-    der = spki.to_der
-    spki = OpenSSL::Netscape::SPKI.new(der)
-    assert_equal("RandomString", spki.challenge)
-    assert_equal(key1.public_key.to_der, spki.public_key.to_der)
-    assert(spki.verify(spki.public_key))
-    assert_not_nil(spki.to_text)
-  end
-
-  def test_decode_data
-    spki = OpenSSL::Netscape::SPKI.new(@b64)
-    assert_equal(@b64, spki.to_pem)
-    assert_equal(@b64.unpack("m").first, spki.to_der)
-    assert_equal("MozillaIsMyFriend", spki.challenge)
-    assert_equal(OpenSSL::PKey::RSA, spki.public_key.class)
-
-    spki = OpenSSL::Netscape::SPKI.new(@b64.unpack("m").first)
-    assert_equal(@b64, spki.to_pem)
-    assert_equal(@b64.unpack("m").first, spki.to_der)
-    assert_equal("MozillaIsMyFriend", spki.challenge)
-    assert_equal(OpenSSL::PKey::RSA, spki.public_key.class)
-  end
-end
-
-end
diff --git a/test/openssl/test_ocsp.rb b/test/openssl/test_ocsp.rb
deleted file mode 100644
index b3c4caf..0000000
--- a/test/openssl/test_ocsp.rb
+++ /dev/null
@@ -1,311 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestOCSP < OpenSSL::TestCase
-  def setup
-    super
-    # @ca_cert
-    #   |
-    # @cert
-    #   |----------|
-    # @cert2   @ocsp_cert
-
-    ca_subj = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=TestCA")
-    @ca_key = Fixtures.pkey("rsa1024")
-    ca_exts = [
-      ["basicConstraints", "CA:TRUE", true],
-      ["keyUsage", "cRLSign,keyCertSign", true],
-    ]
-    @ca_cert = OpenSSL::TestUtils.issue_cert(
-      ca_subj, @ca_key, 1, ca_exts, nil, nil)
-
-    cert_subj = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=TestCA2")
-    @cert_key = Fixtures.pkey("rsa1024")
-    cert_exts = [
-      ["basicConstraints", "CA:TRUE", true],
-      ["keyUsage", "cRLSign,keyCertSign", true],
-    ]
-    @cert = OpenSSL::TestUtils.issue_cert(
-      cert_subj, @cert_key, 5, cert_exts, @ca_cert, @ca_key)
-
-    cert2_subj = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=TestCert")
-    @cert2_key = Fixtures.pkey("rsa1024")
-    cert2_exts = [
-    ]
-    @cert2 = OpenSSL::TestUtils.issue_cert(
-      cert2_subj, @cert2_key, 10, cert2_exts, @cert, @cert_key)
-
-    ocsp_subj = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=TestCAOCSP")
-    @ocsp_key = Fixtures.pkey("rsa2048")
-    ocsp_exts = [
-      ["extendedKeyUsage", "OCSPSigning", true],
-    ]
-    @ocsp_cert = OpenSSL::TestUtils.issue_cert(
-       ocsp_subj, @ocsp_key, 100, ocsp_exts, @cert, @cert_key)
-  end
-
-  def test_new_certificate_id
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert)
-    assert_kind_of OpenSSL::OCSP::CertificateId, cid
-    assert_equal @cert.serial, cid.serial
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA256'))
-    assert_kind_of OpenSSL::OCSP::CertificateId, cid
-    assert_equal @cert.serial, cid.serial
-  end
-
-  def test_certificate_id_issuer_name_hash
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert)
-    assert_equal OpenSSL::Digest.hexdigest('SHA1', @cert.issuer.to_der), cid.issuer_name_hash
-    assert_equal "d91f736ac4dc3242f0fb9b77a3149bd83c5c43d0", cid.issuer_name_hash
-  end
-
-  def test_certificate_id_issuer_key_hash
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert)
-    assert_equal OpenSSL::Digest.hexdigest('SHA1', OpenSSL::ASN1.decode(@ca_cert.to_der).value[0].value[6].value[1].value), cid.issuer_key_hash
-    assert_equal "d1fef9fbf8ae1bc160cbfa03e2596dd873089213", cid.issuer_key_hash
-  end
-
-  def test_certificate_id_hash_algorithm
-    cid_sha1 = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    cid_sha256 = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA256'))
-    assert_equal "sha1", cid_sha1.hash_algorithm
-    assert_equal "sha256", cid_sha256.hash_algorithm
-  end
-
-  def test_certificate_id_der
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert)
-    der = cid.to_der
-    asn1 = OpenSSL::ASN1.decode(der)
-    # hash algorithm defaults to SHA-1
-    assert_equal OpenSSL::ASN1.ObjectId("SHA1").to_der, asn1.value[0].value[0].to_der
-    assert_equal [cid.issuer_name_hash].pack("H*"), asn1.value[1].value
-    assert_equal [cid.issuer_key_hash].pack("H*"), asn1.value[2].value
-    assert_equal @cert.serial, asn1.value[3].value
-    assert_equal der, OpenSSL::OCSP::CertificateId.new(der).to_der
-    assert_equal der, OpenSSL::OCSP::CertificateId.new(asn1).to_der
-  end
-
-  def test_certificate_id_dup
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert)
-    assert_equal cid.to_der, cid.dup.to_der
-  end
-
-  def test_request_der
-    request = OpenSSL::OCSP::Request.new
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    request.add_certid(cid)
-    request.sign(@cert, @cert_key, [@ca_cert], 0)
-    asn1 = OpenSSL::ASN1.decode(request.to_der)
-    assert_equal cid.to_der, asn1.value[0].value.find { |a| a.tag_class == :UNIVERSAL }.value[0].value[0].to_der
-    assert_equal OpenSSL::ASN1.ObjectId("sha1WithRSAEncryption").to_der, asn1.value[1].value[0].value[0].value[0].to_der
-    assert_equal @cert.to_der, asn1.value[1].value[0].value[2].value[0].value[0].to_der
-    assert_equal @ca_cert.to_der, asn1.value[1].value[0].value[2].value[0].value[1].to_der
-    assert_equal asn1.to_der, OpenSSL::OCSP::Request.new(asn1.to_der).to_der
-  end
-
-  def test_request_sign_verify
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert)
-    store = OpenSSL::X509::Store.new.add_cert(@ca_cert)
-
-    # with signer cert
-    req = OpenSSL::OCSP::Request.new.add_certid(cid)
-    req.sign(@cert, @cert_key, [])
-    assert_equal true, req.verify([], store)
-
-    # without signer cert
-    req = OpenSSL::OCSP::Request.new.add_certid(cid)
-    req.sign(@cert, @cert_key, nil)
-    assert_equal false, req.verify([@cert2], store)
-    assert_equal false, req.verify([], store) # no signer
-    assert_equal false, req.verify([], store, OpenSSL::OCSP::NOVERIFY)
-
-    assert_equal true, req.verify([@cert], store, OpenSSL::OCSP::NOINTERN)
-    ret = req.verify([@cert], store)
-    if ret || openssl?(1, 0, 2)
-      assert_equal true, ret
-    else
-      # RT2560; OCSP_request_verify() does not find signer cert from 'certs' when
-      # OCSP_NOINTERN is not specified.
-      # fixed by OpenSSL 1.0.1j, 1.0.2
-      pend "RT2560: ocsp_req_find_signer"
-    end
-
-    # not signed
-    req = OpenSSL::OCSP::Request.new.add_certid(cid)
-    assert_equal false, req.verify([], store)
-  end
-
-  def test_request_is_signed
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert)
-    req = OpenSSL::OCSP::Request.new
-    req.add_certid(cid)
-    assert_equal false, req.signed?
-    assert_equal false, OpenSSL::OCSP::Request.new(req.to_der).signed?
-    req.sign(@cert, @cert_key, [])
-    assert_equal true, req.signed?
-    assert_equal true, OpenSSL::OCSP::Request.new(req.to_der).signed?
-  end
-
-  def test_request_nonce
-    req0 = OpenSSL::OCSP::Request.new
-    req1 = OpenSSL::OCSP::Request.new.add_nonce("NONCE")
-    req2 = OpenSSL::OCSP::Request.new.add_nonce("ABCDE")
-    bres = OpenSSL::OCSP::BasicResponse.new
-    assert_equal 2, req0.check_nonce(bres)
-    bres.copy_nonce(req1)
-    assert_equal 3, req0.check_nonce(bres)
-    assert_equal 1, req1.check_nonce(bres)
-    bres.add_nonce("NONCE")
-    assert_equal 1, req1.check_nonce(bres)
-    assert_equal 0, req2.check_nonce(bres)
-  end
-
-  def test_request_dup
-    request = OpenSSL::OCSP::Request.new
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    request.add_certid(cid)
-    assert_equal request.to_der, request.dup.to_der
-  end
-
-  def test_basic_response_der
-    bres = OpenSSL::OCSP::BasicResponse.new
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    bres.add_status(cid, OpenSSL::OCSP::V_CERTSTATUS_GOOD, 0, nil, -300, 500, [])
-    bres.add_nonce("NONCE")
-    bres.sign(@ocsp_cert, @ocsp_key, [@ca_cert], 0)
-    der = bres.to_der
-    asn1 = OpenSSL::ASN1.decode(der)
-    assert_equal OpenSSL::ASN1.Sequence([@ocsp_cert, @ca_cert]).to_der, asn1.value[3].value[0].to_der
-    assert_equal der, OpenSSL::OCSP::BasicResponse.new(der).to_der
-  rescue TypeError
-    if /GENERALIZEDTIME/ =~ $!.message
-      pend "OCSP_basic_sign() is broken"
-    else
-      raise
-    end
-  end
-
-  def test_basic_response_sign_verify
-    store = OpenSSL::X509::Store.new.add_cert(@ca_cert)
-
-    # signed by CA
-    bres = OpenSSL::OCSP::BasicResponse.new
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, "SHA256")
-    bres.add_status(cid, OpenSSL::OCSP::V_CERTSTATUS_GOOD, nil, -400, -300, 500, [])
-    bres.sign(@ca_cert, @ca_key, nil, 0, "SHA256")
-    assert_equal false, bres.verify([], store) # signer not found
-    assert_equal true, bres.verify([@ca_cert], store)
-    bres.sign(@ca_cert, @ca_key, [], 0, "SHA256")
-    assert_equal true, bres.verify([], store)
-
-    # signed by OCSP signer
-    bres = OpenSSL::OCSP::BasicResponse.new
-    cid = OpenSSL::OCSP::CertificateId.new(@cert2, @cert)
-    bres.add_status(cid, OpenSSL::OCSP::V_CERTSTATUS_GOOD, nil, -400, -300, 500, [])
-    bres.sign(@ocsp_cert, @ocsp_key, [@cert])
-    assert_equal true, bres.verify([], store)
-    assert_equal false, bres.verify([], store, OpenSSL::OCSP::NOCHAIN)
-    # OpenSSL had a bug on this; test that our workaround works
-    bres.sign(@ocsp_cert, @ocsp_key, [])
-    assert_equal true, bres.verify([@cert], store)
-  end
-
-  def test_basic_response_dup
-    bres = OpenSSL::OCSP::BasicResponse.new
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    bres.add_status(cid, OpenSSL::OCSP::V_CERTSTATUS_GOOD, 0, nil, -300, 500, [])
-    bres.sign(@ocsp_cert, @ocsp_key, [@ca_cert], 0)
-    assert_equal bres.to_der, bres.dup.to_der
-  end
-
-  def test_basic_response_response_operations
-    bres = OpenSSL::OCSP::BasicResponse.new
-    now = Time.at(Time.now.to_i)
-    cid1 = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    cid2 = OpenSSL::OCSP::CertificateId.new(@ocsp_cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    cid3 = OpenSSL::OCSP::CertificateId.new(@ca_cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    bres.add_status(cid1, OpenSSL::OCSP::V_CERTSTATUS_REVOKED, OpenSSL::OCSP::REVOKED_STATUS_UNSPECIFIED, now - 400, -300, nil, nil)
-    bres.add_status(cid2, OpenSSL::OCSP::V_CERTSTATUS_GOOD, nil, nil, -300, 500, [])
-
-    assert_equal 2, bres.responses.size
-    single = bres.responses.first
-    assert_equal cid1.to_der, single.certid.to_der
-    assert_equal OpenSSL::OCSP::V_CERTSTATUS_REVOKED, single.cert_status
-    assert_equal OpenSSL::OCSP::REVOKED_STATUS_UNSPECIFIED, single.revocation_reason
-    assert_equal now - 400, single.revocation_time
-    assert_in_delta (now - 301), single.this_update, 1
-    assert_equal nil, single.next_update
-    assert_equal [], single.extensions
-
-    assert_equal cid2.to_der, bres.find_response(cid2).certid.to_der
-    assert_equal nil, bres.find_response(cid3)
-  end
-
-  def test_single_response_der
-    bres = OpenSSL::OCSP::BasicResponse.new
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert)
-    bres.add_status(cid, OpenSSL::OCSP::V_CERTSTATUS_GOOD, nil, nil, -300, 500, nil)
-    single = bres.responses[0]
-    der = single.to_der
-    asn1 = OpenSSL::ASN1.decode(der)
-    assert_equal :CONTEXT_SPECIFIC, asn1.value[1].tag_class
-    assert_equal 0, asn1.value[1].tag # good
-    assert_equal der, OpenSSL::OCSP::SingleResponse.new(der).to_der
-  end
-
-  def test_single_response_check_validity
-    bres = OpenSSL::OCSP::BasicResponse.new
-    cid1 = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    cid2 = OpenSSL::OCSP::CertificateId.new(@ocsp_cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    bres.add_status(cid1, OpenSSL::OCSP::V_CERTSTATUS_REVOKED, OpenSSL::OCSP::REVOKED_STATUS_UNSPECIFIED, -400, -300, -50, [])
-    bres.add_status(cid2, OpenSSL::OCSP::V_CERTSTATUS_REVOKED, OpenSSL::OCSP::REVOKED_STATUS_UNSPECIFIED, -400, -300, nil, [])
-    bres.add_status(cid2, OpenSSL::OCSP::V_CERTSTATUS_GOOD, nil, nil, Time.now + 100, nil, nil)
-
-    single1 = bres.responses[0]
-    assert_equal false, single1.check_validity
-    assert_equal false, single1.check_validity(30)
-    assert_equal true, single1.check_validity(60)
-    single2 = bres.responses[1]
-    assert_equal true, single2.check_validity
-    assert_equal true, single2.check_validity(0, 500)
-    assert_equal false, single2.check_validity(0, 200)
-    single3 = bres.responses[2]
-    assert_equal false, single3.check_validity
-  end
-
-  def test_response
-    bres = OpenSSL::OCSP::BasicResponse.new
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    bres.add_status(cid, OpenSSL::OCSP::V_CERTSTATUS_GOOD, 0, nil, -300, 500, [])
-    bres.sign(@ocsp_cert, @ocsp_key, [])
-    res = OpenSSL::OCSP::Response.create(OpenSSL::OCSP::RESPONSE_STATUS_SUCCESSFUL, bres)
-
-    assert_equal bres.to_der, res.basic.to_der
-    assert_equal OpenSSL::OCSP::RESPONSE_STATUS_SUCCESSFUL, res.status
-  end
-
-  def test_response_der
-    bres = OpenSSL::OCSP::BasicResponse.new
-    cid = OpenSSL::OCSP::CertificateId.new(@cert, @ca_cert, OpenSSL::Digest.new('SHA1'))
-    bres.add_status(cid, OpenSSL::OCSP::V_CERTSTATUS_GOOD, 0, nil, -300, 500, [])
-    bres.sign(@ocsp_cert, @ocsp_key, [@ca_cert], 0)
-    res = OpenSSL::OCSP::Response.create(OpenSSL::OCSP::RESPONSE_STATUS_SUCCESSFUL, bres)
-    der = res.to_der
-    asn1 = OpenSSL::ASN1.decode(der)
-    assert_equal OpenSSL::OCSP::RESPONSE_STATUS_SUCCESSFUL, asn1.value[0].value
-    assert_equal OpenSSL::ASN1.ObjectId("basicOCSPResponse").to_der, asn1.value[1].value[0].value[0].to_der
-    assert_equal bres.to_der, asn1.value[1].value[0].value[1].value
-    assert_equal der, OpenSSL::OCSP::Response.new(der).to_der
-  end
-
-  def test_response_dup
-    bres = OpenSSL::OCSP::BasicResponse.new
-    bres.sign(@ocsp_cert, @ocsp_key, [@ca_cert], 0)
-    res = OpenSSL::OCSP::Response.create(OpenSSL::OCSP::RESPONSE_STATUS_SUCCESSFUL, bres)
-    assert_equal res.to_der, res.dup.to_der
-  end
-end
-
-end
diff --git a/test/openssl/test_ossl.rb b/test/openssl/test_ossl.rb
deleted file mode 100644
index e1d86bd..0000000
--- a/test/openssl/test_ossl.rb
+++ /dev/null
@@ -1,65 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-require 'benchmark'
-
-if defined?(OpenSSL)
-
-class OpenSSL::OSSL < OpenSSL::SSLTestCase
-  def test_fixed_length_secure_compare
-    assert_raise(ArgumentError) { OpenSSL.fixed_length_secure_compare("aaa", "a") }
-    assert_raise(ArgumentError) { OpenSSL.fixed_length_secure_compare("aaa", "aa") }
-
-    assert OpenSSL.fixed_length_secure_compare("aaa", "aaa")
-    assert OpenSSL.fixed_length_secure_compare(
-      OpenSSL::Digest.digest('SHA256', "aaa"), OpenSSL::Digest::SHA256.digest("aaa")
-    )
-
-    assert_raise(ArgumentError) { OpenSSL.fixed_length_secure_compare("aaa", "aaaa") }
-    refute OpenSSL.fixed_length_secure_compare("aaa", "baa")
-    refute OpenSSL.fixed_length_secure_compare("aaa", "aba")
-    refute OpenSSL.fixed_length_secure_compare("aaa", "aab")
-    assert_raise(ArgumentError) { OpenSSL.fixed_length_secure_compare("aaa", "aaab") }
-    assert_raise(ArgumentError) { OpenSSL.fixed_length_secure_compare("aaa", "b") }
-    assert_raise(ArgumentError) { OpenSSL.fixed_length_secure_compare("aaa", "bb") }
-    refute OpenSSL.fixed_length_secure_compare("aaa", "bbb")
-    assert_raise(ArgumentError) { OpenSSL.fixed_length_secure_compare("aaa", "bbbb") }
-  end
-
-  def test_secure_compare
-    refute OpenSSL.secure_compare("aaa", "a")
-    refute OpenSSL.secure_compare("aaa", "aa")
-
-    assert OpenSSL.secure_compare("aaa", "aaa")
-
-    refute OpenSSL.secure_compare("aaa", "aaaa")
-    refute OpenSSL.secure_compare("aaa", "baa")
-    refute OpenSSL.secure_compare("aaa", "aba")
-    refute OpenSSL.secure_compare("aaa", "aab")
-    refute OpenSSL.secure_compare("aaa", "aaab")
-    refute OpenSSL.secure_compare("aaa", "b")
-    refute OpenSSL.secure_compare("aaa", "bb")
-    refute OpenSSL.secure_compare("aaa", "bbb")
-    refute OpenSSL.secure_compare("aaa", "bbbb")
-  end
-
-  def test_memcmp_timing
-    # Ensure using fixed_length_secure_compare takes almost exactly the same amount of time to compare two different strings.
-    # Regular string comparison will short-circuit on the first non-matching character, failing this test.
-    # NOTE: this test may be susceptible to noise if the system running the tests is otherwise under load.
-    a = "x" * 512_000
-    b = "#{a}y"
-    c = "y#{a}"
-    a = "#{a}x"
-
-    a_b_time = a_c_time = 0
-    100.times do
-      a_b_time += Benchmark.measure { 100.times { OpenSSL.fixed_length_secure_compare(a, b) } }.real
-      a_c_time += Benchmark.measure { 100.times { OpenSSL.fixed_length_secure_compare(a, c) } }.real
-    end
-    assert_operator(a_b_time, :<, a_c_time * 10, "fixed_length_secure_compare timing test failed")
-    assert_operator(a_c_time, :<, a_b_time * 10, "fixed_length_secure_compare timing test failed")
-  end
-end
-
-end
diff --git a/test/openssl/test_pair.rb b/test/openssl/test_pair.rb
deleted file mode 100644
index 8316ec2..0000000
--- a/test/openssl/test_pair.rb
+++ /dev/null
@@ -1,509 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-require_relative 'ut_eof'
-
-if defined?(OpenSSL)
-
-module OpenSSL::SSLPairM
-  def setup
-    svr_dn = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=localhost")
-    ee_exts = [
-      ["keyUsage", "keyEncipherment,digitalSignature", true],
-    ]
-    @svr_key = OpenSSL::TestUtils::Fixtures.pkey("rsa-1")
-    @svr_cert = issue_cert(svr_dn, @svr_key, 1, ee_exts, nil, nil)
-  end
-
-  def ssl_pair
-    host = "127.0.0.1"
-    tcps = create_tcp_server(host, 0)
-    port = tcps.connect_address.ip_port
-
-    th = Thread.new {
-      sctx = OpenSSL::SSL::SSLContext.new
-      sctx.cert = @svr_cert
-      sctx.key = @svr_key
-      sctx.tmp_dh_callback = proc { OpenSSL::TestUtils::Fixtures.pkey("dh-1") }
-      sctx.options |= OpenSSL::SSL::OP_NO_COMPRESSION
-      ssls = OpenSSL::SSL::SSLServer.new(tcps, sctx)
-      ns = ssls.accept
-      ssls.close
-      ns
-    }
-
-    tcpc = create_tcp_client(host, port)
-    c = OpenSSL::SSL::SSLSocket.new(tcpc)
-    c.connect
-    s = th.value
-
-    yield c, s
-  ensure
-    tcpc&.close
-    tcps&.close
-    s&.close
-  end
-end
-
-module OpenSSL::SSLPair
-  include OpenSSL::SSLPairM
-
-  def create_tcp_server(host, port)
-    TCPServer.new(host, port)
-  end
-
-  def create_tcp_client(host, port)
-    TCPSocket.new(host, port)
-  end
-end
-
-module OpenSSL::SSLPairLowlevelSocket
-  include OpenSSL::SSLPairM
-
-  def create_tcp_server(host, port)
-    Addrinfo.tcp(host, port).listen
-  end
-
-  def create_tcp_client(host, port)
-    Addrinfo.tcp(host, port).connect
-  end
-end
-
-module OpenSSL::TestEOF1M
-  def open_file(content)
-    ssl_pair { |s1, s2|
-      begin
-        th = Thread.new { s2 << content; s2.close }
-        yield s1
-      ensure
-        th&.join
-      end
-    }
-  end
-end
-
-module OpenSSL::TestEOF2M
-  def open_file(content)
-    ssl_pair { |s1, s2|
-      begin
-        th = Thread.new { s1 << content; s1.close }
-        yield s2
-      ensure
-        th&.join
-      end
-    }
-  end
-end
-
-module OpenSSL::TestPairM
-  def test_getc
-    ssl_pair {|s1, s2|
-      s1 << "a"
-      assert_equal(?a, s2.getc)
-    }
-  end
-
-  def test_gets
-    ssl_pair {|s1, s2|
-      s1 << "abc\n\n$def123ghi"
-      s1.close
-      ret = s2.gets
-      assert_equal Encoding::BINARY, ret.encoding
-      assert_equal "abc\n", ret
-      assert_equal "\n$", s2.gets("$")
-      assert_equal "def123", s2.gets(/\d+/)
-      assert_equal "ghi", s2.gets
-      assert_equal nil, s2.gets
-    }
-  end
-
-  def test_gets_eof_limit
-    ssl_pair {|s1, s2|
-      s1.write("hello")
-      s1.close # trigger EOF
-      assert_match "hello", s2.gets("\n", 6), "[ruby-core:70149] [Bug #11400]"
-    }
-  end
-
-  def test_readpartial
-    ssl_pair {|s1, s2|
-      s2.write "a\nbcd"
-      assert_equal("a\n", s1.gets)
-      result = String.new
-      result << s1.readpartial(10) until result.length == 3
-      assert_equal("bcd", result)
-      s2.write "efg"
-      result = String.new
-      result << s1.readpartial(10) until result.length == 3
-      assert_equal("efg", result)
-      s2.close
-      assert_raise(EOFError) { s1.readpartial(10) }
-      assert_raise(EOFError) { s1.readpartial(10) }
-      assert_equal("", s1.readpartial(0))
-    }
-  end
-
-  def test_readall
-    ssl_pair {|s1, s2|
-      s2.close
-      assert_equal("", s1.read)
-    }
-  end
-
-  def test_readline
-    ssl_pair {|s1, s2|
-      s2.close
-      assert_raise(EOFError) { s1.readline }
-    }
-  end
-
-  def test_puts_empty
-    ssl_pair {|s1, s2|
-      s1.puts
-      s1.close
-      assert_equal("\n", s2.read)
-    }
-  end
-
-  def test_multibyte_read_write
-    # German a umlaut
-    auml = [%w{ C3 A4 }.join('')].pack('H*')
-    auml.force_encoding(Encoding::UTF_8)
-    bsize = auml.bytesize
-
-    ssl_pair { |s1, s2|
-      assert_equal bsize, s1.write(auml)
-      read = s2.read(bsize)
-      assert_equal Encoding::ASCII_8BIT, read.encoding
-      assert_equal bsize, read.bytesize
-      assert_equal auml, read.force_encoding(Encoding::UTF_8)
-
-      s1.puts(auml)
-      read = s2.gets
-      assert_equal Encoding::ASCII_8BIT, read.encoding
-      assert_equal bsize + 1, read.bytesize
-      assert_equal auml + "\n", read.force_encoding(Encoding::UTF_8)
-    }
-  end
-
-  def test_read_nonblock
-    ssl_pair {|s1, s2|
-      err = nil
-      assert_raise(OpenSSL::SSL::SSLErrorWaitReadable) {
-        begin
-          s2.read_nonblock(10)
-        ensure
-          err = $!
-        end
-      }
-      assert_kind_of(IO::WaitReadable, err)
-      s1.write "abc\ndef\n"
-      IO.select([s2])
-      assert_equal("ab", s2.read_nonblock(2))
-      assert_equal("c\n", s2.gets)
-      ret = nil
-      assert_nothing_raised("[ruby-core:20298]") { ret = s2.read_nonblock(10) }
-      assert_equal("def\n", ret)
-      s1.close
-      IO.select([s2])
-      assert_raise(EOFError) { s2.read_nonblock(10) }
-    }
-  end
-
-  def test_read_nonblock_no_exception
-    ssl_pair {|s1, s2|
-      assert_equal :wait_readable, s2.read_nonblock(10, exception: false)
-      s1.write "abc\ndef\n"
-      IO.select([s2])
-      assert_equal("ab", s2.read_nonblock(2, exception: false))
-      assert_equal("c\n", s2.gets)
-      ret = nil
-      assert_nothing_raised("[ruby-core:20298]") { ret = s2.read_nonblock(10, exception: false) }
-      assert_equal("def\n", ret)
-      s1.close
-      IO.select([s2])
-      assert_equal(nil, s2.read_nonblock(10, exception: false))
-    }
-  end
-
-  def test_read_with_outbuf
-    ssl_pair { |s1, s2|
-      s1.write("abc\n")
-      buf = String.new
-      ret = s2.read(2, buf)
-      assert_same ret, buf
-      assert_equal "ab", ret
-
-      buf = +"garbage"
-      ret = s2.read(2, buf)
-      assert_same ret, buf
-      assert_equal "c\n", ret
-
-      buf = +"garbage"
-      assert_equal :wait_readable, s2.read_nonblock(100, buf, exception: false)
-      assert_equal "", buf
-
-      s1.close
-      buf = +"garbage"
-      assert_equal nil, s2.read(100, buf)
-      assert_equal "", buf
-    }
-  end
-
-  def test_write_nonblock
-    ssl_pair {|s1, s2|
-      assert_equal 3, s1.write_nonblock("foo")
-      assert_equal "foo", s2.read(3)
-
-      data = "x" * 16384
-      written = 0
-      while true
-        begin
-          written += s1.write_nonblock(data)
-        rescue IO::WaitWritable, IO::WaitReadable
-          break
-        end
-      end
-      assert written > 0
-      assert_equal written, s2.read(written).bytesize
-    }
-  end
-
-  def test_write_nonblock_no_exceptions
-    ssl_pair {|s1, s2|
-      assert_equal 3, s1.write_nonblock("foo", exception: false)
-      assert_equal "foo", s2.read(3)
-
-      data = "x" * 16384
-      written = 0
-      while true
-        case ret = s1.write_nonblock(data, exception: false)
-        when :wait_readable, :wait_writable
-          break
-        else
-          written += ret
-        end
-      end
-      assert written > 0
-      assert_equal written, s2.read(written).bytesize
-    }
-  end
-
-  def test_write_nonblock_with_buffered_data
-    ssl_pair {|s1, s2|
-      s1.write "foo"
-      s1.write_nonblock("bar")
-      s1.write "baz"
-      s1.close
-      assert_equal("foobarbaz", s2.read)
-    }
-  end
-
-  def test_write_nonblock_with_buffered_data_no_exceptions
-    ssl_pair {|s1, s2|
-      s1.write "foo"
-      s1.write_nonblock("bar", exception: false)
-      s1.write "baz"
-      s1.close
-      assert_equal("foobarbaz", s2.read)
-    }
-  end
-
-  def test_write_nonblock_retry
-    ssl_pair {|s1, s2|
-      # fill up a socket so we hit EAGAIN
-      written = String.new
-      n = 0
-      buf = 'a' * 4099
-      case ret = s1.write_nonblock(buf, exception: false)
-      when :wait_readable then break
-      when :wait_writable then break
-      when Integer
-        written << buf
-        n += ret
-        exp = buf.bytesize
-        if ret != exp
-          buf = buf.byteslice(ret, exp - ret)
-        end
-      end while true
-      assert_kind_of Symbol, ret
-
-      # make more space for subsequent write:
-      readed = s2.read(n)
-      assert_equal written, readed
-
-      # this fails if SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER is missing:
-      buf2 = Marshal.load(Marshal.dump(buf))
-      assert_kind_of Integer, s1.write_nonblock(buf2, exception: false)
-    }
-  end
-
-  def test_write_zero
-    ssl_pair {|s1, s2|
-      assert_equal 0, s2.write_nonblock('', exception: false)
-      assert_kind_of Symbol, s1.read_nonblock(1, exception: false)
-      assert_equal 0, s2.syswrite('')
-      assert_kind_of Symbol, s1.read_nonblock(1, exception: false)
-      assert_equal 0, s2.write('')
-      assert_kind_of Symbol, s1.read_nonblock(1, exception: false)
-    }
-  end
-
-  def test_write_multiple_arguments
-    ssl_pair {|s1, s2|
-      str1 = "foo"; str2 = "bar"
-      assert_equal 6, s1.write(str1, str2)
-      s1.close
-      assert_equal "foobar", s2.read
-    }
-  end
-
-  def test_partial_tls_record_read_nonblock
-    ssl_pair { |s1, s2|
-      # the beginning of a TLS record
-      s1.io.write("\x17")
-      # should raise a IO::WaitReadable since a full TLS record is not available
-      # for reading
-      assert_raise(IO::WaitReadable) { s2.read_nonblock(1) }
-    }
-  end
-
-  def tcp_pair
-    host = "127.0.0.1"
-    serv = TCPServer.new(host, 0)
-    port = serv.connect_address.ip_port
-    sock1 = TCPSocket.new(host, port)
-    sock2 = serv.accept
-    serv.close
-    [sock1, sock2]
-  ensure
-    serv.close if serv && !serv.closed?
-  end
-
-  def test_connect_accept_nonblock_no_exception
-    ctx2 = OpenSSL::SSL::SSLContext.new
-    ctx2.cert = @svr_cert
-    ctx2.key = @svr_key
-    ctx2.tmp_dh_callback = proc { OpenSSL::TestUtils::Fixtures.pkey("dh-1") }
-
-    sock1, sock2 = tcp_pair
-
-    s2 = OpenSSL::SSL::SSLSocket.new(sock2, ctx2)
-    accepted = s2.accept_nonblock(exception: false)
-    assert_equal :wait_readable, accepted
-
-    ctx1 = OpenSSL::SSL::SSLContext.new
-    s1 = OpenSSL::SSL::SSLSocket.new(sock1, ctx1)
-    th = Thread.new do
-      rets = []
-      begin
-        rv = s1.connect_nonblock(exception: false)
-        rets << rv
-        case rv
-        when :wait_writable
-          IO.select(nil, [s1], nil, 5)
-        when :wait_readable
-          IO.select([s1], nil, nil, 5)
-        end
-      end until rv == s1
-      rets
-    end
-
-    until th.join(0.01)
-      accepted = s2.accept_nonblock(exception: false)
-      assert_include([s2, :wait_readable, :wait_writable ], accepted)
-    end
-
-    rets = th.value
-    assert_instance_of Array, rets
-    rets.each do |rv|
-      assert_include([s1, :wait_readable, :wait_writable ], rv)
-    end
-  ensure
-    th.join if th
-    s1.close if s1
-    s2.close if s2
-    sock1.close if sock1
-    sock2.close if sock2
-    accepted.close if accepted.respond_to?(:close)
-  end
-
-  def test_connect_accept_nonblock
-    ctx = OpenSSL::SSL::SSLContext.new
-    ctx.cert = @svr_cert
-    ctx.key = @svr_key
-    ctx.tmp_dh_callback = proc { OpenSSL::TestUtils::Fixtures.pkey("dh-1") }
-
-    sock1, sock2 = tcp_pair
-
-    th = Thread.new {
-      s2 = OpenSSL::SSL::SSLSocket.new(sock2, ctx)
-      5.times {
-        begin
-          break s2.accept_nonblock
-        rescue IO::WaitReadable
-          IO.select([s2], nil, nil, 1)
-        rescue IO::WaitWritable
-          IO.select(nil, [s2], nil, 1)
-        end
-        sleep 0.2
-      }
-    }
-
-    s1 = OpenSSL::SSL::SSLSocket.new(sock1)
-    5.times {
-      begin
-        break s1.connect_nonblock
-      rescue IO::WaitReadable
-        IO.select([s1], nil, nil, 1)
-      rescue IO::WaitWritable
-        IO.select(nil, [s1], nil, 1)
-      end
-      sleep 0.2
-    }
-
-    s2 = th.value
-
-    s1.print "a\ndef"
-    assert_equal("a\n", s2.gets)
-  ensure
-    sock1&.close
-    sock2&.close
-    th&.join
-  end
-end
-
-class OpenSSL::TestEOF1 < OpenSSL::TestCase
-  include OpenSSL::TestEOF
-  include OpenSSL::SSLPair
-  include OpenSSL::TestEOF1M
-end
-
-class OpenSSL::TestEOF1LowlevelSocket < OpenSSL::TestCase
-  include OpenSSL::TestEOF
-  include OpenSSL::SSLPairLowlevelSocket
-  include OpenSSL::TestEOF1M
-end
-
-class OpenSSL::TestEOF2 < OpenSSL::TestCase
-  include OpenSSL::TestEOF
-  include OpenSSL::SSLPair
-  include OpenSSL::TestEOF2M
-end
-
-class OpenSSL::TestEOF2LowlevelSocket < OpenSSL::TestCase
-  include OpenSSL::TestEOF
-  include OpenSSL::SSLPairLowlevelSocket
-  include OpenSSL::TestEOF2M
-end
-
-class OpenSSL::TestPair < OpenSSL::TestCase
-  include OpenSSL::SSLPair
-  include OpenSSL::TestPairM
-end
-
-class OpenSSL::TestPairLowlevelSocket < OpenSSL::TestCase
-  include OpenSSL::SSLPairLowlevelSocket
-  include OpenSSL::TestPairM
-end
-
-end
diff --git a/test/openssl/test_pkcs12.rb b/test/openssl/test_pkcs12.rb
deleted file mode 100644
index fdbe753..0000000
--- a/test/openssl/test_pkcs12.rb
+++ /dev/null
@@ -1,313 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-module OpenSSL
-  class TestPKCS12 < OpenSSL::TestCase
-    def setup
-      super
-      ca = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=CA")
-      ca_exts = [
-        ["basicConstraints","CA:TRUE",true],
-        ["keyUsage","keyCertSign, cRLSign",true],
-        ["subjectKeyIdentifier","hash",false],
-        ["authorityKeyIdentifier","keyid:always",false],
-      ]
-      @cacert = issue_cert(ca, Fixtures.pkey("rsa2048"), 1, ca_exts, nil, nil)
-
-      inter_ca = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=Intermediate CA")
-      inter_ca_key = OpenSSL::PKey.read <<-_EOS_
------BEGIN RSA PRIVATE KEY-----
-MIICXAIBAAKBgQDp7hIG0SFMG/VWv1dBUWziAPrNmkMXJgTCAoB7jffzRtyyN04K
-oq/89HAszTMStZoMigQURfokzKsjpUp8OYCAEsBtt9d5zPndWMz/gHN73GrXk3LT
-ZsxEn7Xv5Da+Y9F/Hx2QZUHarV5cdZixq2NbzWGwrToogOQMh2pxN3Z/0wIDAQAB
-AoGBAJysUyx3olpsGzv3OMRJeahASbmsSKTXVLZvoIefxOINosBFpCIhZccAG6UV
-5c/xCvS89xBw8aD15uUfziw3AuT8QPEtHCgfSjeT7aWzBfYswEgOW4XPuWr7EeI9
-iNHGD6z+hCN/IQr7FiEBgTp6A+i/hffcSdR83fHWKyb4M7TRAkEA+y4BNd668HmC
-G5MPRx25n6LixuBxrNp1umfjEI6UZgEFVpYOg4agNuimN6NqM253kcTR94QNTUs5
-Kj3EhG1YWwJBAO5rUjiOyCNVX2WUQrOMYK/c1lU7fvrkdygXkvIGkhsPoNRzLPeA
-HGJszKtrKD8bNihWpWNIyqKRHfKVD7yXT+kCQGCAhVCIGTRoypcDghwljHqLnysf
-ci0h5ZdPcIqc7ODfxYhFsJ/Rql5ONgYsT5Ig/+lOQAkjf+TRYM4c2xKx2/8CQBvG
-jv6dy70qDgIUgqzONtlmHeYyFzn9cdBO5sShdVYHvRHjFSMEXsosqK9zvW2UqvuK
-FJx7d3f29gkzynCLJDkCQGQZlEZJC4vWmWJGRKJ24P6MyQn3VsPfErSKOg4lvyM3
-Li8JsX5yIiuVYaBg/6ha3tOg4TCa5K/3r3tVliRZ2Es=
------END RSA PRIVATE KEY-----
-      _EOS_
-      @inter_cacert = issue_cert(inter_ca, inter_ca_key, 2, ca_exts, @cacert, Fixtures.pkey("rsa2048"))
-
-      exts = [
-        ["keyUsage","digitalSignature",true],
-        ["subjectKeyIdentifier","hash",false],
-      ]
-      ee = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=Ruby PKCS12 Test Certificate")
-      @mykey = Fixtures.pkey("rsa1024")
-      @mycert = issue_cert(ee, @mykey, 3, exts, @inter_cacert, inter_ca_key)
-    end
-
-    def test_create
-      pkcs12 = OpenSSL::PKCS12.create(
-        "omg",
-        "hello",
-        @mykey,
-        @mycert
-      )
-      assert_equal @mycert.to_der, pkcs12.certificate.to_der
-      assert_equal @mykey.to_der, pkcs12.key.to_der
-      assert_nil pkcs12.ca_certs
-    end
-
-    def test_create_no_pass
-      pkcs12 = OpenSSL::PKCS12.create(
-        nil,
-        "hello",
-        @mykey,
-        @mycert
-      )
-      assert_equal @mycert.to_der, pkcs12.certificate.to_der
-      assert_equal @mykey.to_der, pkcs12.key.to_der
-      assert_nil pkcs12.ca_certs
-
-      decoded = OpenSSL::PKCS12.new(pkcs12.to_der)
-      assert_cert @mycert, decoded.certificate
-    end
-
-    def test_create_with_chain
-      chain = [@inter_cacert, @cacert]
-
-      pkcs12 = OpenSSL::PKCS12.create(
-        "omg",
-        "hello",
-        @mykey,
-        @mycert,
-        chain
-      )
-      assert_equal chain, pkcs12.ca_certs
-    end
-
-    def test_create_with_chain_decode
-      chain = [@cacert, @inter_cacert]
-
-      passwd = "omg"
-
-      pkcs12 = OpenSSL::PKCS12.create(
-        passwd,
-        "hello",
-        @mykey,
-        @mycert,
-        chain
-      )
-
-      decoded = OpenSSL::PKCS12.new(pkcs12.to_der, passwd)
-      assert_equal chain.size, decoded.ca_certs.size
-      assert_include_cert @cacert, decoded.ca_certs
-      assert_include_cert @inter_cacert, decoded.ca_certs
-      assert_cert @mycert, decoded.certificate
-      assert_equal @mykey.to_der, decoded.key.to_der
-    end
-
-    def test_create_with_bad_nid
-      assert_raise(ArgumentError) do
-        OpenSSL::PKCS12.create(
-          "omg",
-          "hello",
-          @mykey,
-          @mycert,
-          [],
-          "foo"
-        )
-      end
-    end
-
-    def test_create_with_itr
-      OpenSSL::PKCS12.create(
-        "omg",
-        "hello",
-        @mykey,
-        @mycert,
-        [],
-        nil,
-        nil,
-        2048
-      )
-
-      assert_raise(TypeError) do
-        OpenSSL::PKCS12.create(
-          "omg",
-          "hello",
-          @mykey,
-          @mycert,
-          [],
-          nil,
-          nil,
-          "omg"
-        )
-      end
-    end
-
-    def test_create_with_mac_itr
-      OpenSSL::PKCS12.create(
-        "omg",
-        "hello",
-        @mykey,
-        @mycert,
-        [],
-        nil,
-        nil,
-        nil,
-        2048
-      )
-
-      assert_raise(TypeError) do
-        OpenSSL::PKCS12.create(
-          "omg",
-          "hello",
-          @mykey,
-          @mycert,
-          [],
-          nil,
-          nil,
-          nil,
-          "omg"
-        )
-      end
-    end
-
-    def test_new_with_one_key_and_one_cert
-      # generated with:
-      #   openssl version #=> OpenSSL 1.0.2h  3 May 2016
-      #   openssl pkcs12 -in <@mycert> -inkey <RSA1024> -export -out <out>
-      str = <<~EOF.unpack("m").first
-MIIGQQIBAzCCBgcGCSqGSIb3DQEHAaCCBfgEggX0MIIF8DCCAu8GCSqGSIb3DQEH
-BqCCAuAwggLcAgEAMIIC1QYJKoZIhvcNAQcBMBwGCiqGSIb3DQEMAQYwDgQIeZPM
-Rh6KiXgCAggAgIICqL6O+LCZmBzdIg6mozPF3FpY0hVbWHvTNMiDHieW3CrAanhN
-YCH2/wHqH8WpFpEWwF0qEEXAWjHsIlYB4Cfqo6b7XpuZe5eVESsjNTOTMF1JCUJj
-A6iNefXmCFLync1JK5LUodRDhTlKLU1WPK20X9X4vuEwHn8wt5RUb8P0E+Xh6rpS
-XC4LkZKT45zF3cJa/n5+dW65ohVGNVnF9D1bCNEKHMOllK1V9omutQ9slW88hpga
-LGiFsJoFOb/ESGb78KO+bd6zbX1MdKdBV+WD6t1uF/cgU65y+2A4nXs1urda+MJ7
-7iVqiB7Vnc9cANTbAkTSGNyoUDVM/NZde782/8IvddLAzUZ2EftoRDke6PvuBOVL
-ljBhNWmdamrtBqzuzVZCRdWq44KZkF2Xoc9asepwIkdVmntzQF7f1Z+Ta5yg6HFp
-xnr7CuM+MlHEShXkMgYtHnwAq10fDMSXIvjhi/AA5XUAusDO3D+hbtcRDcJ4uUes
-dm5dhQE2qJ02Ysn4aH3o1F3RYNOzrxejHJwl0D2TCE8Ww2X342xib57+z9u03ufj
-jswhiMKxy67f1LhUMq3XrT3uV6kCVXk/KUOUPcXPlPVNA5JmZeFhMp6GrtB5xJJ9
-wwBZD8UL5A2U2Mxi2OZsdUBv8eo3jnjZ284aFpt+mCjIHrLW5O0jwY8OCwSlYUoY
-IY00wlabX0s82kBcIQNZbC1RSV2267ro/7A0MClc8YQ/zWN0FKY6apgtUkHJI1cL
-1dc77mhnjETjwW94iLMDFy4zQfVu7IfCBqOBzygRNnqqUG66UhTs1xFnWM0mWXl/
-Zh9+AMpbRLIPaKCktIjl5juzzm+KEgkhD+707XRCFIGUYGP5bSHzGaz8PK9hj0u1
-E2SpZHUvYOcawmxtA7pmpSxl5uQjMIIC+QYJKoZIhvcNAQcBoIIC6gSCAuYwggLi
-MIIC3gYLKoZIhvcNAQwKAQKgggKmMIICojAcBgoqhkiG9w0BDAEDMA4ECKB338m8
-qSzHAgIIAASCAoACFhJeqA3xx+s1qIH6udNQYY5hAL6oz7SXoGwFhDiceSyJjmAD
-Dby9XWM0bPl1Gj5nqdsuI/lAM++fJeoETk+rxw8q6Ofk2zUaRRE39qgpwBwSk44o
-0SAFJ6bzHpc5CFh6sZmDaUX5Lm9GtjnGFmmsPTSJT5an5JuJ9WczGBEd0nSBQhJq
-xHbTGZiN8i3SXcIH531Sub+CBIFWy5lyCKgDYh/kgJFGQAaWUOjLI+7dCEESonXn
-F3Jh2uPbnDF9MGJyAFoNgWFhgSpi1cf6AUi87GY4Oyur88ddJ1o0D0Kz2uw8/bpG
-s3O4PYnIW5naZ8mozzbnYByEFk7PoTwM7VhoFBfYNtBoAI8+hBnPY/Y71YUojEXf
-SeX6QbtkIANfzS1XuFNKElShC3DPQIHpKzaatEsfxHfP+8VOav6zcn4mioao7NHA
-x7Dp6R1enFGoQOq4UNjBT8YjnkG5vW8zQHW2dAHLTJBq6x2Fzm/4Pjo/8vM1FiGl
-BQdW5vfDeJ/l6NgQm3xR9ka2E2HaDqIcj1zWbN8jy/bHPFJYuF/HH8MBV/ngMIXE
-vFEW/ToYv8eif0+EpUtzBsCKD4a7qYYYh87RmEVoQU96q6m+UbhpD2WztYfAPkfo
-OSL9j2QHhVczhL7OAgqNeM95pOsjA9YMe7exTeqK31LYnTX8oH8WJD1xGbRSJYgu
-SY6PQbumcJkc/TFPn0GeVUpiDdf83SeG50lo/i7UKQi2l1hi5Y51fQhnBnyMr68D
-llSZEvSWqfDxBJkBpeg6PIYvkTpEwKRJpVQoM3uYvdqVSSnW6rydqIb+snfOrlhd
-f+xCtq9xr+kHeTSqLIDRRAnMfgFRhY3IBlj6MSUwIwYJKoZIhvcNAQkVMRYEFBdb
-8XGWehZ6oPj56Pf/uId46M9AMDEwITAJBgUrDgMCGgUABBRvSCB04/f8f13pp2PF
-vyl2WuMdEwQIMWFFphPkIUICAggA
-      EOF
-      p12 = OpenSSL::PKCS12.new(str, "abc123")
-
-      assert_equal @mykey.to_der, p12.key.to_der
-      assert_equal @mycert.subject.to_der, p12.certificate.subject.to_der
-      assert_equal [], Array(p12.ca_certs)
-    end
-
-    def test_new_with_no_keys
-      # generated with:
-      #   openssl pkcs12 -in <@mycert> -nokeys -export -out <out>
-      str = <<~EOF.unpack("m").first
-MIIDHAIBAzCCAuIGCSqGSIb3DQEHAaCCAtMEggLPMIICyzCCAscGCSqGSIb3DQEH
-BqCCArgwggK0AgEAMIICrQYJKoZIhvcNAQcBMBwGCiqGSIb3DQEMAQYwDgQIX4+W
-irqwH40CAggAgIICgOaCyo+5+6IOVoGCCL80c50bkkzAwqdXxvkKExJSdcJz2uMU
-0gRrKnZEjL5wrUsN8RwZu8DvgQTEhNEkKsUgM7AWainmN/EnwohIdHZAHpm6WD67
-I9kLGp0/DHrqZrV9P2dLfhXLUSQE8PI0tqZPZ8UEABhizkViw4eISTkrOUN7pGbN
-Qtx/oqgitXDuX2polbxYYDwt9vfHZhykHoKgew26SeJyZfeMs/WZ6olEI4cQUAFr
-mvYGuC1AxEGTo9ERmU8Pm16j9Hr9PFk50WYe+rnk9oX3wJogQ7XUWS5kYf7XRycd
-NDkNiwV/ts94bbuaGZp1YA6I48FXpIc8b5fX7t9tY0umGaWy0bARe1L7o0Y89EPe
-lMg25rOM7j3uPtFG8whbSfdETSy57UxzzTcJ6UwexeaK6wb2jqEmj5AOoPLWeaX0
-LyOAszR3v7OPAcjIDYZGdrbb3MZ2f2vo2pdQfu9698BrWhXuM7Odh73RLhJVreNI
-aezNOAtPyBlvGiBQBGTzRIYHSLL5Y5aVj2vWLAa7hjm5qTL5C5mFdDIo6TkEMr6I
-OsexNQofEGs19kr8nARXDlcbEimk2VsPj4efQC2CEXZNzURsKca82pa62MJ8WosB
-DTFd8X06zZZ4nED50vLopZvyW4fyW60lELwOyThAdG8UchoAaz2baqP0K4de44yM
-Y5/yPFDu4+GoimipJfbiYviRwbzkBxYW8+958ILh0RtagLbvIGxbpaym9PqGjOzx
-ShNXjLK2aAFZsEizQ8kd09quJHU/ogq2cUXdqqhmOqPnUWrJVi/VCoRB3Pv1/lE4
-mrUgr2YZ11rYvBw6g5XvNvFcSc53OKyV7SLn0dwwMTAhMAkGBSsOAwIaBQAEFEWP
-1WRQykaoD4uJCpTx/wv0SLLBBAiDKI26LJK7xgICCAA=
-      EOF
-      p12 = OpenSSL::PKCS12.new(str, "abc123")
-
-      assert_equal nil, p12.key
-      assert_equal nil, p12.certificate
-      assert_equal 1, p12.ca_certs.size
-      assert_equal @mycert.subject.to_der, p12.ca_certs[0].subject.to_der
-    end
-
-    def test_new_with_no_certs
-      # generated with:
-      #   openssl pkcs12 -inkey <RSA1024> -nocerts -export -out <out>
-      str = <<~EOF.unpack("m").first
-MIIDJwIBAzCCAu0GCSqGSIb3DQEHAaCCAt4EggLaMIIC1jCCAtIGCSqGSIb3DQEH
-AaCCAsMEggK/MIICuzCCArcGCyqGSIb3DQEMCgECoIICpjCCAqIwHAYKKoZIhvcN
-AQwBAzAOBAg6AaYnJs84SwICCAAEggKAQzZH+fWSpcQYD1J7PsGSune85A++fLCQ
-V7tacp2iv95GJkxwYmfTP176pJdgs00mceB9UJ/u9EX5nD0djdjjQjwo6sgKjY0q
-cpVhZw8CMxw7kBD2dhtui0zT8z5hy03LePxsjEKsGiSbeVeeGbSfw/I6AAYbv+Uh
-O/YPBGumeHj/D2WKnfsHJLQ9GAV3H6dv5VKYNxjciK7f/JEyZCuUQGIN64QFHDhJ
-7fzLqd/ul3FZzJZO6a+dwvcgux09SKVXDRSeFmRCEX4b486iWhJJVspCo9P2KNne
-ORrpybr3ZSwxyoICmjyo8gj0OSnEfdx9790Ej1takPqSA1wIdSdBLekbZqB0RBQg
-DEuPOsXNo3QFi8ji1vu0WBRJZZSNC2hr5NL6lNR+DKxG8yzDll2j4W4BBIp22mAE
-7QRX7kVxu17QJXQhOUac4Dd1qXmzebP8t6xkAxD9L7BWEN5OdiXWwSWGjVjMBneX
-nYObi/3UT/aVc5WHMHK2BhCI1bwH51E6yZh06d5m0TQpYGUTWDJdWGBSrp3A+8jN
-N2PMQkWBFrXP3smHoTEN4oZC4FWiPsIEyAkQsfKRhcV9lGKl2Xgq54ROTFLnwKoj
-Z3zJScnq9qmNzvVZSMmDLkjLyDq0pxRxGKBvgouKkWY7VFFIwwBIJM39iDJ5NbBY
-i1AQFTRsRSsZrNVPasCXrIq7bhMoJZb/YZOGBLNyJVqKUoYXhtwsajzSq54VlWft
-JxsPayEd4Vi6O9EU1ahnj6qFEZiKFzsicgK2J1Rb8cYagrp0XWjHW0SBn5GVUWCg
-GUokSFG/0JTdeYTo/sQuG4qNgJkOolRjpeI48Fciq5VUWLvVdKioXzAxMCEwCQYF
-Kw4DAhoFAAQUYAuwVtGD1TdgbFK4Yal2XBgwUR4ECEawsN3rNaa6AgIIAA==
-      EOF
-      p12 = OpenSSL::PKCS12.new(str, "abc123")
-
-      assert_equal @mykey.to_der, p12.key.to_der
-      assert_equal nil, p12.certificate
-      assert_equal [], Array(p12.ca_certs)
-    end
-
-    def test_dup
-      p12 = OpenSSL::PKCS12.create("pass", "name", @mykey, @mycert)
-      assert_equal p12.to_der, p12.dup.to_der
-    end
-
-    private
-    def assert_cert expected, actual
-      [
-        :subject,
-        :issuer,
-        :serial,
-        :not_before,
-        :not_after,
-      ].each do |attribute|
-        assert_equal expected.send(attribute), actual.send(attribute)
-      end
-      assert_equal expected.to_der, actual.to_der
-    end
-
-    def assert_include_cert cert, ary
-      der = cert.to_der
-      ary.each do |candidate|
-        if candidate.to_der == der
-          return true
-        end
-      end
-      false
-    end
-  end
-end
-
-end
diff --git a/test/openssl/test_pkcs7.rb b/test/openssl/test_pkcs7.rb
deleted file mode 100644
index d0d9dca..0000000
--- a/test/openssl/test_pkcs7.rb
+++ /dev/null
@@ -1,309 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestPKCS7 < OpenSSL::TestCase
-  def setup
-    super
-    @rsa1024 = Fixtures.pkey("rsa1024")
-    @rsa2048 = Fixtures.pkey("rsa2048")
-    ca = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=CA")
-    ee1 = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=EE1")
-    ee2 = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=EE2")
-
-    ca_exts = [
-      ["basicConstraints","CA:TRUE",true],
-      ["keyUsage","keyCertSign, cRLSign",true],
-      ["subjectKeyIdentifier","hash",false],
-      ["authorityKeyIdentifier","keyid:always",false],
-    ]
-    @ca_cert = issue_cert(ca, @rsa2048, 1, ca_exts, nil, nil)
-    ee_exts = [
-      ["keyUsage","Non Repudiation, Digital Signature, Key Encipherment",true],
-      ["authorityKeyIdentifier","keyid:always",false],
-      ["extendedKeyUsage","clientAuth, emailProtection, codeSigning",false],
-    ]
-    @ee1_cert = issue_cert(ee1, @rsa1024, 2, ee_exts, @ca_cert, @rsa2048)
-    @ee2_cert = issue_cert(ee2, @rsa1024, 3, ee_exts, @ca_cert, @rsa2048)
-  end
-
-  def test_signed
-    store = OpenSSL::X509::Store.new
-    store.add_cert(@ca_cert)
-    ca_certs = [@ca_cert]
-
-    data = "aaaaa\r\nbbbbb\r\nccccc\r\n"
-    tmp = OpenSSL::PKCS7.sign(@ee1_cert, @rsa1024, data, ca_certs)
-    p7 = OpenSSL::PKCS7.new(tmp.to_der)
-    certs = p7.certificates
-    signers = p7.signers
-    assert(p7.verify([], store))
-    assert_equal(data, p7.data)
-    assert_equal(2, certs.size)
-    assert_equal(@ee1_cert.subject.to_s, certs[0].subject.to_s)
-    assert_equal(@ca_cert.subject.to_s, certs[1].subject.to_s)
-    assert_equal(1, signers.size)
-    assert_equal(@ee1_cert.serial, signers[0].serial)
-    assert_equal(@ee1_cert.issuer.to_s, signers[0].issuer.to_s)
-
-    # Normally OpenSSL tries to translate the supplied content into canonical
-    # MIME format (e.g. a newline character is converted into CR+LF).
-    # If the content is a binary, PKCS7::BINARY flag should be used.
-
-    data = "aaaaa\nbbbbb\nccccc\n"
-    flag = OpenSSL::PKCS7::BINARY
-    tmp = OpenSSL::PKCS7.sign(@ee1_cert, @rsa1024, data, ca_certs, flag)
-    p7 = OpenSSL::PKCS7.new(tmp.to_der)
-    certs = p7.certificates
-    signers = p7.signers
-    assert(p7.verify([], store))
-    assert_equal(data, p7.data)
-    assert_equal(2, certs.size)
-    assert_equal(@ee1_cert.subject.to_s, certs[0].subject.to_s)
-    assert_equal(@ca_cert.subject.to_s, certs[1].subject.to_s)
-    assert_equal(1, signers.size)
-    assert_equal(@ee1_cert.serial, signers[0].serial)
-    assert_equal(@ee1_cert.issuer.to_s, signers[0].issuer.to_s)
-
-    # A signed-data which have multiple signatures can be created
-    # through the following steps.
-    #   1. create two signed-data
-    #   2. copy signerInfo and certificate from one to another
-
-    tmp1 = OpenSSL::PKCS7.sign(@ee1_cert, @rsa1024, data, [], flag)
-    tmp2 = OpenSSL::PKCS7.sign(@ee2_cert, @rsa1024, data, [], flag)
-    tmp1.add_signer(tmp2.signers[0])
-    tmp1.add_certificate(@ee2_cert)
-
-    p7 = OpenSSL::PKCS7.new(tmp1.to_der)
-    certs = p7.certificates
-    signers = p7.signers
-    assert(p7.verify([], store))
-    assert_equal(data, p7.data)
-    assert_equal(2, certs.size)
-    assert_equal(2, signers.size)
-    assert_equal(@ee1_cert.serial, signers[0].serial)
-    assert_equal(@ee1_cert.issuer.to_s, signers[0].issuer.to_s)
-    assert_equal(@ee2_cert.serial, signers[1].serial)
-    assert_equal(@ee2_cert.issuer.to_s, signers[1].issuer.to_s)
-  end
-
-  def test_detached_sign
-    store = OpenSSL::X509::Store.new
-    store.add_cert(@ca_cert)
-    ca_certs = [@ca_cert]
-
-    data = "aaaaa\nbbbbb\nccccc\n"
-    flag = OpenSSL::PKCS7::BINARY|OpenSSL::PKCS7::DETACHED
-    tmp = OpenSSL::PKCS7.sign(@ee1_cert, @rsa1024, data, ca_certs, flag)
-    p7 = OpenSSL::PKCS7.new(tmp.to_der)
-    assert_nothing_raised do
-      OpenSSL::ASN1.decode(p7)
-    end
-
-    certs = p7.certificates
-    signers = p7.signers
-    assert(!p7.verify([], store))
-    assert(p7.verify([], store, data))
-    assert_equal(data, p7.data)
-    assert_equal(2, certs.size)
-    assert_equal(@ee1_cert.subject.to_s, certs[0].subject.to_s)
-    assert_equal(@ca_cert.subject.to_s, certs[1].subject.to_s)
-    assert_equal(1, signers.size)
-    assert_equal(@ee1_cert.serial, signers[0].serial)
-    assert_equal(@ee1_cert.issuer.to_s, signers[0].issuer.to_s)
-  end
-
-  def test_enveloped
-    certs = [@ee1_cert, @ee2_cert]
-    cipher = OpenSSL::Cipher::AES.new("128-CBC")
-    data = "aaaaa\nbbbbb\nccccc\n"
-
-    tmp = OpenSSL::PKCS7.encrypt(certs, data, cipher, OpenSSL::PKCS7::BINARY)
-    p7 = OpenSSL::PKCS7.new(tmp.to_der)
-    recip = p7.recipients
-    assert_equal(:enveloped, p7.type)
-    assert_equal(2, recip.size)
-
-    assert_equal(@ca_cert.subject.to_s, recip[0].issuer.to_s)
-    assert_equal(2, recip[0].serial)
-    assert_equal(data, p7.decrypt(@rsa1024, @ee1_cert))
-
-    assert_equal(@ca_cert.subject.to_s, recip[1].issuer.to_s)
-    assert_equal(3, recip[1].serial)
-    assert_equal(data, p7.decrypt(@rsa1024, @ee2_cert))
-
-    assert_equal(data, p7.decrypt(@rsa1024))
-  end
-
-  def test_graceful_parsing_failure #[ruby-core:43250]
-    contents = File.read(__FILE__)
-    assert_raise(ArgumentError) { OpenSSL::PKCS7.new(contents) }
-  end
-
-  def test_set_type_signed
-    p7 = OpenSSL::PKCS7.new
-    p7.type = "signed"
-    assert_equal(:signed, p7.type)
-  end
-
-  def test_set_type_data
-    p7 = OpenSSL::PKCS7.new
-    p7.type = "data"
-    assert_equal(:data, p7.type)
-  end
-
-  def test_set_type_signed_and_enveloped
-    p7 = OpenSSL::PKCS7.new
-    p7.type = "signedAndEnveloped"
-    assert_equal(:signedAndEnveloped, p7.type)
-  end
-
-  def test_set_type_enveloped
-    p7 = OpenSSL::PKCS7.new
-    p7.type = "enveloped"
-    assert_equal(:enveloped, p7.type)
-  end
-
-  def test_set_type_encrypted
-    p7 = OpenSSL::PKCS7.new
-    p7.type = "encrypted"
-    assert_equal(:encrypted, p7.type)
-  end
-
-  def test_smime
-    store = OpenSSL::X509::Store.new
-    store.add_cert(@ca_cert)
-    ca_certs = [@ca_cert]
-
-    data = "aaaaa\r\nbbbbb\r\nccccc\r\n"
-    tmp = OpenSSL::PKCS7.sign(@ee1_cert, @rsa1024, data, ca_certs)
-    p7 = OpenSSL::PKCS7.new(tmp.to_der)
-    smime = OpenSSL::PKCS7.write_smime(p7)
-    assert_equal(true, smime.start_with?(<<END))
-MIME-Version: 1.0
-Content-Disposition: attachment; filename="smime.p7m"
-Content-Type: application/x-pkcs7-mime; smime-type=signed-data; name="smime.p7m"
-Content-Transfer-Encoding: base64
-
-END
-    assert_equal(p7.to_der, OpenSSL::PKCS7.read_smime(smime).to_der)
-
-    smime = OpenSSL::PKCS7.write_smime(p7, nil, 0)
-    assert_equal(p7.to_der, OpenSSL::PKCS7.read_smime(smime).to_der)
-  end
-
-  def test_degenerate_pkcs7
-    ca_cert_pem = <<END
------BEGIN CERTIFICATE-----
-MIID4DCCAsigAwIBAgIJAL1oVI72wmQwMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNV
-BAYTAkFVMQ4wDAYDVQQIEwVTdGF0ZTENMAsGA1UEBxMEQ2l0eTEQMA4GA1UEChMH
-RXhhbXBsZTETMBEGA1UEAxMKRXhhbXBsZSBDQTAeFw0xMjEwMTgwOTE2NTBaFw0y
-MjEwMTYwOTE2NTBaMFMxCzAJBgNVBAYTAkFVMQ4wDAYDVQQIEwVTdGF0ZTENMAsG
-A1UEBxMEQ2l0eTEQMA4GA1UEChMHRXhhbXBsZTETMBEGA1UEAxMKRXhhbXBsZSBD
-QTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMTSPNxOkd5NN19XO0fJ
-tGVlWN4DWuvVL9WbWnXJXX9rU6X8sSOL9RrRA64eEZf2UBFjz9fMHZj/OGcxZpus
-4YtzfSrMU6xfvsIHeqX+mT60ms2RfX4UXab50MQArBin3JVKHGnOi25uyAOylVFU
-TuzzQJvKyB67vjuRPMlVAgVAZAP07ru9gW0ajt/ODxvUfvXxp5SFF68mVP2ipMBr
-4fujUwQC6cVHmnuL6p87VFoo9uk87TSQVDOQGL8MK4moMFtEW9oUTU22CgnxnCsS
-sCCELYhy9BdaTWQH26LzMfhnwSuIRHZyprW4WZtU0akrYXNiCj8o92rZmQWXJDbl
-qNECAwEAAaOBtjCBszAdBgNVHQ4EFgQUNtVw4jvkZZbkdQbkYi2/F4QN79owgYMG
-A1UdIwR8MHqAFDbVcOI75GWW5HUG5GItvxeEDe/aoVekVTBTMQswCQYDVQQGEwJB
-VTEOMAwGA1UECBMFU3RhdGUxDTALBgNVBAcTBENpdHkxEDAOBgNVBAoTB0V4YW1w
-bGUxEzARBgNVBAMTCkV4YW1wbGUgQ0GCCQC9aFSO9sJkMDAMBgNVHRMEBTADAQH/
-MA0GCSqGSIb3DQEBBQUAA4IBAQBvJIsY9bIqliZ3WD1KoN4cvAQeRAPsoLXQkkHg
-P6Nrcw9rJ5JvoHfYbo5aNlwbnkbt/B2xlVEXUYpJoBZFXafgxG2gJleioIgnaDS4
-FPPwZf1C5ZrOgUBfxTGjHex4ghSAoNGOd35jQzin5NGKOvZclPjZ2vQ++LP3aA2l
-9Fn2qASS46IzMGJlC75mlTOTQwDM16UunMAK26lNG9J6q02o4d/oU2a7x0fD80yF
-64kNA1wDAwaVCYiUH541qKp+b4iDqer8nf8HqzYDFlpje18xYZMEd1hj8dVOharM
-pISJ+D52hV/BGEYF8r5k3hpC5d76gSP2oCcaY0XvLBf97qik
------END CERTIFICATE-----
-END
-    p7 = OpenSSL::PKCS7.new
-    p7.type = "signed"
-    ca_cert = OpenSSL::X509::Certificate.new(ca_cert_pem)
-    p7.add_certificate ca_cert
-    p7.add_data ""
-
-    assert_nothing_raised do
-      p7.to_pem
-    end
-  end
-
-  def test_split_content
-     pki_message_pem = <<END
------BEGIN PKCS7-----
-MIIHSwYJKoZIhvcNAQcCoIIHPDCCBzgCAQExCzAJBgUrDgMCGgUAMIIDiAYJKoZI
-hvcNAQcBoIIDeQSCA3UwgAYJKoZIhvcNAQcDoIAwgAIBADGCARAwggEMAgEAMHUw
-cDEQMA4GA1UECgwHZXhhbXBsZTEXMBUGA1UEAwwOVEFSTUFDIFJPT1QgQ0ExIjAg
-BgkqhkiG9w0BCQEWE3NvbWVvbmVAZXhhbXBsZS5vcmcxCzAJBgNVBAYTAlVTMRIw
-EAYDVQQHDAlUb3duIEhhbGwCAWYwDQYJKoZIhvcNAQEBBQAEgYBspXXse8ZhG1FE
-E3PVAulbvrdR52FWPkpeLvSjgEkYzTiUi0CC3poUL1Ku5mOlavWAJgoJpFICDbvc
-N4ZNDCwOhnzoI9fMGmm1gvPQy15BdhhZRo9lP7Ga/Hg2APKT0/0yhPsmJ+w+u1e7
-OoJEVeEZ27x3+u745bGEcu8of5th6TCABgkqhkiG9w0BBwEwFAYIKoZIhvcNAwcE
-CBNs2U5mMsd/oIAEggIQU6cur8QBz02/4eMpHdlU9IkyrRMiaMZ/ky9zecOAjnvY
-d2jZqS7RhczpaNJaSli3GmDsKrF+XqE9J58s9ScGqUigzapusTsxIoRUPr7Ztb0a
-pg8VWDipAsuw7GfEkgx868sV93uC4v6Isfjbhd+JRTFp/wR1kTi7YgSXhES+RLUW
-gQbDIDgEQYxJ5U951AJtnSpjs9za2ZkTdd8RSEizJK0bQ1vqLoApwAVgZqluATqQ
-AHSDCxhweVYw6+y90B9xOrqPC0eU7Wzryq2+Raq5ND2Wlf5/N11RQ3EQdKq/l5Te
-ijp9PdWPlkUhWVoDlOFkysjk+BE+7AkzgYvz9UvBjmZsMsWqf+KsZ4S8/30ndLzu
-iucsu6eOnFLLX8DKZxV6nYffZOPzZZL8hFBcE7PPgSdBEkazMrEBXq1j5mN7exbJ
-NOA5uGWyJNBMOCe+1JbxG9UeoqvCCTHESxEeDu7xR3NnSOD47n7cXwHr81YzK2zQ
-5oWpP3C8jzI7tUjLd1S0Z3Psd17oaCn+JOfUtuB0nc3wfPF/WPo0xZQodWxp2/Cl
-EltR6qr1zf5C7GwmLzBZ6bHFAIT60/JzV0/56Pn8ztsRFtI4cwaBfTfvnwi8/sD9
-/LYOMY+/b6UDCUSR7RTN7XfrtAqDEzSdzdJkOWm1jvM8gkLmxpZdvxG3ZvDYnEQE
-5Nq+un5nAny1wf3rWierBAjE5ntiAmgs5AAAAAAAAAAAAACgggHqMIIB5jCCAU+g
-AwIBAgIBATANBgkqhkiG9w0BAQUFADAvMS0wKwYDVQQDEyQwQUM5RjAyNi1EQ0VB
-LTRDMTItOTEyNy1DMEZEN0QyQThCNUEwHhcNMTIxMDE5MDk0NTQ3WhcNMTMxMDE5
-MDk0NTQ3WjAvMS0wKwYDVQQDEyQwQUM5RjAyNi1EQ0VBLTRDMTItOTEyNy1DMEZE
-N0QyQThCNUEwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALTsTNyGIsKvyw56
-WI3Gll/RmjsupkrdEtPbx7OjS9MEgyhOAf9+u6CV0LJGHpy7HUeROykF6xpbSdCm
-Mr6kNObl5N0ljOb8OmV4atKjmGg1rWawDLyDQ9Dtuby+dzfHtzAzP+J/3ZoOtSqq
-AHVTnCclU1pm/uHN0HZ5nL5iLJTvAgMBAAGjEjAQMA4GA1UdDwEB/wQEAwIFoDAN
-BgkqhkiG9w0BAQUFAAOBgQA8K+BouEV04HRTdMZd3akjTQOm6aEGW4nIRnYIf8ZV
-mvUpLirVlX/unKtJinhGisFGpuYLMpemx17cnGkBeLCQRvHQjC+ho7l8/LOGheMS
-nvu0XHhvmJtRbm8MKHhogwZqHFDnXonvjyqhnhEtK5F2Fimcce3MoF2QtEe0UWv/
-8DGCAaowggGmAgEBMDQwLzEtMCsGA1UEAxMkMEFDOUYwMjYtRENFQS00QzEyLTkx
-MjctQzBGRDdEMkE4QjVBAgEBMAkGBSsOAwIaBQCggc0wEgYKYIZIAYb4RQEJAjEE
-EwIxOTAYBgkqhkiG9w0BCQMxCwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0x
-MjEwMTkwOTQ1NDdaMCAGCmCGSAGG+EUBCQUxEgQQ2EFUJdQNwQDxclIQ8qNyYzAj
-BgkqhkiG9w0BCQQxFgQUy8GFXPpAwRJUT3rdvNC9Pn+4eoswOAYKYIZIAYb4RQEJ
-BzEqEygwRkU3QzJEQTVEMDc2NzFFOTcxNDlCNUE3MDRCMERDNkM4MDYwRDJBMA0G
-CSqGSIb3DQEBAQUABIGAWUNdzvU2iiQOtihBwF0h48Nnw/2qX8uRjg6CVTOMcGji
-BxjUMifEbT//KJwljshl4y3yBLqeVYLOd04k6aKSdjgdZnrnUPI6p5tL5PfJkTAE
-L6qflZ9YCU5erE4T5U98hCQBMh4nOYxgaTjnZzhpkKQuEiKq/755cjzTzlI/eok=
------END PKCS7-----
-END
-    pki_message_content_pem = <<END
------BEGIN PKCS7-----
-MIIDawYJKoZIhvcNAQcDoIIDXDCCA1gCAQAxggEQMIIBDAIBADB1MHAxEDAOBgNV
-BAoMB2V4YW1wbGUxFzAVBgNVBAMMDlRBUk1BQyBST09UIENBMSIwIAYJKoZIhvcN
-AQkBFhNzb21lb25lQGV4YW1wbGUub3JnMQswCQYDVQQGEwJVUzESMBAGA1UEBwwJ
-VG93biBIYWxsAgFmMA0GCSqGSIb3DQEBAQUABIGAbKV17HvGYRtRRBNz1QLpW763
-UedhVj5KXi70o4BJGM04lItAgt6aFC9SruZjpWr1gCYKCaRSAg273DeGTQwsDoZ8
-6CPXzBpptYLz0MteQXYYWUaPZT+xmvx4NgDyk9P9MoT7JifsPrtXuzqCRFXhGdu8
-d/ru+OWxhHLvKH+bYekwggI9BgkqhkiG9w0BBwEwFAYIKoZIhvcNAwcECBNs2U5m
-Msd/gIICGFOnLq/EAc9Nv+HjKR3ZVPSJMq0TImjGf5Mvc3nDgI572Hdo2aku0YXM
-6WjSWkpYtxpg7Cqxfl6hPSefLPUnBqlIoM2qbrE7MSKEVD6+2bW9GqYPFVg4qQLL
-sOxnxJIMfOvLFfd7guL+iLH424XfiUUxaf8EdZE4u2IEl4REvkS1FoEGwyA4BEGM
-SeVPedQCbZ0qY7Pc2tmZE3XfEUhIsyStG0Nb6i6AKcAFYGapbgE6kAB0gwsYcHlW
-MOvsvdAfcTq6jwtHlO1s68qtvkWquTQ9lpX+fzddUUNxEHSqv5eU3oo6fT3Vj5ZF
-IVlaA5ThZMrI5PgRPuwJM4GL8/VLwY5mbDLFqn/irGeEvP99J3S87ornLLunjpxS
-y1/AymcVep2H32Tj82WS/IRQXBOzz4EnQRJGszKxAV6tY+Zje3sWyTTgObhlsiTQ
-TDgnvtSW8RvVHqKrwgkxxEsRHg7u8UdzZ0jg+O5+3F8B6/NWMyts0OaFqT9wvI8y
-O7VIy3dUtGdz7Hde6Ggp/iTn1LbgdJ3N8Hzxf1j6NMWUKHVsadvwpRJbUeqq9c3+
-QuxsJi8wWemxxQCE+tPyc1dP+ej5/M7bERbSOHMGgX03758IvP7A/fy2DjGPv2+l
-AwlEke0Uze1367QKgxM0nc3SZDlptY7zPIJC5saWXb8Rt2bw2JxEBOTavrp+ZwJ8
-tcH961onq8Tme2ICaCzk
------END PKCS7-----
-END
-    pki_msg = OpenSSL::PKCS7.new(pki_message_pem)
-    store = OpenSSL::X509::Store.new
-    pki_msg.verify(nil, store, nil, OpenSSL::PKCS7::NOVERIFY)
-    p7enc = OpenSSL::PKCS7.new(pki_msg.data)
-    assert_equal(pki_message_content_pem, p7enc.to_pem)
-  end
-end
-
-end
diff --git a/test/openssl/test_pkey.rb b/test/openssl/test_pkey.rb
deleted file mode 100644
index 0bdc979..0000000
--- a/test/openssl/test_pkey.rb
+++ /dev/null
@@ -1,28 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-class OpenSSL::TestPKey < OpenSSL::PKeyTestCase
-  def test_generic_oid_inspect
-    # RSA private key
-    rsa = Fixtures.pkey("rsa-1")
-    assert_instance_of OpenSSL::PKey::RSA, rsa
-    assert_equal "rsaEncryption", rsa.oid
-    assert_match %r{oid=rsaEncryption}, rsa.inspect
-
-    # X25519 private key
-    x25519_pem = <<~EOF
-    -----BEGIN PRIVATE KEY-----
-    MC4CAQAwBQYDK2VuBCIEIHcHbQpzGKV9PBbBclGyZkXfTC+H68CZKrF3+6UduSwq
-    -----END PRIVATE KEY-----
-    EOF
-    begin
-      x25519 = OpenSSL::PKey.read(x25519_pem)
-    rescue OpenSSL::PKey::PKeyError
-      # OpenSSL < 1.1.0
-      pend "X25519 is not implemented"
-    end
-    assert_instance_of OpenSSL::PKey::PKey, x25519
-    assert_equal "X25519", x25519.oid
-    assert_match %r{oid=X25519}, x25519.inspect
-  end
-end
diff --git a/test/openssl/test_pkey_dh.rb b/test/openssl/test_pkey_dh.rb
deleted file mode 100644
index fd2c7a6..0000000
--- a/test/openssl/test_pkey_dh.rb
+++ /dev/null
@@ -1,110 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL) && defined?(OpenSSL::PKey::DH)
-
-class OpenSSL::TestPKeyDH < OpenSSL::PKeyTestCase
-  NEW_KEYLEN = 256
-
-  def test_new
-    dh = OpenSSL::PKey::DH.new(NEW_KEYLEN)
-    assert_key(dh)
-  end
-
-  def test_new_break
-    assert_nil(OpenSSL::PKey::DH.new(NEW_KEYLEN) { break })
-    assert_raise(RuntimeError) do
-      OpenSSL::PKey::DH.new(NEW_KEYLEN) { raise }
-    end
-  end
-
-  def test_DHparams
-    dh1024 = Fixtures.pkey("dh1024")
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Integer(dh1024.p),
-      OpenSSL::ASN1::Integer(dh1024.g)
-    ])
-    key = OpenSSL::PKey::DH.new(asn1.to_der)
-    assert_same_dh dup_public(dh1024), key
-
-    pem = <<~EOF
-    -----BEGIN DH PARAMETERS-----
-    MIGHAoGBAKnKQ8MNK6nYZzLrrcuTsLxuiJGXoOO5gT+tljOTbHBuiktdMTITzIY0
-    pFxIvjG05D7HoBZQfrR0c92NGWPkAiCkhQKB8JCbPVzwNLDy6DZ0pmofDKrEsYHG
-    AQjjxMXhwULlmuR/K+WwlaZPiLIBYalLAZQ7ZbOPeVkJ8ePao0eLAgEC
-    -----END DH PARAMETERS-----
-    EOF
-    key = OpenSSL::PKey::DH.new(pem)
-    assert_same_dh dup_public(dh1024), key
-
-    assert_equal asn1.to_der, dh1024.to_der
-    assert_equal pem, dh1024.export
-  end
-
-  def test_public_key
-    dh = Fixtures.pkey("dh1024")
-    public_key = dh.public_key
-    assert_no_key(public_key) #implies public_key.public? is false!
-    assert_equal(dh.to_der, public_key.to_der)
-    assert_equal(dh.to_pem, public_key.to_pem)
-  end
-
-  def test_generate_key
-    dh = Fixtures.pkey("dh1024").public_key # creates a copy
-    assert_no_key(dh)
-    dh.generate_key!
-    assert_key(dh)
-  end
-
-  def test_key_exchange
-    dh = Fixtures.pkey("dh1024")
-    dh2 = dh.public_key
-    dh.generate_key!
-    dh2.generate_key!
-    assert_equal(dh.compute_key(dh2.pub_key), dh2.compute_key(dh.pub_key))
-  end
-
-  def test_dup
-    dh = OpenSSL::PKey::DH.new(NEW_KEYLEN)
-    dh2 = dh.dup
-    assert_equal dh.to_der, dh2.to_der # params
-    assert_equal_params dh, dh2 # keys
-    dh2.set_pqg(dh2.p + 1, nil, dh2.g)
-    assert_not_equal dh2.p, dh.p
-    assert_equal dh2.g, dh.g
-  end
-
-  def test_marshal
-    dh = Fixtures.pkey("dh1024")
-    deserialized = Marshal.load(Marshal.dump(dh))
-
-    assert_equal dh.to_der, deserialized.to_der
-  end
-
-  private
-
-  def assert_equal_params(dh1, dh2)
-    assert_equal(dh1.g, dh2.g)
-    assert_equal(dh1.p, dh2.p)
-  end
-
-  def assert_no_key(dh)
-    assert_equal(false, dh.public?)
-    assert_equal(false, dh.private?)
-    assert_equal(nil, dh.pub_key)
-    assert_equal(nil, dh.priv_key)
-  end
-
-  def assert_key(dh)
-    assert(dh.public?)
-    assert(dh.private?)
-    assert(dh.pub_key)
-    assert(dh.priv_key)
-  end
-
-  def assert_same_dh(expected, key)
-    check_component(expected, key, [:p, :q, :g, :pub_key, :priv_key])
-  end
-end
-
-end
diff --git a/test/openssl/test_pkey_dsa.rb b/test/openssl/test_pkey_dsa.rb
deleted file mode 100644
index 4bf8a7b..0000000
--- a/test/openssl/test_pkey_dsa.rb
+++ /dev/null
@@ -1,207 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL) && defined?(OpenSSL::PKey::DSA)
-
-class OpenSSL::TestPKeyDSA < OpenSSL::PKeyTestCase
-  def test_private
-    key = OpenSSL::PKey::DSA.new(256)
-    assert(key.private?)
-    key2 = OpenSSL::PKey::DSA.new(key.to_der)
-    assert(key2.private?)
-    key3 = key.public_key
-    assert(!key3.private?)
-    key4 = OpenSSL::PKey::DSA.new(key3.to_der)
-    assert(!key4.private?)
-  end
-
-  def test_new
-    key = OpenSSL::PKey::DSA.new 256
-    pem  = key.public_key.to_pem
-    OpenSSL::PKey::DSA.new pem
-    if $0 == __FILE__
-      assert_nothing_raised {
-        key = OpenSSL::PKey::DSA.new 2048
-      }
-    end
-  end
-
-  def test_new_break
-    assert_nil(OpenSSL::PKey::DSA.new(512) { break })
-    assert_raise(RuntimeError) do
-      OpenSSL::PKey::DSA.new(512) { raise }
-    end
-  end
-
-  def test_sign_verify
-    dsa512 = Fixtures.pkey("dsa512")
-    data = "Sign me!"
-    if defined?(OpenSSL::Digest::DSS1)
-      signature = dsa512.sign(OpenSSL::Digest.new('DSS1'), data)
-      assert_equal true, dsa512.verify(OpenSSL::Digest.new('DSS1'), signature, data)
-    end
-
-    signature = dsa512.sign("SHA1", data)
-    assert_equal true, dsa512.verify("SHA1", signature, data)
-
-    signature0 = (<<~'end;').unpack("m")[0]
-      MCwCFH5h40plgU5Fh0Z4wvEEpz0eE9SnAhRPbkRB8ggsN/vsSEYMXvJwjGg/
-      6g==
-    end;
-    assert_equal true, dsa512.verify("SHA256", signature0, data)
-    signature1 = signature0.succ
-    assert_equal false, dsa512.verify("SHA256", signature1, data)
-  end
-
-  def test_sys_sign_verify
-    key = Fixtures.pkey("dsa256")
-    data = 'Sign me!'
-    digest = OpenSSL::Digest.digest('SHA1', data)
-    sig = key.syssign(digest)
-    assert(key.sysverify(digest, sig))
-  end
-
-  def test_DSAPrivateKey
-    # OpenSSL DSAPrivateKey format; similar to RSAPrivateKey
-    dsa512 = Fixtures.pkey("dsa512")
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Integer(0),
-      OpenSSL::ASN1::Integer(dsa512.p),
-      OpenSSL::ASN1::Integer(dsa512.q),
-      OpenSSL::ASN1::Integer(dsa512.g),
-      OpenSSL::ASN1::Integer(dsa512.pub_key),
-      OpenSSL::ASN1::Integer(dsa512.priv_key)
-    ])
-    key = OpenSSL::PKey::DSA.new(asn1.to_der)
-    assert_predicate key, :private?
-    assert_same_dsa dsa512, key
-
-    pem = <<~EOF
-    -----BEGIN DSA PRIVATE KEY-----
-    MIH4AgEAAkEA5lB4GvEwjrsMlGDqGsxrbqeFRh6o9OWt6FgTYiEEHaOYhkIxv0Ok
-    RZPDNwOG997mDjBnvDJ1i56OmS3MbTnovwIVAJgub/aDrSDB4DZGH7UyarcaGy6D
-    AkB9HdFw/3td8K4l1FZHv7TCZeJ3ZLb7dF3TWoGUP003RCqoji3/lHdKoVdTQNuR
-    S/m6DlCwhjRjiQ/lBRgCLCcaAkEAjN891JBjzpMj4bWgsACmMggFf57DS0Ti+5++
-    Q1VB8qkJN7rA7/2HrCR3gTsWNb1YhAsnFsoeRscC+LxXoXi9OAIUBG98h4tilg6S
-    55jreJD3Se3slps=
-    -----END DSA PRIVATE KEY-----
-    EOF
-    key = OpenSSL::PKey::DSA.new(pem)
-    assert_same_dsa dsa512, key
-
-    assert_equal asn1.to_der, dsa512.to_der
-    assert_equal pem, dsa512.export
-  end
-
-  def test_DSAPrivateKey_encrypted
-    # key = abcdef
-    dsa512 = Fixtures.pkey("dsa512")
-    pem = <<~EOF
-    -----BEGIN DSA PRIVATE KEY-----
-    Proc-Type: 4,ENCRYPTED
-    DEK-Info: AES-128-CBC,F8BB7BFC7EAB9118AC2E3DA16C8DB1D9
-
-    D2sIzsM9MLXBtlF4RW42u2GB9gX3HQ3prtVIjWPLaKBYoToRUiv8WKsjptfZuLSB
-    74ZPdMS7VITM+W1HIxo/tjS80348Cwc9ou8H/E6WGat8ZUk/igLOUEII+coQS6qw
-    QpuLMcCIavevX0gjdjEIkojBB81TYDofA1Bp1z1zDI/2Zhw822xapI79ZF7Rmywt
-    OSyWzFaGipgDpdFsGzvT6//z0jMr0AuJVcZ0VJ5lyPGQZAeVBlbYEI4T72cC5Cz7
-    XvLiaUtum6/sASD2PQqdDNpgx/WA6Vs1Po2kIUQIM5TIwyJI0GdykZcYm6xIK/ta
-    Wgx6c8K+qBAIVrilw3EWxw==
-    -----END DSA PRIVATE KEY-----
-    EOF
-    key = OpenSSL::PKey::DSA.new(pem, "abcdef")
-    assert_same_dsa dsa512, key
-    key = OpenSSL::PKey::DSA.new(pem) { "abcdef" }
-    assert_same_dsa dsa512, key
-
-    cipher = OpenSSL::Cipher.new("aes-128-cbc")
-    exported = dsa512.to_pem(cipher, "abcdef\0\1")
-    assert_same_dsa dsa512, OpenSSL::PKey::DSA.new(exported, "abcdef\0\1")
-    assert_raise(OpenSSL::PKey::DSAError) {
-      OpenSSL::PKey::DSA.new(exported, "abcdef")
-    }
-  end
-
-  def test_PUBKEY
-    dsa512 = Fixtures.pkey("dsa512")
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Sequence([
-        OpenSSL::ASN1::ObjectId("DSA"),
-        OpenSSL::ASN1::Sequence([
-          OpenSSL::ASN1::Integer(dsa512.p),
-          OpenSSL::ASN1::Integer(dsa512.q),
-          OpenSSL::ASN1::Integer(dsa512.g)
-        ])
-      ]),
-      OpenSSL::ASN1::BitString(
-        OpenSSL::ASN1::Integer(dsa512.pub_key).to_der
-      )
-    ])
-    key = OpenSSL::PKey::DSA.new(asn1.to_der)
-    assert_not_predicate key, :private?
-    assert_same_dsa dup_public(dsa512), key
-
-    pem = <<~EOF
-    -----BEGIN PUBLIC KEY-----
-    MIHxMIGoBgcqhkjOOAQBMIGcAkEA5lB4GvEwjrsMlGDqGsxrbqeFRh6o9OWt6FgT
-    YiEEHaOYhkIxv0OkRZPDNwOG997mDjBnvDJ1i56OmS3MbTnovwIVAJgub/aDrSDB
-    4DZGH7UyarcaGy6DAkB9HdFw/3td8K4l1FZHv7TCZeJ3ZLb7dF3TWoGUP003RCqo
-    ji3/lHdKoVdTQNuRS/m6DlCwhjRjiQ/lBRgCLCcaA0QAAkEAjN891JBjzpMj4bWg
-    sACmMggFf57DS0Ti+5++Q1VB8qkJN7rA7/2HrCR3gTsWNb1YhAsnFsoeRscC+LxX
-    oXi9OA==
-    -----END PUBLIC KEY-----
-    EOF
-    key = OpenSSL::PKey::DSA.new(pem)
-    assert_same_dsa dup_public(dsa512), key
-
-    assert_equal asn1.to_der, dup_public(dsa512).to_der
-    assert_equal pem, dup_public(dsa512).export
-  end
-
-  def test_read_DSAPublicKey_pem
-    # TODO: where is the standard? PKey::DSA.new can read only PEM
-    p = 12260055936871293565827712385212529106400444521449663325576634579961635627321079536132296996623400607469624537382977152381984332395192110731059176842635699
-    q = 979494906553787301107832405790107343409973851677
-    g = 3731695366899846297271147240305742456317979984190506040697507048095553842519347835107669437969086119948785140453492839427038591924536131566350847469993845
-    y = 10505239074982761504240823422422813362721498896040719759460296306305851824586095328615844661273887569281276387605297130014564808567159023649684010036304695
-    pem = <<-EOF
------BEGIN DSA PUBLIC KEY-----
-MIHfAkEAyJSJ+g+P/knVcgDwwTzC7Pwg/pWs2EMd/r+lYlXhNfzg0biuXRul8VR4
-VUC/phySExY0PdcqItkR/xYAYNMbNwJBAOoV57X0FxKO/PrNa/MkoWzkCKV/hzhE
-p0zbFdsicw+hIjJ7S6Sd/FlDlo89HQZ2FuvWJ6wGLM1j00r39+F2qbMCFQCrkhIX
-SG+is37hz1IaBeEudjB2HQJAR0AloavBvtsng8obsjLb7EKnB+pSeHr/BdIQ3VH7
-fWLOqqkzFeRrYMDzUpl36XktY6Yq8EJYlW9pCMmBVNy/dQ==
------END DSA PUBLIC KEY-----
-    EOF
-    key = OpenSSL::PKey::DSA.new(pem)
-    assert(key.public?)
-    assert(!key.private?)
-    assert_equal(p, key.p)
-    assert_equal(q, key.q)
-    assert_equal(g, key.g)
-    assert_equal(y, key.pub_key)
-    assert_equal(nil, key.priv_key)
-  end
-
-  def test_dup
-    key = OpenSSL::PKey::DSA.new(256)
-    key2 = key.dup
-    assert_equal key.params, key2.params
-    key2.set_pqg(key2.p + 1, key2.q, key2.g)
-    assert_not_equal key.params, key2.params
-  end
-
-  def test_marshal
-    key = Fixtures.pkey("dsa1024")
-    deserialized = Marshal.load(Marshal.dump(key))
-
-    assert_equal key.to_der, deserialized.to_der
-  end
-
-  private
-  def assert_same_dsa(expected, key)
-    check_component(expected, key, [:p, :q, :g, :pub_key, :priv_key])
-  end
-end
-
-end
diff --git a/test/openssl/test_pkey_ec.rb b/test/openssl/test_pkey_ec.rb
deleted file mode 100644
index a0e6a23..0000000
--- a/test/openssl/test_pkey_ec.rb
+++ /dev/null
@@ -1,381 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL) && defined?(OpenSSL::PKey::EC)
-
-class OpenSSL::TestEC < OpenSSL::PKeyTestCase
-  def test_ec_key
-    builtin_curves = OpenSSL::PKey::EC.builtin_curves
-    assert_not_empty builtin_curves
-
-    builtin_curves.each do |curve_name, comment|
-      # Oakley curves and X25519 are not suitable for signing and causes
-      # FIPS-selftest failure on some environment, so skip for now.
-      next if ["Oakley", "X25519"].any? { |n| curve_name.start_with?(n) }
-
-      key = OpenSSL::PKey::EC.new(curve_name)
-      key.generate_key!
-
-      assert_predicate key, :private?
-      assert_predicate key, :public?
-      assert_nothing_raised { key.check_key }
-    end
-
-    key1 = OpenSSL::PKey::EC.new("prime256v1").generate_key!
-
-    key2 = OpenSSL::PKey::EC.new
-    key2.group = key1.group
-    key2.private_key = key1.private_key
-    key2.public_key = key1.public_key
-    assert_equal key1.to_der, key2.to_der
-
-    key3 = OpenSSL::PKey::EC.new(key1)
-    assert_equal key1.to_der, key3.to_der
-
-    key4 = OpenSSL::PKey::EC.new(key1.to_der)
-    assert_equal key1.to_der, key4.to_der
-
-    key5 = key1.dup
-    assert_equal key1.to_der, key5.to_der
-    key_tmp = OpenSSL::PKey::EC.new("prime256v1").generate_key!
-    key5.private_key = key_tmp.private_key
-    key5.public_key = key_tmp.public_key
-    assert_not_equal key1.to_der, key5.to_der
-  end
-
-  def test_generate
-    assert_raise(OpenSSL::PKey::ECError) { OpenSSL::PKey::EC.generate("non-existent") }
-    g = OpenSSL::PKey::EC::Group.new("prime256v1")
-    ec = OpenSSL::PKey::EC.generate(g)
-    assert_equal(true, ec.private?)
-    ec = OpenSSL::PKey::EC.generate("prime256v1")
-    assert_equal(true, ec.private?)
-  end
-
-  def test_marshal
-    key = Fixtures.pkey("p256")
-    deserialized = Marshal.load(Marshal.dump(key))
-
-    assert_equal key.to_der, deserialized.to_der
-  end
-
-  def test_check_key
-    key = OpenSSL::PKey::EC.new("prime256v1").generate_key!
-    assert_equal(true, key.check_key)
-    assert_equal(true, key.private?)
-    assert_equal(true, key.public?)
-    key2 = OpenSSL::PKey::EC.new(key.group)
-    assert_equal(false, key2.private?)
-    assert_equal(false, key2.public?)
-    key2.public_key = key.public_key
-    assert_equal(false, key2.private?)
-    assert_equal(true, key2.public?)
-    key2.private_key = key.private_key
-    assert_equal(true, key2.private?)
-    assert_equal(true, key2.public?)
-    assert_equal(true, key2.check_key)
-    key2.private_key += 1
-    assert_raise(OpenSSL::PKey::ECError) { key2.check_key }
-  end
-
-  def test_sign_verify
-    p256 = Fixtures.pkey("p256")
-    data = "Sign me!"
-    signature = p256.sign("SHA1", data)
-    assert_equal true, p256.verify("SHA1", signature, data)
-
-    signature0 = (<<~'end;').unpack("m")[0]
-      MEQCIEOTY/hD7eI8a0qlzxkIt8LLZ8uwiaSfVbjX2dPAvN11AiAQdCYx56Fq
-      QdBp1B4sxJoA8jvODMMklMyBKVmudboA6A==
-    end;
-    assert_equal true, p256.verify("SHA256", signature0, data)
-    signature1 = signature0.succ
-    assert_equal false, p256.verify("SHA256", signature1, data)
-  end
-
-  def test_dsa_sign_verify
-    data1 = "foo"
-    data2 = "bar"
-    key = OpenSSL::PKey::EC.new("prime256v1").generate_key!
-    sig = key.dsa_sign_asn1(data1)
-    assert_equal true, key.dsa_verify_asn1(data1, sig)
-    assert_equal false, key.dsa_verify_asn1(data2, sig)
-  end
-
-  def test_dsa_sign_asn1_FIPS186_3
-    key = OpenSSL::PKey::EC.new("prime256v1").generate_key!
-    size = key.group.order.num_bits / 8 + 1
-    dgst = (1..size).to_a.pack('C*')
-    sig = key.dsa_sign_asn1(dgst)
-    # dgst is auto-truncated according to FIPS186-3 after openssl-0.9.8m
-    assert(key.dsa_verify_asn1(dgst + "garbage", sig))
-  end
-
-  def test_dh_compute_key
-    key_a = OpenSSL::PKey::EC.new("prime256v1").generate_key!
-    key_b = OpenSSL::PKey::EC.new(key_a.group).generate_key!
-
-    pub_a = key_a.public_key
-    pub_b = key_b.public_key
-    a = key_a.dh_compute_key(pub_b)
-    b = key_b.dh_compute_key(pub_a)
-    assert_equal a, b
-  end
-
-  def test_ECPrivateKey
-    p256 = Fixtures.pkey("p256")
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Integer(1),
-      OpenSSL::ASN1::OctetString(p256.private_key.to_s(2)),
-      OpenSSL::ASN1::ObjectId("prime256v1", 0, :EXPLICIT),
-      OpenSSL::ASN1::BitString(p256.public_key.to_octet_string(:uncompressed),
-                               1, :EXPLICIT)
-    ])
-    key = OpenSSL::PKey::EC.new(asn1.to_der)
-    assert_predicate key, :private?
-    assert_same_ec p256, key
-
-    pem = <<~EOF
-    -----BEGIN EC PRIVATE KEY-----
-    MHcCAQEEIID49FDqcf1O1eO8saTgG70UbXQw9Fqwseliit2aWhH1oAoGCCqGSM49
-    AwEHoUQDQgAEFglk2c+oVUIKQ64eZG9bhLNPWB7lSZ/ArK41eGy5wAzU/0G51Xtt
-    CeBUl+MahZtn9fO1JKdF4qJmS39dXnpENg==
-    -----END EC PRIVATE KEY-----
-    EOF
-    key = OpenSSL::PKey::EC.new(pem)
-    assert_same_ec p256, key
-
-    assert_equal asn1.to_der, p256.to_der
-    assert_equal pem, p256.export
-  end
-
-  def test_ECPrivateKey_encrypted
-    p256 = Fixtures.pkey("p256")
-    # key = abcdef
-    pem = <<~EOF
-    -----BEGIN EC PRIVATE KEY-----
-    Proc-Type: 4,ENCRYPTED
-    DEK-Info: AES-128-CBC,85743EB6FAC9EA76BF99D9328AFD1A66
-
-    nhsP1NHxb53aeZdzUe9umKKyr+OIwQq67eP0ONM6E1vFTIcjkDcFLR6PhPFufF4m
-    y7E2HF+9uT1KPQhlE+D63i1m1Mvez6PWfNM34iOQp2vEhaoHHKlR3c43lLyzaZDI
-    0/dGSU5SzFG+iT9iFXCwCvv+bxyegkBOyALFje1NAsM=
-    -----END EC PRIVATE KEY-----
-    EOF
-    key = OpenSSL::PKey::EC.new(pem, "abcdef")
-    assert_same_ec p256, key
-    key = OpenSSL::PKey::EC.new(pem) { "abcdef" }
-    assert_same_ec p256, key
-
-    cipher = OpenSSL::Cipher.new("aes-128-cbc")
-    exported = p256.to_pem(cipher, "abcdef\0\1")
-    assert_same_ec p256, OpenSSL::PKey::EC.new(exported, "abcdef\0\1")
-    assert_raise(OpenSSL::PKey::ECError) {
-      OpenSSL::PKey::EC.new(exported, "abcdef")
-    }
-  end
-
-  def test_PUBKEY
-    p256 = Fixtures.pkey("p256")
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Sequence([
-        OpenSSL::ASN1::ObjectId("id-ecPublicKey"),
-        OpenSSL::ASN1::ObjectId("prime256v1")
-      ]),
-      OpenSSL::ASN1::BitString(
-        p256.public_key.to_octet_string(:uncompressed)
-      )
-    ])
-    key = OpenSSL::PKey::EC.new(asn1.to_der)
-    assert_not_predicate key, :private?
-    assert_same_ec dup_public(p256), key
-
-    pem = <<~EOF
-    -----BEGIN PUBLIC KEY-----
-    MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEFglk2c+oVUIKQ64eZG9bhLNPWB7l
-    SZ/ArK41eGy5wAzU/0G51XttCeBUl+MahZtn9fO1JKdF4qJmS39dXnpENg==
-    -----END PUBLIC KEY-----
-    EOF
-    key = OpenSSL::PKey::EC.new(pem)
-    assert_same_ec dup_public(p256), key
-
-    assert_equal asn1.to_der, dup_public(p256).to_der
-    assert_equal pem, dup_public(p256).export
-  end
-
-  def test_ec_group
-    group1 = OpenSSL::PKey::EC::Group.new("prime256v1")
-    key1 = OpenSSL::PKey::EC.new(group1)
-    assert_equal group1, key1.group
-
-    group2 = OpenSSL::PKey::EC::Group.new(group1)
-    assert_equal group1.to_der, group2.to_der
-    assert_equal group1, group2
-    group2.asn1_flag ^=OpenSSL::PKey::EC::NAMED_CURVE
-    assert_not_equal group1.to_der, group2.to_der
-    assert_equal group1, group2
-
-    group3 = group1.dup
-    assert_equal group1.to_der, group3.to_der
-
-    assert group1.asn1_flag & OpenSSL::PKey::EC::NAMED_CURVE # our default
-    der = group1.to_der
-    group4 = OpenSSL::PKey::EC::Group.new(der)
-    group1.point_conversion_form = group4.point_conversion_form = :uncompressed
-    assert_equal :uncompressed, group1.point_conversion_form
-    assert_equal :uncompressed, group4.point_conversion_form
-    assert_equal group1, group4
-    assert_equal group1.curve_name, group4.curve_name
-    assert_equal group1.generator.to_octet_string(:uncompressed),
-      group4.generator.to_octet_string(:uncompressed)
-    assert_equal group1.order, group4.order
-    assert_equal group1.cofactor, group4.cofactor
-    assert_equal group1.seed, group4.seed
-    assert_equal group1.degree, group4.degree
-  end
-
-  def test_ec_point
-    group = OpenSSL::PKey::EC::Group.new("prime256v1")
-    key = OpenSSL::PKey::EC.new(group).generate_key!
-    point = key.public_key
-
-    point2 = OpenSSL::PKey::EC::Point.new(group, point.to_bn)
-    assert_equal point, point2
-    assert_equal point.to_bn, point2.to_bn
-    assert_equal point.to_octet_string(:uncompressed),
-      point2.to_octet_string(:uncompressed)
-
-    point3 = OpenSSL::PKey::EC::Point.new(group,
-                                          point.to_octet_string(:uncompressed))
-    assert_equal point, point3
-    assert_equal point.to_bn, point3.to_bn
-    assert_equal point.to_octet_string(:uncompressed),
-      point3.to_octet_string(:uncompressed)
-
-    point2.invert!
-    point3.invert!
-    assert_not_equal point.to_octet_string(:uncompressed),
-      point2.to_octet_string(:uncompressed)
-    assert_equal point2.to_octet_string(:uncompressed),
-      point3.to_octet_string(:uncompressed)
-
-    begin
-      group = OpenSSL::PKey::EC::Group.new(:GFp, 17, 2, 2)
-      group.point_conversion_form = :uncompressed
-      generator = OpenSSL::PKey::EC::Point.new(group, B(%w{ 04 05 01 }))
-      group.set_generator(generator, 19, 1)
-      point = OpenSSL::PKey::EC::Point.new(group, B(%w{ 04 06 03 }))
-    rescue OpenSSL::PKey::EC::Group::Error
-      pend "Patched OpenSSL rejected curve" if /unsupported field/ =~ $!.message
-      raise
-    end
-
-    assert_equal 0x040603.to_bn, point.to_bn
-    assert_equal 0x040603.to_bn, point.to_bn(:uncompressed)
-    assert_equal 0x0306.to_bn, point.to_bn(:compressed)
-    assert_equal 0x070603.to_bn, point.to_bn(:hybrid)
-
-    group2 = group.dup; group2.point_conversion_form = :compressed
-    point2 = OpenSSL::PKey::EC::Point.new(group2, B(%w{ 04 06 03 }))
-    assert_equal 0x0306.to_bn, point2.to_bn
-
-    assert_equal B(%w{ 04 06 03 }), point.to_octet_string(:uncompressed)
-    assert_equal B(%w{ 03 06 }), point.to_octet_string(:compressed)
-    assert_equal B(%w{ 07 06 03 }), point.to_octet_string(:hybrid)
-
-    assert_equal true, point.on_curve?
-    point.invert! # 8.5
-    assert_equal B(%w{ 04 06 0E }), point.to_octet_string(:uncompressed)
-    assert_equal true, point.on_curve?
-
-    assert_equal false, point.infinity?
-    point.set_to_infinity!
-    assert_equal true, point.infinity?
-    assert_equal 0.to_bn, point.to_bn
-    assert_equal B(%w{ 00 }), point.to_octet_string(:uncompressed)
-    assert_equal true, point.on_curve?
-  end
-
-  def test_ec_point_add
-    begin
-      group = OpenSSL::PKey::EC::Group.new(:GFp, 17, 2, 2)
-      group.point_conversion_form = :uncompressed
-      gen = OpenSSL::PKey::EC::Point.new(group, B(%w{ 04 05 01 }))
-      group.set_generator(gen, 19, 1)
-
-      point_a = OpenSSL::PKey::EC::Point.new(group, B(%w{ 04 06 03 }))
-      point_b = OpenSSL::PKey::EC::Point.new(group, B(%w{ 04 10 0D }))
-    rescue OpenSSL::PKey::EC::Group::Error
-      pend "Patched OpenSSL rejected curve" if /unsupported field/ =~ $!.message
-      raise
-    end
-
-    result = point_a.add(point_b)
-    assert_equal B(%w{ 04 0D 07 }), result.to_octet_string(:uncompressed)
-
-    assert_raise(TypeError) { point_a.add(nil) }
-    assert_raise(ArgumentError) { point_a.add }
-  end
-
-  def test_ec_point_mul
-    begin
-      # y^2 = x^3 + 2x + 2 over F_17
-      # generator is (5, 1)
-      group = OpenSSL::PKey::EC::Group.new(:GFp, 17, 2, 2)
-      group.point_conversion_form = :uncompressed
-      gen = OpenSSL::PKey::EC::Point.new(group, B(%w{ 04 05 01 }))
-      group.set_generator(gen, 19, 1)
-
-      # 3 * (6, 3) = (16, 13)
-      point_a = OpenSSL::PKey::EC::Point.new(group, B(%w{ 04 06 03 }))
-      result_a1 = point_a.mul(3)
-      assert_equal B(%w{ 04 10 0D }), result_a1.to_octet_string(:uncompressed)
-      # 3 * (6, 3) + 3 * (5, 1) = (7, 6)
-      result_a2 = point_a.mul(3, 3)
-      assert_equal B(%w{ 04 07 06 }), result_a2.to_octet_string(:uncompressed)
-      # 3 * point_a = 3 * (6, 3) = (16, 13)
-      result_b1 = point_a.mul([3], [])
-      assert_equal B(%w{ 04 10 0D }), result_b1.to_octet_string(:uncompressed)
-      # 3 * point_a + 2 * point_a = 3 * (6, 3) + 2 * (6, 3) = (7, 11)
-      begin
-        result_b1 = point_a.mul([3, 2], [point_a])
-      rescue OpenSSL::PKey::EC::Point::Error
-        # LibreSSL doesn't support multiple entries in first argument
-        raise if $!.message !~ /called a function you should not call/
-      else
-        assert_equal B(%w{ 04 07 0B }), result_b1.to_octet_string(:uncompressed)
-      end
-      # 3 * point_a + 5 * point_a.group.generator = 3 * (6, 3) + 5 * (5, 1) = (13, 10)
-      result_b1 = point_a.mul([3], [], 5)
-      assert_equal B(%w{ 04 0D 0A }), result_b1.to_octet_string(:uncompressed)
-    rescue OpenSSL::PKey::EC::Group::Error
-      # CentOS patches OpenSSL to reject curves defined over Fp where p < 256 bits
-      raise if $!.message !~ /unsupported field/
-    end
-
-    p256_key = Fixtures.pkey("p256")
-    p256_g = p256_key.group
-    assert_equal(p256_key.public_key, p256_g.generator.mul(p256_key.private_key))
-
-    # invalid argument
-    point = p256_key.public_key
-    assert_raise(TypeError) { point.mul(nil) }
-    assert_raise(ArgumentError) { point.mul([1], [point]) }
-    assert_raise(TypeError) { point.mul([1], nil) }
-    assert_raise(TypeError) { point.mul([nil], []) }
-  end
-
-# test Group: asn1_flag, point_conversion
-
-  private
-
-  def B(ary)
-    [Array(ary).join].pack("H*")
-  end
-
-  def assert_same_ec(expected, key)
-    check_component(expected, key, [:group, :public_key, :private_key])
-  end
-end
-
-end
diff --git a/test/openssl/test_pkey_rsa.rb b/test/openssl/test_pkey_rsa.rb
deleted file mode 100644
index 88164c3..0000000
--- a/test/openssl/test_pkey_rsa.rb
+++ /dev/null
@@ -1,459 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestPKeyRSA < OpenSSL::PKeyTestCase
-  def test_no_private_exp
-    key = OpenSSL::PKey::RSA.new
-    rsa = Fixtures.pkey("rsa2048")
-    key.set_key(rsa.n, rsa.e, nil)
-    key.set_factors(rsa.p, rsa.q)
-    assert_raise(OpenSSL::PKey::RSAError){ key.private_encrypt("foo") }
-    assert_raise(OpenSSL::PKey::RSAError){ key.private_decrypt("foo") }
-  end
-
-  def test_padding
-    key = OpenSSL::PKey::RSA.new(512, 3)
-
-    # Need right size for raw mode
-    plain0 = "x" * (512/8)
-    cipher = key.private_encrypt(plain0, OpenSSL::PKey::RSA::NO_PADDING)
-    plain1 = key.public_decrypt(cipher, OpenSSL::PKey::RSA::NO_PADDING)
-    assert_equal(plain0, plain1)
-
-    # Need smaller size for pkcs1 mode
-    plain0 = "x" * (512/8 - 11)
-    cipher1 = key.private_encrypt(plain0, OpenSSL::PKey::RSA::PKCS1_PADDING)
-    plain1 = key.public_decrypt(cipher1, OpenSSL::PKey::RSA::PKCS1_PADDING)
-    assert_equal(plain0, plain1)
-
-    cipherdef = key.private_encrypt(plain0) # PKCS1_PADDING is default
-    plain1 = key.public_decrypt(cipherdef)
-    assert_equal(plain0, plain1)
-    assert_equal(cipher1, cipherdef)
-
-    # Failure cases
-    assert_raise(ArgumentError){ key.private_encrypt() }
-    assert_raise(ArgumentError){ key.private_encrypt("hi", 1, nil) }
-    assert_raise(OpenSSL::PKey::RSAError){ key.private_encrypt(plain0, 666) }
-  end
-
-  def test_private
-    # Generated by key size and public exponent
-    key = OpenSSL::PKey::RSA.new(512, 3)
-    assert(key.private?)
-
-    # Generated by DER
-    key2 = OpenSSL::PKey::RSA.new(key.to_der)
-    assert(key2.private?)
-
-    # public key
-    key3 = key.public_key
-    assert(!key3.private?)
-
-    # Generated by public key DER
-    key4 = OpenSSL::PKey::RSA.new(key3.to_der)
-    assert(!key4.private?)
-    rsa1024 = Fixtures.pkey("rsa1024")
-
-    # Generated by RSA#set_key
-    key5 = OpenSSL::PKey::RSA.new
-    key5.set_key(rsa1024.n, rsa1024.e, rsa1024.d)
-    assert(key5.private?)
-
-    # Generated by RSA#set_key, without d
-    key6 = OpenSSL::PKey::RSA.new
-    key6.set_key(rsa1024.n, rsa1024.e, nil)
-    assert(!key6.private?)
-  end
-
-  def test_new
-    key = OpenSSL::PKey::RSA.new 512
-    pem  = key.public_key.to_pem
-    OpenSSL::PKey::RSA.new pem
-    assert_equal([], OpenSSL.errors)
-  end
-
-  def test_new_exponent_default
-    assert_equal(65537, OpenSSL::PKey::RSA.new(512).e)
-  end
-
-  def test_new_with_exponent
-    1.upto(30) do |idx|
-      e = (2 ** idx) + 1
-      key = OpenSSL::PKey::RSA.new(512, e)
-      assert_equal(e, key.e)
-    end
-  end
-
-  def test_generate
-    key = OpenSSL::PKey::RSA.generate(512, 17)
-    assert_equal 512, key.n.num_bits
-    assert_equal 17, key.e
-    assert_not_nil key.d
-  end
-
-  def test_new_break
-    assert_nil(OpenSSL::PKey::RSA.new(1024) { break })
-    assert_raise(RuntimeError) do
-      OpenSSL::PKey::RSA.new(1024) { raise }
-    end
-  end
-
-  def test_sign_verify
-    rsa1024 = Fixtures.pkey("rsa1024")
-    data = "Sign me!"
-    signature = rsa1024.sign("SHA1", data)
-    assert_equal true, rsa1024.verify("SHA1", signature, data)
-
-    signature0 = (<<~'end;').unpack("m")[0]
-      oLCgbprPvfhM4pjFQiDTFeWI9Sk+Og7Nh9TmIZ/xSxf2CGXQrptlwo7NQ28+
-      WA6YQo8jPH4hSuyWIM4Gz4qRYiYRkl5TDMUYob94zm8Si1HxEiS9354tzvqS
-      zS8MLW2BtNPuTubMxTItHGTnOzo9sUg0LAHVFt8kHG2NfKAw/gQ=
-    end;
-    assert_equal true, rsa1024.verify("SHA256", signature0, data)
-    signature1 = signature0.succ
-    assert_equal false, rsa1024.verify("SHA256", signature1, data)
-  end
-
-  def test_digest_state_irrelevant_sign
-    key = Fixtures.pkey("rsa1024")
-    digest1 = OpenSSL::Digest.new('SHA1')
-    digest2 = OpenSSL::Digest.new('SHA1')
-    data = 'Sign me!'
-    digest1 << 'Change state of digest1'
-    sig1 = key.sign(digest1, data)
-    sig2 = key.sign(digest2, data)
-    assert_equal(sig1, sig2)
-  end
-
-  def test_digest_state_irrelevant_verify
-    key = Fixtures.pkey("rsa1024")
-    digest1 = OpenSSL::Digest.new('SHA1')
-    digest2 = OpenSSL::Digest.new('SHA1')
-    data = 'Sign me!'
-    sig = key.sign(digest1, data)
-    digest1.reset
-    digest1 << 'Change state of digest1'
-    assert(key.verify(digest1, sig, data))
-    assert(key.verify(digest2, sig, data))
-  end
-
-  def test_verify_empty_rsa
-    rsa = OpenSSL::PKey::RSA.new
-    assert_raise(OpenSSL::PKey::PKeyError, "[Bug #12783]") {
-      rsa.verify("SHA1", "a", "b")
-    }
-  end
-
-  def test_sign_verify_pss
-    key = Fixtures.pkey("rsa1024")
-    data = "Sign me!"
-    invalid_data = "Sign me?"
-
-    signature = key.sign_pss("SHA256", data, salt_length: 20, mgf1_hash: "SHA1")
-    assert_equal 128, signature.bytesize
-    assert_equal true,
-      key.verify_pss("SHA256", signature, data, salt_length: 20, mgf1_hash: "SHA1")
-    assert_equal true,
-      key.verify_pss("SHA256", signature, data, salt_length: :auto, mgf1_hash: "SHA1")
-    assert_equal false,
-      key.verify_pss("SHA256", signature, invalid_data, salt_length: 20, mgf1_hash: "SHA1")
-
-    signature = key.sign_pss("SHA256", data, salt_length: :digest, mgf1_hash: "SHA1")
-    assert_equal true,
-      key.verify_pss("SHA256", signature, data, salt_length: 32, mgf1_hash: "SHA1")
-    assert_equal true,
-      key.verify_pss("SHA256", signature, data, salt_length: :auto, mgf1_hash: "SHA1")
-    assert_equal false,
-      key.verify_pss("SHA256", signature, data, salt_length: 20, mgf1_hash: "SHA1")
-
-    signature = key.sign_pss("SHA256", data, salt_length: :max, mgf1_hash: "SHA1")
-    assert_equal true,
-      key.verify_pss("SHA256", signature, data, salt_length: 94, mgf1_hash: "SHA1")
-    assert_equal true,
-      key.verify_pss("SHA256", signature, data, salt_length: :auto, mgf1_hash: "SHA1")
-
-    assert_raise(OpenSSL::PKey::RSAError) {
-      key.sign_pss("SHA256", data, salt_length: 95, mgf1_hash: "SHA1")
-    }
-  end
-
-  def test_export
-    rsa1024 = Fixtures.pkey("rsa1024")
-    key = OpenSSL::PKey::RSA.new
-
-    # key has only n, e and d
-    key.set_key(rsa1024.n, rsa1024.e, rsa1024.d)
-    assert_equal rsa1024.public_key.export, key.export
-
-    # key has only n, e, d, p and q
-    key.set_factors(rsa1024.p, rsa1024.q)
-    assert_equal rsa1024.public_key.export, key.export
-
-    # key has n, e, d, p, q, dmp1, dmq1 and iqmp
-    key.set_crt_params(rsa1024.dmp1, rsa1024.dmq1, rsa1024.iqmp)
-    assert_equal rsa1024.export, key.export
-  end
-
-  def test_to_der
-    rsa1024 = Fixtures.pkey("rsa1024")
-    key = OpenSSL::PKey::RSA.new
-
-    # key has only n, e and d
-    key.set_key(rsa1024.n, rsa1024.e, rsa1024.d)
-    assert_equal rsa1024.public_key.to_der, key.to_der
-
-    # key has only n, e, d, p and q
-    key.set_factors(rsa1024.p, rsa1024.q)
-    assert_equal rsa1024.public_key.to_der, key.to_der
-
-    # key has n, e, d, p, q, dmp1, dmq1 and iqmp
-    key.set_crt_params(rsa1024.dmp1, rsa1024.dmq1, rsa1024.iqmp)
-    assert_equal rsa1024.to_der, key.to_der
-  end
-
-  def test_RSAPrivateKey
-    rsa1024 = Fixtures.pkey("rsa1024")
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Integer(0),
-      OpenSSL::ASN1::Integer(rsa1024.n),
-      OpenSSL::ASN1::Integer(rsa1024.e),
-      OpenSSL::ASN1::Integer(rsa1024.d),
-      OpenSSL::ASN1::Integer(rsa1024.p),
-      OpenSSL::ASN1::Integer(rsa1024.q),
-      OpenSSL::ASN1::Integer(rsa1024.dmp1),
-      OpenSSL::ASN1::Integer(rsa1024.dmq1),
-      OpenSSL::ASN1::Integer(rsa1024.iqmp)
-    ])
-    key = OpenSSL::PKey::RSA.new(asn1.to_der)
-    assert_predicate key, :private?
-    assert_same_rsa rsa1024, key
-
-    pem = <<~EOF
-    -----BEGIN RSA PRIVATE KEY-----
-    MIICXgIBAAKBgQDLwsSw1ECnPtT+PkOgHhcGA71nwC2/nL85VBGnRqDxOqjVh7Cx
-    aKPERYHsk4BPCkE3brtThPWc9kjHEQQ7uf9Y1rbCz0layNqHyywQEVLFmp1cpIt/
-    Q3geLv8ZD9pihowKJDyMDiN6ArYUmZczvW4976MU3+l54E6lF/JfFEU5hwIDAQAB
-    AoGBAKSl/MQarye1yOysqX6P8fDFQt68VvtXkNmlSiKOGuzyho0M+UVSFcs6k1L0
-    maDE25AMZUiGzuWHyaU55d7RXDgeskDMakD1v6ZejYtxJkSXbETOTLDwUWTn618T
-    gnb17tU1jktUtU67xK/08i/XodlgnQhs6VoHTuCh3Hu77O6RAkEA7+gxqBuZR572
-    74/akiW/SuXm0SXPEviyO1MuSRwtI87B02D0qgV8D1UHRm4AhMnJ8MCs1809kMQE
-    JiQUCrp9mQJBANlt2ngBO14us6NnhuAseFDTBzCHXwUUu1YKHpMMmxpnGqaldGgX
-    sOZB3lgJsT9VlGf3YGYdkLTNVbogQKlKpB8CQQDiSwkb4vyQfDe8/NpU5Not0fII
-    8jsDUCb+opWUTMmfbxWRR3FBNu8wnym/m19N4fFj8LqYzHX4KY0oVPu6qvJxAkEA
-    wa5snNekFcqONLIE4G5cosrIrb74sqL8GbGb+KuTAprzj5z1K8Bm0UW9lTjVDjDi
-    qRYgZfZSL+x1P/54+xTFSwJAY1FxA/N3QPCXCjPh5YqFxAMQs2VVYTfg+t0MEcJD
-    dPMQD5JX6g5HKnHFg2mZtoXQrWmJSn7p8GJK8yNTopEErA==
-    -----END RSA PRIVATE KEY-----
-    EOF
-    key = OpenSSL::PKey::RSA.new(pem)
-    assert_same_rsa rsa1024, key
-
-    assert_equal asn1.to_der, rsa1024.to_der
-    assert_equal pem, rsa1024.export
-  end
-
-  def test_RSAPrivateKey_encrypted
-    rsa1024 = Fixtures.pkey("rsa1024")
-    # key = abcdef
-    pem = <<~EOF
-    -----BEGIN RSA PRIVATE KEY-----
-    Proc-Type: 4,ENCRYPTED
-    DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0
-
-    zgJniZZQfvv8TFx3LzV6zhAQVayvQVZlAYqFq2yWbbxzF7C+IBhKQle9IhUQ9j/y
-    /jkvol550LS8vZ7TX5WxyDLe12cdqzEvpR6jf3NbxiNysOCxwG4ErhaZGP+krcoB
-    ObuL0nvls/+3myy5reKEyy22+0GvTDjaChfr+FwJjXMG+IBCLscYdgZC1LQL6oAn
-    9xY5DH3W7BW4wR5ttxvtN32TkfVQh8xi3jrLrduUh+hV8DTiAiLIhv0Vykwhep2p
-    WZA+7qbrYaYM8GLLgLrb6LfBoxeNxAEKiTpl1quFkm+Hk1dKq0EhVnxHf92x0zVF
-    jRGZxAMNcrlCoE4f5XK45epVZSZvihdo1k73GPbp84aZ5P/xlO4OwZ3i4uCQXynl
-    jE9c+I+4rRWKyPz9gkkqo0+teJL8ifeKt/3ab6FcdA0aArynqmsKJMktxmNu83We
-    YVGEHZPeOlyOQqPvZqWsLnXQUfg54OkbuV4/4mWSIzxFXdFy/AekSeJugpswMXqn
-    oNck4qySNyfnlyelppXyWWwDfVus9CVAGZmJQaJExHMT/rQFRVchlmY0Ddr5O264
-    gcjv90o1NBOc2fNcqjivuoX7ROqys4K/YdNQ1HhQ7usJghADNOtuLI8ZqMh9akXD
-    Eqp6Ne97wq1NiJj0nt3SJlzTnOyTjzrTe0Y+atPkVKp7SsjkATMI9JdhXwGhWd7a
-    qFVl0owZiDasgEhyG2K5L6r+yaJLYkPVXZYC/wtWC3NEchnDWZGQcXzB4xROCQkD
-    OlWNYDkPiZioeFkA3/fTMvG4moB2Pp9Q4GU5fJ6k43Ccu1up8dX/LumZb4ecg5/x
-    -----END RSA PRIVATE KEY-----
-    EOF
-    key = OpenSSL::PKey::RSA.new(pem, "abcdef")
-    assert_same_rsa rsa1024, key
-    key = OpenSSL::PKey::RSA.new(pem) { "abcdef" }
-    assert_same_rsa rsa1024, key
-
-    cipher = OpenSSL::Cipher.new("aes-128-cbc")
-    exported = rsa1024.to_pem(cipher, "abcdef\0\1")
-    assert_same_rsa rsa1024, OpenSSL::PKey::RSA.new(exported, "abcdef\0\1")
-    assert_raise(OpenSSL::PKey::RSAError) {
-      OpenSSL::PKey::RSA.new(exported, "abcdef")
-    }
-  end
-
-  def test_RSAPublicKey
-    rsa1024 = Fixtures.pkey("rsa1024")
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Integer(rsa1024.n),
-      OpenSSL::ASN1::Integer(rsa1024.e)
-    ])
-    key = OpenSSL::PKey::RSA.new(asn1.to_der)
-    assert_not_predicate key, :private?
-    assert_same_rsa dup_public(rsa1024), key
-
-    pem = <<~EOF
-    -----BEGIN RSA PUBLIC KEY-----
-    MIGJAoGBAMvCxLDUQKc+1P4+Q6AeFwYDvWfALb+cvzlUEadGoPE6qNWHsLFoo8RF
-    geyTgE8KQTduu1OE9Zz2SMcRBDu5/1jWtsLPSVrI2ofLLBARUsWanVyki39DeB4u
-    /xkP2mKGjAokPIwOI3oCthSZlzO9bj3voxTf6XngTqUX8l8URTmHAgMBAAE=
-    -----END RSA PUBLIC KEY-----
-    EOF
-    key = OpenSSL::PKey::RSA.new(pem)
-    assert_same_rsa dup_public(rsa1024), key
-  end
-
-  def test_PUBKEY
-    rsa1024 = Fixtures.pkey("rsa1024")
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Sequence([
-        OpenSSL::ASN1::ObjectId("rsaEncryption"),
-        OpenSSL::ASN1::Null(nil)
-      ]),
-      OpenSSL::ASN1::BitString(
-        OpenSSL::ASN1::Sequence([
-          OpenSSL::ASN1::Integer(rsa1024.n),
-          OpenSSL::ASN1::Integer(rsa1024.e)
-        ]).to_der
-      )
-    ])
-    key = OpenSSL::PKey::RSA.new(asn1.to_der)
-    assert_not_predicate key, :private?
-    assert_same_rsa dup_public(rsa1024), key
-
-    pem = <<~EOF
-    -----BEGIN PUBLIC KEY-----
-    MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDLwsSw1ECnPtT+PkOgHhcGA71n
-    wC2/nL85VBGnRqDxOqjVh7CxaKPERYHsk4BPCkE3brtThPWc9kjHEQQ7uf9Y1rbC
-    z0layNqHyywQEVLFmp1cpIt/Q3geLv8ZD9pihowKJDyMDiN6ArYUmZczvW4976MU
-    3+l54E6lF/JfFEU5hwIDAQAB
-    -----END PUBLIC KEY-----
-    EOF
-    key = OpenSSL::PKey::RSA.new(pem)
-    assert_same_rsa dup_public(rsa1024), key
-
-    assert_equal asn1.to_der, dup_public(rsa1024).to_der
-    assert_equal pem, dup_public(rsa1024).export
-  end
-
-  def test_pem_passwd
-    key = Fixtures.pkey("rsa1024")
-    pem3c = key.to_pem("aes-128-cbc", "key")
-    assert_match (/ENCRYPTED/), pem3c
-    assert_equal key.to_der, OpenSSL::PKey.read(pem3c, "key").to_der
-    assert_equal key.to_der, OpenSSL::PKey.read(pem3c) { "key" }.to_der
-    assert_raise(OpenSSL::PKey::PKeyError) {
-      OpenSSL::PKey.read(pem3c) { nil }
-    }
-  end
-
-  def test_private_encoding
-    rsa1024 = Fixtures.pkey("rsa1024")
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Integer(0),
-      OpenSSL::ASN1::Sequence([
-        OpenSSL::ASN1::ObjectId("rsaEncryption"),
-        OpenSSL::ASN1::Null(nil)
-      ]),
-      OpenSSL::ASN1::OctetString(rsa1024.to_der)
-    ])
-    assert_equal asn1.to_der, rsa1024.private_to_der
-    assert_same_rsa rsa1024, OpenSSL::PKey.read(asn1.to_der)
-
-    pem = <<~EOF
-    -----BEGIN PRIVATE KEY-----
-    MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAMvCxLDUQKc+1P4+
-    Q6AeFwYDvWfALb+cvzlUEadGoPE6qNWHsLFoo8RFgeyTgE8KQTduu1OE9Zz2SMcR
-    BDu5/1jWtsLPSVrI2ofLLBARUsWanVyki39DeB4u/xkP2mKGjAokPIwOI3oCthSZ
-    lzO9bj3voxTf6XngTqUX8l8URTmHAgMBAAECgYEApKX8xBqvJ7XI7Kypfo/x8MVC
-    3rxW+1eQ2aVKIo4a7PKGjQz5RVIVyzqTUvSZoMTbkAxlSIbO5YfJpTnl3tFcOB6y
-    QMxqQPW/pl6Ni3EmRJdsRM5MsPBRZOfrXxOCdvXu1TWOS1S1TrvEr/TyL9eh2WCd
-    CGzpWgdO4KHce7vs7pECQQDv6DGoG5lHnvbvj9qSJb9K5ebRJc8S+LI7Uy5JHC0j
-    zsHTYPSqBXwPVQdGbgCEycnwwKzXzT2QxAQmJBQKun2ZAkEA2W3aeAE7Xi6zo2eG
-    4Cx4UNMHMIdfBRS7VgoekwybGmcapqV0aBew5kHeWAmxP1WUZ/dgZh2QtM1VuiBA
-    qUqkHwJBAOJLCRvi/JB8N7z82lTk2i3R8gjyOwNQJv6ilZRMyZ9vFZFHcUE27zCf
-    Kb+bX03h8WPwupjMdfgpjShU+7qq8nECQQDBrmyc16QVyo40sgTgblyiysitvviy
-    ovwZsZv4q5MCmvOPnPUrwGbRRb2VONUOMOKpFiBl9lIv7HU//nj7FMVLAkBjUXED
-    83dA8JcKM+HlioXEAxCzZVVhN+D63QwRwkN08xAPklfqDkcqccWDaZm2hdCtaYlK
-    funwYkrzI1OikQSs
-    -----END PRIVATE KEY-----
-    EOF
-    assert_equal pem, rsa1024.private_to_pem
-    assert_same_rsa rsa1024, OpenSSL::PKey.read(pem)
-  end
-
-  def test_private_encoding_encrypted
-    rsa1024 = Fixtures.pkey("rsa1024")
-    encoded = rsa1024.private_to_der("aes-128-cbc", "abcdef")
-    asn1 = OpenSSL::ASN1.decode(encoded) # PKCS #8 EncryptedPrivateKeyInfo
-    assert_kind_of OpenSSL::ASN1::Sequence, asn1
-    assert_equal 2, asn1.value.size
-    assert_not_equal rsa1024.private_to_der, encoded
-    assert_same_rsa rsa1024, OpenSSL::PKey.read(encoded, "abcdef")
-    assert_same_rsa rsa1024, OpenSSL::PKey.read(encoded) { "abcdef" }
-    assert_raise(OpenSSL::PKey::PKeyError) { OpenSSL::PKey.read(encoded, "abcxyz") }
-
-    encoded = rsa1024.private_to_pem("aes-128-cbc", "abcdef")
-    assert_match (/BEGIN ENCRYPTED PRIVATE KEY/), encoded.lines[0]
-    assert_same_rsa rsa1024, OpenSSL::PKey.read(encoded, "abcdef")
-
-    # certtool --load-privkey=test/fixtures/pkey/rsa1024.pem --to-p8 --password=abcdef
-    pem = <<~EOF
-    -----BEGIN ENCRYPTED PRIVATE KEY-----
-    MIICojAcBgoqhkiG9w0BDAEDMA4ECLqajUdSNfzwAgIEkQSCAoCDWhxr1HUrKLXA
-    FsFGGQfPT0aKH4gZipaSXXQRl0KwifHwHoDtfo/mAkJVZMnUVOm1AQ4LTFS3EdTy
-    JUwICGEQHb7QAiokIRoi0K2yHhOxVO8qgbnWuisWpiT6Ru1jCqTs/wcqlqF7z2jM
-    oXDk/vuekKst1DDXDcHrzhDkwhCQWj6jt1r2Vwaryy0FyeqsWAgBDiK2LsnCgkGD
-    21uhNZ/iWMG6tvY9hB8MDdiBJ41YdSG/AKLulAxQ1ibJz0Tasu66TmwFvWhBlME+
-    QbqfgmkgWg5buu53SvDfCA47zXihclbtdfW+U3CJ9OJkx0535TVdZbuC1QgKXvG7
-    4iKGFRMWYJqZvZM3GL4xbC75AxjXZsdCfV81VjZxjeU6ung/NRzCuCUcmBOQzo1D
-    Vv6COwAa6ttQWM0Ti8oIQHdu5Qi+nuOEHDLxCxD962M37H99sEO5cESjmrGVxhEo
-    373L4+11geGSCajdp0yiAGnXQfwaKta8cL693bRObN+b1Y+vqtDKH26N9a4R3qgg
-    2XwgQ5GH5CODoXZpi0wxncXO+3YuuhGeArtzKSXLNxHzIMlY7wZX+0e9UU03zfV/
-    aOe4/q5DpkNxgHePt0oEpamSKY5W3jzVi1dlFWsRjud1p/Grt2zjSWTYClBlJqG1
-    A/3IeDZCu+acaePJjFyv5dFffIj2l4bAYB+LFrZlSu3F/EimO/dCDWJ9JGlMK0aF
-    l9brh7786Mo+YfyklaqMMEHBbbR2Es7PR6Gt7lrcIXmzy9XSsxT6IiD1rG9KKR3i
-    CQxTup6JAx9w1q+adL+Ypikoy3gGD/ccUY6TtPoCmkQwSCS+JqQnFlCiThDJbu+V
-    eqqUNkZq
-    -----END ENCRYPTED PRIVATE KEY-----
-    EOF
-    assert_same_rsa rsa1024, OpenSSL::PKey.read(pem, "abcdef")
-  end
-
-  def test_public_encoding
-    rsa1024 = Fixtures.pkey("rsa1024")
-    assert_equal dup_public(rsa1024).to_der, rsa1024.public_to_der
-    assert_equal dup_public(rsa1024).to_pem, rsa1024.public_to_pem
-  end
-
-  def test_dup
-    key = Fixtures.pkey("rsa1024")
-    key2 = key.dup
-    assert_equal key.params, key2.params
-    key2.set_key(key2.n, 3, key2.d)
-    assert_not_equal key.params, key2.params
-  end
-
-  def test_marshal
-    key = Fixtures.pkey("rsa2048")
-    deserialized = Marshal.load(Marshal.dump(key))
-
-    assert_equal key.to_der, deserialized.to_der
-  end
-
-  private
-  def assert_same_rsa(expected, key)
-    check_component(expected, key, [:n, :e, :d, :p, :q, :dmp1, :dmq1, :iqmp])
-  end
-end
-
-end
diff --git a/test/openssl/test_random.rb b/test/openssl/test_random.rb
deleted file mode 100644
index 33af375..0000000
--- a/test/openssl/test_random.rb
+++ /dev/null
@@ -1,19 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestRandom < OpenSSL::TestCase
-  def test_random_bytes
-    assert_equal("", OpenSSL::Random.random_bytes(0))
-    assert_equal(12, OpenSSL::Random.random_bytes(12).bytesize)
-  end
-
-  def test_pseudo_bytes
-    # deprecated as of OpenSSL 1.1.0
-    assert_equal("", OpenSSL::Random.pseudo_bytes(0))
-    assert_equal(12, OpenSSL::Random.pseudo_bytes(12).bytesize)
-  end if OpenSSL::Random.methods.include?(:pseudo_bytes)
-end
-
-end
diff --git a/test/openssl/test_ssl.rb b/test/openssl/test_ssl.rb
deleted file mode 100644
index 2d9ee7b..0000000
--- a/test/openssl/test_ssl.rb
+++ /dev/null
@@ -1,1761 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestSSL < OpenSSL::SSLTestCase
-  def test_ctx_options
-    ctx = OpenSSL::SSL::SSLContext.new
-
-    assert (OpenSSL::SSL::OP_ALL & ctx.options) == OpenSSL::SSL::OP_ALL,
-           "OP_ALL is set by default"
-    ctx.options = 4
-    assert_equal 4, ctx.options & 4
-    if ctx.options != 4
-      pend "SSL_CTX_set_options() seems to be modified by distributor"
-    end
-    ctx.options = nil
-    assert_equal OpenSSL::SSL::OP_ALL, ctx.options
-
-    assert_equal true, ctx.setup
-    assert_predicate ctx, :frozen?
-    assert_equal nil, ctx.setup
-  end
-
-  def test_ssl_with_server_cert
-    ctx_proc = -> ctx {
-      ctx.cert = @svr_cert
-      ctx.key = @svr_key
-      ctx.extra_chain_cert = [@ca_cert]
-    }
-    server_proc = -> (ctx, ssl) {
-      assert_equal @svr_cert.to_der, ssl.cert.to_der
-      assert_equal nil, ssl.peer_cert
-
-      readwrite_loop(ctx, ssl)
-    }
-    start_server(ctx_proc: ctx_proc, server_proc: server_proc) { |port|
-      begin
-        sock = TCPSocket.new("127.0.0.1", port)
-        ctx = OpenSSL::SSL::SSLContext.new
-        ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)
-        ssl.connect
-
-        assert_equal sock, ssl.io
-        assert_equal nil, ssl.cert
-        assert_equal @svr_cert.to_der, ssl.peer_cert.to_der
-        assert_equal 2, ssl.peer_cert_chain.size
-        assert_equal @svr_cert.to_der, ssl.peer_cert_chain[0].to_der
-        assert_equal @ca_cert.to_der, ssl.peer_cert_chain[1].to_der
-
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      ensure
-        ssl&.close
-        sock&.close
-      end
-    }
-  end
-
-  def test_socket_open
-    start_server { |port|
-      begin
-        ssl = OpenSSL::SSL::SSLSocket.open("127.0.0.1", port)
-        ssl.sync_close = true
-        ssl.connect
-
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      ensure
-        ssl&.close
-      end
-    }
-  end
-
-  def test_socket_open_with_context
-    start_server { |port|
-      begin
-        ctx = OpenSSL::SSL::SSLContext.new
-        ssl = OpenSSL::SSL::SSLSocket.open("127.0.0.1", port, context: ctx)
-        ssl.sync_close = true
-        ssl.connect
-
-        assert_equal ssl.context, ctx
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      ensure
-        ssl&.close
-      end
-    }
-  end
-
-  def test_socket_open_with_local_address_port_context
-    start_server { |port|
-      begin
-        # Guess a free port number
-        random_port = rand(49152..65535)
-        ctx = OpenSSL::SSL::SSLContext.new
-        ssl = OpenSSL::SSL::SSLSocket.open("127.0.0.1", port, "127.0.0.1", random_port, context: ctx)
-        ssl.sync_close = true
-        ssl.connect
-
-        assert_equal ctx, ssl.context
-        assert_equal random_port, ssl.io.local_address.ip_port
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      rescue Errno::EADDRINUSE
-      ensure
-        ssl&.close
-      end
-    }
-  end
-
-  def test_add_certificate
-    ctx_proc = -> ctx {
-      # Unset values set by start_server
-      ctx.cert = ctx.key = ctx.extra_chain_cert = nil
-      ctx.add_certificate(@svr_cert, @svr_key, [@ca_cert]) # RSA
-    }
-    start_server(ctx_proc: ctx_proc) do |port|
-      server_connect(port) { |ssl|
-        assert_equal @svr_cert.subject, ssl.peer_cert.subject
-        assert_equal [@svr_cert.subject, @ca_cert.subject],
-          ssl.peer_cert_chain.map(&:subject)
-
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      }
-    end
-  end
-
-  def test_add_certificate_multiple_certs
-    pend "EC is not supported" unless defined?(OpenSSL::PKey::EC)
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-
-    # SSL_CTX_set0_chain() is needed for setting multiple certificate chains
-    add0_chain_supported = openssl?(1, 0, 2)
-
-    if add0_chain_supported
-      ca2_key = Fixtures.pkey("rsa-3")
-      ca2_exts = [
-        ["basicConstraints", "CA:TRUE", true],
-        ["keyUsage", "cRLSign, keyCertSign", true],
-      ]
-      ca2_dn = OpenSSL::X509::Name.parse_rfc2253("CN=CA2")
-      ca2_cert = issue_cert(ca2_dn, ca2_key, 123, ca2_exts, nil, nil)
-    else
-      # Use the same CA as @svr_cert
-      ca2_key = @ca_key; ca2_cert = @ca_cert
-    end
-
-    ecdsa_key = Fixtures.pkey("p256")
-    exts = [
-      ["keyUsage", "digitalSignature", false],
-    ]
-    ecdsa_dn = OpenSSL::X509::Name.parse_rfc2253("CN=localhost2")
-    ecdsa_cert = issue_cert(ecdsa_dn, ecdsa_key, 456, exts, ca2_cert, ca2_key)
-
-    if !add0_chain_supported
-      # Testing the warning emitted when 'extra' chain is replaced
-      tctx = OpenSSL::SSL::SSLContext.new
-      tctx.add_certificate(@svr_cert, @svr_key, [@ca_cert])
-      assert_warning(/set0_chain/) {
-        tctx.add_certificate(ecdsa_cert, ecdsa_key, [ca2_cert])
-      }
-    end
-
-    ctx_proc = -> ctx {
-      # Unset values set by start_server
-      ctx.cert = ctx.key = ctx.extra_chain_cert = nil
-      ctx.ecdh_curves = "P-256" unless openssl?(1, 0, 2)
-      ctx.add_certificate(@svr_cert, @svr_key, [@ca_cert]) # RSA
-      EnvUtil.suppress_warning do # !add0_chain_supported
-        ctx.add_certificate(ecdsa_cert, ecdsa_key, [ca2_cert])
-      end
-    }
-    start_server(ctx_proc: ctx_proc) do |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.max_version = :TLS1_2 # TODO: We need this to force certificate type
-      ctx.ciphers = "aECDSA"
-      server_connect(port, ctx) { |ssl|
-        assert_equal ecdsa_cert.subject, ssl.peer_cert.subject
-        assert_equal [ecdsa_cert.subject, ca2_cert.subject],
-          ssl.peer_cert_chain.map(&:subject)
-      }
-
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.max_version = :TLS1_2
-      ctx.ciphers = "aRSA"
-      server_connect(port, ctx) { |ssl|
-        assert_equal @svr_cert.subject, ssl.peer_cert.subject
-        assert_equal [@svr_cert.subject, @ca_cert.subject],
-          ssl.peer_cert_chain.map(&:subject)
-      }
-    end
-  end
-
-  def test_sysread_and_syswrite
-    start_server { |port|
-      server_connect(port) { |ssl|
-        str = +("x" * 100 + "\n")
-        ssl.syswrite(str)
-        newstr = ssl.sysread(str.bytesize)
-        assert_equal(str, newstr)
-
-        buf = String.new
-        ssl.syswrite(str)
-        assert_same buf, ssl.sysread(str.size, buf)
-        assert_equal(str, buf)
-      }
-    }
-  end
-
-  def test_sync_close
-    start_server do |port|
-      begin
-        sock = TCPSocket.new("127.0.0.1", port)
-        ssl = OpenSSL::SSL::SSLSocket.new(sock)
-        ssl.connect
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-        ssl.close
-        assert_not_predicate sock, :closed?
-      ensure
-        sock&.close
-      end
-
-      begin
-        sock = TCPSocket.new("127.0.0.1", port)
-        ssl = OpenSSL::SSL::SSLSocket.new(sock)
-        ssl.sync_close = true  # !!
-        ssl.connect
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-        ssl.close
-        assert_predicate sock, :closed?
-      ensure
-        sock&.close
-      end
-    end
-  end
-
-  def test_copy_stream
-    start_server do |port|
-      server_connect(port) do |ssl|
-        IO.pipe do |r, w|
-          str = "hello world\n"
-          w.write(str)
-          IO.copy_stream(r, ssl, str.bytesize)
-          IO.copy_stream(ssl, w, str.bytesize)
-          assert_equal str, r.read(str.bytesize)
-        end
-      end
-    end
-  end
-
-  def test_client_auth_failure
-    vflag = OpenSSL::SSL::VERIFY_PEER|OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT
-    start_server(verify_mode: vflag, ignore_listener_error: true) { |port|
-      assert_handshake_error {
-        server_connect(port) { |ssl| ssl.puts("abc"); ssl.gets }
-      }
-    }
-  end
-
-  def test_client_auth_success
-    vflag = OpenSSL::SSL::VERIFY_PEER|OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT
-    start_server(verify_mode: vflag,
-      ctx_proc: proc { |ctx|
-        ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION if libressl?(3, 2, 0)
-    }) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.key = @cli_key
-      ctx.cert = @cli_cert
-
-      server_connect(port, ctx) { |ssl|
-        ssl.puts("foo")
-        assert_equal("foo\n", ssl.gets)
-      }
-
-      called = nil
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.client_cert_cb = Proc.new{ |sslconn|
-        called = true
-        [@cli_cert, @cli_key]
-      }
-
-      server_connect(port, ctx) { |ssl|
-        assert(called)
-        ssl.puts("foo")
-        assert_equal("foo\n", ssl.gets)
-      }
-    }
-  end
-
-  def test_client_auth_public_key
-    vflag = OpenSSL::SSL::VERIFY_PEER|OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT
-    start_server(verify_mode: vflag, ignore_listener_error: true) do |port|
-      assert_raise(ArgumentError) {
-        ctx = OpenSSL::SSL::SSLContext.new
-        ctx.key = @cli_key.public_key
-        ctx.cert = @cli_cert
-        server_connect(port, ctx) { |ssl| ssl.puts("abc"); ssl.gets }
-      }
-
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.client_cert_cb = Proc.new{ |ssl|
-        [@cli_cert, @cli_key.public_key]
-      }
-      assert_handshake_error {
-        server_connect(port, ctx) { |ssl| ssl.puts("abc"); ssl.gets }
-      }
-    end
-  end
-
-  def test_client_ca
-    pend "LibreSSL 3.2 has broken client CA support" if libressl?(3, 2, 0)
-
-    ctx_proc = Proc.new do |ctx|
-      ctx.client_ca = [@ca_cert]
-    end
-
-    vflag = OpenSSL::SSL::VERIFY_PEER|OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT
-    start_server(verify_mode: vflag, ctx_proc: ctx_proc) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      client_ca_from_server = nil
-      ctx.client_cert_cb = Proc.new do |sslconn|
-        client_ca_from_server = sslconn.client_ca
-        [@cli_cert, @cli_key]
-      end
-      server_connect(port, ctx) { |ssl|
-        assert_equal([@ca], client_ca_from_server)
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      }
-    }
-  end
-
-  def test_read_nonblock_without_session
-    EnvUtil.suppress_warning do
-      start_server(start_immediately: false) { |port|
-        sock = TCPSocket.new("127.0.0.1", port)
-        ssl = OpenSSL::SSL::SSLSocket.new(sock)
-        ssl.sync_close = true
-
-        assert_equal :wait_readable, ssl.read_nonblock(100, exception: false)
-        ssl.write("abc\n")
-        IO.select [ssl]
-        assert_equal('a', ssl.read_nonblock(1))
-        assert_equal("bc\n", ssl.read_nonblock(100))
-        assert_equal :wait_readable, ssl.read_nonblock(100, exception: false)
-        ssl.close
-      }
-    end
-  end
-
-  def test_starttls
-    server_proc = -> (ctx, ssl) {
-      while line = ssl.gets
-        if line =~ /^STARTTLS$/
-          ssl.write("x")
-          ssl.flush
-          ssl.accept
-          break
-        end
-        ssl.write(line)
-      end
-      readwrite_loop(ctx, ssl)
-    }
-
-    EnvUtil.suppress_warning do # read/write on not started session
-      start_server(start_immediately: false,
-                   server_proc: server_proc) { |port|
-        begin
-          sock = TCPSocket.new("127.0.0.1", port)
-          ssl = OpenSSL::SSL::SSLSocket.new(sock)
-
-          ssl.puts "plaintext"
-          assert_equal "plaintext\n", ssl.gets
-
-          ssl.puts("STARTTLS")
-          ssl.read(1)
-          ssl.connect
-
-          ssl.puts "over-tls"
-          assert_equal "over-tls\n", ssl.gets
-        ensure
-          ssl&.close
-          sock&.close
-        end
-      }
-    end
-  end
-
-  def test_parallel
-    start_server { |port|
-      ssls = []
-      10.times{
-        sock = TCPSocket.new("127.0.0.1", port)
-        ssl = OpenSSL::SSL::SSLSocket.new(sock)
-        ssl.connect
-        ssl.sync_close = true
-        ssls << ssl
-      }
-      str = "x" * 1000 + "\n"
-      ITERATIONS.times{
-        ssls.each{|ssl|
-          ssl.puts(str)
-          assert_equal(str, ssl.gets)
-        }
-      }
-      ssls.each{|ssl| ssl.close }
-    }
-  end
-
-  def test_verify_result
-    start_server(ignore_listener_error: true) { |port|
-      sock = TCPSocket.new("127.0.0.1", port)
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.verify_mode = OpenSSL::SSL::VERIFY_PEER
-      ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)
-      ssl.sync_close = true
-      begin
-        assert_raise(OpenSSL::SSL::SSLError){ ssl.connect }
-        assert_equal(OpenSSL::X509::V_ERR_SELF_SIGNED_CERT_IN_CHAIN, ssl.verify_result)
-      ensure
-        ssl.close
-      end
-    }
-
-    start_server { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.verify_mode = OpenSSL::SSL::VERIFY_PEER
-      ctx.verify_callback = Proc.new do |preverify_ok, store_ctx|
-        store_ctx.error = OpenSSL::X509::V_OK
-        true
-      end
-      server_connect(port, ctx) { |ssl|
-        assert_equal(OpenSSL::X509::V_OK, ssl.verify_result)
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      }
-    }
-
-    start_server(ignore_listener_error: true) { |port|
-      sock = TCPSocket.new("127.0.0.1", port)
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.verify_mode = OpenSSL::SSL::VERIFY_PEER
-      ctx.verify_callback = Proc.new do |preverify_ok, store_ctx|
-        store_ctx.error = OpenSSL::X509::V_ERR_APPLICATION_VERIFICATION
-        false
-      end
-      ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)
-      ssl.sync_close = true
-      begin
-        assert_raise(OpenSSL::SSL::SSLError){ ssl.connect }
-        assert_equal(OpenSSL::X509::V_ERR_APPLICATION_VERIFICATION, ssl.verify_result)
-      ensure
-        ssl.close
-      end
-    }
-  end
-
-  def test_exception_in_verify_callback_is_ignored
-    start_server(ignore_listener_error: true) { |port|
-      sock = TCPSocket.new("127.0.0.1", port)
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.verify_mode = OpenSSL::SSL::VERIFY_PEER
-      ctx.verify_callback = Proc.new do |preverify_ok, store_ctx|
-        store_ctx.error = OpenSSL::X509::V_OK
-        raise RuntimeError
-      end
-      ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)
-      ssl.sync_close = true
-      begin
-        EnvUtil.suppress_warning do
-          # SSLError, not RuntimeError
-          assert_raise(OpenSSL::SSL::SSLError) { ssl.connect }
-        end
-        assert_equal(OpenSSL::X509::V_ERR_CERT_REJECTED, ssl.verify_result)
-      ensure
-        ssl.close
-      end
-    }
-  end
-
-  def test_finished_messages
-    server_finished = nil
-    server_peer_finished = nil
-    client_finished = nil
-    client_peer_finished = nil
-
-    start_server(accept_proc: proc { |server|
-      server_finished = server.finished_message
-      server_peer_finished = server.peer_finished_message
-    }) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.verify_mode = OpenSSL::SSL::VERIFY_NONE
-      ctx.max_version = :TLS1_2 if libressl?(3, 2, 0) && !libressl?(3, 3, 0)
-      server_connect(port, ctx) { |ssl|
-        ssl.puts "abc"; ssl.gets
-
-        client_finished = ssl.finished_message
-        client_peer_finished = ssl.peer_finished_message
-      }
-    }
-    assert_not_nil(server_finished)
-    assert_not_nil(client_finished)
-    assert_equal(server_finished, client_peer_finished)
-    assert_equal(server_peer_finished, client_finished)
-  end
-
-  def test_sslctx_set_params
-    ctx = OpenSSL::SSL::SSLContext.new
-    ctx.set_params
-
-    assert_equal OpenSSL::SSL::VERIFY_PEER, ctx.verify_mode
-    ciphers_names = ctx.ciphers.collect{|v, _, _, _| v }
-    assert ciphers_names.all?{|v| /A(EC)?DH/ !~ v }, "anon ciphers are disabled"
-    assert ciphers_names.all?{|v| /(RC4|MD5|EXP|DES(?!-EDE|-CBC3))/ !~ v }, "weak ciphers are disabled"
-    assert_equal 0, ctx.options & OpenSSL::SSL::OP_DONT_INSERT_EMPTY_FRAGMENTS
-    assert_equal OpenSSL::SSL::OP_NO_COMPRESSION,
-                 ctx.options & OpenSSL::SSL::OP_NO_COMPRESSION
-  end
-
-  def test_post_connect_check_with_anon_ciphers
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-
-    ctx_proc = -> ctx {
-      ctx.ssl_version = :TLSv1_2
-      ctx.ciphers = "aNULL"
-      ctx.security_level = 0
-    }
-
-    start_server(ctx_proc: ctx_proc) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.ssl_version = :TLSv1_2
-      ctx.ciphers = "aNULL"
-      ctx.security_level = 0
-      server_connect(port, ctx) { |ssl|
-        assert_raise_with_message(OpenSSL::SSL::SSLError, /anonymous cipher suite/i) {
-          ssl.post_connection_check("localhost.localdomain")
-        }
-      }
-    }
-  end
-
-  def test_post_connection_check
-    sslerr = OpenSSL::SSL::SSLError
-
-    start_server { |port|
-      server_connect(port) { |ssl|
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-
-        assert_raise(sslerr){ssl.post_connection_check("localhost.localdomain")}
-        assert_raise(sslerr){ssl.post_connection_check("127.0.0.1")}
-        assert(ssl.post_connection_check("localhost"))
-        assert_raise(sslerr){ssl.post_connection_check("foo.example.com")}
-
-        cert = ssl.peer_cert
-        assert(!OpenSSL::SSL.verify_certificate_identity(cert, "localhost.localdomain"))
-        assert(!OpenSSL::SSL.verify_certificate_identity(cert, "127.0.0.1"))
-        assert(OpenSSL::SSL.verify_certificate_identity(cert, "localhost"))
-        assert(!OpenSSL::SSL.verify_certificate_identity(cert, "foo.example.com"))
-      }
-    }
-
-    exts = [
-      ["keyUsage","keyEncipherment,digitalSignature",true],
-      ["subjectAltName","DNS:localhost.localdomain",false],
-      ["subjectAltName","IP:127.0.0.1",false],
-    ]
-    @svr_cert = issue_cert(@svr, @svr_key, 4, exts, @ca_cert, @ca_key)
-    start_server { |port|
-      server_connect(port) { |ssl|
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-
-        assert(ssl.post_connection_check("localhost.localdomain"))
-        assert(ssl.post_connection_check("127.0.0.1"))
-        assert_raise(sslerr){ssl.post_connection_check("localhost")}
-        assert_raise(sslerr){ssl.post_connection_check("foo.example.com")}
-
-        cert = ssl.peer_cert
-        assert(OpenSSL::SSL.verify_certificate_identity(cert, "localhost.localdomain"))
-        assert(OpenSSL::SSL.verify_certificate_identity(cert, "127.0.0.1"))
-        assert(!OpenSSL::SSL.verify_certificate_identity(cert, "localhost"))
-        assert(!OpenSSL::SSL.verify_certificate_identity(cert, "foo.example.com"))
-      }
-    }
-
-    exts = [
-      ["keyUsage","keyEncipherment,digitalSignature",true],
-      ["subjectAltName","DNS:*.localdomain",false],
-    ]
-    @svr_cert = issue_cert(@svr, @svr_key, 5, exts, @ca_cert, @ca_key)
-    start_server { |port|
-      server_connect(port) { |ssl|
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-
-        assert(ssl.post_connection_check("localhost.localdomain"))
-        assert_raise(sslerr){ssl.post_connection_check("127.0.0.1")}
-        assert_raise(sslerr){ssl.post_connection_check("localhost")}
-        assert_raise(sslerr){ssl.post_connection_check("foo.example.com")}
-        cert = ssl.peer_cert
-        assert(OpenSSL::SSL.verify_certificate_identity(cert, "localhost.localdomain"))
-        assert(!OpenSSL::SSL.verify_certificate_identity(cert, "127.0.0.1"))
-        assert(!OpenSSL::SSL.verify_certificate_identity(cert, "localhost"))
-        assert(!OpenSSL::SSL.verify_certificate_identity(cert, "foo.example.com"))
-      }
-    }
-  end
-
-  def test_verify_certificate_identity
-    [true, false].each do |criticality|
-      cert = create_null_byte_SAN_certificate(criticality)
-      assert_equal(false, OpenSSL::SSL.verify_certificate_identity(cert, 'www.example.com'))
-      assert_equal(true,  OpenSSL::SSL.verify_certificate_identity(cert, "www.example.com\0.evil.com"))
-      assert_equal(false, OpenSSL::SSL.verify_certificate_identity(cert, '192.168.7.255'))
-      assert_equal(true,  OpenSSL::SSL.verify_certificate_identity(cert, '192.168.7.1'))
-      assert_equal(true,  OpenSSL::SSL.verify_certificate_identity(cert, '13::17'))
-      assert_equal(false,  OpenSSL::SSL.verify_certificate_identity(cert, '13::18'))
-      assert_equal(true,  OpenSSL::SSL.verify_certificate_identity(cert, '13:0:0:0:0:0:0:17'))
-      assert_equal(false,  OpenSSL::SSL.verify_certificate_identity(cert, '44:0:0:0:0:0:0:17'))
-      assert_equal(true,  OpenSSL::SSL.verify_certificate_identity(cert, '0013:0000:0000:0000:0000:0000:0000:0017'))
-      assert_equal(false,  OpenSSL::SSL.verify_certificate_identity(cert, '1313:0000:0000:0000:0000:0000:0000:0017'))
-    end
-  end
-
-  def test_verify_hostname
-    assert_equal(true,  OpenSSL::SSL.verify_hostname("www.example.com", "*.example.com"))
-    assert_equal(false, OpenSSL::SSL.verify_hostname("www.subdomain.example.com", "*.example.com"))
-  end
-
-  def test_verify_wildcard
-    assert_equal(false, OpenSSL::SSL.verify_wildcard("foo", "x*"))
-    assert_equal(true,  OpenSSL::SSL.verify_wildcard("foo", "foo"))
-    assert_equal(true,  OpenSSL::SSL.verify_wildcard("foo", "f*"))
-    assert_equal(true,  OpenSSL::SSL.verify_wildcard("foo", "*"))
-    assert_equal(false, OpenSSL::SSL.verify_wildcard("abc*bcd", "abcd"))
-    assert_equal(false, OpenSSL::SSL.verify_wildcard("xn--qdk4b9b", "x*"))
-    assert_equal(false, OpenSSL::SSL.verify_wildcard("xn--qdk4b9b", "*--qdk4b9b"))
-    assert_equal(true,  OpenSSL::SSL.verify_wildcard("xn--qdk4b9b", "xn--qdk4b9b"))
-  end
-
-  # Comments in this test is excerpted from http://tools.ietf.org/html/rfc6125#page-27
-  def test_post_connection_check_wildcard_san
-    # case-insensitive ASCII comparison
-    # RFC 6125, section 6.4.1
-    #
-    # "..matching of the reference identifier against the presented identifier
-    # is performed by comparing the set of domain name labels using a
-    # case-insensitive ASCII comparison, as clarified by [DNS-CASE] (e.g.,
-    # "WWW.Example.Com" would be lower-cased to "www.example.com" for
-    # comparison purposes)
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:*.example.com'), 'www.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:*.Example.COM'), 'www.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:*.example.com'), 'WWW.Example.COM'))
-    # 1.  The client SHOULD NOT attempt to match a presented identifier in
-    #     which the wildcard character comprises a label other than the
-    #     left-most label (e.g., do not match bar.*.example.net).
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:www.*.com'), 'www.example.com'))
-    # 2.  If the wildcard character is the only character of the left-most
-    #     label in the presented identifier, the client SHOULD NOT compare
-    #     against anything but the left-most label of the reference
-    #     identifier (e.g., *.example.com would match foo.example.com but
-    #     not bar.foo.example.com or example.com).
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:*.example.com'), 'foo.example.com'))
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:*.example.com'), 'bar.foo.example.com'))
-    # 3.  The client MAY match a presented identifier in which the wildcard
-    #     character is not the only character of the label (e.g.,
-    #     baz*.example.net and *baz.example.net and b*z.example.net would
-    #     be taken to match baz1.example.net and foobaz.example.net and
-    #     buzz.example.net, respectively).  ...
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:baz*.example.com'), 'baz1.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:*baz.example.com'), 'foobaz.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:b*z.example.com'), 'buzz.example.com'))
-    # Section 6.4.3 of RFC6125 states that client should NOT match identifier
-    # where wildcard is other than left-most label.
-    #
-    # Also implicitly mentions the wildcard character only in singular form,
-    # and discourages matching against more than one wildcard.
-    #
-    # See RFC 6125, section 7.2, subitem 2.
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:*b*.example.com'), 'abc.example.com'))
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:*b*.example.com'), 'ab.example.com'))
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:*b*.example.com'), 'bc.example.com'))
-    #                                ...  However, the client SHOULD NOT
-    #   attempt to match a presented identifier where the wildcard
-    #   character is embedded within an A-label or U-label [IDNA-DEFS] of
-    #   an internationalized domain name [IDNA-PROTO].
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:xn*.example.com'), 'xn1ca.example.com'))
-    # part of A-label
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:xn--*.example.com'), 'xn--1ca.example.com'))
-    # part of U-label
-    # dNSName in RFC5280 is an IA5String so U-label should NOT be allowed
-    # regardless of wildcard.
-    #
-    # See Section 7.2 of RFC 5280:
-    #   IA5String is limited to the set of ASCII characters.
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_san('DNS:á*.example.com'), 'á1.example.com'))
-  end
-
-  def test_post_connection_check_wildcard_cn
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('*.example.com'), 'www.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('*.Example.COM'), 'www.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('*.example.com'), 'WWW.Example.COM'))
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('www.*.com'), 'www.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('*.example.com'), 'foo.example.com'))
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('*.example.com'), 'bar.foo.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('baz*.example.com'), 'baz1.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('*baz.example.com'), 'foobaz.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('b*z.example.com'), 'buzz.example.com'))
-    # Section 6.4.3 of RFC6125 states that client should NOT match identifier
-    # where wildcard is other than left-most label.
-    #
-    # Also implicitly mentions the wildcard character only in singular form,
-    # and discourages matching against more than one wildcard.
-    #
-    # See RFC 6125, section 7.2, subitem 2.
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('*b*.example.com'), 'abc.example.com'))
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('*b*.example.com'), 'ab.example.com'))
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('*b*.example.com'), 'bc.example.com'))
-    assert_equal(true, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('xn*.example.com'), 'xn1ca.example.com'))
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('xn--*.example.com'), 'xn--1ca.example.com'))
-    # part of U-label
-    # Subject in RFC5280 states case-insensitive ASCII comparison.
-    #
-    # See Section 7.2 of RFC 5280:
-    #   IA5String is limited to the set of ASCII characters.
-    assert_equal(false, OpenSSL::SSL.verify_certificate_identity(
-      create_cert_with_name('á*.example.com'), 'á1.example.com'))
-  end
-
-  def create_cert_with_san(san)
-    ef = OpenSSL::X509::ExtensionFactory.new
-    cert = OpenSSL::X509::Certificate.new
-    cert.subject = OpenSSL::X509::Name.parse("/DC=some/DC=site/CN=Some Site")
-    ext = ef.create_ext('subjectAltName', san)
-    cert.add_extension(ext)
-    cert
-  end
-
-  def create_cert_with_name(name)
-    cert = OpenSSL::X509::Certificate.new
-    cert.subject = OpenSSL::X509::Name.new([['DC', 'some'], ['DC', 'site'], ['CN', name]])
-    cert
-  end
-
-
-  # Create NULL byte SAN certificate
-  def create_null_byte_SAN_certificate(critical = false)
-    ef = OpenSSL::X509::ExtensionFactory.new
-    cert = OpenSSL::X509::Certificate.new
-    cert.subject = OpenSSL::X509::Name.parse "/DC=some/DC=site/CN=Some Site"
-    ext = ef.create_ext('subjectAltName', 'DNS:placeholder,IP:192.168.7.1,IP:13::17', critical)
-    ext_asn1 = OpenSSL::ASN1.decode(ext.to_der)
-    san_list_der = ext_asn1.value.reduce(nil) { |memo,val| val.tag == 4 ? val.value : memo }
-    san_list_asn1 = OpenSSL::ASN1.decode(san_list_der)
-    san_list_asn1.value[0].value = "www.example.com\0.evil.com"
-    pos = critical ? 2 : 1
-    ext_asn1.value[pos].value = san_list_asn1.to_der
-    real_ext = OpenSSL::X509::Extension.new ext_asn1
-    cert.add_extension(real_ext)
-    cert
-  end
-
-  def socketpair
-    if defined? UNIXSocket
-      UNIXSocket.pair
-    else
-      Socket.pair(Socket::AF_INET, Socket::SOCK_STREAM, 0)
-    end
-  end
-
-  def test_tlsext_hostname
-    fooctx = OpenSSL::SSL::SSLContext.new
-    fooctx.tmp_dh_callback = proc { Fixtures.pkey("dh-1") }
-    fooctx.cert = @cli_cert
-    fooctx.key = @cli_key
-
-    ctx_proc = proc { |ctx|
-      ctx.servername_cb = proc { |ssl, servername|
-        case servername
-        when "foo.example.com"
-          fooctx
-        when "bar.example.com"
-          nil
-        else
-          raise "unreachable"
-        end
-      }
-    }
-    start_server(ctx_proc: ctx_proc) do |port|
-      sock = TCPSocket.new("127.0.0.1", port)
-      begin
-        ssl = OpenSSL::SSL::SSLSocket.new(sock)
-        ssl.hostname = "foo.example.com"
-        ssl.connect
-        assert_equal @cli_cert.serial, ssl.peer_cert.serial
-        assert_predicate fooctx, :frozen?
-
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      ensure
-        ssl&.close
-        sock.close
-      end
-
-      sock = TCPSocket.new("127.0.0.1", port)
-      begin
-        ssl = OpenSSL::SSL::SSLSocket.new(sock)
-        ssl.hostname = "bar.example.com"
-        ssl.connect
-        assert_equal @svr_cert.serial, ssl.peer_cert.serial
-
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      ensure
-        ssl&.close
-        sock.close
-      end
-    end
-  end
-
-  def test_servername_cb_raises_an_exception_on_unknown_objects
-    hostname = 'example.org'
-
-    ctx2 = OpenSSL::SSL::SSLContext.new
-    ctx2.cert = @svr_cert
-    ctx2.key = @svr_key
-    ctx2.tmp_dh_callback = proc { Fixtures.pkey("dh-1") }
-    ctx2.servername_cb = lambda { |args| Object.new }
-
-    sock1, sock2 = socketpair
-
-    s2 = OpenSSL::SSL::SSLSocket.new(sock2, ctx2)
-
-    ctx1 = OpenSSL::SSL::SSLContext.new
-
-    s1 = OpenSSL::SSL::SSLSocket.new(sock1, ctx1)
-    s1.hostname = hostname
-    t = Thread.new {
-      assert_raise(OpenSSL::SSL::SSLError) do
-        s1.connect
-      end
-    }
-
-    assert_raise(ArgumentError) do
-      s2.accept
-    end
-
-    assert t.join
-  ensure
-    sock1.close if sock1
-    sock2.close if sock2
-  end
-
-  def test_verify_hostname_on_connect
-    ctx_proc = proc { |ctx|
-      san = "DNS:a.example.com,DNS:*.b.example.com"
-      san += ",DNS:c*.example.com,DNS:d.*.example.com" unless libressl?(3, 2, 2)
-      exts = [
-        ["keyUsage", "keyEncipherment,digitalSignature", true],
-        ["subjectAltName", san],
-      ]
-
-      ctx.cert = issue_cert(@svr, @svr_key, 4, exts, @ca_cert, @ca_key)
-      ctx.key = @svr_key
-    }
-
-    start_server(ctx_proc: ctx_proc, ignore_listener_error: true) do |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.verify_hostname = true
-      ctx.cert_store = OpenSSL::X509::Store.new
-      ctx.cert_store.add_cert(@ca_cert)
-      ctx.verify_mode = OpenSSL::SSL::VERIFY_PEER
-
-      [
-        ["a.example.com", true],
-        ["A.Example.Com", true],
-        ["x.example.com", false],
-        ["b.example.com", false],
-        ["x.b.example.com", true],
-        ["cx.example.com", true],
-        ["d.x.example.com", false],
-      ].each do |name, expected_ok|
-        next if name.start_with?('cx') if libressl?(3, 2, 2)
-        begin
-          sock = TCPSocket.new("127.0.0.1", port)
-          ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)
-          ssl.hostname = name
-          if expected_ok
-            ssl.connect
-            ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-          else
-            assert_handshake_error { ssl.connect }
-          end
-        ensure
-          ssl.close if ssl
-          sock.close if sock
-        end
-      end
-    end
-  end
-
-  def test_verify_hostname_failure_error_code
-    ctx_proc = proc { |ctx|
-      exts = [
-        ["keyUsage", "keyEncipherment,digitalSignature", true],
-        ["subjectAltName", "DNS:a.example.com"],
-      ]
-      ctx.cert = issue_cert(@svr, @svr_key, 4, exts, @ca_cert, @ca_key)
-      ctx.key = @svr_key
-    }
-
-    start_server(ctx_proc: ctx_proc, ignore_listener_error: true) do |port|
-      verify_callback_ok = verify_callback_err = nil
-
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.verify_hostname = true
-      ctx.cert_store = OpenSSL::X509::Store.new
-      ctx.cert_store.add_cert(@ca_cert)
-      ctx.verify_mode = OpenSSL::SSL::VERIFY_PEER
-      ctx.verify_callback = -> (preverify_ok, store_ctx) {
-        verify_callback_ok = preverify_ok
-        verify_callback_err = store_ctx.error
-        preverify_ok
-      }
-
-      begin
-        sock = TCPSocket.new("127.0.0.1", port)
-        ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)
-        ssl.hostname = "b.example.com"
-        assert_handshake_error { ssl.connect }
-        assert_equal false, verify_callback_ok
-        code_expected = openssl?(1, 0, 2) || defined?(OpenSSL::X509::V_ERR_HOSTNAME_MISMATCH) ?
-          OpenSSL::X509::V_ERR_HOSTNAME_MISMATCH :
-          OpenSSL::X509::V_ERR_CERT_REJECTED
-        assert_equal code_expected, verify_callback_err
-      ensure
-        sock&.close
-      end
-    end
-  end
-
-  def test_connect_certificate_verify_failed_exception_message
-    start_server(ignore_listener_error: true) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.set_params
-      assert_raise_with_message(OpenSSL::SSL::SSLError, /self signed/) {
-        server_connect(port, ctx)
-      }
-    }
-
-    ctx_proc = proc { |ctx|
-      ctx.cert = issue_cert(@svr, @svr_key, 30, [], @ca_cert, @ca_key,
-                            not_before: Time.now-100, not_after: Time.now-10)
-    }
-    start_server(ignore_listener_error: true, ctx_proc: ctx_proc) { |port|
-      store = OpenSSL::X509::Store.new
-      store.add_cert(@ca_cert)
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.set_params(cert_store: store)
-      assert_raise_with_message(OpenSSL::SSL::SSLError, /expired/) {
-        server_connect(port, ctx)
-      }
-    }
-  end
-
-  def test_unset_OP_ALL
-    ctx_proc = Proc.new { |ctx|
-      # If OP_DONT_INSERT_EMPTY_FRAGMENTS is not defined, this test is
-      # redundant because the default options already are equal to OP_ALL.
-      # But it also degrades gracefully, so keep it
-      ctx.options = OpenSSL::SSL::OP_ALL
-    }
-    start_server(ctx_proc: ctx_proc) { |port|
-      server_connect(port) { |ssl|
-        ssl.puts('hello')
-        assert_equal("hello\n", ssl.gets)
-      }
-    }
-  end
-
-  def check_supported_protocol_versions
-    possible_versions = [
-      OpenSSL::SSL::SSL3_VERSION,
-      OpenSSL::SSL::TLS1_VERSION,
-      OpenSSL::SSL::TLS1_1_VERSION,
-      OpenSSL::SSL::TLS1_2_VERSION,
-      # OpenSSL 1.1.1
-      defined?(OpenSSL::SSL::TLS1_3_VERSION) && OpenSSL::SSL::TLS1_3_VERSION,
-    ].compact
-
-    # Prepare for testing & do sanity check
-    supported = []
-    possible_versions.each do |ver|
-      catch(:unsupported) {
-        ctx_proc = proc { |ctx|
-          begin
-            ctx.min_version = ctx.max_version = ver
-          rescue ArgumentError, OpenSSL::SSL::SSLError
-            throw :unsupported
-          end
-        }
-        start_server(ctx_proc: ctx_proc, ignore_listener_error: true) do |port|
-          begin
-            server_connect(port) { |ssl|
-              ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-            }
-          rescue OpenSSL::SSL::SSLError, Errno::ECONNRESET
-          else
-            supported << ver
-          end
-        end
-      }
-    end
-    assert_not_empty supported
-
-    supported
-  end
-
-  def test_set_params_min_version
-    supported = check_supported_protocol_versions
-    store = OpenSSL::X509::Store.new
-    store.add_cert(@ca_cert)
-
-    if supported.include?(OpenSSL::SSL::SSL3_VERSION)
-      # SSLContext#set_params properly disables SSL 3.0 by default
-      ctx_proc = proc { |ctx|
-        ctx.min_version = ctx.max_version = OpenSSL::SSL::SSL3_VERSION
-      }
-      start_server(ctx_proc: ctx_proc, ignore_listener_error: true) { |port|
-        ctx = OpenSSL::SSL::SSLContext.new
-        ctx.set_params(cert_store: store, verify_hostname: false)
-        assert_handshake_error { server_connect(port, ctx) { } }
-      }
-    end
-  end
-
-  def test_minmax_version
-    supported = check_supported_protocol_versions
-
-    # name: The string that would be returned by SSL_get_version()
-    # method: The version-specific method name (if any)
-    vmap = {
-      OpenSSL::SSL::SSL3_VERSION => { name: "SSLv3", method: "SSLv3" },
-      OpenSSL::SSL::SSL3_VERSION => { name: "SSLv3", method: "SSLv3" },
-      OpenSSL::SSL::TLS1_VERSION => { name: "TLSv1", method: "TLSv1" },
-      OpenSSL::SSL::TLS1_1_VERSION => { name: "TLSv1.1", method: "TLSv1_1" },
-      OpenSSL::SSL::TLS1_2_VERSION => { name: "TLSv1.2", method: "TLSv1_2" },
-      # OpenSSL 1.1.1
-      defined?(OpenSSL::SSL::TLS1_3_VERSION) && OpenSSL::SSL::TLS1_3_VERSION =>
-      { name: "TLSv1.3", method: nil },
-    }
-
-    # Server enables a single version
-    supported.each do |ver|
-      ctx_proc = proc { |ctx| ctx.min_version = ctx.max_version = ver }
-      start_server(ctx_proc: ctx_proc, ignore_listener_error: true) { |port|
-        supported.each do |cver|
-          # Client enables a single version
-          ctx1 = OpenSSL::SSL::SSLContext.new
-          ctx1.min_version = ctx1.max_version = cver
-          if ver == cver
-            server_connect(port, ctx1) { |ssl|
-              assert_equal vmap[cver][:name], ssl.ssl_version
-              ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-            }
-          else
-            assert_handshake_error { server_connect(port, ctx1) { } }
-          end
-
-          # There is no version-specific SSL methods for TLS 1.3
-          if cver <= OpenSSL::SSL::TLS1_2_VERSION
-            # Client enables a single version using #ssl_version=
-            ctx2 = OpenSSL::SSL::SSLContext.new
-            ctx2.ssl_version = vmap[cver][:method]
-            if ver == cver
-              server_connect(port, ctx2) { |ssl|
-                assert_equal vmap[cver][:name], ssl.ssl_version
-                ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-              }
-            else
-              assert_handshake_error { server_connect(port, ctx2) { } }
-            end
-          end
-        end
-
-        # Client enables all supported versions
-        ctx3 = OpenSSL::SSL::SSLContext.new
-        ctx3.min_version = ctx3.max_version = nil
-        server_connect(port, ctx3) { |ssl|
-          assert_equal vmap[ver][:name], ssl.ssl_version
-          ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-        }
-      }
-    end
-
-    if supported.size == 1
-      pend "More than one protocol version must be supported"
-    end
-
-    # Server sets min_version (earliest is disabled)
-    sver = supported[1]
-    ctx_proc = proc { |ctx| ctx.min_version = sver }
-    start_server(ctx_proc: ctx_proc, ignore_listener_error: true) { |port|
-      supported.each do |cver|
-        # Client sets min_version
-        ctx1 = OpenSSL::SSL::SSLContext.new
-        ctx1.min_version = cver
-        server_connect(port, ctx1) { |ssl|
-          assert_equal vmap[supported.last][:name], ssl.ssl_version
-          ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-        }
-
-        # Client sets max_version
-        ctx2 = OpenSSL::SSL::SSLContext.new
-        ctx2.max_version = cver
-        if cver >= sver
-          server_connect(port, ctx2) { |ssl|
-            assert_equal vmap[cver][:name], ssl.ssl_version
-            ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-          }
-        else
-          assert_handshake_error { server_connect(port, ctx2) { } }
-        end
-      end
-    }
-
-    # Server sets max_version (latest is disabled)
-    sver = supported[-2]
-    ctx_proc = proc { |ctx| ctx.max_version = sver }
-    start_server(ctx_proc: ctx_proc, ignore_listener_error: true) { |port|
-      supported.each do |cver|
-        # Client sets min_version
-        ctx1 = OpenSSL::SSL::SSLContext.new
-        ctx1.min_version = cver
-        if cver <= sver
-          server_connect(port, ctx1) { |ssl|
-            assert_equal vmap[sver][:name], ssl.ssl_version
-            ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-          }
-        else
-          assert_handshake_error { server_connect(port, ctx1) { } }
-        end
-
-        # Client sets max_version
-        ctx2 = OpenSSL::SSL::SSLContext.new
-        ctx2.max_version = cver
-        server_connect(port, ctx2) { |ssl|
-          if cver >= sver
-            assert_equal vmap[sver][:name], ssl.ssl_version
-          else
-            assert_equal vmap[cver][:name], ssl.ssl_version
-          end
-          ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-        }
-      end
-    }
-  end
-
-  def test_options_disable_versions
-    # Note: Use of these OP_* flags has been deprecated since OpenSSL 1.1.0.
-    supported = check_supported_protocol_versions
-
-    if supported.include?(OpenSSL::SSL::TLS1_1_VERSION) &&
-        supported.include?(OpenSSL::SSL::TLS1_2_VERSION)
-      # Server disables ~ TLS 1.1
-      ctx_proc = proc { |ctx|
-        ctx.options |= OpenSSL::SSL::OP_NO_SSLv2 | OpenSSL::SSL::OP_NO_SSLv3 |
-          OpenSSL::SSL::OP_NO_TLSv1 | OpenSSL::SSL::OP_NO_TLSv1_1
-      }
-      start_server(ctx_proc: ctx_proc, ignore_listener_error: true) { |port|
-        # Client only supports TLS 1.1
-        ctx1 = OpenSSL::SSL::SSLContext.new
-        ctx1.min_version = ctx1.max_version = OpenSSL::SSL::TLS1_1_VERSION
-        assert_handshake_error { server_connect(port, ctx1) { } }
-
-        # Client only supports TLS 1.2
-        ctx2 = OpenSSL::SSL::SSLContext.new
-        ctx2.min_version = ctx2.max_version = OpenSSL::SSL::TLS1_2_VERSION
-        assert_nothing_raised { server_connect(port, ctx2) { } }
-      }
-
-      # Server only supports TLS 1.1
-      ctx_proc = proc { |ctx|
-        ctx.min_version = ctx.max_version = OpenSSL::SSL::TLS1_1_VERSION
-      }
-      start_server(ctx_proc: ctx_proc, ignore_listener_error: true) { |port|
-        # Client disables TLS 1.1
-        ctx1 = OpenSSL::SSL::SSLContext.new
-        ctx1.options |= OpenSSL::SSL::OP_NO_TLSv1_1
-        assert_handshake_error { server_connect(port, ctx1) { } }
-
-        # Client disables TLS 1.2
-        ctx2 = OpenSSL::SSL::SSLContext.new
-        ctx2.options |= OpenSSL::SSL::OP_NO_TLSv1_2
-        assert_nothing_raised { server_connect(port, ctx2) { } }
-      }
-    else
-      pend "TLS 1.1 and TLS 1.2 must be supported; skipping"
-    end
-  end
-
-  def test_ssl_methods_constant
-    EnvUtil.suppress_warning { # Deprecated in v2.1.0
-      base = [:TLSv1_2, :TLSv1_1, :TLSv1, :SSLv3, :SSLv2, :SSLv23]
-      base.each do |name|
-        assert_include OpenSSL::SSL::SSLContext::METHODS, name
-        assert_include OpenSSL::SSL::SSLContext::METHODS, :"#{name}_client"
-        assert_include OpenSSL::SSL::SSLContext::METHODS, :"#{name}_server"
-      end
-    }
-  end
-
-  def test_renegotiation_cb
-    num_handshakes = 0
-    renegotiation_cb = Proc.new { |ssl| num_handshakes += 1 }
-    ctx_proc = Proc.new { |ctx| ctx.renegotiation_cb = renegotiation_cb }
-    start_server_version(:SSLv23, ctx_proc) { |port|
-      server_connect(port) { |ssl|
-        assert_equal(1, num_handshakes)
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      }
-    }
-  end
-
-if openssl?(1, 0, 2) || libressl?
-  def test_alpn_protocol_selection_ary
-    advertised = ["http/1.1", "spdy/2"]
-    ctx_proc = Proc.new { |ctx|
-      ctx.alpn_select_cb = -> (protocols) {
-        protocols.first
-      }
-      ctx.alpn_protocols = advertised
-    }
-    start_server_version(:SSLv23, ctx_proc) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.alpn_protocols = advertised
-      server_connect(port, ctx) { |ssl|
-        assert_equal(advertised.first, ssl.alpn_protocol)
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      }
-    }
-  end
-
-  def test_alpn_protocol_selection_cancel
-    sock1, sock2 = socketpair
-
-    ctx1 = OpenSSL::SSL::SSLContext.new
-    ctx1.cert = @svr_cert
-    ctx1.key = @svr_key
-    ctx1.tmp_dh_callback = proc { Fixtures.pkey("dh-1") }
-    ctx1.alpn_select_cb = -> (protocols) { nil }
-    ssl1 = OpenSSL::SSL::SSLSocket.new(sock1, ctx1)
-
-    ctx2 = OpenSSL::SSL::SSLContext.new
-    ctx2.alpn_protocols = ["http/1.1"]
-    ssl2 = OpenSSL::SSL::SSLSocket.new(sock2, ctx2)
-
-    t = Thread.new {
-      ssl2.connect_nonblock(exception: false)
-    }
-    assert_raise_with_message(TypeError, /nil/) { ssl1.accept }
-    t.join
-  ensure
-    sock1&.close
-    sock2&.close
-    ssl1&.close
-    ssl2&.close
-    t&.kill
-    t&.join
-  end
-end
-
-  def test_npn_protocol_selection_ary
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-    pend "NPN is not supported" unless \
-      OpenSSL::SSL::SSLContext.method_defined?(:npn_select_cb)
-    pend "LibreSSL 2.6 has broken NPN functions" if libressl?(2, 6, 1)
-
-    advertised = ["http/1.1", "spdy/2"]
-    ctx_proc = proc { |ctx| ctx.npn_protocols = advertised }
-    start_server_version(:TLSv1_2, ctx_proc) { |port|
-      selector = lambda { |which|
-        ctx = OpenSSL::SSL::SSLContext.new
-        ctx.npn_select_cb = -> (protocols) { protocols.send(which) }
-        server_connect(port, ctx) { |ssl|
-          assert_equal(advertised.send(which), ssl.npn_protocol)
-        }
-      }
-      selector.call(:first)
-      selector.call(:last)
-    }
-  end
-
-  def test_npn_protocol_selection_enum
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-    pend "NPN is not supported" unless \
-      OpenSSL::SSL::SSLContext.method_defined?(:npn_select_cb)
-    pend "LibreSSL 2.6 has broken NPN functions" if libressl?(2, 6, 1)
-
-    advertised = Object.new
-    def advertised.each
-      yield "http/1.1"
-      yield "spdy/2"
-    end
-    ctx_proc = Proc.new { |ctx| ctx.npn_protocols = advertised }
-    start_server_version(:TLSv1_2, ctx_proc) { |port|
-      selector = lambda { |selected, which|
-        ctx = OpenSSL::SSL::SSLContext.new
-        ctx.npn_select_cb = -> (protocols) { protocols.to_a.send(which) }
-        server_connect(port, ctx) { |ssl|
-          assert_equal(selected, ssl.npn_protocol)
-        }
-      }
-      selector.call("http/1.1", :first)
-      selector.call("spdy/2", :last)
-    }
-  end
-
-  def test_npn_protocol_selection_cancel
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-    pend "NPN is not supported" unless \
-      OpenSSL::SSL::SSLContext.method_defined?(:npn_select_cb)
-    pend "LibreSSL 2.6 has broken NPN functions" if libressl?(2, 6, 1)
-
-    ctx_proc = Proc.new { |ctx| ctx.npn_protocols = ["http/1.1"] }
-    start_server_version(:TLSv1_2, ctx_proc) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.npn_select_cb = -> (protocols) { raise RuntimeError.new }
-      assert_raise(RuntimeError) { server_connect(port, ctx) }
-    }
-  end
-
-  def test_npn_advertised_protocol_too_long
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-    pend "NPN is not supported" unless \
-      OpenSSL::SSL::SSLContext.method_defined?(:npn_select_cb)
-    pend "LibreSSL 2.6 has broken NPN functions" if libressl?(2, 6, 1)
-
-    ctx_proc = Proc.new { |ctx| ctx.npn_protocols = ["a" * 256] }
-    start_server_version(:TLSv1_2, ctx_proc) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.npn_select_cb = -> (protocols) { protocols.first }
-      assert_handshake_error { server_connect(port, ctx) }
-    }
-  end
-
-  def test_npn_selected_protocol_too_long
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-    pend "NPN is not supported" unless \
-      OpenSSL::SSL::SSLContext.method_defined?(:npn_select_cb)
-    pend "LibreSSL 2.6 has broken NPN functions" if libressl?(2, 6, 1)
-
-    ctx_proc = Proc.new { |ctx| ctx.npn_protocols = ["http/1.1"] }
-    start_server_version(:TLSv1_2, ctx_proc) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.npn_select_cb = -> (protocols) { "a" * 256 }
-      assert_handshake_error { server_connect(port, ctx) }
-    }
-  end
-
-  def readwrite_loop_safe(ctx, ssl)
-    readwrite_loop(ctx, ssl)
-  rescue OpenSSL::SSL::SSLError
-  end
-
-  def test_close_after_socket_close
-    start_server(server_proc: method(:readwrite_loop_safe)) { |port|
-      sock = TCPSocket.new("127.0.0.1", port)
-      ssl = OpenSSL::SSL::SSLSocket.new(sock)
-      ssl.connect
-      ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      sock.close
-      assert_nothing_raised do
-        ssl.close
-      end
-    }
-  end
-
-  def test_sync_close_without_connect
-    Socket.open(:INET, :STREAM) {|s|
-      ssl = OpenSSL::SSL::SSLSocket.new(s)
-      ssl.sync_close = true
-      ssl.close
-      assert(s.closed?)
-    }
-  end
-
-  def test_get_ephemeral_key
-    # OpenSSL >= 1.0.2
-    unless OpenSSL::SSL::SSLSocket.method_defined?(:tmp_key)
-      pend "SSL_get_server_tmp_key() is not supported"
-    end
-
-    if tls12_supported?
-      # kRSA
-      ctx_proc1 = proc { |ctx|
-        ctx.ssl_version = :TLSv1_2
-        ctx.ciphers = "kRSA"
-      }
-      start_server(ctx_proc: ctx_proc1, ignore_listener_error: true) do |port|
-        ctx = OpenSSL::SSL::SSLContext.new
-        ctx.ssl_version = :TLSv1_2
-        ctx.ciphers = "kRSA"
-        begin
-          server_connect(port, ctx) { |ssl| assert_nil ssl.tmp_key }
-        rescue OpenSSL::SSL::SSLError
-          # kRSA seems disabled
-          raise unless $!.message =~ /no cipher/
-        end
-      end
-    end
-
-    if defined?(OpenSSL::PKey::DH) && tls12_supported?
-      # DHE
-      # TODO: How to test this with TLS 1.3?
-      ctx_proc2 = proc { |ctx|
-        ctx.ssl_version = :TLSv1_2
-        ctx.ciphers = "EDH"
-      }
-      start_server(ctx_proc: ctx_proc2) do |port|
-        ctx = OpenSSL::SSL::SSLContext.new
-        ctx.ssl_version = :TLSv1_2
-        ctx.ciphers = "EDH"
-        server_connect(port, ctx) { |ssl|
-          assert_instance_of OpenSSL::PKey::DH, ssl.tmp_key
-        }
-      end
-    end
-
-    if defined?(OpenSSL::PKey::EC)
-      # ECDHE
-      ctx_proc3 = proc { |ctx|
-        ctx.ciphers = "DEFAULT:!kRSA:!kEDH"
-        ctx.ecdh_curves = "P-256"
-      }
-      start_server(ctx_proc: ctx_proc3) do |port|
-        ctx = OpenSSL::SSL::SSLContext.new
-        ctx.ciphers = "DEFAULT:!kRSA:!kEDH"
-        server_connect(port, ctx) { |ssl|
-          assert_instance_of OpenSSL::PKey::EC, ssl.tmp_key
-          ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-        }
-      end
-    end
-  end
-
-  def test_fallback_scsv
-    supported = check_supported_protocol_versions
-    return unless supported.include?(OpenSSL::SSL::TLS1_1_VERSION) &&
-      supported.include?(OpenSSL::SSL::TLS1_2_VERSION)
-
-    pend "Fallback SCSV is not supported" unless \
-      OpenSSL::SSL::SSLContext.method_defined?(:enable_fallback_scsv)
-
-    start_server do |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION
-      # Here is OK
-      # TLS1.2 supported and this is what we ask the first time
-      server_connect(port, ctx)
-    end
-
-    ctx_proc = proc { |ctx|
-      ctx.max_version = OpenSSL::SSL::TLS1_1_VERSION
-    }
-    start_server(ctx_proc: ctx_proc) do |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.enable_fallback_scsv
-      ctx.max_version = OpenSSL::SSL::TLS1_1_VERSION
-      # Here is OK too
-      # TLS1.2 not supported, fallback to TLS1.1 and signaling the fallback
-      # Server doesn't support better, so connection OK
-      server_connect(port, ctx)
-    end
-
-    # Here is not OK
-    # TLS1.2 is supported, fallback to TLS1.1 (downgrade attack) and signaling the fallback
-    # Server support better, so refuse the connection
-    sock1, sock2 = socketpair
-    begin
-      # This test is for the downgrade protection mechanism of TLS1.2.
-      # This is why ctx1 bounds max_version == TLS1.2.
-      # Otherwise, this test fails when using openssl 1.1.1 (or later) that supports TLS1.3.
-      # TODO: We may need another test for TLS1.3 because it seems to have a different mechanism.
-      ctx1 = OpenSSL::SSL::SSLContext.new
-      ctx1.max_version = OpenSSL::SSL::TLS1_2_VERSION
-      s1 = OpenSSL::SSL::SSLSocket.new(sock1, ctx1)
-
-      ctx2 = OpenSSL::SSL::SSLContext.new
-      ctx2.enable_fallback_scsv
-      ctx2.max_version = OpenSSL::SSL::TLS1_1_VERSION
-      s2 = OpenSSL::SSL::SSLSocket.new(sock2, ctx2)
-      t = Thread.new {
-        assert_raise_with_message(OpenSSL::SSL::SSLError, /inappropriate fallback/) {
-          s2.connect
-        }
-      }
-      assert_raise_with_message(OpenSSL::SSL::SSLError, /inappropriate fallback/) {
-        s1.accept
-      }
-      t.join
-    ensure
-      sock1.close
-      sock2.close
-    end
-  end
-
-  def test_dh_callback
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-
-    dh = Fixtures.pkey("dh-1")
-    called = false
-    ctx_proc = -> ctx {
-      ctx.ssl_version = :TLSv1_2
-      ctx.ciphers = "DH:!NULL"
-      ctx.tmp_dh_callback = ->(*args) {
-        called = true
-        dh
-      }
-    }
-    start_server(ctx_proc: ctx_proc) do |port|
-      server_connect(port) { |ssl|
-        assert called, "dh callback should be called"
-        if ssl.respond_to?(:tmp_key)
-          assert_equal dh.to_der, ssl.tmp_key.to_der
-        end
-      }
-    end
-  end
-
-  def test_connect_works_when_setting_dh_callback_to_nil
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-
-    ctx_proc = -> ctx {
-      ctx.ssl_version = :TLSv1_2
-      ctx.ciphers = "DH:!NULL" # use DH
-      ctx.tmp_dh_callback = nil
-    }
-    start_server(ctx_proc: ctx_proc) do |port|
-      EnvUtil.suppress_warning { # uses default callback
-        assert_nothing_raised {
-          server_connect(port) { }
-        }
-      }
-    end
-  end
-
-  def test_tmp_ecdh_callback
-    pend "EC is disabled" unless defined?(OpenSSL::PKey::EC)
-    pend "tmp_ecdh_callback is not supported" unless \
-      OpenSSL::SSL::SSLContext.method_defined?(:tmp_ecdh_callback)
-    pend "LibreSSL 2.6 has broken SSL_CTX_set_tmp_ecdh_callback()" \
-      if libressl?(2, 6, 1)
-
-    EnvUtil.suppress_warning do # tmp_ecdh_callback is deprecated (2016-05)
-      called = false
-      ctx_proc = -> ctx {
-        ctx.ciphers = "DEFAULT:!kRSA:!kEDH"
-        ctx.tmp_ecdh_callback = -> (*args) {
-          called = true
-          OpenSSL::PKey::EC.new "prime256v1"
-        }
-      }
-      start_server(ctx_proc: ctx_proc) do |port|
-        server_connect(port) { |s|
-          assert called, "tmp_ecdh_callback should be called"
-        }
-      end
-    end
-  end
-
-  def test_ecdh_curves_tls12
-    pend "EC is disabled" unless defined?(OpenSSL::PKey::EC)
-
-    ctx_proc = -> ctx {
-      # Enable both ECDHE (~ TLS 1.2) cipher suites and TLS 1.3
-      ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION
-      ctx.ciphers = "kEECDH"
-      ctx.ecdh_curves = "P-384:P-521"
-    }
-    start_server(ctx_proc: ctx_proc, ignore_listener_error: true) do |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.ecdh_curves = "P-256:P-384" # disable P-521 for OpenSSL >= 1.0.2
-
-      server_connect(port, ctx) { |ssl|
-        cs = ssl.cipher[0]
-        assert_match (/\AECDH/), cs
-        if ssl.respond_to?(:tmp_key)
-          assert_equal "secp384r1", ssl.tmp_key.group.curve_name
-        end
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      }
-
-      if openssl?(1, 0, 2) || libressl?(2, 5, 1)
-        ctx = OpenSSL::SSL::SSLContext.new
-        ctx.ecdh_curves = "P-256"
-
-        assert_raise(OpenSSL::SSL::SSLError) {
-          server_connect(port, ctx) { }
-        }
-
-        ctx = OpenSSL::SSL::SSLContext.new
-        ctx.ecdh_curves = "P-521:P-384"
-
-        server_connect(port, ctx) { |ssl|
-          assert_equal "secp521r1", ssl.tmp_key.group.curve_name
-          ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-        }
-      end
-    end
-  end
-
-  def test_ecdh_curves_tls13
-    pend "EC is disabled" unless defined?(OpenSSL::PKey::EC)
-    pend "TLS 1.3 not supported" unless tls13_supported?
-
-    ctx_proc = -> ctx {
-      # Assume TLS 1.3 is enabled and chosen by default
-      ctx.ecdh_curves = "P-384:P-521"
-    }
-    start_server(ctx_proc: ctx_proc, ignore_listener_error: true) do |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.ecdh_curves = "P-256:P-384" # disable P-521
-
-      server_connect(port, ctx) { |ssl|
-        assert_equal "TLSv1.3", ssl.ssl_version
-        assert_equal "secp384r1", ssl.tmp_key.group.curve_name
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-      }
-    end
-  end
-
-  def test_security_level
-    ctx = OpenSSL::SSL::SSLContext.new
-    begin
-      ctx.security_level = 1
-    rescue NotImplementedError
-      assert_equal(0, ctx.security_level)
-      return
-    end
-    assert_equal(1, ctx.security_level)
-
-    dsa512 = Fixtures.pkey("dsa512")
-    dsa512_cert = issue_cert(@svr, dsa512, 50, [], @ca_cert, @ca_key)
-    rsa1024 = Fixtures.pkey("rsa1024")
-    rsa1024_cert = issue_cert(@svr, rsa1024, 51, [], @ca_cert, @ca_key)
-
-    assert_raise(OpenSSL::SSL::SSLError) {
-      # 512 bit DSA key is rejected because it offers < 80 bits of security
-      ctx.add_certificate(dsa512_cert, dsa512)
-    }
-    assert_nothing_raised {
-      ctx.add_certificate(rsa1024_cert, rsa1024)
-    }
-    ctx.security_level = 2
-    assert_raise(OpenSSL::SSL::SSLError) {
-      # < 112 bits of security
-      ctx.add_certificate(rsa1024_cert, rsa1024)
-    }
-  end
-
-  def test_dup
-    ctx = OpenSSL::SSL::SSLContext.new
-    sock1, sock2 = socketpair
-    ssl = OpenSSL::SSL::SSLSocket.new(sock1, ctx)
-
-    assert_raise(NoMethodError) { ctx.dup }
-    assert_raise(NoMethodError) { ssl.dup }
-  ensure
-    ssl.close if ssl
-    sock1.close
-    sock2.close
-  end
-
-  def test_freeze_calls_setup
-    bug = "[ruby/openssl#85]"
-    start_server(ignore_listener_error: true) { |port|
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.verify_mode = OpenSSL::SSL::VERIFY_PEER
-      ctx.freeze
-      assert_raise(OpenSSL::SSL::SSLError, bug) {
-        server_connect(port, ctx)
-      }
-    }
-  end
-
-  def test_fileno
-    ctx = OpenSSL::SSL::SSLContext.new
-    sock1, sock2 = socketpair
-
-    socket = OpenSSL::SSL::SSLSocket.new(sock1)
-    server = OpenSSL::SSL::SSLServer.new(sock2, ctx)
-
-    assert_equal socket.fileno, socket.to_io.fileno
-    assert_equal server.fileno, server.to_io.fileno
-  ensure
-    sock1.close
-    sock2.close
-  end
-
-  private
-
-  def start_server_version(version, ctx_proc = nil,
-                           server_proc = method(:readwrite_loop), &blk)
-    ctx_wrap = Proc.new { |ctx|
-      ctx.ssl_version = version
-      ctx_proc.call(ctx) if ctx_proc
-    }
-    start_server(
-      ctx_proc: ctx_wrap,
-      server_proc: server_proc,
-      ignore_listener_error: true,
-      &blk
-    )
-  end
-
-  def server_connect(port, ctx = nil)
-    sock = TCPSocket.new("127.0.0.1", port)
-    ssl = ctx ? OpenSSL::SSL::SSLSocket.new(sock, ctx) : OpenSSL::SSL::SSLSocket.new(sock)
-    ssl.sync_close = true
-    ssl.connect
-    yield ssl if block_given?
-  ensure
-    if ssl
-      ssl.close
-    elsif sock
-      sock.close
-    end
-  end
-
-  def assert_handshake_error
-    # different OpenSSL versions react differently when facing a SSL/TLS version
-    # that has been marked as forbidden, therefore any of these may be raised
-    assert_raise(OpenSSL::SSL::SSLError, Errno::ECONNRESET, Errno::EPIPE) {
-      yield
-    }
-  end
-end
-
-end
diff --git a/test/openssl/test_ssl_session.rb b/test/openssl/test_ssl_session.rb
deleted file mode 100644
index a98efda..0000000
--- a/test/openssl/test_ssl_session.rb
+++ /dev/null
@@ -1,401 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestSSLSession < OpenSSL::SSLTestCase
-  def test_session
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-
-    ctx_proc = proc { |ctx| ctx.ssl_version = :TLSv1_2 }
-    start_server(ctx_proc: ctx_proc) do |port|
-      server_connect_with_session(port, nil, nil) { |ssl|
-        session = ssl.session
-        assert(session == OpenSSL::SSL::Session.new(session.to_pem))
-        assert(session == OpenSSL::SSL::Session.new(ssl))
-        session.timeout = 5
-        assert_equal(5, session.timeout)
-        assert_not_nil(session.time)
-        # SSL_SESSION_time keeps long value so we can't keep nsec fragment.
-        session.time = t1 = Time.now.to_i
-        assert_equal(Time.at(t1), session.time)
-        assert_not_nil(session.id)
-        pem = session.to_pem
-        assert_match(/\A-----BEGIN SSL SESSION PARAMETERS-----/, pem)
-        assert_match(/-----END SSL SESSION PARAMETERS-----\Z/, pem)
-        pem.gsub!(/-----(BEGIN|END) SSL SESSION PARAMETERS-----/, '').gsub!(/[\r\n]+/m, '')
-        assert_equal(session.to_der, pem.unpack('m*')[0])
-        assert_not_nil(session.to_text)
-      }
-    end
-  end
-
-  DUMMY_SESSION = <<__EOS__
------BEGIN SSL SESSION PARAMETERS-----
-MIIDzQIBAQICAwEEAgA5BCAF219w9ZEV8dNA60cpEGOI34hJtIFbf3bkfzSgMyad
-MQQwyGLbkCxE4OiMLdKKem+pyh8V7ifoP7tCxhdmwoDlJxI1v6nVCjai+FGYuncy
-NNSWoQYCBE4DDWuiAwIBCqOCAo4wggKKMIIBcqADAgECAgECMA0GCSqGSIb3DQEB
-BQUAMD0xEzARBgoJkiaJk/IsZAEZFgNvcmcxGTAXBgoJkiaJk/IsZAEZFglydWJ5
-LWxhbmcxCzAJBgNVBAMMAkNBMB4XDTExMDYyMzA5NTQ1MVoXDTExMDYyMzEwMjQ1
-MVowRDETMBEGCgmSJomT8ixkARkWA29yZzEZMBcGCgmSJomT8ixkARkWCXJ1Ynkt
-bGFuZzESMBAGA1UEAwwJbG9jYWxob3N0MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB
-iQKBgQDLwsSw1ECnPtT+PkOgHhcGA71nwC2/nL85VBGnRqDxOqjVh7CxaKPERYHs
-k4BPCkE3brtThPWc9kjHEQQ7uf9Y1rbCz0layNqHyywQEVLFmp1cpIt/Q3geLv8Z
-D9pihowKJDyMDiN6ArYUmZczvW4976MU3+l54E6lF/JfFEU5hwIDAQABoxIwEDAO
-BgNVHQ8BAf8EBAMCBaAwDQYJKoZIhvcNAQEFBQADggEBACj5WhoZ/ODVeHpwgq1d
-8fW/13ICRYHYpv6dzlWihyqclGxbKMlMnaVCPz+4JaVtMz3QB748KJQgL3Llg3R1
-ek+f+n1MBCMfFFsQXJ2gtLB84zD6UCz8aaCWN5/czJCd7xMz7fRLy3TOIW5boXAU
-zIa8EODk+477K1uznHm286ab0Clv+9d304hwmBZgkzLg6+31Of6d6s0E0rwLGiS2
-sOWYg34Y3r4j8BS9Ak4jzpoLY6cJ0QAKCOJCgmjGr4XHpyXMLbicp3ga1uSbwtVO
-gF/gTfpLhJC+y0EQ5x3Ftl88Cq7ZJuLBDMo/TLIfReJMQu/HlrTT7+LwtneSWGmr
-KkSkAgQApQMCAROqgcMEgcAuDkAVfj6QAJMz9yqTzW5wPFyty7CxUEcwKjUqj5UP
-/Yvky1EkRuM/eQfN7ucY+MUvMqv+R8ZSkHPsnjkBN5ChvZXjrUSZKFVjR4eFVz2V
-jismLEJvIFhQh6pqTroRrOjMfTaM5Lwoytr2FTGobN9rnjIRsXeFQW1HLFbXn7Dh
-8uaQkMwIVVSGRB8T7t6z6WIdWruOjCZ6G5ASI5XoqAHwGezhLodZuvJEfsVyCF9y
-j+RBGfCFrrQbBdnkFI/ztgM=
------END SSL SESSION PARAMETERS-----
-__EOS__
-
-  DUMMY_SESSION_NO_EXT = <<-__EOS__
------BEGIN SSL SESSION PARAMETERS-----
-MIIDCAIBAQICAwAEAgA5BCDyAW7rcpzMjDSosH+Tv6sukymeqgq3xQVVMez628A+
-lAQw9TrKzrIqlHEh6ltuQaqv/Aq83AmaAlogYktZgXAjOGnhX7ifJDNLMuCfQq53
-hPAaoQYCBE4iDeeiBAICASyjggKOMIICijCCAXKgAwIBAgIBAjANBgkqhkiG9w0B
-AQUFADA9MRMwEQYKCZImiZPyLGQBGRYDb3JnMRkwFwYKCZImiZPyLGQBGRYJcnVi
-eS1sYW5nMQswCQYDVQQDDAJDQTAeFw0xMTA3MTYyMjE3MTFaFw0xMTA3MTYyMjQ3
-MTFaMEQxEzARBgoJkiaJk/IsZAEZFgNvcmcxGTAXBgoJkiaJk/IsZAEZFglydWJ5
-LWxhbmcxEjAQBgNVBAMMCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAw
-gYkCgYEAy8LEsNRApz7U/j5DoB4XBgO9Z8Atv5y/OVQRp0ag8Tqo1YewsWijxEWB
-7JOATwpBN267U4T1nPZIxxEEO7n/WNa2ws9JWsjah8ssEBFSxZqdXKSLf0N4Hi7/
-GQ/aYoaMCiQ8jA4jegK2FJmXM71uPe+jFN/peeBOpRfyXxRFOYcCAwEAAaMSMBAw
-DgYDVR0PAQH/BAQDAgWgMA0GCSqGSIb3DQEBBQUAA4IBAQA3TRzABRG3kz8jEEYr
-tDQqXgsxwTsLhTT5d1yF0D8uFw+y15hJAJnh6GJHjqhWBrF4zNoTApFo+4iIL6g3
-q9C3mUsxIVAHx41DwZBh/FI7J4FqlAoGOguu7892CNVY3ZZjc3AXMTdKjcNoWPzz
-FCdj5fNT24JMMe+ZdGZK97ChahJsdn/6B3j6ze9NK9mfYEbiJhejGTPLOFVHJCGR
-KYYZ3ZcKhLDr9ql4d7cCo1gBtemrmFQGPui7GttNEqmXqUKvV8mYoa8farf5i7T4
-L6a/gp2cVZTaDIS1HjbJsA/Ag7AajZqiN6LfqShNUVsrMZ+5CoV8EkBDTZPJ9MSr
-a3EqpAIEAKUDAgET
------END SSL SESSION PARAMETERS-----
-__EOS__
-
-
-  def test_session_time
-    sess = OpenSSL::SSL::Session.new(DUMMY_SESSION_NO_EXT)
-    sess.time = (now = Time.now)
-    assert_equal(now.to_i, sess.time.to_i)
-    sess.time = 1
-    assert_equal(1, sess.time.to_i)
-    sess.time = 1.2345
-    assert_equal(1, sess.time.to_i)
-    # Can OpenSSL handle t>2038y correctly? Version?
-    sess.time = 2**31 - 1
-    assert_equal(2**31 - 1, sess.time.to_i)
-  end
-
-  def test_session_timeout
-    sess = OpenSSL::SSL::Session.new(DUMMY_SESSION_NO_EXT)
-    assert_raise(TypeError) do
-      sess.timeout = Time.now
-    end
-    sess.timeout = 1
-    assert_equal(1, sess.timeout.to_i)
-    sess.timeout = 1.2345
-    assert_equal(1, sess.timeout.to_i)
-    sess.timeout = 2**31 - 1
-    assert_equal(2**31 - 1, sess.timeout.to_i)
-  end
-
-  def test_session_exts_read
-    assert(OpenSSL::SSL::Session.new(DUMMY_SESSION))
-  end
-
-  def test_resumption
-    non_resumable = nil
-    start_server { |port|
-      server_connect_with_session(port, nil, nil) { |ssl|
-        ssl.puts "abc"; assert_equal "abc\n", ssl.gets
-        non_resumable = ssl.session
-      }
-    }
-
-    ctx_proc = proc { |ctx|
-      ctx.options &= ~OpenSSL::SSL::OP_NO_TICKET
-      # Disable server-side session cache which is enabled by default
-      ctx.session_cache_mode = OpenSSL::SSL::SSLContext::SESSION_CACHE_OFF
-      ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION if libressl?(3, 2, 0)
-    }
-    start_server(ctx_proc: ctx_proc) do |port|
-      sess1 = server_connect_with_session(port, nil, nil) { |ssl|
-        ssl.puts("abc"); assert_equal "abc\n", ssl.gets
-        assert_equal false, ssl.session_reused?
-        ssl.session
-      }
-
-      server_connect_with_session(port, nil, non_resumable) { |ssl|
-        ssl.puts("abc"); assert_equal "abc\n", ssl.gets
-        assert_equal false, ssl.session_reused?
-      }
-
-      server_connect_with_session(port, nil, sess1) { |ssl|
-        ssl.puts("abc"); assert_equal "abc\n", ssl.gets
-        assert_equal true, ssl.session_reused?
-      }
-    end
-  end
-
-  def test_server_session_cache
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-
-    ctx_proc = Proc.new do |ctx|
-      ctx.ssl_version = :TLSv1_2
-      ctx.options |= OpenSSL::SSL::OP_NO_TICKET
-    end
-
-    connections = nil
-    saved_session = nil
-    server_proc = Proc.new do |ctx, ssl|
-      stats = ctx.session_cache_stats
-
-      case connections
-      when 0
-        assert_equal false, ssl.session_reused?
-        assert_equal 1, stats[:cache_num]
-        assert_equal 0, stats[:cache_hits]
-        assert_equal 0, stats[:cache_misses]
-      when 1
-        assert_equal true, ssl.session_reused?
-        assert_equal 1, stats[:cache_num]
-        assert_equal 1, stats[:cache_hits]
-        assert_equal 0, stats[:cache_misses]
-
-        saved_session = ssl.session
-        assert_equal true, ctx.session_remove(ssl.session)
-      when 2
-        assert_equal false, ssl.session_reused?
-        assert_equal 1, stats[:cache_num]
-        assert_equal 1, stats[:cache_hits]
-        assert_equal 1, stats[:cache_misses]
-
-        assert_equal true, ctx.session_add(saved_session.dup)
-      when 3
-        assert_equal true, ssl.session_reused?
-        assert_equal 2, stats[:cache_num]
-        assert_equal 2, stats[:cache_hits]
-        assert_equal 1, stats[:cache_misses]
-
-        ctx.flush_sessions(Time.now + 10000)
-      when 4
-        assert_equal false, ssl.session_reused?
-        assert_equal 1, stats[:cache_num]
-        assert_equal 2, stats[:cache_hits]
-        assert_equal 2, stats[:cache_misses]
-
-        assert_equal true, ctx.session_add(saved_session.dup)
-      end
-
-      readwrite_loop(ctx, ssl)
-    end
-
-    start_server(ctx_proc: ctx_proc, server_proc: server_proc) do |port|
-      first_session = nil
-      10.times do |i|
-        connections = i
-        cctx = OpenSSL::SSL::SSLContext.new
-        cctx.ssl_version = :TLSv1_2
-        server_connect_with_session(port, cctx, first_session) { |ssl|
-          ssl.puts("abc"); assert_equal "abc\n", ssl.gets
-          first_session ||= ssl.session
-
-          case connections
-          when 0;
-          when 1; assert_equal true, ssl.session_reused?
-          when 2; assert_equal false, ssl.session_reused?
-          when 3; assert_equal true, ssl.session_reused?
-          when 4; assert_equal false, ssl.session_reused?
-          when 5..9; assert_equal true, ssl.session_reused?
-          end
-        }
-      end
-    end
-  end
-
-  # Skipping tests that use session_remove_cb by default because it may cause
-  # deadlock.
-  TEST_SESSION_REMOVE_CB = ENV["OSSL_TEST_ALL"] == "1"
-
-  def test_ctx_client_session_cb
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-
-    ctx_proc = proc { |ctx| ctx.ssl_version = :TLSv1_2 }
-    start_server(ctx_proc: ctx_proc) do |port|
-      called = {}
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.session_cache_mode = OpenSSL::SSL::SSLContext::SESSION_CACHE_CLIENT
-      ctx.session_new_cb = lambda { |ary|
-        sock, sess = ary
-        called[:new] = [sock, sess]
-      }
-      if TEST_SESSION_REMOVE_CB
-        ctx.session_remove_cb = lambda { |ary|
-          ctx, sess = ary
-          called[:remove] = [ctx, sess]
-          # any resulting value is OK (ignored)
-        }
-      end
-
-      server_connect_with_session(port, ctx, nil) { |ssl|
-        assert_equal(1, ctx.session_cache_stats[:cache_num])
-        assert_equal(1, ctx.session_cache_stats[:connect_good])
-        assert_equal([ssl, ssl.session], called[:new])
-        assert(ctx.session_remove(ssl.session))
-        assert(!ctx.session_remove(ssl.session))
-        if TEST_SESSION_REMOVE_CB
-          assert_equal([ctx, ssl.session], called[:remove])
-        end
-      }
-    end
-  end
-
-  def test_ctx_server_session_cb
-    pend "TLS 1.2 is not supported" unless tls12_supported?
-
-    connections = nil
-    called = {}
-    cctx = OpenSSL::SSL::SSLContext.new
-    cctx.ssl_version = :TLSv1_2
-    sctx = nil
-    ctx_proc = Proc.new { |ctx|
-      sctx = ctx
-      ctx.ssl_version = :TLSv1_2
-      ctx.options |= OpenSSL::SSL::OP_NO_TICKET
-
-      # get_cb is called whenever a client proposed to resume a session but
-      # the session could not be found in the internal session cache.
-      last_server_session = nil
-      ctx.session_get_cb = lambda { |ary|
-        _sess, data = ary
-        called[:get] = data
-
-        if connections == 2
-          last_server_session.dup
-        else
-          nil
-        end
-      }
-
-      ctx.session_new_cb = lambda { |ary|
-        _sock, sess = ary
-        called[:new] = sess
-        last_server_session = sess
-      }
-
-      if TEST_SESSION_REMOVE_CB
-        ctx.session_remove_cb = lambda { |ary|
-          _ctx, sess = ary
-          called[:remove] = sess
-        }
-      end
-    }
-    start_server(ctx_proc: ctx_proc) do |port|
-      connections = 0
-      sess0 = server_connect_with_session(port, cctx, nil) { |ssl|
-        ssl.puts("abc"); assert_equal "abc\n", ssl.gets
-        assert_equal false, ssl.session_reused?
-        ssl.session
-      }
-      assert_nil called[:get]
-      assert_not_nil called[:new]
-      assert_equal sess0.id, called[:new].id
-      if TEST_SESSION_REMOVE_CB
-        assert_nil called[:remove]
-      end
-      called.clear
-
-      # Internal cache hit
-      connections = 1
-      server_connect_with_session(port, cctx, sess0.dup) { |ssl|
-        ssl.puts("abc"); assert_equal "abc\n", ssl.gets
-        assert_equal true, ssl.session_reused?
-        ssl.session
-      }
-      assert_nil called[:get]
-      assert_nil called[:new]
-      if TEST_SESSION_REMOVE_CB
-        assert_nil called[:remove]
-      end
-      called.clear
-
-      sctx.flush_sessions(Time.now + 10000)
-      if TEST_SESSION_REMOVE_CB
-        assert_not_nil called[:remove]
-        assert_equal sess0.id, called[:remove].id
-      end
-      called.clear
-
-      # External cache hit
-      connections = 2
-      sess2 = server_connect_with_session(port, cctx, sess0.dup) { |ssl|
-        ssl.puts("abc"); assert_equal "abc\n", ssl.gets
-        if !ssl.session_reused? && openssl?(1, 1, 0) && !openssl?(1, 1, 0, 7)
-          # OpenSSL >= 1.1.0, < 1.1.0g
-          pend "External session cache is not working; " \
-            "see https://github.com/openssl/openssl/pull/4014"
-        end
-        assert_equal true, ssl.session_reused?
-        ssl.session
-      }
-      assert_equal sess0.id, sess2.id
-      assert_equal sess0.id, called[:get]
-      assert_nil called[:new]
-      if TEST_SESSION_REMOVE_CB
-        assert_nil called[:remove]
-      end
-      called.clear
-
-      sctx.flush_sessions(Time.now + 10000)
-      if TEST_SESSION_REMOVE_CB
-        assert_not_nil called[:remove]
-        assert_equal sess0.id, called[:remove].id
-      end
-      called.clear
-
-      # Cache miss
-      connections = 3
-      sess3 = server_connect_with_session(port, cctx, sess0.dup) { |ssl|
-        ssl.puts("abc"); assert_equal "abc\n", ssl.gets
-        assert_equal false, ssl.session_reused?
-        ssl.session
-      }
-      assert_not_equal sess0.id, sess3.id
-      assert_equal sess0.id, called[:get]
-      assert_not_nil called[:new]
-      assert_equal sess3.id, called[:new].id
-      if TEST_SESSION_REMOVE_CB
-        assert_nil called[:remove]
-      end
-    end
-  end
-
-  def test_dup
-    sess_orig = OpenSSL::SSL::Session.new(DUMMY_SESSION)
-    sess_dup = sess_orig.dup
-    assert_equal(sess_orig.to_der, sess_dup.to_der)
-  end
-
-  private
-
-  def server_connect_with_session(port, ctx = nil, sess = nil)
-    sock = TCPSocket.new("127.0.0.1", port)
-    ctx ||= OpenSSL::SSL::SSLContext.new
-    ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)
-    ssl.session = sess if sess
-    ssl.sync_close = true
-    ssl.connect
-    yield ssl if block_given?
-  ensure
-    ssl&.close
-    sock&.close
-  end
-end
-
-end
diff --git a/test/openssl/test_ts.rb b/test/openssl/test_ts.rb
deleted file mode 100644
index 7cb1a1f..0000000
--- a/test/openssl/test_ts.rb
+++ /dev/null
@@ -1,680 +0,0 @@
-require_relative "utils"
-
-if defined?(OpenSSL) && defined?(OpenSSL::Timestamp)
-
-class OpenSSL::TestTimestamp < OpenSSL::TestCase
-  def intermediate_key
-    @intermediate_key ||= OpenSSL::PKey::RSA.new <<-_end_of_pem_
------BEGIN RSA PRIVATE KEY-----
-MIICWwIBAAKBgQCcyODxH+oTrr7l7MITWcGaYnnBma6vidCCJjuSzZpaRmXZHAyH
-0YcY4ttC0BdJ4uV+cE05IySVC7tyvVfFb8gFQ6XJV+AEktP+XkLbcxZgj9d2NVu1
-ziXdI+ldXkPnMhyWpMS5E7SD6gflv9NhUYEsmAGsUgdK6LDmm2W2/4TlewIDAQAB
-AoGAYgx6KDFWONLqjW3f/Sv/mGYHUNykUyDzpcD1Npyf797gqMMSzwlo3FZa2tC6
-D7n23XirwpTItvEsW9gvgMikJDPlThAeGLZ+L0UbVNNBHVxGP998Nda1kxqKvhRE
-pfZCKc7PLM9ZXc6jBTmgxdcAYfVCCVUoa2mEf9Ktr3BlI4kCQQDQAM09+wHDXGKP
-o2UnCwCazGtyGU2r0QCzHlh9BVY+KD2KjjhuWh86rEbdWN7hEW23Je1vXIhuM6Pa
-/Ccd+XYnAkEAwPZ91PK6idEONeGQ4I3dyMKV2SbaUjfq3MDL4iIQPQPuj7QsBO/5
-3Nf9ReSUUTRFCUVwoC8k4Z1KAJhR/K/ejQJANE7PTnPuGJQGETs09+GTcFpR9uqY
-FspDk8fg1ufdrVnvSAXF+TJewiGK3KU5v33jinhWQngRsyz3Wt2odKhEZwJACbjh
-oicQqvzzgFd7GzVKpWDYd/ZzLY1PsgusuhoJQ2m9TVRAm4cTycLAKhNYPbcqe0sa
-X5fAffWU0u7ZwqeByQJAOUAbYET4RU3iymAvAIDFj8LiQnizG9t5Ty3HXlijKQYv
-y8gsvWd4CdxwOPatWpBUX9L7IXcMJmD44xXTUvpbfQ==
------END RSA PRIVATE KEY-----
-_end_of_pem_
-  end
-
-  def ee_key
-    @ee_key ||= OpenSSL::PKey::RSA.new <<-_end_of_pem_
------BEGIN RSA PRIVATE KEY-----
-MIICWwIBAAKBgQDA6eB5r2O5KOKNbKMBhzadl43lgpwqq28m+G0gH38kKCL1f3o9
-P8xUZm7sZqcWEervZMSSXMGBV9DgeoSR+U6FMJywgQGx/JNRx7wZTMNym3PvgLkl
-xCXh6ZA0/xbtJtcNI+UUv0ENBkTIuUWBhkAf3jQclAr9aQ0ktYBuHAcRcQIDAQAB
-AoGAKNhcAuezwZx6e18pFEXAtpVEIfgJgK9TlXi8AjUpAkrNPBWFmDpN1QDrM3p4
-nh+lEpLPW/3vqqchPqYyM4YJraMLpS3KUG+s7+m9QIia0ri2WV5Cig7WL+Tl9p7K
-b3oi2Aj/wti8GfOLFQXOQQ4Ea4GoCv2Sxe0GZR39UBxzTsECQQD1zuVIwBvqU2YR
-8innsoa+j4u2hulRmQO6Zgpzj5vyRYfA9uZxQ9nKbfJvzuWwUv+UzyS9RqxarqrP
-5nQw5EmVAkEAyOmJg6+AfGrgvSWfSpXEds/WA/sHziCO3rE4/sd6cnDc6XcTgeMs
-mT8Z3kAYGpqFDew5orUylPfJJa+PUueJbQJAY+gkvw3+Cp69FLw1lgu0wo07fwOU
-n2qu3jsNMm0DOFRUWfTAMvcd9S385L7WEnWZldUfnKK1+OGXYYrMXPbchQJAChU2
-UoaHQzc16iguM1cK0g+iJPb/MEgQA3sPajHmokGpxIm2T+lvvo0dJjs/Om6QyN8X
-EWRYkoNQ8/Q4lCeMjQJAfvDIGtyqF4PieFHYgluQAv5pGgYpakdc8SYyeRH9NKey
-GaL27FRs4fRWf9OmxPhUVgIyGzLGXrueemvQUDHObA==
------END RSA PRIVATE KEY-----
-_end_of_pem_
-  end
-
-  def ca_cert
-    @ca_cert ||= OpenSSL::Certs.ca_cert
-  end
-
-  def ca_store
-    @ca_store ||= OpenSSL::X509::Store.new.tap { |s| s.add_cert(ca_cert) }
-  end
-
-  def ts_cert_direct
-    @ts_cert_direct ||= OpenSSL::Certs.ts_cert_direct(ee_key, ca_cert)
-  end
-
-  def intermediate_cert
-    @intermediate_cert ||= OpenSSL::Certs.intermediate_cert(intermediate_key, ca_cert)
-  end
-
-  def intermediate_store
-    @intermediate_store ||= OpenSSL::X509::Store.new.tap { |s| s.add_cert(intermediate_cert) }
-  end
-
-  def ts_cert_ee
-    @ts_cert_ee ||= OpenSSL::Certs.ts_cert_ee(ee_key, intermediate_cert, intermediate_key)
-  end
-
-  def test_request_mandatory_fields
-    req = OpenSSL::Timestamp::Request.new
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      tmp = req.to_der
-      pp OpenSSL::ASN1.decode(tmp)
-    end
-    req.algorithm = "sha1"
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      req.to_der
-    end
-    req.message_imprint = OpenSSL::Digest.digest('SHA1', "data")
-    req.to_der
-  end
-
-  def test_request_assignment
-    req = OpenSSL::Timestamp::Request.new
-
-    req.version = 2
-    assert_equal(2, req.version)
-    assert_raise(TypeError) { req.version = nil }
-    assert_raise(TypeError) { req.version = "foo" }
-
-    req.algorithm = "SHA1"
-    assert_equal("SHA1", req.algorithm)
-    assert_raise(TypeError) { req.algorithm = nil }
-    assert_raise(OpenSSL::ASN1::ASN1Error) { req.algorithm = "xxx" }
-
-    req.message_imprint = "test"
-    assert_equal("test", req.message_imprint)
-    assert_raise(TypeError) { req.message_imprint = nil }
-
-    req.policy_id = "1.2.3.4.5"
-    assert_equal("1.2.3.4.5", req.policy_id)
-    assert_raise(TypeError) { req.policy_id = 123 }
-    assert_raise(TypeError) { req.policy_id = nil }
-
-    req.nonce = 42
-    assert_equal(42, req.nonce)
-    assert_raise(TypeError) { req.nonce = "foo" }
-    assert_raise(TypeError) { req.nonce = nil }
-
-    req.cert_requested = false
-    assert_equal(false, req.cert_requested?)
-    req.cert_requested = nil
-    assert_equal(false, req.cert_requested?)
-    req.cert_requested = 123
-    assert_equal(true, req.cert_requested?)
-    req.cert_requested = "asdf"
-    assert_equal(true, req.cert_requested?)
-  end
-
-  def test_request_serialization
-    req = OpenSSL::Timestamp::Request.new
-
-    req.version = 2
-    req.algorithm = "SHA1"
-    req.message_imprint = "test"
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-    req.cert_requested = true
-
-    req = OpenSSL::Timestamp::Request.new(req.to_der)
-
-    assert_equal(2, req.version)
-    assert_equal("SHA1", req.algorithm)
-    assert_equal("test", req.message_imprint)
-    assert_equal("1.2.3.4.5", req.policy_id)
-    assert_equal(42, req.nonce)
-    assert_equal(true, req.cert_requested?)
-
-  end
-
-  def test_request_re_assignment
-    #tests whether the potential 'freeing' of previous values in C works properly
-    req = OpenSSL::Timestamp::Request.new
-    req.version = 2
-    req.version = 3
-    req.algorithm = "SHA1"
-    req.algorithm = "SHA256"
-    req.message_imprint = "test"
-    req.message_imprint = "test2"
-    req.policy_id = "1.2.3.4.5"
-    req.policy_id = "1.2.3.4.6"
-    req.nonce = 42
-    req.nonce = 24
-    req.cert_requested = false
-    req.cert_requested = true
-    req.to_der
-  end
-
-  def test_request_encode_decode
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-
-    qer = OpenSSL::Timestamp::Request.new(req.to_der)
-    assert_equal(1, qer.version)
-    assert_equal("SHA1", qer.algorithm)
-    assert_equal(digest, qer.message_imprint)
-    assert_equal("1.2.3.4.5", qer.policy_id)
-    assert_equal(42, qer.nonce)
-
-    #put OpenSSL::ASN1.decode inbetween
-    qer2 = OpenSSL::Timestamp::Request.new(OpenSSL::ASN1.decode(req.to_der))
-    assert_equal(1, qer2.version)
-    assert_equal("SHA1", qer2.algorithm)
-    assert_equal(digest, qer2.message_imprint)
-    assert_equal("1.2.3.4.5", qer2.policy_id)
-    assert_equal(42, qer2.nonce)
-  end
-
-  def test_request_invalid_asn1
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      OpenSSL::Timestamp::Request.new("*" * 44)
-    end
-  end
-
-  def test_response_constants
-    assert_equal(0, OpenSSL::Timestamp::Response::GRANTED)
-    assert_equal(1, OpenSSL::Timestamp::Response::GRANTED_WITH_MODS)
-    assert_equal(2, OpenSSL::Timestamp::Response::REJECTION)
-    assert_equal(3, OpenSSL::Timestamp::Response::WAITING)
-    assert_equal(4, OpenSSL::Timestamp::Response::REVOCATION_WARNING)
-    assert_equal(5, OpenSSL::Timestamp::Response::REVOCATION_NOTIFICATION)
-  end
-
-  def test_response_creation
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-
-    fac = OpenSSL::Timestamp::Factory.new
-    time = Time.now
-    fac.gen_time = time
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-
-    resp = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    resp = OpenSSL::Timestamp::Response.new(resp)
-    assert_equal(OpenSSL::Timestamp::Response::GRANTED, resp.status)
-    assert_nil(resp.failure_info)
-    assert_equal([], resp.status_text)
-    assert_equal(1, resp.token_info.version)
-    assert_equal("1.2.3.4.5", resp.token_info.policy_id)
-    assert_equal("SHA1", resp.token_info.algorithm)
-    assert_equal(digest, resp.token_info.message_imprint)
-    assert_equal(1, resp.token_info.serial_number)
-    assert_equal(time.to_i, resp.token_info.gen_time.to_i)
-    assert_equal(false, resp.token_info.ordering)
-    assert_nil(resp.token_info.nonce)
-    assert_cert(ts_cert_ee, resp.tsa_certificate)
-    #compare PKCS7
-    token = OpenSSL::ASN1.decode(resp.to_der).value[1]
-    assert_equal(token.to_der, resp.token.to_der)
-  end
-
-  def test_response_failure_info
-    resp = OpenSSL::Timestamp::Response.new("0\"0 \x02\x01\x020\x17\f\x15Invalid TimeStampReq.\x03\x02\x06\x80")
-    assert_equal(:BAD_ALG, resp.failure_info)
-  end
-
-  def test_response_mandatory_fields
-    fac = OpenSSL::Timestamp::Factory.new
-    req = OpenSSL::Timestamp::Request.new
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      fac.create_timestamp(ee_key, ts_cert_ee, req)
-    end
-    req.algorithm = "sha1"
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      fac.create_timestamp(ee_key, ts_cert_ee, req)
-    end
-    req.message_imprint = OpenSSL::Digest.digest('SHA1', "data")
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      fac.create_timestamp(ee_key, ts_cert_ee, req)
-    end
-    fac.gen_time = Time.now
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      fac.create_timestamp(ee_key, ts_cert_ee, req)
-    end
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      fac.create_timestamp(ee_key, ts_cert_ee, req)
-    end
-    fac.default_policy_id = "1.2.3.4.5"
-    assert_equal OpenSSL::Timestamp::Response::GRANTED, fac.create_timestamp(ee_key, ts_cert_ee, req).status
-    fac.default_policy_id = nil
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      fac.create_timestamp(ee_key, ts_cert_ee, req)
-    end
-    req.policy_id = "1.2.3.4.5"
-    assert_equal OpenSSL::Timestamp::Response::GRANTED, fac.create_timestamp(ee_key, ts_cert_ee, req).status
-  end
-
-  def test_response_allowed_digests
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    req.message_imprint = OpenSSL::Digest.digest('SHA1', "test")
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.default_policy_id = "1.2.3.4.6"
-
-    # None allowed by default
-    resp = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal OpenSSL::Timestamp::Response::REJECTION, resp.status
-
-    # Explicitly allow SHA1 (string)
-    fac.allowed_digests = ["sha1"]
-    resp = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal OpenSSL::Timestamp::Response::GRANTED, resp.status
-
-    # Explicitly allow SHA1 (object)
-    fac.allowed_digests = [OpenSSL::Digest.new('SHA1')]
-    resp = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal OpenSSL::Timestamp::Response::GRANTED, resp.status
-
-    # Others not allowed
-    req.algorithm = "SHA256"
-    req.message_imprint = OpenSSL::Digest.digest('SHA256', "test")
-    resp = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal OpenSSL::Timestamp::Response::REJECTION, resp.status
-
-    # Non-Array
-    fac.allowed_digests = 123
-    resp = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal OpenSSL::Timestamp::Response::REJECTION, resp.status
-
-    # Non-String, non-Digest Array element
-    fac.allowed_digests = ["sha1", OpenSSL::Digest.new('SHA1'), 123]
-    assert_raise(TypeError) do
-      fac.create_timestamp(ee_key, ts_cert_ee, req)
-    end
-  end
-
-  def test_response_default_policy
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    fac.default_policy_id = "1.2.3.4.6"
-
-    resp = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal(OpenSSL::Timestamp::Response::GRANTED, resp.status)
-    assert_equal("1.2.3.4.6", resp.token_info.policy_id)
-  end
-
-  def test_response_bad_purpose
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-
-
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      fac.create_timestamp(ee_key, intermediate_cert, req)
-    end
-  end
-
-  def test_response_invalid_asn1
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      OpenSSL::Timestamp::Response.new("*" * 44)
-    end
-  end
-
-  def test_no_cert_requested
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.cert_requested = false
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    fac.default_policy_id = "1.2.3.4.5"
-
-    resp = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal(OpenSSL::Timestamp::Response::GRANTED, resp.status)
-    assert_nil(resp.tsa_certificate)
-  end
-
-  def test_response_no_policy_defined
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      req = OpenSSL::Timestamp::Request.new
-      req.algorithm = "SHA1"
-      digest = OpenSSL::Digest.digest('SHA1', "test")
-      req.message_imprint = digest
-
-      fac = OpenSSL::Timestamp::Factory.new
-      fac.gen_time = Time.now
-      fac.serial_number = 1
-      fac.allowed_digests = ["sha1"]
-
-      fac.create_timestamp(ee_key, ts_cert_ee, req)
-    end
-  end
-
-  def test_verify_ee_no_req
-    assert_raise(TypeError) do
-      ts, _ = timestamp_ee
-      ts.verify(nil, ca_cert)
-    end
-  end
-
-  def test_verify_ee_no_store
-    assert_raise(TypeError) do
-      ts, req = timestamp_ee
-      ts.verify(req, nil)
-    end
-  end
-
-  def test_verify_ee_wrong_root_no_intermediate
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      ts, req = timestamp_ee
-      ts.verify(req, intermediate_store)
-    end
-  end
-
-  def test_verify_ee_wrong_root_wrong_intermediate
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      ts, req = timestamp_ee
-      ts.verify(req, intermediate_store, [ca_cert])
-    end
-  end
-
-  def test_verify_ee_nonce_mismatch
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      ts, req = timestamp_ee
-      req.nonce = 1
-      ts.verify(req, ca_store, [intermediate_cert])
-    end
-  end
-
-  def test_verify_ee_intermediate_missing
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      ts, req = timestamp_ee
-      ts.verify(req, ca_store)
-    end
-  end
-
-  def test_verify_ee_intermediate
-    ts, req = timestamp_ee
-    ts.verify(req, ca_store, [intermediate_cert])
-  end
-
-  def test_verify_ee_intermediate_type_error
-    ts, req = timestamp_ee
-    assert_raise(TypeError) { ts.verify(req, [ca_cert], 123) }
-  end
-
-  def test_verify_ee_def_policy
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.nonce = 42
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    fac.default_policy_id = "1.2.3.4.5"
-
-    ts = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    ts.verify(req, ca_store, [intermediate_cert])
-  end
-
-  def test_verify_direct
-    ts, req = timestamp_direct
-    ts.verify(req, ca_store)
-  end
-
-  def test_verify_direct_redundant_untrusted
-    ts, req = timestamp_direct
-    ts.verify(req, ca_store, [ts.tsa_certificate, ts.tsa_certificate])
-  end
-
-  def test_verify_direct_unrelated_untrusted
-    ts, req = timestamp_direct
-    ts.verify(req, ca_store, [intermediate_cert])
-  end
-
-  def test_verify_direct_wrong_root
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      ts, req = timestamp_direct
-      ts.verify(req, intermediate_store)
-    end
-  end
-
-  def test_verify_direct_no_cert_no_intermediate
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      ts, req = timestamp_direct_no_cert
-      ts.verify(req, ca_store)
-    end
-  end
-
-  def test_verify_ee_no_cert
-    ts, req = timestamp_ee_no_cert
-    ts.verify(req, ca_store, [ts_cert_ee, intermediate_cert])
-  end
-
-  def test_verify_ee_no_cert_no_intermediate
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      ts, req = timestamp_ee_no_cert
-      ts.verify(req, ca_store, [ts_cert_ee])
-    end
-  end
-
-  def test_verify_ee_additional_certs_array
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    fac.additional_certs = [intermediate_cert]
-    ts = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal(2, ts.token.certificates.size)
-    fac.additional_certs = nil
-    ts.verify(req, ca_store)
-    ts = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal(1, ts.token.certificates.size)
-  end
-
-  def test_verify_ee_additional_certs_with_root
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    fac.additional_certs = [intermediate_cert, ca_cert]
-    ts = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_equal(3, ts.token.certificates.size)
-    ts.verify(req, ca_store)
-  end
-
-  def test_verify_ee_cert_inclusion_not_requested
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.nonce = 42
-    req.cert_requested = false
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    #needed because the Request contained no policy identifier
-    fac.default_policy_id = '1.2.3.4.5'
-    fac.additional_certs = [ ts_cert_ee, intermediate_cert ]
-    ts = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    assert_nil(ts.token.certificates) #since cert_requested? == false
-    ts.verify(req, ca_store, [ts_cert_ee, intermediate_cert])
-  end
-
-  def test_reusable
-    #test if req and faq are reusable, i.e. the internal
-    #CTX_free methods don't mess up e.g. the certificates
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    fac.additional_certs = [ intermediate_cert ]
-    ts1 = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    ts1.verify(req, ca_store)
-    ts2 = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    ts2.verify(req, ca_store)
-    refute_nil(ts1.tsa_certificate)
-    refute_nil(ts2.tsa_certificate)
-  end
-
-  def test_token_info_creation
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = OpenSSL::BN.new(123)
-
-    fac = OpenSSL::Timestamp::Factory.new
-    time = Time.now
-    fac.gen_time = time
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-
-    resp = fac.create_timestamp(ee_key, ts_cert_ee, req)
-    info = resp.token_info
-    info = OpenSSL::Timestamp::TokenInfo.new(info.to_der)
-
-    assert_equal(1, info.version)
-    assert_equal("1.2.3.4.5", info.policy_id)
-    assert_equal("SHA1", info.algorithm)
-    assert_equal(digest, info.message_imprint)
-    assert_equal(1, info.serial_number)
-    assert_equal(time.to_i, info.gen_time.to_i)
-    assert_equal(false, info.ordering)
-    assert_equal(123, info.nonce)
-  end
-
-  def test_token_info_invalid_asn1
-    assert_raise(OpenSSL::Timestamp::TimestampError) do
-      OpenSSL::Timestamp::TokenInfo.new("*" * 44)
-    end
-  end
-
-  private
-
-  def assert_cert expected, actual
-    assert_equal expected.to_der, actual.to_der
-  end
-
-  def timestamp_ee
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    return fac.create_timestamp(ee_key, ts_cert_ee, req), req
-  end
-
-  def timestamp_ee_no_cert
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-    req.cert_requested = false
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    return fac.create_timestamp(ee_key, ts_cert_ee, req), req
-  end
-
-  def timestamp_direct
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    return fac.create_timestamp(ee_key, ts_cert_direct, req), req
-  end
-
-  def timestamp_direct_no_cert
-    req = OpenSSL::Timestamp::Request.new
-    req.algorithm = "SHA1"
-    digest = OpenSSL::Digest.digest('SHA1', "test")
-    req.message_imprint = digest
-    req.policy_id = "1.2.3.4.5"
-    req.nonce = 42
-    req.cert_requested = false
-
-    fac = OpenSSL::Timestamp::Factory.new
-    fac.gen_time = Time.now
-    fac.serial_number = 1
-    fac.allowed_digests = ["sha1"]
-    return fac.create_timestamp(ee_key, ts_cert_direct, req), req
-  end
-end
-
-end
diff --git a/test/openssl/test_x509attr.rb b/test/openssl/test_x509attr.rb
deleted file mode 100644
index 2919d23..0000000
--- a/test/openssl/test_x509attr.rb
+++ /dev/null
@@ -1,94 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestX509Attribute < OpenSSL::TestCase
-  def test_new
-    ef = OpenSSL::X509::ExtensionFactory.new
-    val = OpenSSL::ASN1::Set.new([OpenSSL::ASN1::Sequence.new([
-      ef.create_extension("keyUsage", "keyCertSign", true)
-    ])])
-    attr = OpenSSL::X509::Attribute.new("extReq", val)
-    assert_equal("extReq", attr.oid)
-    assert_equal(val.to_der, attr.value.to_der)
-
-    attr = OpenSSL::X509::Attribute.new("1.2.840.113549.1.9.14", val)
-    assert_equal("extReq", attr.oid)
-  end
-
-  def test_from_der
-    # oid: challengePassword, values: Set[UTF8String<"abc123">]
-    test_der = "\x30\x15\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x09\x07\x31\x08" \
-      "\x0c\x06\x61\x62\x63\x31\x32\x33".b
-    attr = OpenSSL::X509::Attribute.new(test_der)
-    assert_equal(test_der, attr.to_der)
-    assert_equal("challengePassword", attr.oid)
-    assert_equal("abc123", attr.value.value[0].value)
-  end
-
-  def test_to_der
-    ef = OpenSSL::X509::ExtensionFactory.new
-    val = OpenSSL::ASN1::Set.new([OpenSSL::ASN1::Sequence.new([
-      ef.create_extension("keyUsage", "keyCertSign", true)
-    ])])
-    attr = OpenSSL::X509::Attribute.new("extReq", val)
-    expected = OpenSSL::ASN1::Sequence.new([
-      OpenSSL::ASN1::ObjectId.new("extReq"),
-      val
-    ])
-    assert_equal(expected.to_der, attr.to_der)
-  end
-
-  def test_invalid_value
-    # should not change the original value
-    test_der = "\x30\x15\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x09\x07\x31\x08" \
-      "\x0c\x06\x61\x62\x63\x31\x32\x33".b
-    attr = OpenSSL::X509::Attribute.new(test_der)
-    assert_raise(TypeError) {
-      attr.value = "1234"
-    }
-    assert_equal(test_der, attr.to_der)
-    assert_raise(OpenSSL::X509::AttributeError) {
-      attr.oid = "abc123"
-    }
-    assert_equal(test_der, attr.to_der)
-  end
-
-  def test_dup
-    val = OpenSSL::ASN1::Set([
-      OpenSSL::ASN1::UTF8String("abc123")
-    ])
-    attr = OpenSSL::X509::Attribute.new("challengePassword", val)
-    assert_equal(attr.to_der, attr.dup.to_der)
-  end
-
-  def test_eq
-    val1 = OpenSSL::ASN1::Set([
-      OpenSSL::ASN1::UTF8String("abc123")
-    ])
-    attr1 = OpenSSL::X509::Attribute.new("challengePassword", val1)
-    attr2 = OpenSSL::X509::Attribute.new("challengePassword", val1)
-    ef = OpenSSL::X509::ExtensionFactory.new
-    val2 = OpenSSL::ASN1::Set.new([OpenSSL::ASN1::Sequence.new([
-      ef.create_extension("keyUsage", "keyCertSign", true)
-    ])])
-    attr3 = OpenSSL::X509::Attribute.new("extReq", val2)
-
-    assert_equal false, attr1 == 12345
-    assert_equal true, attr1 == attr2
-    assert_equal false, attr1 == attr3
-  end
-
-  def test_marshal
-    val = OpenSSL::ASN1::Set([
-      OpenSSL::ASN1::UTF8String("abc123")
-    ])
-    attr = OpenSSL::X509::Attribute.new("challengePassword", val)
-    deserialized = Marshal.load(Marshal.dump(attr))
-
-    assert_equal attr.to_der, deserialized.to_der
-  end
-end
-
-end
diff --git a/test/openssl/test_x509cert.rb b/test/openssl/test_x509cert.rb
deleted file mode 100644
index 848a314..0000000
--- a/test/openssl/test_x509cert.rb
+++ /dev/null
@@ -1,288 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestX509Certificate < OpenSSL::TestCase
-  def setup
-    super
-    @rsa1024 = Fixtures.pkey("rsa1024")
-    @rsa2048 = Fixtures.pkey("rsa2048")
-    @dsa256  = Fixtures.pkey("dsa256")
-    @dsa512  = Fixtures.pkey("dsa512")
-    @ca = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=CA")
-    @ee1 = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=EE1")
-  end
-
-  def test_serial
-    [1, 2**32, 2**100].each{|s|
-      cert = issue_cert(@ca, @rsa2048, s, [], nil, nil)
-      assert_equal(s, cert.serial)
-      cert = OpenSSL::X509::Certificate.new(cert.to_der)
-      assert_equal(s, cert.serial)
-    }
-  end
-
-  def test_public_key
-    exts = [
-      ["basicConstraints","CA:TRUE",true],
-      ["subjectKeyIdentifier","hash",false],
-      ["authorityKeyIdentifier","keyid:always",false],
-    ]
-
-    [
-      @rsa1024, @rsa2048, @dsa256, @dsa512,
-    ].each{|pk|
-      cert = issue_cert(@ca, pk, 1, exts, nil, nil)
-      assert_equal(cert.extensions.sort_by(&:to_s)[2].value,
-                   OpenSSL::TestUtils.get_subject_key_id(cert))
-      cert = OpenSSL::X509::Certificate.new(cert.to_der)
-      assert_equal(cert.extensions.sort_by(&:to_s)[2].value,
-                   OpenSSL::TestUtils.get_subject_key_id(cert))
-    }
-  end
-
-  def test_validity
-    now = Time.at(Time.now.to_i + 0.9)
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil,
-                      not_before: now, not_after: now+3600)
-    assert_equal(Time.at(now.to_i), cert.not_before)
-    assert_equal(Time.at(now.to_i+3600), cert.not_after)
-
-    now = Time.at(now.to_i)
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil,
-                      not_before: now, not_after: now+3600)
-    assert_equal(now.getutc, cert.not_before)
-    assert_equal((now+3600).getutc, cert.not_after)
-
-    now = Time.at(0)
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil,
-                      not_before: now, not_after: now)
-    assert_equal(now.getutc, cert.not_before)
-    assert_equal(now.getutc, cert.not_after)
-
-    now = Time.at(0x7fffffff)
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil,
-                      not_before: now, not_after: now)
-    assert_equal(now.getutc, cert.not_before)
-    assert_equal(now.getutc, cert.not_after)
-  end
-
-  def test_extension
-    ca_exts = [
-      ["basicConstraints","CA:TRUE",true],
-      ["keyUsage","keyCertSign, cRLSign",true],
-      ["subjectKeyIdentifier","hash",false],
-      ["authorityKeyIdentifier","issuer:always,keyid:always",false],
-    ]
-    ca_cert = issue_cert(@ca, @rsa2048, 1, ca_exts, nil, nil)
-    keyid = get_subject_key_id(ca_cert.to_der, hex: false)
-    assert_equal keyid, ca_cert.authority_key_identifier
-    assert_equal keyid, ca_cert.subject_key_identifier
-    ca_cert.extensions.each_with_index{|ext, i|
-      assert_equal(ca_exts[i].first, ext.oid)
-      assert_equal(ca_exts[i].last, ext.critical?)
-    }
-
-    ee1_exts = [
-      ["keyUsage","Non Repudiation, Digital Signature, Key Encipherment",true],
-      ["subjectKeyIdentifier","hash",false],
-      ["authorityKeyIdentifier","issuer:always,keyid:always",false],
-      ["extendedKeyUsage","clientAuth, emailProtection, codeSigning",false],
-      ["subjectAltName","email:ee1@ruby-lang.org",false],
-      ["authorityInfoAccess","caIssuers;URI:http://www.example.com/caIssuers,OCSP;URI:http://www.example.com/ocsp",false],
-    ]
-    ee1_cert = issue_cert(@ee1, @rsa1024, 2, ee1_exts, ca_cert, @rsa2048)
-    assert_equal(ca_cert.subject.to_der, ee1_cert.issuer.to_der)
-    ee1_cert.extensions.each_with_index{|ext, i|
-      assert_equal(ee1_exts[i].first, ext.oid)
-      assert_equal(ee1_exts[i].last, ext.critical?)
-    }
-    assert_nil(ee1_cert.crl_uris)
-
-    ef = OpenSSL::X509::ExtensionFactory.new
-    ef.config = OpenSSL::Config.parse(<<~_cnf_)
-      [crlDistPts]
-      URI.1 = http://www.example.com/crl
-      URI.2 = ldap://ldap.example.com/cn=ca?certificateRevocationList;binary
-    _cnf_
-    cdp_cert = generate_cert(@ee1, @rsa1024, 3, ca_cert)
-    ef.subject_certificate = cdp_cert
-    cdp_cert.add_extension(ef.create_extension("crlDistributionPoints", "@crlDistPts"))
-    cdp_cert.sign(@rsa2048, "sha256")
-    assert_equal(
-      ["http://www.example.com/crl", "ldap://ldap.example.com/cn=ca?certificateRevocationList;binary"],
-      cdp_cert.crl_uris
-    )
-
-    ef = OpenSSL::X509::ExtensionFactory.new
-    aia_cert = generate_cert(@ee1, @rsa1024, 4, ca_cert)
-    ef.subject_certificate = aia_cert
-    aia_cert.add_extension(
-      ef.create_extension(
-        "authorityInfoAccess",
-        "caIssuers;URI:http://www.example.com/caIssuers," \
-        "caIssuers;URI:ldap://ldap.example.com/cn=ca?authorityInfoAccessCaIssuers;binary," \
-        "OCSP;URI:http://www.example.com/ocsp," \
-        "OCSP;URI:ldap://ldap.example.com/cn=ca?authorityInfoAccessOcsp;binary",
-        false
-      )
-    )
-    aia_cert.sign(@rsa2048, "sha256")
-    assert_equal(
-      ["http://www.example.com/caIssuers", "ldap://ldap.example.com/cn=ca?authorityInfoAccessCaIssuers;binary"],
-      aia_cert.ca_issuer_uris
-    )
-    assert_equal(
-      ["http://www.example.com/ocsp", "ldap://ldap.example.com/cn=ca?authorityInfoAccessOcsp;binary"],
-      aia_cert.ocsp_uris
-    )
-
-    no_exts_cert = issue_cert(@ca, @rsa2048, 5, [], nil, nil)
-    assert_equal nil, no_exts_cert.authority_key_identifier
-    assert_equal nil, no_exts_cert.subject_key_identifier
-    assert_equal nil, no_exts_cert.crl_uris
-    assert_equal nil, no_exts_cert.ca_issuer_uris
-    assert_equal nil, no_exts_cert.ocsp_uris
-  end
-
-  def test_invalid_extension
-    integer = OpenSSL::ASN1::Integer.new(0)
-    invalid_exts_cert = generate_cert(@ee1, @rsa1024, 1, nil)
-    ["subjectKeyIdentifier", "authorityKeyIdentifier", "crlDistributionPoints", "authorityInfoAccess"].each do |ext|
-      invalid_exts_cert.add_extension(
-        OpenSSL::X509::Extension.new(ext, integer.to_der)
-      )
-    end
-
-    assert_raise(OpenSSL::ASN1::ASN1Error, "invalid extension") {
-      invalid_exts_cert.authority_key_identifier
-    }
-    assert_raise(OpenSSL::ASN1::ASN1Error, "invalid extension") {
-      invalid_exts_cert.subject_key_identifier
-    }
-    assert_raise(OpenSSL::ASN1::ASN1Error, "invalid extension") {
-      invalid_exts_cert.crl_uris
-    }
-    assert_raise(OpenSSL::ASN1::ASN1Error, "invalid extension") {
-      invalid_exts_cert.ca_issuer_uris
-    }
-    assert_raise(OpenSSL::ASN1::ASN1Error, "invalid extension") {
-      invalid_exts_cert.ocsp_uris
-    }
-  end
-
-  def test_sign_and_verify_rsa_sha1
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil, digest: "sha1")
-    assert_equal(false, cert.verify(@rsa1024))
-    assert_equal(true,  cert.verify(@rsa2048))
-    assert_equal(false, certificate_error_returns_false { cert.verify(@dsa256) })
-    assert_equal(false, certificate_error_returns_false { cert.verify(@dsa512) })
-    cert.serial = 2
-    assert_equal(false, cert.verify(@rsa2048))
-  end
-
-  def test_sign_and_verify_rsa_md5
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil, digest: "md5")
-    assert_equal(false, cert.verify(@rsa1024))
-    assert_equal(true, cert.verify(@rsa2048))
-
-    assert_equal(false, certificate_error_returns_false { cert.verify(@dsa256) })
-    assert_equal(false, certificate_error_returns_false { cert.verify(@dsa512) })
-    cert.subject = @ee1
-    assert_equal(false, cert.verify(@rsa2048))
-  rescue OpenSSL::X509::CertificateError # RHEL7 disables MD5
-  end
-
-  def test_sign_and_verify_dsa
-    cert = issue_cert(@ca, @dsa512, 1, [], nil, nil)
-    assert_equal(false, certificate_error_returns_false { cert.verify(@rsa1024) })
-    assert_equal(false, certificate_error_returns_false { cert.verify(@rsa2048) })
-    assert_equal(false, cert.verify(@dsa256))
-    assert_equal(true,  cert.verify(@dsa512))
-    cert.not_after = Time.now
-    assert_equal(false, cert.verify(@dsa512))
-  end
-
-  def test_sign_and_verify_rsa_dss1
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil, digest: OpenSSL::Digest.new('DSS1'))
-    assert_equal(false, cert.verify(@rsa1024))
-    assert_equal(true, cert.verify(@rsa2048))
-    assert_equal(false, certificate_error_returns_false { cert.verify(@dsa256) })
-    assert_equal(false, certificate_error_returns_false { cert.verify(@dsa512) })
-    cert.subject = @ee1
-    assert_equal(false, cert.verify(@rsa2048))
-  rescue OpenSSL::X509::CertificateError
-  end if defined?(OpenSSL::Digest::DSS1)
-
-  def test_sign_and_verify_dsa_md5
-    assert_raise(OpenSSL::X509::CertificateError){
-      issue_cert(@ca, @dsa512, 1, [], nil, nil, digest: "md5")
-    }
-  end
-
-  def test_dsa_with_sha2
-    cert = issue_cert(@ca, @dsa256, 1, [], nil, nil, digest: "sha256")
-    assert_equal("dsa_with_SHA256", cert.signature_algorithm)
-    # TODO: need more tests for dsa + sha2
-
-    # SHA1 is allowed from OpenSSL 1.0.0 (0.9.8 requires DSS1)
-    cert = issue_cert(@ca, @dsa256, 1, [], nil, nil, digest: "sha1")
-    assert_equal("dsaWithSHA1", cert.signature_algorithm)
-  end
-
-  def test_check_private_key
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil)
-    assert_equal(true, cert.check_private_key(@rsa2048))
-  end
-
-  def test_read_from_file
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil)
-    Tempfile.create("cert") { |f|
-      f << cert.to_pem
-      f.rewind
-      assert_equal cert.to_der, OpenSSL::X509::Certificate.new(f).to_der
-    }
-  end
-
-  def test_eq
-    now = Time.now
-    cacert = issue_cert(@ca, @rsa1024, 1, [], nil, nil,
-                        not_before: now, not_after: now + 3600)
-    cert1 = issue_cert(@ee1, @rsa2048, 2, [], cacert, @rsa1024,
-                       not_before: now, not_after: now + 3600)
-    cert2 = issue_cert(@ee1, @rsa2048, 2, [], cacert, @rsa1024,
-                       not_before: now, not_after: now + 3600)
-    cert3 = issue_cert(@ee1, @rsa2048, 3, [], cacert, @rsa1024,
-                       not_before: now, not_after: now + 3600)
-    cert4 = issue_cert(@ee1, @rsa2048, 2, [], cacert, @rsa1024,
-                       digest: "sha512", not_before: now, not_after: now + 3600)
-
-    assert_equal false, cert1 == 12345
-    assert_equal true, cert1 == cert2
-    assert_equal false, cert1 == cert3
-    assert_equal false, cert1 == cert4
-    assert_equal false, cert3 == cert4
-  end
-
-  def test_marshal
-    now = Time.now
-    cacert = issue_cert(@ca, @rsa1024, 1, [], nil, nil,
-      not_before: now, not_after: now + 3600)
-    cert = issue_cert(@ee1, @rsa2048, 2, [], cacert, @rsa1024,
-      not_before: now, not_after: now + 3600)
-    deserialized = Marshal.load(Marshal.dump(cert))
-
-    assert_equal cert.to_der, deserialized.to_der
-  end
-
-  private
-
-  def certificate_error_returns_false
-    yield
-  rescue OpenSSL::X509::CertificateError
-    false
-  end
-end
-
-end
diff --git a/test/openssl/test_x509crl.rb b/test/openssl/test_x509crl.rb
deleted file mode 100644
index bcdb0a6..0000000
--- a/test/openssl/test_x509crl.rb
+++ /dev/null
@@ -1,284 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestX509CRL < OpenSSL::TestCase
-  def setup
-    super
-    @rsa1024 = Fixtures.pkey("rsa1024")
-    @rsa2048 = Fixtures.pkey("rsa2048")
-    @dsa256  = Fixtures.pkey("dsa256")
-    @dsa512  = Fixtures.pkey("dsa512")
-    @ca = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=CA")
-    @ee1 = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=EE1")
-    @ee2 = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=EE2")
-  end
-
-  def test_basic
-    now = Time.at(Time.now.to_i)
-
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil)
-    crl = issue_crl([], 1, now, now+1600, [],
-                    cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    assert_equal(1, crl.version)
-    assert_equal(cert.issuer.to_der, crl.issuer.to_der)
-    assert_equal(now, crl.last_update)
-    assert_equal(now+1600, crl.next_update)
-
-    crl = OpenSSL::X509::CRL.new(crl.to_der)
-    assert_equal(1, crl.version)
-    assert_equal(cert.issuer.to_der, crl.issuer.to_der)
-    assert_equal(now, crl.last_update)
-    assert_equal(now+1600, crl.next_update)
-  end
-
-  def test_revoked
-
-    # CRLReason ::= ENUMERATED {
-    #      unspecified             (0),
-    #      keyCompromise           (1),
-    #      cACompromise            (2),
-    #      affiliationChanged      (3),
-    #      superseded              (4),
-    #      cessationOfOperation    (5),
-    #      certificateHold         (6),
-    #      removeFromCRL           (8),
-    #      privilegeWithdrawn      (9),
-    #      aACompromise           (10) }
-
-    now = Time.at(Time.now.to_i)
-    revoke_info = [
-      [1, Time.at(0),          1],
-      [2, Time.at(0x7fffffff), 2],
-      [3, now,                 3],
-      [4, now,                 4],
-      [5, now,                 5],
-    ]
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil)
-    crl = issue_crl(revoke_info, 1, Time.now, Time.now+1600, [],
-                    cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    revoked = crl.revoked
-    assert_equal(5, revoked.size)
-    assert_equal(1, revoked[0].serial)
-    assert_equal(2, revoked[1].serial)
-    assert_equal(3, revoked[2].serial)
-    assert_equal(4, revoked[3].serial)
-    assert_equal(5, revoked[4].serial)
-
-    assert_equal(Time.at(0), revoked[0].time)
-    assert_equal(Time.at(0x7fffffff), revoked[1].time)
-    assert_equal(now, revoked[2].time)
-    assert_equal(now, revoked[3].time)
-    assert_equal(now, revoked[4].time)
-
-    assert_equal("CRLReason", revoked[0].extensions[0].oid)
-    assert_equal("CRLReason", revoked[1].extensions[0].oid)
-    assert_equal("CRLReason", revoked[2].extensions[0].oid)
-    assert_equal("CRLReason", revoked[3].extensions[0].oid)
-    assert_equal("CRLReason", revoked[4].extensions[0].oid)
-
-    assert_equal("Key Compromise", revoked[0].extensions[0].value)
-    assert_equal("CA Compromise", revoked[1].extensions[0].value)
-    assert_equal("Affiliation Changed", revoked[2].extensions[0].value)
-    assert_equal("Superseded", revoked[3].extensions[0].value)
-    assert_equal("Cessation Of Operation", revoked[4].extensions[0].value)
-
-    assert_equal(false, revoked[0].extensions[0].critical?)
-    assert_equal(false, revoked[1].extensions[0].critical?)
-    assert_equal(false, revoked[2].extensions[0].critical?)
-    assert_equal(false, revoked[3].extensions[0].critical?)
-    assert_equal(false, revoked[4].extensions[0].critical?)
-
-    assert_equal("Key Compromise", revoked[0].extensions[0].value)
-    assert_equal("CA Compromise", revoked[1].extensions[0].value)
-    assert_equal("Affiliation Changed", revoked[2].extensions[0].value)
-    assert_equal("Superseded", revoked[3].extensions[0].value)
-    assert_equal("Cessation Of Operation", revoked[4].extensions[0].value)
-
-    revoke_info = (1..1000).collect{|i| [i, now, 0] }
-    crl = issue_crl(revoke_info, 1, Time.now, Time.now+1600, [],
-                    cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    revoked = crl.revoked
-    assert_equal(1000, revoked.size)
-    assert_equal(1, revoked[0].serial)
-    assert_equal(1000, revoked[999].serial)
-
-    crl.revoked = revoked
-    revoked2 = crl.revoked
-    assert_equal(revoked.map(&:serial), revoked2.map(&:serial))
-  end
-
-  def test_extension
-    cert_exts = [
-      ["basicConstraints", "CA:TRUE", true],
-      ["subjectKeyIdentifier", "hash", false],
-      ["authorityKeyIdentifier", "keyid:always", false],
-      ["subjectAltName", "email:xyzzy@ruby-lang.org", false],
-      ["keyUsage", "cRLSign, keyCertSign", true],
-    ]
-    crl_exts = [
-      ["authorityKeyIdentifier", "issuer:always,keyid:always", false],
-      ["issuerAltName", "issuer:copy", false],
-    ]
-
-    cert = issue_cert(@ca, @rsa2048, 1, cert_exts, nil, nil)
-    crl = issue_crl([], 1, Time.now, Time.now+1600, crl_exts,
-                    cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    exts = crl.extensions
-    assert_equal(3, exts.size)
-    assert_equal("1", exts[0].value)
-    assert_equal("crlNumber", exts[0].oid)
-    assert_equal(false, exts[0].critical?)
-
-    expected_keyid = OpenSSL::TestUtils.get_subject_key_id(cert, hex: false)
-    assert_equal expected_keyid, crl.authority_key_identifier
-
-    assert_equal("authorityKeyIdentifier", exts[1].oid)
-    keyid = OpenSSL::TestUtils.get_subject_key_id(cert)
-    assert_match(/^keyid:#{keyid}/, exts[1].value)
-    assert_equal(false, exts[1].critical?)
-
-    assert_equal("issuerAltName", exts[2].oid)
-    assert_equal("email:xyzzy@ruby-lang.org", exts[2].value)
-    assert_equal(false, exts[2].critical?)
-
-    crl = OpenSSL::X509::CRL.new(crl.to_der)
-    exts = crl.extensions
-    assert_equal(3, exts.size)
-    assert_equal("1", exts[0].value)
-    assert_equal("crlNumber", exts[0].oid)
-    assert_equal(false, exts[0].critical?)
-
-    assert_equal("authorityKeyIdentifier", exts[1].oid)
-    keyid = OpenSSL::TestUtils.get_subject_key_id(cert)
-    assert_match(/^keyid:#{keyid}/, exts[1].value)
-    assert_equal(false, exts[1].critical?)
-
-    assert_equal("issuerAltName", exts[2].oid)
-    assert_equal("email:xyzzy@ruby-lang.org", exts[2].value)
-    assert_equal(false, exts[2].critical?)
-
-    no_ext_crl = issue_crl([], 1, Time.now, Time.now+1600, [],
-      cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    assert_equal nil, no_ext_crl.authority_key_identifier
-  end
-
-  def test_crlnumber
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil)
-    crl = issue_crl([], 1, Time.now, Time.now+1600, [],
-                    cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    assert_match(1.to_s, crl.extensions[0].value)
-    assert_match(/X509v3 CRL Number:\s+#{1}/m, crl.to_text)
-
-    crl = issue_crl([], 2**32, Time.now, Time.now+1600, [],
-                    cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    assert_match((2**32).to_s, crl.extensions[0].value)
-    assert_match(/X509v3 CRL Number:\s+#{2**32}/m, crl.to_text)
-
-    crl = issue_crl([], 2**100, Time.now, Time.now+1600, [],
-                    cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    assert_match(/X509v3 CRL Number:\s+#{2**100}/m, crl.to_text)
-    assert_match((2**100).to_s, crl.extensions[0].value)
-  end
-
-  def test_sign_and_verify
-    cert = issue_cert(@ca, @rsa2048, 1, [], nil, nil)
-    crl = issue_crl([], 1, Time.now, Time.now+1600, [],
-                    cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    assert_equal(false, crl.verify(@rsa1024))
-    assert_equal(true,  crl.verify(@rsa2048))
-    assert_equal(false, crl_error_returns_false { crl.verify(@dsa256) })
-    assert_equal(false, crl_error_returns_false { crl.verify(@dsa512) })
-    crl.version = 0
-    assert_equal(false, crl.verify(@rsa2048))
-
-    cert = issue_cert(@ca, @dsa512, 1, [], nil, nil)
-    crl = issue_crl([], 1, Time.now, Time.now+1600, [],
-                    cert, @dsa512, OpenSSL::Digest.new('SHA1'))
-    assert_equal(false, crl_error_returns_false { crl.verify(@rsa1024) })
-    assert_equal(false, crl_error_returns_false { crl.verify(@rsa2048) })
-    assert_equal(false, crl.verify(@dsa256))
-    assert_equal(true,  crl.verify(@dsa512))
-    crl.version = 0
-    assert_equal(false, crl.verify(@dsa512))
-  end
-
-  def test_revoked_to_der
-    # revokedCertificates     SEQUENCE OF SEQUENCE  {
-    #      userCertificate         CertificateSerialNumber,
-    #      revocationDate          Time,
-    #      crlEntryExtensions      Extensions OPTIONAL
-    #                               -- if present, version MUST be v2
-    #                           }  OPTIONAL,
-
-    now = Time.utc(2000, 1, 1)
-    rev1 = OpenSSL::X509::Revoked.new
-    rev1.serial = 123
-    rev1.time = now
-    ext = OpenSSL::X509::Extension.new("CRLReason", OpenSSL::ASN1::Enumerated(1))
-    rev1.extensions = [ext]
-    asn1 = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Integer(123),
-      OpenSSL::ASN1::UTCTime(now),
-      OpenSSL::ASN1::Sequence([ext.to_der])
-    ])
-
-    assert_equal asn1.to_der, rev1.to_der
-  end
-
-  def test_eq
-    now = Time.now
-
-    cacert = issue_cert(@ca, @rsa1024, 1, [], nil, nil)
-    crl1 = issue_crl([], 1, now, now + 3600, [], cacert, @rsa1024, "sha256")
-    rev1 = OpenSSL::X509::Revoked.new.tap { |rev|
-      rev.serial = 1
-      rev.time = now
-    }
-    crl1.add_revoked(rev1)
-    crl2 = OpenSSL::X509::CRL.new(crl1.to_der)
-
-    # CRL
-    assert_equal false, crl1 == 12345
-    assert_equal true, crl1 == crl2
-    rev2 = OpenSSL::X509::Revoked.new.tap { |rev|
-      rev.serial = 2
-      rev.time = now
-    }
-    crl2.add_revoked(rev2)
-    assert_equal false, crl1 == crl2
-
-    # Revoked
-    assert_equal false, rev1 == 12345
-    assert_equal true, rev1 == crl2.revoked[0]
-    assert_equal false, rev1 == crl2.revoked[1]
-    assert_equal true, rev2 == crl2.revoked[1]
-  end
-
-  def test_marshal
-    now = Time.now
-
-    cacert = issue_cert(@ca, @rsa1024, 1, [], nil, nil)
-    crl = issue_crl([], 1, now, now + 3600, [], cacert, @rsa1024, "sha256")
-    rev = OpenSSL::X509::Revoked.new.tap { |rev|
-      rev.serial = 1
-      rev.time = now
-    }
-    crl.add_revoked(rev)
-    deserialized = Marshal.load(Marshal.dump(crl))
-
-    assert_equal crl.to_der, deserialized.to_der
-    assert_equal crl.revoked[0].to_der, deserialized.revoked[0].to_der
-  end
-
-  private
-
-  def crl_error_returns_false
-    yield
-  rescue OpenSSL::X509::CRLError
-    false
-  end
-end
-
-end
diff --git a/test/openssl/test_x509ext.rb b/test/openssl/test_x509ext.rb
deleted file mode 100644
index 7ad010d..0000000
--- a/test/openssl/test_x509ext.rb
+++ /dev/null
@@ -1,104 +0,0 @@
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestX509Extension < OpenSSL::TestCase
-  def setup
-    super
-    @basic_constraints_value = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::Boolean(true),   # CA
-      OpenSSL::ASN1::Integer(2)       # pathlen
-    ])
-    @basic_constraints = OpenSSL::ASN1::Sequence([
-      OpenSSL::ASN1::ObjectId("basicConstraints"),
-      OpenSSL::ASN1::Boolean(true),
-      OpenSSL::ASN1::OctetString(@basic_constraints_value.to_der),
-    ])
-  end
-
-  def test_new
-    ext = OpenSSL::X509::Extension.new(@basic_constraints.to_der)
-    assert_equal("basicConstraints", ext.oid)
-    assert_equal(true, ext.critical?)
-    assert_equal("CA:TRUE, pathlen:2", ext.value)
-
-    ext = OpenSSL::X509::Extension.new("2.5.29.19",
-                                       @basic_constraints_value.to_der, true)
-    assert_equal(@basic_constraints.to_der, ext.to_der)
-  end
-
-  def test_create_by_factory
-    ef = OpenSSL::X509::ExtensionFactory.new
-
-    bc = ef.create_extension("basicConstraints", "critical, CA:TRUE, pathlen:2")
-    assert_equal(@basic_constraints.to_der, bc.to_der)
-
-    bc = ef.create_extension("basicConstraints", "CA:TRUE, pathlen:2", true)
-    assert_equal(@basic_constraints.to_der, bc.to_der)
-
-    ef.config = OpenSSL::Config.parse(<<-_end_of_cnf_)
-    [crlDistPts]
-    URI.1 = http://www.example.com/crl
-    URI.2 = ldap://ldap.example.com/cn=ca?certificateRevocationList;binary
-
-    [certPolicies]
-    policyIdentifier = 2.23.140.1.2.1
-    CPS.1 = http://cps.example.com
-    _end_of_cnf_
-
-    cdp = ef.create_extension("crlDistributionPoints", "@crlDistPts")
-    assert_equal(false, cdp.critical?)
-    assert_equal("crlDistributionPoints", cdp.oid)
-    assert_match(%{URI:http://www\.example\.com/crl}, cdp.value)
-    assert_match(
-      %r{URI:ldap://ldap\.example\.com/cn=ca\?certificateRevocationList;binary},
-      cdp.value)
-
-    cdp = ef.create_extension("crlDistributionPoints", "critical, @crlDistPts")
-    assert_equal(true, cdp.critical?)
-    assert_equal("crlDistributionPoints", cdp.oid)
-    assert_match(%{URI:http://www.example.com/crl}, cdp.value)
-    assert_match(
-      %r{URI:ldap://ldap.example.com/cn=ca\?certificateRevocationList;binary},
-      cdp.value)
-
-    cp = ef.create_extension("certificatePolicies", "@certPolicies")
-    assert_equal(false, cp.critical?)
-    assert_equal("certificatePolicies", cp.oid)
-    assert_match(%r{2.23.140.1.2.1}, cp.value)
-    assert_match(%r{http://cps.example.com}, cp.value)
-  end
-
-  def test_dup
-    ext = OpenSSL::X509::Extension.new(@basic_constraints.to_der)
-    assert_equal(@basic_constraints.to_der, ext.to_der)
-    assert_equal(ext.to_der, ext.dup.to_der)
-  end
-
-  def test_eq
-    ext1 = OpenSSL::X509::Extension.new(@basic_constraints.to_der)
-    ef = OpenSSL::X509::ExtensionFactory.new
-    ext2 = ef.create_extension("basicConstraints", "critical, CA:TRUE, pathlen:2")
-    ext3 = ef.create_extension("basicConstraints", "critical, CA:TRUE")
-
-    assert_equal false, ext1 == 12345
-    assert_equal true, ext1 == ext2
-    assert_equal false, ext1 == ext3
-  end
-
-  def test_marshal
-    ef = OpenSSL::X509::ExtensionFactory.new
-    ext = ef.create_extension("basicConstraints", "critical, CA:TRUE, pathlen:2")
-    deserialized = Marshal.load(Marshal.dump(ext))
-
-    assert_equal ext.to_der, deserialized.to_der
-  end
-
-  def test_value_der
-    ext = OpenSSL::X509::Extension.new(@basic_constraints.to_der)
-    assert_equal @basic_constraints_value.to_der, ext.value_der
-  end
-end
-
-end
diff --git a/test/openssl/test_x509name.rb b/test/openssl/test_x509name.rb
deleted file mode 100644
index c6d1521..0000000
--- a/test/openssl/test_x509name.rb
+++ /dev/null
@@ -1,469 +0,0 @@
-# coding: ASCII-8BIT
-# frozen_string_literal: true
-require_relative 'utils'
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestX509Name < OpenSSL::TestCase
-  def setup
-    super
-    @obj_type_tmpl = Hash.new(OpenSSL::ASN1::PRINTABLESTRING)
-    @obj_type_tmpl.update(OpenSSL::X509::Name::OBJECT_TYPE_TEMPLATE)
-  end
-
-  def test_s_new
-    dn = [ ["C", "JP"], ["O", "example"], ["CN", "www.example.jp"] ]
-    name = OpenSSL::X509::Name.new(dn)
-    ary = name.to_a
-    assert_equal("/C=JP/O=example/CN=www.example.jp", name.to_s)
-    assert_equal("C", ary[0][0])
-    assert_equal("O", ary[1][0])
-    assert_equal("CN", ary[2][0])
-    assert_equal("JP", ary[0][1])
-    assert_equal("example", ary[1][1])
-    assert_equal("www.example.jp", ary[2][1])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[0][2])
-    assert_equal(OpenSSL::ASN1::UTF8STRING, ary[1][2])
-    assert_equal(OpenSSL::ASN1::UTF8STRING, ary[2][2])
-
-    dn = [
-      ["countryName", "JP"],
-      ["organizationName", "example"],
-      ["commonName", "www.example.jp"]
-    ]
-    name = OpenSSL::X509::Name.new(dn)
-    ary = name.to_a
-    assert_equal("/C=JP/O=example/CN=www.example.jp", name.to_s)
-    assert_equal("C", ary[0][0])
-    assert_equal("O", ary[1][0])
-    assert_equal("CN", ary[2][0])
-    assert_equal("JP", ary[0][1])
-    assert_equal("example", ary[1][1])
-    assert_equal("www.example.jp", ary[2][1])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[0][2])
-    assert_equal(OpenSSL::ASN1::UTF8STRING, ary[1][2])
-    assert_equal(OpenSSL::ASN1::UTF8STRING, ary[2][2])
-
-    name = OpenSSL::X509::Name.new(dn, @obj_type_tmpl)
-    ary = name.to_a
-    assert_equal("/C=JP/O=example/CN=www.example.jp", name.to_s)
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[0][2])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[1][2])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[2][2])
-
-    dn = [
-      ["countryName", "JP", OpenSSL::ASN1::PRINTABLESTRING],
-      ["organizationName", "example", OpenSSL::ASN1::PRINTABLESTRING],
-      ["commonName", "www.example.jp", OpenSSL::ASN1::PRINTABLESTRING]
-    ]
-    name = OpenSSL::X509::Name.new(dn)
-    ary = name.to_a
-    assert_equal("/C=JP/O=example/CN=www.example.jp", name.to_s)
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[0][2])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[1][2])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[2][2])
-
-    dn = [
-      ["DC", "org"],
-      ["DC", "ruby-lang"],
-      ["CN", "GOTOU Yuuzou"],
-      ["emailAddress", "gotoyuzo@ruby-lang.org"],
-      ["serialNumber", "123"],
-    ]
-    name = OpenSSL::X509::Name.new(dn)
-    ary = name.to_a
-    assert_equal("/DC=org/DC=ruby-lang/CN=GOTOU Yuuzou/emailAddress=gotoyuzo@ruby-lang.org/serialNumber=123", name.to_s)
-    assert_equal("DC", ary[0][0])
-    assert_equal("DC", ary[1][0])
-    assert_equal("CN", ary[2][0])
-    assert_equal("emailAddress", ary[3][0])
-    assert_equal("serialNumber", ary[4][0])
-    assert_equal("org", ary[0][1])
-    assert_equal("ruby-lang", ary[1][1])
-    assert_equal("GOTOU Yuuzou", ary[2][1])
-    assert_equal("gotoyuzo@ruby-lang.org", ary[3][1])
-    assert_equal("123", ary[4][1])
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[0][2])
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[1][2])
-    assert_equal(OpenSSL::ASN1::UTF8STRING, ary[2][2])
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[3][2])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[4][2])
-
-    name_from_der = OpenSSL::X509::Name.new(name.to_der)
-    assert_equal(name_from_der.to_s, name.to_s)
-    assert_equal(name_from_der.to_a, name.to_a)
-    assert_equal(name_from_der.to_der, name.to_der)
-  end
-
-  def test_unrecognized_oid
-    dn = [ ["1.2.3.4.5.6.7.8.9.7.5.3.1", "Unknown OID 1"],
-           ["1.1.2.3.5.8.13.21.34", "Unknown OID 2"],
-           ["C", "US"],
-           ["postalCode", "60602"],
-           ["ST", "Illinois"],
-           ["L", "Chicago"],
-           #["street", "123 Fake St"],
-           ["O", "Some Company LLC"],
-           ["CN", "mydomain.com"] ]
-
-    name = OpenSSL::X509::Name.new(dn)
-    ary = name.to_a
-    #assert_equal("/1.2.3.4.5.6.7.8.9.7.5.3.1=Unknown OID 1/1.1.2.3.5.8.13.21.34=Unknown OID 2/C=US/postalCode=60602/ST=Illinois/L=Chicago/street=123 Fake St/O=Some Company LLC/CN=mydomain.com", name.to_s)
-    assert_equal("/1.2.3.4.5.6.7.8.9.7.5.3.1=Unknown OID 1/1.1.2.3.5.8.13.21.34=Unknown OID 2/C=US/postalCode=60602/ST=Illinois/L=Chicago/O=Some Company LLC/CN=mydomain.com", name.to_s)
-    assert_equal("1.2.3.4.5.6.7.8.9.7.5.3.1", ary[0][0])
-    assert_equal("1.1.2.3.5.8.13.21.34", ary[1][0])
-    assert_equal("C", ary[2][0])
-    assert_equal("postalCode", ary[3][0])
-    assert_equal("ST", ary[4][0])
-    assert_equal("L", ary[5][0])
-    #assert_equal("street", ary[6][0])
-    assert_equal("O", ary[6][0])
-    assert_equal("CN", ary[7][0])
-    assert_equal("Unknown OID 1", ary[0][1])
-    assert_equal("Unknown OID 2", ary[1][1])
-    assert_equal("US", ary[2][1])
-    assert_equal("60602", ary[3][1])
-    assert_equal("Illinois", ary[4][1])
-    assert_equal("Chicago", ary[5][1])
-    #assert_equal("123 Fake St", ary[6][1])
-    assert_equal("Some Company LLC", ary[6][1])
-    assert_equal("mydomain.com", ary[7][1])
-  end
-
-  def test_unrecognized_oid_parse_encode_equality
-    dn = [ ["1.2.3.4.5.6.7.8.9.7.5.3.2", "Unknown OID1"],
-           ["1.1.2.3.5.8.13.21.35", "Unknown OID2"],
-           ["C", "US"],
-           ["postalCode", "60602"],
-           ["ST", "Illinois"],
-           ["L", "Chicago"],
-           #["street", "123 Fake St"],
-           ["O", "Some Company LLC"],
-           ["CN", "mydomain.com"] ]
-
-    name1 = OpenSSL::X509::Name.new(dn)
-    name2 = OpenSSL::X509::Name.parse(name1.to_s)
-    assert_equal(name1.to_s, name2.to_s)
-    assert_equal(name1.to_a, name2.to_a)
-  end
-
-  def test_s_parse
-    dn = "/DC=org/DC=ruby-lang/CN=www.ruby-lang.org/1.2.3.4.5.6=A=BCD"
-    name = OpenSSL::X509::Name.parse(dn)
-    assert_equal(dn, name.to_s)
-    ary = name.to_a
-    assert_equal [
-      ["DC", "org", OpenSSL::ASN1::IA5STRING],
-      ["DC", "ruby-lang", OpenSSL::ASN1::IA5STRING],
-      ["CN", "www.ruby-lang.org", OpenSSL::ASN1::UTF8STRING],
-      ["1.2.3.4.5.6", "A=BCD", OpenSSL::ASN1::UTF8STRING],
-    ], ary
-
-    dn2 = "DC=org, DC=ruby-lang, CN=www.ruby-lang.org, 1.2.3.4.5.6=A=BCD"
-    name = OpenSSL::X509::Name.parse(dn2)
-    assert_equal(dn, name.to_s)
-    assert_equal ary, name.to_a
-
-    name = OpenSSL::X509::Name.parse(dn2, @obj_type_tmpl)
-    ary = name.to_a
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[0][2])
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[1][2])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[2][2])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[3][2])
-  end
-
-  def test_s_parse_rfc2253
-    scanner = OpenSSL::X509::Name::RFC2253DN.method(:scan)
-
-    assert_equal([["C", "JP"]], scanner.call("C=JP"))
-    assert_equal([
-        ["DC", "org"],
-        ["DC", "ruby-lang"],
-        ["CN", "GOTOU Yuuzou"],
-        ["emailAddress", "gotoyuzo@ruby-lang.org"],
-      ],
-      scanner.call(
-        "emailAddress=gotoyuzo@ruby-lang.org,CN=GOTOU Yuuzou,"+
-        "DC=ruby-lang,DC=org")
-    )
-
-    u8 = OpenSSL::ASN1::UTF8STRING
-    assert_equal([
-        ["DC", "org"],
-        ["DC", "ruby-lang"],
-        ["O", ",=+<>#;"],
-        ["O", ",=+<>#;"],
-        ["OU", ""],
-        ["OU", ""],
-        ["L", "aaa=\"bbb, ccc\""],
-        ["L", "aaa=\"bbb, ccc\""],
-        ["CN", "\345\276\214\350\227\244\350\243\225\350\224\265"],
-        ["CN", "\345\276\214\350\227\244\350\243\225\350\224\265"],
-        ["CN", "\345\276\214\350\227\244\350\243\225\350\224\265"],
-        ["CN", "\345\276\214\350\227\244\350\243\225\350\224\265", u8],
-        ["2.5.4.3", "GOTOU, Yuuzou"],
-        ["2.5.4.3", "GOTOU, Yuuzou"],
-        ["2.5.4.3", "GOTOU, Yuuzou"],
-        ["2.5.4.3", "GOTOU, Yuuzou"],
-        ["CN", "GOTOU \"gotoyuzo\" Yuuzou"],
-        ["CN", "GOTOU \"gotoyuzo\" Yuuzou"],
-        ["1.2.840.113549.1.9.1", "gotoyuzo@ruby-lang.org"],
-        ["emailAddress", "gotoyuzo@ruby-lang.org"],
-      ],
-      scanner.call(
-        "emailAddress=gotoyuzo@ruby-lang.org," +
-        "1.2.840.113549.1.9.1=gotoyuzo@ruby-lang.org," +
-        'CN=GOTOU \"gotoyuzo\" Yuuzou,' +
-        'CN="GOTOU \"gotoyuzo\" Yuuzou",' +
-        '2.5.4.3=GOTOU\,\20Yuuzou,' +
-        '2.5.4.3=GOTOU\, Yuuzou,' +
-        '2.5.4.3="GOTOU, Yuuzou",' +
-        '2.5.4.3="GOTOU\, Yuuzou",' +
-        "CN=#0C0CE5BE8CE897A4E8A395E894B5," +
-        'CN=\E5\BE\8C\E8\97\A4\E8\A3\95\E8\94\B5,' +
-        "CN=\"\xE5\xBE\x8C\xE8\x97\xA4\xE8\xA3\x95\xE8\x94\xB5\"," +
-        "CN=\xE5\xBE\x8C\xE8\x97\xA4\xE8\xA3\x95\xE8\x94\xB5," +
-        'L=aaa\=\"bbb\, ccc\",' +
-        'L="aaa=\"bbb, ccc\"",' +
-        'OU=,' +
-        'OU="",' +
-        'O=\,\=\+\<\>\#\;,' +
-        'O=",=+<>#;",' +
-        "DC=ruby-lang," +
-        "DC=org")
-    )
-
-    [
-      "DC=org+DC=jp",
-      "DC=org,DC=ruby-lang+DC=rubyist,DC=www"
-    ].each{|dn|
-      ex = scanner.call(dn) rescue $!
-      dn_r = Regexp.escape(dn)
-      assert_match(/^multi-valued RDN is not supported: #{dn_r}/, ex.message)
-    }
-
-    [
-      ["DC=org,DC=exapmle,CN", "CN"],
-      ["DC=org,DC=example,", ""],
-      ["DC=org,DC=exapmle,CN=www.example.org;", "CN=www.example.org;"],
-      ["DC=org,DC=exapmle,CN=#www.example.org", "CN=#www.example.org"],
-      ["DC=org,DC=exapmle,CN=#777777.example.org", "CN=#777777.example.org"],
-      ["DC=org,DC=exapmle,CN=\"www.example\".org", "CN=\"www.example\".org"],
-      ["DC=org,DC=exapmle,CN=www.\"example.org\"", "CN=www.\"example.org\""],
-      ["DC=org,DC=exapmle,CN=www.\"example\".org", "CN=www.\"example\".org"],
-    ].each{|dn, msg|
-      ex = scanner.call(dn) rescue $!
-      assert_match(/^malformed RDN: .*=>#{Regexp.escape(msg)}/, ex.message)
-    }
-
-    dn = "CN=www.ruby-lang.org,DC=ruby-lang,DC=org"
-    name = OpenSSL::X509::Name.parse_rfc2253(dn)
-    assert_equal(dn, name.to_s(OpenSSL::X509::Name::RFC2253))
-    ary = name.to_a
-    assert_equal("DC", ary[0][0])
-    assert_equal("DC", ary[1][0])
-    assert_equal("CN", ary[2][0])
-    assert_equal("org", ary[0][1])
-    assert_equal("ruby-lang", ary[1][1])
-    assert_equal("www.ruby-lang.org", ary[2][1])
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[0][2])
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[1][2])
-    assert_equal(OpenSSL::ASN1::UTF8STRING, ary[2][2])
-  end
-
-  def test_add_entry
-    dn = [
-      ["DC", "org"],
-      ["DC", "ruby-lang"],
-      ["CN", "GOTOU Yuuzou"],
-      ["emailAddress", "gotoyuzo@ruby-lang.org"],
-      ["serialNumber", "123"],
-    ]
-    name = OpenSSL::X509::Name.new
-    dn.each{|attr| name.add_entry(*attr) }
-    ary = name.to_a
-    assert_equal("/DC=org/DC=ruby-lang/CN=GOTOU Yuuzou/emailAddress=gotoyuzo@ruby-lang.org/serialNumber=123", name.to_s)
-    assert_equal("DC", ary[0][0])
-    assert_equal("DC", ary[1][0])
-    assert_equal("CN", ary[2][0])
-    assert_equal("emailAddress", ary[3][0])
-    assert_equal("serialNumber", ary[4][0])
-    assert_equal("org", ary[0][1])
-    assert_equal("ruby-lang", ary[1][1])
-    assert_equal("GOTOU Yuuzou", ary[2][1])
-    assert_equal("gotoyuzo@ruby-lang.org", ary[3][1])
-    assert_equal("123", ary[4][1])
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[0][2])
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[1][2])
-    assert_equal(OpenSSL::ASN1::UTF8STRING, ary[2][2])
-    assert_equal(OpenSSL::ASN1::IA5STRING, ary[3][2])
-    assert_equal(OpenSSL::ASN1::PRINTABLESTRING, ary[4][2])
-  end
-
-  def test_add_entry_street
-    # openssl/crypto/objects/obj_mac.h 1.83
-    dn = [
-      ["DC", "org"],
-      ["DC", "ruby-lang"],
-      ["CN", "GOTOU Yuuzou"],
-      ["emailAddress", "gotoyuzo@ruby-lang.org"],
-      ["serialNumber", "123"],
-      ["street", "Namiki"],
-    ]
-    name = OpenSSL::X509::Name.new
-    dn.each{|attr| name.add_entry(*attr) }
-    ary = name.to_a
-    assert_equal("/DC=org/DC=ruby-lang/CN=GOTOU Yuuzou/emailAddress=gotoyuzo@ruby-lang.org/serialNumber=123/street=Namiki", name.to_s)
-    assert_equal("Namiki", ary[5][1])
-  end
-
-  def test_add_entry_placing
-    der = %w{ 30 2A
-                 31 12
-                    30 10 06 03 55 04 0A 0C 09 72 75 62 79 2D 6C 61 6E 67
-                 31 14
-                    30 08 06 03 55 04 0B 0C 01 61
-                    30 08 06 03 55 04 0B 0C 01 62 }
-    orig = OpenSSL::X509::Name.new([der.join].pack("H*"))
-    assert_equal("OU=b+OU=a,O=ruby-lang", orig.to_s(OpenSSL::X509::Name::RFC2253))
-    # Skip for now; they do not work
-    #
-    # dn = orig.dup
-    # dn.add_entry("CN", "unya", loc: 0, set: 0)
-    # assert_equal("OU=b+OU=a,O=ruby-lang,CN=unya", dn.dup.to_s(OpenSSL::X509::Name::RFC2253))
-    # dn = orig.dup
-    # dn.add_entry("CN", "unya", loc: 0, set: 1)
-    # assert_equal("OU=b+OU=a,O=ruby-lang+CN=unya", dn.dup.to_s(OpenSSL::X509::Name::RFC2253))
-    dn = orig.dup
-    dn.add_entry("CN", "unya", loc: 1, set: -1)
-    assert_equal("OU=b+OU=a,O=ruby-lang+CN=unya", dn.dup.to_s(OpenSSL::X509::Name::RFC2253))
-    # dn = orig.dup
-    # dn.add_entry("CN", "unya", loc: 1, set: 0)
-    # assert_equal("OU=b+OU=a,CN=unya,O=ruby-lang", dn.dup.to_s(OpenSSL::X509::Name::RFC2253))
-    dn = orig.dup
-    dn.add_entry("CN", "unya", loc: 1, set: 1)
-    assert_equal("CN=unya+OU=b+OU=a,O=ruby-lang", dn.dup.to_s(OpenSSL::X509::Name::RFC2253))
-    dn = orig.dup
-    dn.add_entry("CN", "unya", loc: -1, set: -1)
-    assert_equal("CN=unya+OU=b+OU=a,O=ruby-lang", dn.dup.to_s(OpenSSL::X509::Name::RFC2253))
-    dn = orig.dup
-    dn.add_entry("CN", "unya", loc: -1, set: 0)
-    assert_equal("CN=unya,OU=b+OU=a,O=ruby-lang", dn.dup.to_s(OpenSSL::X509::Name::RFC2253))
-  end
-
-  def test_to_s
-    dn = [
-      ["DC", "org"],
-      ["DC", "ruby-lang"],
-      ["CN", "フー, バー"],
-    ]
-    name = OpenSSL::X509::Name.new
-    dn.each { |x| name.add_entry(*x) }
-
-    assert_equal "/DC=org/DC=ruby-lang/" \
-      "CN=\\xE3\\x83\\x95\\xE3\\x83\\xBC, \\xE3\\x83\\x90\\xE3\\x83\\xBC",
-      name.to_s
-    # OpenSSL escapes characters with MSB by default
-    assert_equal \
-      "CN=\\E3\\83\\95\\E3\\83\\BC\\, \\E3\\83\\90\\E3\\83\\BC," \
-      "DC=ruby-lang,DC=org",
-      name.to_s(OpenSSL::X509::Name::RFC2253)
-    assert_equal "DC = org, DC = ruby-lang, " \
-      "CN = \"\\E3\\83\\95\\E3\\83\\BC, \\E3\\83\\90\\E3\\83\\BC\"",
-      name.to_s(OpenSSL::X509::Name::ONELINE)
-
-    empty = OpenSSL::X509::Name.new
-    assert_equal "", empty.to_s
-    assert_equal "", empty.to_s(OpenSSL::X509::Name::COMPAT)
-    assert_equal "", empty.to_s(OpenSSL::X509::Name::RFC2253)
-    assert_equal "", empty.to_s(OpenSSL::X509::Name::ONELINE)
-  end
-
-  def test_to_utf8
-    dn = [
-      ["DC", "org"],
-      ["DC", "ruby-lang"],
-      ["CN", "フー, バー"],
-    ]
-    name = OpenSSL::X509::Name.new
-    dn.each { |x| name.add_entry(*x) }
-
-    str = name.to_utf8
-    expected = String.new("CN=フー\\, バー,DC=ruby-lang,DC=org").force_encoding("UTF-8")
-    assert_equal expected, str
-    assert_equal Encoding.find("UTF-8"), str.encoding
-
-    empty = OpenSSL::X509::Name.new
-    assert_equal "", empty.to_utf8
-  end
-
-  def test_equals2
-    n1 = OpenSSL::X509::Name.parse_rfc2253 'CN=a'
-    n2 = OpenSSL::X509::Name.parse_rfc2253 'CN=a'
-
-    assert_equal n1, n2
-
-    assert_equal(false, n1 == 'abc')
-    assert_equal(false, n2 == nil)
-  end
-
-  def test_spaceship
-    n1 = OpenSSL::X509::Name.new([["CN", "a"]])
-    n2 = OpenSSL::X509::Name.new([["CN", "a"]])
-    n3 = OpenSSL::X509::Name.new([["CN", "ab"]])
-
-    assert_equal(0, n1 <=> n2)
-    assert_equal(-1, n1 <=> n3)
-    assert_equal(0, n2 <=> n1)
-    assert_equal(-1, n2 <=> n3)
-    assert_equal(1, n3 <=> n1)
-    assert_equal(1, n3 <=> n2)
-    assert_equal(nil, n1 <=> 'abc')
-    assert_equal(nil, n2 <=> 123)
-    assert_equal(nil, n3 <=> nil)
-  end
-
-  def name_hash(name)
-    # OpenSSL 1.0.0 uses SHA1 for canonical encoding (not just a der) of
-    # X509Name for X509_NAME_hash.
-    name.respond_to?(:hash_old) ? name.hash_old : name.hash
-  end
-
-  def test_hash
-    dn = "/DC=org/DC=ruby-lang/CN=www.ruby-lang.org"
-    name = OpenSSL::X509::Name.parse(dn)
-    d = OpenSSL::Digest.digest('MD5', name.to_der)
-    expected = (d[0].ord & 0xff) | (d[1].ord & 0xff) << 8 | (d[2].ord & 0xff) << 16 | (d[3].ord & 0xff) << 24
-    assert_equal(expected, name_hash(name))
-    #
-    dn = "/DC=org/DC=ruby-lang/CN=baz.ruby-lang.org"
-    name = OpenSSL::X509::Name.parse(dn)
-    d = OpenSSL::Digest.digest('MD5', name.to_der)
-    expected = (d[0].ord & 0xff) | (d[1].ord & 0xff) << 8 | (d[2].ord & 0xff) << 16 | (d[3].ord & 0xff) << 24
-    assert_equal(expected, name_hash(name))
-  end
-
-  def test_equality
-    name0 = OpenSSL::X509::Name.new([["DC", "org"], ["DC", "ruby-lang"], ["CN", "bar.ruby-lang.org"]])
-    name1 = OpenSSL::X509::Name.new([["DC", "org"], ["DC", "ruby-lang"], ["CN", "bar.ruby-lang.org"]])
-    name2 = OpenSSL::X509::Name.new([["DC", "org"], ["DC", "ruby-lang"], ["CN", "baz.ruby-lang.org"]])
-    assert_equal true, name0 == name1
-    assert_equal true, name0.eql?(name1)
-    assert_equal false, name0 == name2
-    assert_equal false, name0.eql?(name2)
-  end
-
-  def test_marshal
-    name = OpenSSL::X509::Name.new([["DC", "org"], ["DC", "ruby-lang"], ["CN", "bar.ruby-lang.org"]])
-    deserialized = Marshal.load(Marshal.dump(name))
-
-    assert_equal name.to_der, deserialized.to_der
-  end
-
-  def test_dup
-    name = OpenSSL::X509::Name.parse("/CN=ruby-lang.org")
-    assert_equal(name.to_der, name.dup.to_der)
-  end
-end
-
-end
diff --git a/test/openssl/test_x509req.rb b/test/openssl/test_x509req.rb
deleted file mode 100644
index ee9c678..0000000
--- a/test/openssl/test_x509req.rb
+++ /dev/null
@@ -1,170 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestX509Request < OpenSSL::TestCase
-  def setup
-    super
-    @rsa1024 = Fixtures.pkey("rsa1024")
-    @rsa2048 = Fixtures.pkey("rsa2048")
-    @dsa256  = Fixtures.pkey("dsa256")
-    @dsa512  = Fixtures.pkey("dsa512")
-    @dn = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=GOTOU Yuuzou")
-  end
-
-  def issue_csr(ver, dn, key, digest)
-    req = OpenSSL::X509::Request.new
-    req.version = ver
-    req.subject = dn
-    req.public_key = key.public_key
-    req.sign(key, digest)
-    req
-  end
-
-  def test_public_key
-    req = issue_csr(0, @dn, @rsa1024, OpenSSL::Digest.new('SHA1'))
-    assert_equal(@rsa1024.public_key.to_der, req.public_key.to_der)
-    req = OpenSSL::X509::Request.new(req.to_der)
-    assert_equal(@rsa1024.public_key.to_der, req.public_key.to_der)
-
-    req = issue_csr(0, @dn, @dsa512, OpenSSL::Digest.new('SHA1'))
-    assert_equal(@dsa512.public_key.to_der, req.public_key.to_der)
-    req = OpenSSL::X509::Request.new(req.to_der)
-    assert_equal(@dsa512.public_key.to_der, req.public_key.to_der)
-  end
-
-  def test_version
-    req = issue_csr(0, @dn, @rsa1024, OpenSSL::Digest.new('SHA1'))
-    assert_equal(0, req.version)
-    req = OpenSSL::X509::Request.new(req.to_der)
-    assert_equal(0, req.version)
-
-    req = issue_csr(1, @dn, @rsa1024, OpenSSL::Digest.new('SHA1'))
-    assert_equal(1, req.version)
-    req = OpenSSL::X509::Request.new(req.to_der)
-    assert_equal(1, req.version)
-  end
-
-  def test_subject
-    req = issue_csr(0, @dn, @rsa1024, OpenSSL::Digest.new('SHA1'))
-    assert_equal(@dn.to_der, req.subject.to_der)
-    req = OpenSSL::X509::Request.new(req.to_der)
-    assert_equal(@dn.to_der, req.subject.to_der)
-  end
-
-  def create_ext_req(exts)
-    ef = OpenSSL::X509::ExtensionFactory.new
-    exts = exts.collect{|e| ef.create_extension(*e) }
-    return OpenSSL::ASN1::Set([OpenSSL::ASN1::Sequence(exts)])
-  end
-
-  def get_ext_req(ext_req_value)
-    set = OpenSSL::ASN1.decode(ext_req_value)
-    seq = set.value[0]
-    seq.value.collect{|asn1ext|
-      OpenSSL::X509::Extension.new(asn1ext).to_a
-    }
-  end
-
-  def test_attr
-    exts = [
-      ["keyUsage", "Digital Signature, Key Encipherment", true],
-      ["subjectAltName", "email:gotoyuzo@ruby-lang.org", false],
-    ]
-    attrval = create_ext_req(exts)
-    attrs = [
-      OpenSSL::X509::Attribute.new("extReq", attrval),
-      OpenSSL::X509::Attribute.new("msExtReq", attrval),
-    ]
-
-    req0 = issue_csr(0, @dn, @rsa1024, OpenSSL::Digest.new('SHA1'))
-    attrs.each{|attr| req0.add_attribute(attr) }
-    req1 = issue_csr(0, @dn, @rsa1024, OpenSSL::Digest.new('SHA1'))
-    req1.attributes = attrs
-    assert_equal(req0.to_der, req1.to_der)
-
-    attrs = req0.attributes
-    assert_equal(2, attrs.size)
-    assert_equal("extReq", attrs[0].oid)
-    assert_equal("msExtReq", attrs[1].oid)
-    assert_equal(exts, get_ext_req(attrs[0].value))
-    assert_equal(exts, get_ext_req(attrs[1].value))
-
-    req = OpenSSL::X509::Request.new(req0.to_der)
-    attrs = req.attributes
-    assert_equal(2, attrs.size)
-    assert_equal("extReq", attrs[0].oid)
-    assert_equal("msExtReq", attrs[1].oid)
-    assert_equal(exts, get_ext_req(attrs[0].value))
-    assert_equal(exts, get_ext_req(attrs[1].value))
-  end
-
-  def test_sign_and_verify_rsa_sha1
-    req = issue_csr(0, @dn, @rsa1024, OpenSSL::Digest.new('SHA1'))
-    assert_equal(true,  req.verify(@rsa1024))
-    assert_equal(false, req.verify(@rsa2048))
-    assert_equal(false, request_error_returns_false { req.verify(@dsa256) })
-    assert_equal(false, request_error_returns_false { req.verify(@dsa512) })
-    req.version = 1
-    assert_equal(false, req.verify(@rsa1024))
-  end
-
-  def test_sign_and_verify_rsa_md5
-    req = issue_csr(0, @dn, @rsa2048, OpenSSL::Digest.new('MD5'))
-    assert_equal(false, req.verify(@rsa1024))
-    assert_equal(true,  req.verify(@rsa2048))
-    assert_equal(false, request_error_returns_false { req.verify(@dsa256) })
-    assert_equal(false, request_error_returns_false { req.verify(@dsa512) })
-    req.subject = OpenSSL::X509::Name.parse("/C=JP/CN=FooBar")
-    assert_equal(false, req.verify(@rsa2048))
-  rescue OpenSSL::X509::RequestError # RHEL7 disables MD5
-  end
-
-  def test_sign_and_verify_dsa
-    req = issue_csr(0, @dn, @dsa512, OpenSSL::Digest.new('SHA1'))
-    assert_equal(false, request_error_returns_false { req.verify(@rsa1024) })
-    assert_equal(false, request_error_returns_false { req.verify(@rsa2048) })
-    assert_equal(false, req.verify(@dsa256))
-    assert_equal(true,  req.verify(@dsa512))
-    req.public_key = @rsa1024.public_key
-    assert_equal(false, req.verify(@dsa512))
-  end
-
-  def test_sign_and_verify_dsa_md5
-    assert_raise(OpenSSL::X509::RequestError){
-      issue_csr(0, @dn, @dsa512, OpenSSL::Digest.new('MD5')) }
-  end
-
-  def test_dup
-    req = issue_csr(0, @dn, @rsa1024, OpenSSL::Digest.new('SHA1'))
-    assert_equal(req.to_der, req.dup.to_der)
-  end
-
-  def test_eq
-    req1 = issue_csr(0, @dn, @rsa1024, "sha1")
-    req2 = issue_csr(0, @dn, @rsa1024, "sha1")
-    req3 = issue_csr(0, @dn, @rsa1024, "sha256")
-
-    assert_equal false, req1 == 12345
-    assert_equal true, req1 == req2
-    assert_equal false, req1 == req3
-  end
-
-  def test_marshal
-    req = issue_csr(0, @dn, @rsa1024, "sha256")
-    deserialized = Marshal.load(Marshal.dump(req))
-
-    assert_equal req.to_der, deserialized.to_der
-  end
-
-  private
-
-  def request_error_returns_false
-    yield
-  rescue OpenSSL::X509::RequestError
-    false
-  end
-end
-
-end
diff --git a/test/openssl/test_x509store.rb b/test/openssl/test_x509store.rb
deleted file mode 100644
index e9602e3..0000000
--- a/test/openssl/test_x509store.rb
+++ /dev/null
@@ -1,241 +0,0 @@
-# frozen_string_literal: true
-require_relative "utils"
-
-if defined?(OpenSSL)
-
-class OpenSSL::TestX509Store < OpenSSL::TestCase
-  def setup
-    super
-    @rsa1024 = Fixtures.pkey("rsa1024")
-    @rsa2048 = Fixtures.pkey("rsa2048")
-    @dsa256  = Fixtures.pkey("dsa256")
-    @dsa512  = Fixtures.pkey("dsa512")
-    @ca1 = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=CA1")
-    @ca2 = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=CA2")
-    @ee1 = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=EE1")
-    @ee2 = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=EE2")
-  end
-
-  def test_nosegv_on_cleanup
-    cert  = OpenSSL::X509::Certificate.new
-    store = OpenSSL::X509::Store.new
-    ctx   = OpenSSL::X509::StoreContext.new(store, cert, [])
-    EnvUtil.suppress_warning do
-      ctx.cleanup
-    end
-    ctx.verify
-  end
-
-  def test_add_file
-    ca_exts = [
-      ["basicConstraints", "CA:TRUE", true],
-      ["keyUsage", "cRLSign,keyCertSign", true],
-    ]
-    cert1 = issue_cert(@ca1, @rsa1024, 1, ca_exts, nil, nil)
-    cert2 = issue_cert(@ca2, @rsa2048, 1, ca_exts, nil, nil)
-    tmpfile = Tempfile.open { |f| f << cert1.to_pem << cert2.to_pem; f }
-
-    store = OpenSSL::X509::Store.new
-    assert_equal false, store.verify(cert1)
-    assert_equal false, store.verify(cert2)
-    store.add_file(tmpfile.path)
-    assert_equal true, store.verify(cert1)
-    assert_equal true, store.verify(cert2)
-
-    # OpenSSL < 1.1.1 leaks an error on a duplicate certificate
-    assert_nothing_raised { store.add_file(tmpfile.path) }
-    assert_equal [], OpenSSL.errors
-  ensure
-    tmpfile and tmpfile.close!
-  end
-
-  def test_verify
-    # OpenSSL uses time(2) while Time.now uses clock_gettime(CLOCK_REALTIME),
-    # and there may be difference.
-    now = Time.now - 3
-    ca_exts = [
-      ["basicConstraints","CA:TRUE",true],
-      ["keyUsage","cRLSign,keyCertSign",true],
-    ]
-    ee_exts = [
-      ["keyUsage","keyEncipherment,digitalSignature",true],
-    ]
-    ca1_cert = issue_cert(@ca1, @rsa2048, 1, ca_exts, nil, nil)
-    ca2_cert = issue_cert(@ca2, @rsa1024, 2, ca_exts, ca1_cert, @rsa2048,
-                          not_after: now+1800)
-    ee1_cert = issue_cert(@ee1, @dsa256, 10, ee_exts, ca2_cert, @rsa1024)
-    ee2_cert = issue_cert(@ee2, @dsa512, 20, ee_exts, ca2_cert, @rsa1024)
-    ee3_cert = issue_cert(@ee2, @dsa512, 30,  ee_exts, ca2_cert, @rsa1024,
-                          not_before: now-100, not_after: now-1)
-    ee4_cert = issue_cert(@ee2, @dsa512, 40, ee_exts, ca2_cert, @rsa1024,
-                          not_before: now+1000, not_after: now+2000,)
-
-    revoke_info = []
-    crl1   = issue_crl(revoke_info, 1, now, now+1800, [],
-                       ca1_cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    revoke_info = [ [2, now, 1], ]
-    crl1_2 = issue_crl(revoke_info, 2, now, now+1800, [],
-                       ca1_cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    revoke_info = [ [20, now, 1], ]
-    crl2   = issue_crl(revoke_info, 1, now, now+1800, [],
-                       ca2_cert, @rsa1024, OpenSSL::Digest.new('SHA1'))
-    revoke_info = []
-    crl2_2 = issue_crl(revoke_info, 2, now-100, now-1, [],
-                       ca2_cert, @rsa1024, OpenSSL::Digest.new('SHA1'))
-
-    assert_equal(true, ca1_cert.verify(ca1_cert.public_key))   # self signed
-    assert_equal(true, ca2_cert.verify(ca1_cert.public_key))   # issued by ca1
-    assert_equal(true, ee1_cert.verify(ca2_cert.public_key))   # issued by ca2
-    assert_equal(true, ee2_cert.verify(ca2_cert.public_key))   # issued by ca2
-    assert_equal(true, ee3_cert.verify(ca2_cert.public_key))   # issued by ca2
-    assert_equal(true, crl1.verify(ca1_cert.public_key))       # issued by ca1
-    assert_equal(true, crl1_2.verify(ca1_cert.public_key))     # issued by ca1
-    assert_equal(true, crl2.verify(ca2_cert.public_key))       # issued by ca2
-    assert_equal(true, crl2_2.verify(ca2_cert.public_key))     # issued by ca2
-
-    store = OpenSSL::X509::Store.new
-    assert_equal(false, store.verify(ca1_cert))
-    assert_not_equal(OpenSSL::X509::V_OK, store.error)
-
-    assert_equal(false, store.verify(ca2_cert))
-    assert_not_equal(OpenSSL::X509::V_OK, store.error)
-
-    store.add_cert(ca1_cert)
-    assert_equal(true, store.verify(ca2_cert))
-    assert_equal(OpenSSL::X509::V_OK, store.error)
-    assert_equal("ok", store.error_string)
-    chain = store.chain
-    assert_equal(2, chain.size)
-    assert_equal(@ca2.to_der, chain[0].subject.to_der)
-    assert_equal(@ca1.to_der, chain[1].subject.to_der)
-
-    store.purpose = OpenSSL::X509::PURPOSE_SSL_CLIENT
-    assert_equal(false, store.verify(ca2_cert))
-    assert_not_equal(OpenSSL::X509::V_OK, store.error)
-
-    store.purpose = OpenSSL::X509::PURPOSE_CRL_SIGN
-    assert_equal(true, store.verify(ca2_cert))
-    assert_equal(OpenSSL::X509::V_OK, store.error)
-
-    store.add_cert(ca2_cert)
-    store.purpose = OpenSSL::X509::PURPOSE_SSL_CLIENT
-    assert_equal(true, store.verify(ee1_cert))
-    assert_equal(true, store.verify(ee2_cert))
-    assert_equal(OpenSSL::X509::V_OK, store.error)
-    assert_equal("ok", store.error_string)
-    chain = store.chain
-    assert_equal(3, chain.size)
-    assert_equal(@ee2.to_der, chain[0].subject.to_der)
-    assert_equal(@ca2.to_der, chain[1].subject.to_der)
-    assert_equal(@ca1.to_der, chain[2].subject.to_der)
-    assert_equal(false, store.verify(ee3_cert))
-    assert_equal(OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED, store.error)
-    assert_match(/expire/i, store.error_string)
-    assert_equal(false, store.verify(ee4_cert))
-    assert_equal(OpenSSL::X509::V_ERR_CERT_NOT_YET_VALID, store.error)
-    assert_match(/not yet valid/i, store.error_string)
-
-    store = OpenSSL::X509::Store.new
-    store.add_cert(ca1_cert)
-    store.add_cert(ca2_cert)
-    store.time = now + 1500
-    assert_equal(true, store.verify(ca1_cert))
-    assert_equal(true, store.verify(ca2_cert))
-    assert_equal(true, store.verify(ee4_cert))
-    store.time = now + 1900
-    assert_equal(true, store.verify(ca1_cert))
-    assert_equal(false, store.verify(ca2_cert))
-    assert_equal(OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED, store.error)
-    assert_equal(false, store.verify(ee4_cert))
-    assert_equal(OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED, store.error)
-    store.time = now + 4000
-    assert_equal(false, store.verify(ee1_cert))
-    assert_equal(OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED, store.error)
-    assert_equal(false, store.verify(ee4_cert))
-    assert_equal(OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED, store.error)
-
-    # the underlying X509 struct caches the result of the last
-    # verification for signature and not-before. so the following code
-    # rebuilds new objects to avoid site effect.
-    store.time = Time.now - 4000
-    assert_equal(false, store.verify(OpenSSL::X509::Certificate.new(ca2_cert)))
-    assert_equal(OpenSSL::X509::V_ERR_CERT_NOT_YET_VALID, store.error)
-    assert_equal(false, store.verify(OpenSSL::X509::Certificate.new(ee1_cert)))
-    assert_equal(OpenSSL::X509::V_ERR_CERT_NOT_YET_VALID, store.error)
-
-    store = OpenSSL::X509::Store.new
-    store.purpose = OpenSSL::X509::PURPOSE_ANY
-    store.flags = OpenSSL::X509::V_FLAG_CRL_CHECK
-    store.add_cert(ca1_cert)
-    store.add_crl(crl1)   # revoke no cert
-    store.add_crl(crl2)   # revoke ee2_cert
-    assert_equal(true,  store.verify(ca1_cert))
-    assert_equal(true,  store.verify(ca2_cert))
-    assert_equal(true,  store.verify(ee1_cert, [ca2_cert]))
-    assert_equal(false, store.verify(ee2_cert, [ca2_cert]))
-
-    store = OpenSSL::X509::Store.new
-    store.purpose = OpenSSL::X509::PURPOSE_ANY
-    store.flags = OpenSSL::X509::V_FLAG_CRL_CHECK
-    store.add_cert(ca1_cert)
-    store.add_crl(crl1_2) # revoke ca2_cert
-    store.add_crl(crl2)   # revoke ee2_cert
-    assert_equal(true,  store.verify(ca1_cert))
-    assert_equal(false, store.verify(ca2_cert))
-    assert_equal(true,  store.verify(ee1_cert, [ca2_cert]),
-      "This test is expected to be success with OpenSSL 0.9.7c or later.")
-    assert_equal(false, store.verify(ee2_cert, [ca2_cert]))
-
-    store.flags =
-      OpenSSL::X509::V_FLAG_CRL_CHECK|OpenSSL::X509::V_FLAG_CRL_CHECK_ALL
-    assert_equal(true,  store.verify(ca1_cert))
-    assert_equal(false, store.verify(ca2_cert))
-    assert_equal(false, store.verify(ee1_cert, [ca2_cert]))
-    assert_equal(false, store.verify(ee2_cert, [ca2_cert]))
-
-    store = OpenSSL::X509::Store.new
-    store.purpose = OpenSSL::X509::PURPOSE_ANY
-    store.flags =
-      OpenSSL::X509::V_FLAG_CRL_CHECK|OpenSSL::X509::V_FLAG_CRL_CHECK_ALL
-    store.add_cert(ca1_cert)
-    store.add_cert(ca2_cert)
-    store.add_crl(crl1)
-    store.add_crl(crl2_2) # issued by ca2 but expired.
-    assert_equal(true, store.verify(ca1_cert))
-    assert_equal(true, store.verify(ca2_cert))
-    assert_equal(false, store.verify(ee1_cert))
-    assert_equal(OpenSSL::X509::V_ERR_CRL_HAS_EXPIRED, store.error)
-    assert_equal(false, store.verify(ee2_cert))
-  end
-
-  def test_set_errors
-    return if openssl?(1, 1, 0) || libressl?
-    now = Time.now
-    ca1_cert = issue_cert(@ca1, @rsa2048, 1, [], nil, nil)
-    store = OpenSSL::X509::Store.new
-    store.add_cert(ca1_cert)
-    assert_raise(OpenSSL::X509::StoreError){
-      store.add_cert(ca1_cert)  # add same certificate twice
-    }
-
-    revoke_info = []
-    crl1 = issue_crl(revoke_info, 1, now, now+1800, [],
-                     ca1_cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    revoke_info = [ [2, now, 1], ]
-    crl2 = issue_crl(revoke_info, 2, now+1800, now+3600, [],
-                     ca1_cert, @rsa2048, OpenSSL::Digest.new('SHA1'))
-    store.add_crl(crl1)
-    assert_raise(OpenSSL::X509::StoreError){
-      store.add_crl(crl2) # add CRL issued by same CA twice.
-    }
-  end
-
-  def test_dup
-    store = OpenSSL::X509::Store.new
-    assert_raise(NoMethodError) { store.dup }
-    ctx = OpenSSL::X509::StoreContext.new(store)
-    assert_raise(NoMethodError) { ctx.dup }
-  end
-end
-
-end
diff --git a/test/openssl/ut_eof.rb b/test/openssl/ut_eof.rb
deleted file mode 100644
index cf1f2d4..0000000
--- a/test/openssl/ut_eof.rb
+++ /dev/null
@@ -1,133 +0,0 @@
-# frozen_string_literal: true
-require 'test/unit'
-
-if defined?(OpenSSL)
-
-module OpenSSL::TestEOF
-  def test_eof_0
-    open_file("") {|f|
-      assert_equal("", f.read(0))
-      assert_equal("", f.read(0))
-      assert_equal("", f.read)
-      assert_equal("", f.read(0))
-      assert_equal("", f.read(0))
-    }
-    open_file("") {|f|
-      assert_nil(f.read(1))
-      assert_equal("", f.read)
-      assert_nil(f.read(1))
-    }
-    open_file("") {|f|
-      s = +"x"
-      assert_equal("", f.read(nil, s))
-      assert_equal("", s)
-    }
-    open_file("") {|f|
-      s = +"x"
-      assert_nil(f.read(10, s))
-      assert_equal("", s)
-    }
-  end
-
-  def test_eof_0_rw
-    return unless respond_to? :open_file_rw
-    open_file_rw("") {|f|
-      assert_equal("", f.read)
-      assert_equal("", f.read)
-      assert_equal(0, f.syswrite(""))
-      assert_equal("", f.read)
-    }
-  end
-
-  def test_eof_1
-    open_file("a") {|f|
-      assert_equal("", f.read(0))
-      assert_equal("a", f.read(1))
-      assert_equal("" , f.read(0))
-      assert_equal("" , f.read(0))
-      assert_equal("", f.read)
-      assert_equal("", f.read(0))
-      assert_equal("", f.read(0))
-    }
-    open_file("a") {|f|
-      assert_equal("a", f.read(1))
-      assert_nil(f.read(1))
-    }
-    open_file("a") {|f|
-      assert_equal("a", f.read(2))
-      assert_nil(f.read(1))
-      assert_equal("", f.read)
-      assert_nil(f.read(1))
-    }
-    open_file("a") {|f|
-      assert_equal("a", f.read)
-      assert_nil(f.read(1))
-      assert_equal("", f.read)
-      assert_nil(f.read(1))
-    }
-    open_file("a") {|f|
-      assert_equal("a", f.read(2))
-      assert_equal("", f.read)
-      assert_equal("", f.read)
-    }
-    open_file("a") {|f|
-      assert_equal("a", f.read)
-      assert_equal("", f.read(0))
-    }
-    open_file("a") {|f|
-      s = +"x"
-      assert_equal("a", f.read(nil, s))
-      assert_equal("a", s)
-    }
-    open_file("a") {|f|
-      s = +"x"
-      assert_equal("a", f.read(10, s))
-      assert_equal("a", s)
-    }
-  end
-
-  def test_eof_2
-    open_file("") {|f|
-      assert_equal("", f.read)
-      assert_predicate(f, :eof?)
-    }
-  end
-
-  def test_eof_3
-    open_file("") {|f|
-      assert_predicate(f, :eof?)
-    }
-  end
-
-  module Seek
-    def open_file_seek(content, pos)
-      open_file(content) do |f|
-        f.seek(pos)
-        yield f
-      end
-    end
-
-    def test_eof_0_seek
-      open_file_seek("", 10) {|f|
-        assert_equal(10, f.pos)
-        assert_equal("", f.read(0))
-        assert_equal("", f.read)
-        assert_equal("", f.read(0))
-        assert_equal("", f.read)
-      }
-    end
-
-    def test_eof_1_seek
-      open_file_seek("a", 10) {|f|
-        assert_equal("", f.read)
-        assert_equal("", f.read)
-      }
-      open_file_seek("a", 1) {|f|
-        assert_equal("", f.read)
-        assert_equal("", f.read)
-      }
-    end
-  end
-end
-
-end
diff --git a/test/openssl/utils.rb b/test/openssl/utils.rb
deleted file mode 100644
index ee734d9..0000000
--- a/test/openssl/utils.rb
+++ /dev/null
@@ -1,405 +0,0 @@
-# frozen_string_literal: true
-begin
-  require "openssl"
-
-  # Disable FIPS mode for tests for installations
-  # where FIPS mode would be enabled by default.
-  # Has no effect on all other installations.
-  OpenSSL.fips_mode=false
-rescue LoadError
-end
-
-# Compile OpenSSL with crypto-mdebug and run this test suite with OSSL_MDEBUG=1
-# environment variable to enable memory leak check.
-if ENV["OSSL_MDEBUG"] == "1"
-  if OpenSSL.respond_to?(:print_mem_leaks)
-    OpenSSL.mem_check_start
-
-    END {
-      GC.start
-      case OpenSSL.print_mem_leaks
-      when nil
-        warn "mdebug: check what is printed"
-      when true
-        raise "mdebug: memory leaks detected"
-      end
-    }
-  else
-    warn "OSSL_MDEBUG=1 is specified but OpenSSL is not built with crypto-mdebug"
-  end
-end
-
-require "test/unit"
-require "tempfile"
-require "socket"
-require "envutil"
-
-if defined?(OpenSSL)
-
-module OpenSSL::TestUtils
-  module Fixtures
-    module_function
-
-    def pkey(name)
-      OpenSSL::PKey.read(read_file("pkey", name))
-    rescue OpenSSL::PKey::PKeyError
-      # TODO: DH parameters can be read by OpenSSL::PKey.read atm
-      OpenSSL::PKey::DH.new(read_file("pkey", name))
-    end
-
-    def read_file(category, name)
-      @file_cache ||= {}
-      @file_cache[[category, name]] ||=
-        File.read(File.join(__dir__, "fixtures", category, name + ".pem"))
-    end
-
-    def file_path(category, name)
-      File.join(__dir__, "fixtures", category, name)
-    end
-  end
-
-  module_function
-
-  def generate_cert(dn, key, serial, issuer,
-                    not_before: nil, not_after: nil)
-    cert = OpenSSL::X509::Certificate.new
-    issuer = cert unless issuer
-    cert.version = 2
-    cert.serial = serial
-    cert.subject = dn
-    cert.issuer = issuer.subject
-    cert.public_key = key
-    now = Time.now
-    cert.not_before = not_before || now - 3600
-    cert.not_after = not_after || now + 3600
-    cert
-  end
-
-
-  def issue_cert(dn, key, serial, extensions, issuer, issuer_key,
-                 not_before: nil, not_after: nil, digest: "sha256")
-    cert = generate_cert(dn, key, serial, issuer,
-                         not_before: not_before, not_after: not_after)
-    issuer = cert unless issuer
-    issuer_key = key unless issuer_key
-    ef = OpenSSL::X509::ExtensionFactory.new
-    ef.subject_certificate = cert
-    ef.issuer_certificate = issuer
-    extensions.each{|oid, value, critical|
-      cert.add_extension(ef.create_extension(oid, value, critical))
-    }
-    cert.sign(issuer_key, digest)
-    cert
-  end
-
-  def issue_crl(revoke_info, serial, lastup, nextup, extensions,
-                issuer, issuer_key, digest)
-    crl = OpenSSL::X509::CRL.new
-    crl.issuer = issuer.subject
-    crl.version = 1
-    crl.last_update = lastup
-    crl.next_update = nextup
-    revoke_info.each{|rserial, time, reason_code|
-      revoked = OpenSSL::X509::Revoked.new
-      revoked.serial = rserial
-      revoked.time = time
-      enum = OpenSSL::ASN1::Enumerated(reason_code)
-      ext = OpenSSL::X509::Extension.new("CRLReason", enum)
-      revoked.add_extension(ext)
-      crl.add_revoked(revoked)
-    }
-    ef = OpenSSL::X509::ExtensionFactory.new
-    ef.issuer_certificate = issuer
-    ef.crl = crl
-    crlnum = OpenSSL::ASN1::Integer(serial)
-    crl.add_extension(OpenSSL::X509::Extension.new("crlNumber", crlnum))
-    extensions.each{|oid, value, critical|
-      crl.add_extension(ef.create_extension(oid, value, critical))
-    }
-    crl.sign(issuer_key, digest)
-    crl
-  end
-
-  def get_subject_key_id(cert, hex: true)
-    asn1_cert = OpenSSL::ASN1.decode(cert)
-    tbscert   = asn1_cert.value[0]
-    pkinfo    = tbscert.value[6]
-    publickey = pkinfo.value[1]
-    pkvalue   = publickey.value
-    digest = OpenSSL::Digest.digest('SHA1', pkvalue)
-    if hex
-      digest.unpack("H2"*20).join(":").upcase
-    else
-      digest
-    end
-  end
-
-  def openssl?(major = nil, minor = nil, fix = nil, patch = 0)
-    return false if OpenSSL::OPENSSL_VERSION.include?("LibreSSL")
-    return true unless major
-    OpenSSL::OPENSSL_VERSION_NUMBER >=
-      major * 0x10000000 + minor * 0x100000 + fix * 0x1000 + patch * 0x10
-  end
-
-  def libressl?(major = nil, minor = nil, fix = nil)
-    version = OpenSSL::OPENSSL_VERSION.scan(/LibreSSL (\d+)\.(\d+)\.(\d+).*/)[0]
-    return false unless version
-    !major || (version.map(&:to_i) <=> [major, minor, fix]) >= 0
-  end
-end
-
-class OpenSSL::TestCase < Test::Unit::TestCase
-  include OpenSSL::TestUtils
-  extend OpenSSL::TestUtils
-
-  def setup
-    if ENV["OSSL_GC_STRESS"] == "1"
-      GC.stress = true
-    end
-  end
-
-  def teardown
-    if ENV["OSSL_GC_STRESS"] == "1"
-      GC.stress = false
-    end
-    # OpenSSL error stack must be empty
-    assert_equal([], OpenSSL.errors)
-  end
-end
-
-class OpenSSL::SSLTestCase < OpenSSL::TestCase
-  RUBY = EnvUtil.rubybin
-  ITERATIONS = ($0 == __FILE__) ? 100 : 10
-
-  def setup
-    super
-    @ca_key  = Fixtures.pkey("rsa-1")
-    @svr_key = Fixtures.pkey("rsa-2")
-    @cli_key = Fixtures.pkey("rsa-3")
-    @ca  = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=CA")
-    @svr = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=localhost")
-    @cli = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=localhost")
-    ca_exts = [
-      ["basicConstraints","CA:TRUE",true],
-      ["keyUsage","cRLSign,keyCertSign",true],
-    ]
-    ee_exts = [
-      ["keyUsage","keyEncipherment,digitalSignature",true],
-    ]
-    @ca_cert  = issue_cert(@ca, @ca_key, 1, ca_exts, nil, nil)
-    @svr_cert = issue_cert(@svr, @svr_key, 2, ee_exts, @ca_cert, @ca_key)
-    @cli_cert = issue_cert(@cli, @cli_key, 3, ee_exts, @ca_cert, @ca_key)
-    @server = nil
-  end
-
-  def tls12_supported?
-    ctx = OpenSSL::SSL::SSLContext.new
-    ctx.min_version = ctx.max_version = OpenSSL::SSL::TLS1_2_VERSION
-    true
-  rescue
-  end
-
-  def tls13_supported?
-    return false unless defined?(OpenSSL::SSL::TLS1_3_VERSION)
-    ctx = OpenSSL::SSL::SSLContext.new
-    ctx.min_version = ctx.max_version = OpenSSL::SSL::TLS1_3_VERSION
-    true
-  rescue
-  end
-
-  def readwrite_loop(ctx, ssl)
-    while line = ssl.gets
-      ssl.write(line)
-    end
-  end
-
-  def start_server(verify_mode: OpenSSL::SSL::VERIFY_NONE, start_immediately: true,
-                   ctx_proc: nil, server_proc: method(:readwrite_loop),
-                   accept_proc: proc{},
-                   ignore_listener_error: false, &block)
-    IO.pipe {|stop_pipe_r, stop_pipe_w|
-      store = OpenSSL::X509::Store.new
-      store.add_cert(@ca_cert)
-      store.purpose = OpenSSL::X509::PURPOSE_SSL_CLIENT
-      ctx = OpenSSL::SSL::SSLContext.new
-      ctx.cert_store = store
-      ctx.cert = @svr_cert
-      ctx.key = @svr_key
-      ctx.tmp_dh_callback = proc { Fixtures.pkey("dh-1") }
-      ctx.verify_mode = verify_mode
-      ctx_proc.call(ctx) if ctx_proc
-
-      Socket.do_not_reverse_lookup = true
-      tcps = TCPServer.new("127.0.0.1", 0)
-      port = tcps.connect_address.ip_port
-
-      ssls = OpenSSL::SSL::SSLServer.new(tcps, ctx)
-      ssls.start_immediately = start_immediately
-
-      threads = []
-      begin
-        server_thread = Thread.new do
-          if Thread.method_defined?(:report_on_exception=) # Ruby >= 2.4
-            Thread.current.report_on_exception = false
-          end
-
-          begin
-            loop do
-              begin
-                readable, = IO.select([ssls, stop_pipe_r])
-                break if readable.include? stop_pipe_r
-                ssl = ssls.accept
-                accept_proc.call(ssl)
-              rescue OpenSSL::SSL::SSLError, IOError, Errno::EBADF, Errno::EINVAL,
-                     Errno::ECONNABORTED, Errno::ENOTSOCK, Errno::ECONNRESET
-                retry if ignore_listener_error
-                raise
-              end
-
-              th = Thread.new do
-                if Thread.method_defined?(:report_on_exception=)
-                  Thread.current.report_on_exception = false
-                end
-
-                begin
-                  server_proc.call(ctx, ssl)
-                ensure
-                  ssl.close
-                end
-                true
-              end
-              threads << th
-            end
-          ensure
-            tcps.close
-          end
-        end
-
-        client_thread = Thread.new do
-          if Thread.method_defined?(:report_on_exception=)
-            Thread.current.report_on_exception = false
-          end
-
-          begin
-            block.call(port)
-          ensure
-            # Stop accepting new connection
-            stop_pipe_w.close
-            server_thread.join
-          end
-        end
-        threads.unshift client_thread
-      ensure
-        # Terminate existing connections. If a thread did 'pend', re-raise it.
-        pend = nil
-        threads.each { |th|
-          begin
-            timeout = EnvUtil.apply_timeout_scale(30)
-            th.join(timeout) or
-              th.raise(RuntimeError, "[start_server] thread did not exit in #{timeout} secs")
-          rescue (defined?(MiniTest::Skip) ? MiniTest::Skip : Test::Unit::PendedError)
-            # MiniTest::Skip is for the Ruby tree
-            pend = $!
-          rescue Exception
-          end
-        }
-        raise pend if pend
-        assert_join_threads(threads)
-      end
-    }
-  end
-end
-
-class OpenSSL::PKeyTestCase < OpenSSL::TestCase
-  def check_component(base, test, keys)
-    keys.each { |comp|
-      assert_equal base.send(comp), test.send(comp)
-    }
-  end
-
-  def dup_public(key)
-    case key
-    when OpenSSL::PKey::RSA
-      rsa = OpenSSL::PKey::RSA.new
-      rsa.set_key(key.n, key.e, nil)
-      rsa
-    when OpenSSL::PKey::DSA
-      dsa = OpenSSL::PKey::DSA.new
-      dsa.set_pqg(key.p, key.q, key.g)
-      dsa.set_key(key.pub_key, nil)
-      dsa
-    when OpenSSL::PKey::DH
-      dh = OpenSSL::PKey::DH.new
-      dh.set_pqg(key.p, nil, key.g)
-      dh
-    else
-      if defined?(OpenSSL::PKey::EC) && OpenSSL::PKey::EC === key
-        ec = OpenSSL::PKey::EC.new(key.group)
-        ec.public_key = key.public_key
-        ec
-      else
-        raise "unknown key type"
-      end
-    end
-  end
-end
-
-module OpenSSL::Certs
-  include OpenSSL::TestUtils
-
-  module_function
-
-  def ca_cert
-    ca = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/CN=Timestamp Root CA")
-
-    ca_exts = [
-      ["basicConstraints","CA:TRUE,pathlen:1",true],
-      ["keyUsage","keyCertSign, cRLSign",true],
-      ["subjectKeyIdentifier","hash",false],
-      ["authorityKeyIdentifier","keyid:always",false],
-    ]
-    OpenSSL::TestUtils.issue_cert(ca, Fixtures.pkey("rsa2048"), 1, ca_exts, nil, nil)
-  end
-
-  def ts_cert_direct(key, ca_cert)
-    dn = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/OU=Timestamp/CN=Server Direct")
-
-    exts = [
-      ["basicConstraints","CA:FALSE",true],
-      ["keyUsage","digitalSignature, nonRepudiation", true],
-      ["subjectKeyIdentifier", "hash",false],
-      ["authorityKeyIdentifier","keyid,issuer", false],
-      ["extendedKeyUsage", "timeStamping", true]
-    ]
-
-    OpenSSL::TestUtils.issue_cert(dn, key, 2, exts, ca_cert, Fixtures.pkey("rsa2048"))
-  end
-
-  def intermediate_cert(key, ca_cert)
-    dn = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/OU=Timestamp/CN=Timestamp Intermediate CA")
-
-    exts = [
-      ["basicConstraints","CA:TRUE,pathlen:0",true],
-      ["keyUsage","keyCertSign, cRLSign",true],
-      ["subjectKeyIdentifier","hash",false],
-      ["authorityKeyIdentifier","keyid:always",false],
-    ]
-
-    OpenSSL::TestUtils.issue_cert(dn, key, 3, exts, ca_cert, Fixtures.pkey("rsa2048"))
-  end
-
-  def ts_cert_ee(key, intermediate, im_key)
-    dn = OpenSSL::X509::Name.parse("/DC=org/DC=ruby-lang/OU=Timestamp/CN=Server End Entity")
-
-    exts = [
-      ["keyUsage","digitalSignature, nonRepudiation", true],
-      ["subjectKeyIdentifier", "hash",false],
-      ["authorityKeyIdentifier","keyid,issuer", false],
-      ["extendedKeyUsage", "timeStamping", true]
-    ]
-
-    OpenSSL::TestUtils.issue_cert(dn, key, 4, exts, intermediate, im_key)
-  end
-end
-
-end
