From: =?utf-8?q?Bastien_Roucari=C3=A8s?= <rouca@debian.org>
Date: Sat, 18 Jan 2025 22:46:46 +0000
Subject: Backport rexml from bullseye

Needed for fixing rexml cve

Backport from 3.1.7.3 to 3.2.3.1

[backport]
- fix test failure by backporting test

[Changelog]
3.2.3 - 2019-10-12 {#version-3-2-3}
Fixes

    Fixed a bug that REXML::XMLDecl#close doesn't copy @writethis. [GitHub#20][Patch by hirura]

Thanks

    hirura

3.2.2 - 2019-06-03 {#version-3-2-2}
Fixes

    xpath: Fixed a bug for equality and relational expressions. [GitHub#17][Reported by Mirko Budszuhn]

    xpath: Fixed boolean() implementation.

    xpath: Fixed local_name() with nonexistent node.

    xpath: Fixed number() implementation with node set. [GitHub#18][Reported by Mirko Budszuhn]

Thanks

    Mirko Budszuhn

3.2.1 - 2019-05-04 {#version-3-2-1}
Improvements

    Improved error message. [GitHub#12][Patch by FUJI Goro]

    Improved error message. [GitHub#16][Patch by ujihisa]

    Improved documentation markup. [GitHub#14][Patch by Alyssa Ross]

Fixes

    Fixed a bug that nil variable value raises an unexpected exception. [GitHub#13][Patch by Alyssa Ross]

Thanks

    FUJI Goro

    Alyssa Ross

    ujihisa

3.2.0 - 2019-01-01 {#version-3-2-0}
Fixes

    Fixed a bug that no namespace attribute isn't matched with prefix.

    [ruby-list:50731][Reported by Yasuhiro KIMURA]

    Fixed a bug that the default namespace is applied to attribute names.

    NOTE: It's a backward incompatible change. If your program has any problem with this change, please report it. We may revert this fix.

        REXML::Attribute#prefix returns "" for no namespace attribute.

        REXML::Attribute#namespace returns "" for no namespace attribute.

Thanks

    Yasuhiro KIMURA

3.1.9 - 2018-12-20 {#version-3-1-9}
Improvements

    Improved backward compatibility.

    Restored REXML::Parsers::BaseParser::UNQME_STR because it's used by kramdown.

3.1.8 - 2018-12-20 {#version-3-1-8}
Improvements

    Added support for customizing quote character in prologue. [GitHub#8][Bug #9367][Reported by Takashi Oguma]

        You can use " as quote character by specifying :quote to REXML::Document#context[:prologue_quote].

        You can use ' as quote character by specifying :apostrophe to REXML::Document#context[:prologue_quote].

    Added processing instruction target check. The target must not nil. [GitHub#7][Reported by Ariel Zelivansky]

    Added name check for element and attribute. [GitHub#7][Reported by Ariel Zelivansky]

    Stopped to use Exception. [GitHub#9][Patch by Jean Boussier]

Fixes

    Fixed a bug that REXML::Text#clone escapes value twice. [ruby-dev:50626][Bug #15058][Reported by Ryosuke Nanba]

Thanks

    Takashi Oguma

    Ariel Zelivansky

    Jean Boussier

    Ryosuke Nanba
---
 lib/rexml/attlistdecl.rb                           |   4 +-
 lib/rexml/attribute.rb                             |  31 +-
 lib/rexml/cdata.rb                                 |   2 +-
 lib/rexml/child.rb                                 |   2 +-
 lib/rexml/comment.rb                               |   2 +-
 lib/rexml/doctype.rb                               |  76 +-
 lib/rexml/document.rb                              |  28 +-
 lib/rexml/dtd/attlistdecl.rb                       |   2 +-
 lib/rexml/dtd/dtd.rb                               |  12 +-
 lib/rexml/dtd/elementdecl.rb                       |   2 +-
 lib/rexml/dtd/entitydecl.rb                        |   2 +-
 lib/rexml/dtd/notationdecl.rb                      |   2 +-
 lib/rexml/element.rb                               |  38 +-
 lib/rexml/entity.rb                                |   8 +-
 lib/rexml/formatters/default.rb                    |  12 +-
 lib/rexml/formatters/pretty.rb                     |   2 +-
 lib/rexml/formatters/transitive.rb                 |   2 +-
 lib/rexml/functions.rb                             | 102 ++-
 lib/rexml/instruction.rb                           |  32 +-
 lib/rexml/light/node.rb                            |   2 +-
 lib/rexml/namespace.rb                             |  25 +-
 lib/rexml/node.rb                                  |   6 +-
 lib/rexml/output.rb                                |   2 +-
 lib/rexml/parent.rb                                |   2 +-
 lib/rexml/parsers/baseparser.rb                    | 355 ++++++--
 lib/rexml/parsers/lightparser.rb                   |   6 +-
 lib/rexml/parsers/pullparser.rb                    |   6 +-
 lib/rexml/parsers/sax2parser.rb                    |   8 +-
 lib/rexml/parsers/streamparser.rb                  |   2 +-
 lib/rexml/parsers/treeparser.rb                    |   4 +-
 lib/rexml/parsers/ultralightparser.rb              |   4 +-
 lib/rexml/parsers/xpathparser.rb                   |  78 +-
 lib/rexml/quickpath.rb                             |   4 +-
 lib/rexml/rexml.gemspec                            |  84 ++
 lib/rexml/rexml.rb                                 |   6 +-
 lib/rexml/source.rb                                |   7 +-
 lib/rexml/text.rb                                  |  66 +-
 lib/rexml/undefinednamespaceexception.rb           |   2 +-
 lib/rexml/validation/relaxng.rb                    |   4 +-
 lib/rexml/validation/validation.rb                 |   2 +-
 lib/rexml/xmldecl.rb                               |  40 +-
 lib/rexml/xpath.rb                                 |  16 +-
 lib/rexml/xpath_parser.rb                          | 980 +++++++++++++--------
 test/rexml/data/t75.xml                            |   2 +-
 test/rexml/formatter/test_default.rb               |  19 +
 test/rexml/functions/test_base.rb                  | 261 ++++++
 test/rexml/functions/test_boolean.rb               |  75 ++
 test/rexml/functions/test_local_name.rb            |  44 +
 test/rexml/functions/test_number.rb                |  38 +
 test/rexml/parse/test_document_type_declaration.rb | 193 +++-
 test/rexml/parse/test_element.rb                   |  77 ++
 test/rexml/parse/test_notation_declaration.rb      | 181 ++++
 test/rexml/parse/test_processing_instruction.rb    |  44 +
 test/rexml/parser/test_tree.rb                     |   2 +-
 test/rexml/parser/test_ultra_light.rb              |   3 +-
 test/rexml/rexml_test_utils.rb                     |   5 +-
 test/rexml/test_attribute.rb                       |  14 +
 test/rexml/test_core.rb                            |  85 +-
 test/rexml/test_doctype.rb                         | 124 ++-
 test/rexml/test_functions.rb                       | 238 -----
 test/rexml/test_functions_number.rb                |  35 -
 test/rexml/test_instruction.rb                     |  14 +
 test/rexml/test_jaxen.rb                           | 189 ++--
 test/rexml/test_martin_fowler.rb                   |   2 +-
 test/rexml/test_stream.rb                          |   4 +-
 test/rexml/test_text.rb                            |  55 +-
 test/rexml/test_xml_declaration.rb                 |  18 +-
 test/rexml/xpath/test_attribute.rb                 |  10 +-
 test/rexml/xpath/test_base.rb                      | 133 +--
 test/rexml/xpath/test_compare.rb                   | 256 ++++++
 70 files changed, 2989 insertions(+), 1204 deletions(-)
 create mode 100644 lib/rexml/rexml.gemspec
 create mode 100644 test/rexml/formatter/test_default.rb
 create mode 100644 test/rexml/functions/test_base.rb
 create mode 100644 test/rexml/functions/test_boolean.rb
 create mode 100644 test/rexml/functions/test_local_name.rb
 create mode 100644 test/rexml/functions/test_number.rb
 create mode 100644 test/rexml/parse/test_element.rb
 create mode 100644 test/rexml/parse/test_processing_instruction.rb
 create mode 100644 test/rexml/test_attribute.rb
 delete mode 100644 test/rexml/test_functions.rb
 delete mode 100644 test/rexml/test_functions_number.rb
 create mode 100644 test/rexml/test_instruction.rb
 create mode 100644 test/rexml/xpath/test_compare.rb

diff --git a/lib/rexml/attlistdecl.rb b/lib/rexml/attlistdecl.rb
index dc1d2ad..44a91d6 100644
--- a/lib/rexml/attlistdecl.rb
+++ b/lib/rexml/attlistdecl.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: false
 #vim:ts=2 sw=2 noexpandtab:
-require 'rexml/child'
-require 'rexml/source'
+require_relative 'child'
+require_relative 'source'
 
 module REXML
   # This class needs:
diff --git a/lib/rexml/attribute.rb b/lib/rexml/attribute.rb
index ca5984e..8933a01 100644
--- a/lib/rexml/attribute.rb
+++ b/lib/rexml/attribute.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: false
-require "rexml/namespace"
-require 'rexml/text'
+require_relative "namespace"
+require_relative 'text'
 
 module REXML
   # Defines an Element Attribute; IE, a attribute=value pair, as in:
@@ -67,15 +67,11 @@ def initialize( first, second=nil, parent=nil )
     #  e.add_attribute( "nsa:a", "aval" )
     #  e.add_attribute( "b", "bval" )
     #  e.attributes.get_attribute( "a" ).prefix   # -> "nsa"
-    #  e.attributes.get_attribute( "b" ).prefix   # -> "elns"
+    #  e.attributes.get_attribute( "b" ).prefix   # -> ""
     #  a = Attribute.new( "x", "y" )
     #  a.prefix                                   # -> ""
     def prefix
-      pf = super
-      if pf == ""
-        pf = @element.prefix if @element
-      end
-      pf
+      super
     end
 
     # Returns the namespace URL, if defined, or nil otherwise
@@ -86,9 +82,26 @@ def prefix
     #  e.add_attribute("nsx:a", "c")
     #  e.attribute("ns:a").namespace # => "http://url"
     #  e.attribute("nsx:a").namespace # => nil
+    #
+    # This method always returns "" for no namespace attribute. Because
+    # the default namespace doesn't apply to attribute names.
+    #
+    # From https://www.w3.org/TR/xml-names/#uniqAttrs
+    #
+    # > the default namespace does not apply to attribute names
+    #
+    #  e = REXML::Element.new("el")
+    #  e.add_namespace("", "http://example.com/")
+    #  e.namespace # => "http://example.com/"
+    #  e.add_attribute("a", "b")
+    #  e.attribute("a").namespace # => ""
     def namespace arg=nil
       arg = prefix if arg.nil?
-      @element.namespace arg
+      if arg == ""
+        ""
+      else
+        @element.namespace(arg)
+      end
     end
 
     # Returns true if other is an Attribute and has the same name and value,
diff --git a/lib/rexml/cdata.rb b/lib/rexml/cdata.rb
index 2238446..997f5a0 100644
--- a/lib/rexml/cdata.rb
+++ b/lib/rexml/cdata.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require "rexml/text"
+require_relative "text"
 
 module REXML
   class CData < Text
diff --git a/lib/rexml/child.rb b/lib/rexml/child.rb
index d23451e..cc6e9a4 100644
--- a/lib/rexml/child.rb
+++ b/lib/rexml/child.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require "rexml/node"
+require_relative "node"
 
 module REXML
   ##
diff --git a/lib/rexml/comment.rb b/lib/rexml/comment.rb
index 822fe0d..52c58b4 100644
--- a/lib/rexml/comment.rb
+++ b/lib/rexml/comment.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require "rexml/child"
+require_relative "child"
 
 module REXML
   ##
diff --git a/lib/rexml/doctype.rb b/lib/rexml/doctype.rb
index 1eb1f5b..a4e9152 100644
--- a/lib/rexml/doctype.rb
+++ b/lib/rexml/doctype.rb
@@ -1,12 +1,50 @@
 # frozen_string_literal: false
-require "rexml/parent"
-require "rexml/parseexception"
-require "rexml/namespace"
-require 'rexml/entity'
-require 'rexml/attlistdecl'
-require 'rexml/xmltokens'
+require_relative "parent"
+require_relative "parseexception"
+require_relative "namespace"
+require_relative 'entity'
+require_relative 'attlistdecl'
+require_relative 'xmltokens'
 
 module REXML
+  class ReferenceWriter
+    def initialize(id_type,
+                   public_id_literal,
+                   system_literal,
+                   context=nil)
+      @id_type = id_type
+      @public_id_literal = public_id_literal
+      @system_literal = system_literal
+      if context and context[:prologue_quote] == :apostrophe
+        @default_quote = "'"
+      else
+        @default_quote = "\""
+      end
+    end
+
+    def write(output)
+      output << " #{@id_type}"
+      if @public_id_literal
+        if @public_id_literal.include?("'")
+          quote = "\""
+        else
+          quote = @default_quote
+        end
+        output << " #{quote}#{@public_id_literal}#{quote}"
+      end
+      if @system_literal
+        if @system_literal.include?("'")
+          quote = "\""
+        elsif @system_literal.include?("\"")
+          quote = "'"
+        else
+          quote = @default_quote
+        end
+        output << " #{quote}#{@system_literal}#{quote}"
+      end
+    end
+  end
+
   # Represents an XML DOCTYPE declaration; that is, the contents of <!DOCTYPE
   # ... >.  DOCTYPES can be used to declare the DTD of a document, as well as
   # being used to declare entities used in the document.
@@ -50,6 +88,8 @@ def initialize( first, parent=nil )
         super( parent )
         @name = first.name
         @external_id = first.external_id
+        @long_name = first.instance_variable_get(:@long_name)
+        @uri = first.instance_variable_get(:@uri)
       elsif first.kind_of? Array
         super( parent )
         @name = first[0]
@@ -112,9 +152,13 @@ def write( output, indent=0, transitive=false, ie_hack=false )
       output << START
       output << ' '
       output << @name
-      output << " #@external_id" if @external_id
-      output << " #{@long_name.inspect}" if @long_name
-      output << " #{@uri.inspect}" if @uri
+      if @external_id
+        reference_writer = ReferenceWriter.new(@external_id,
+                                               @long_name,
+                                               @uri,
+                                               context)
+        reference_writer.write(output)
+      end
       unless @children.empty?
         output << ' ['
         @children.each { |child|
@@ -127,7 +171,11 @@ def write( output, indent=0, transitive=false, ie_hack=false )
     end
 
     def context
-      @parent.context
+      if @parent
+        @parent.context
+      else
+        nil
+      end
     end
 
     def entity( name )
@@ -249,9 +297,11 @@ def initialize name, middle, pub, sys
     end
 
     def to_s
-      notation = "<!NOTATION #{@name} #{@middle}"
-      notation << " #{@public.inspect}" if @public
-      notation << " #{@system.inspect}" if @system
+      context = nil
+      context = parent.context if parent
+      notation = "<!NOTATION #{@name}"
+      reference_writer = ReferenceWriter.new(@middle, @public, @system, context)
+      reference_writer.write(notation)
       notation << ">"
       notation
     end
diff --git a/lib/rexml/document.rb b/lib/rexml/document.rb
index 806bc49..adec293 100644
--- a/lib/rexml/document.rb
+++ b/lib/rexml/document.rb
@@ -1,17 +1,17 @@
 # frozen_string_literal: false
-require "rexml/security"
-require "rexml/element"
-require "rexml/xmldecl"
-require "rexml/source"
-require "rexml/comment"
-require "rexml/doctype"
-require "rexml/instruction"
-require "rexml/rexml"
-require "rexml/parseexception"
-require "rexml/output"
-require "rexml/parsers/baseparser"
-require "rexml/parsers/streamparser"
-require "rexml/parsers/treeparser"
+require_relative "security"
+require_relative "element"
+require_relative "xmldecl"
+require_relative "source"
+require_relative "comment"
+require_relative "doctype"
+require_relative "instruction"
+require_relative "rexml"
+require_relative "parseexception"
+require_relative "output"
+require_relative "parsers/baseparser"
+require_relative "parsers/streamparser"
+require_relative "parsers/treeparser"
 
 module REXML
   # Represents a full XML document, including PIs, a doctype, etc.  A
@@ -226,7 +226,7 @@ def write(*arguments)
       end
       formatter = if indent > -1
           if transitive
-            require "rexml/formatters/transitive"
+            require_relative "formatters/transitive"
             REXML::Formatters::Transitive.new( indent, ie_hack )
           else
             REXML::Formatters::Pretty.new( indent, ie_hack )
diff --git a/lib/rexml/dtd/attlistdecl.rb b/lib/rexml/dtd/attlistdecl.rb
index 32847da..1326cb2 100644
--- a/lib/rexml/dtd/attlistdecl.rb
+++ b/lib/rexml/dtd/attlistdecl.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require "rexml/child"
+require_relative "../child"
 module REXML
   module DTD
     class AttlistDecl < Child
diff --git a/lib/rexml/dtd/dtd.rb b/lib/rexml/dtd/dtd.rb
index 927d5d8..8b0f2d7 100644
--- a/lib/rexml/dtd/dtd.rb
+++ b/lib/rexml/dtd/dtd.rb
@@ -1,10 +1,10 @@
 # frozen_string_literal: false
-require "rexml/dtd/elementdecl"
-require "rexml/dtd/entitydecl"
-require "rexml/comment"
-require "rexml/dtd/notationdecl"
-require "rexml/dtd/attlistdecl"
-require "rexml/parent"
+require_relative "elementdecl"
+require_relative "entitydecl"
+require_relative "../comment"
+require_relative "notationdecl"
+require_relative "attlistdecl"
+require_relative "../parent"
 
 module REXML
   module DTD
diff --git a/lib/rexml/dtd/elementdecl.rb b/lib/rexml/dtd/elementdecl.rb
index 119fd41..20ed023 100644
--- a/lib/rexml/dtd/elementdecl.rb
+++ b/lib/rexml/dtd/elementdecl.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require "rexml/child"
+require_relative "../child"
 module REXML
   module DTD
     class ElementDecl < Child
diff --git a/lib/rexml/dtd/entitydecl.rb b/lib/rexml/dtd/entitydecl.rb
index 45707e2..312df65 100644
--- a/lib/rexml/dtd/entitydecl.rb
+++ b/lib/rexml/dtd/entitydecl.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require "rexml/child"
+require_relative "../child"
 module REXML
   module DTD
     class EntityDecl < Child
diff --git a/lib/rexml/dtd/notationdecl.rb b/lib/rexml/dtd/notationdecl.rb
index cfdf0b9..04a9b08 100644
--- a/lib/rexml/dtd/notationdecl.rb
+++ b/lib/rexml/dtd/notationdecl.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require "rexml/child"
+require_relative "../child"
 module REXML
   module DTD
     class NotationDecl < Child
diff --git a/lib/rexml/element.rb b/lib/rexml/element.rb
index ac9b108..c706a7c 100644
--- a/lib/rexml/element.rb
+++ b/lib/rexml/element.rb
@@ -1,10 +1,10 @@
 # frozen_string_literal: false
-require "rexml/parent"
-require "rexml/namespace"
-require "rexml/attribute"
-require "rexml/cdata"
-require "rexml/xpath"
-require "rexml/parseexception"
+require_relative "parent"
+require_relative "namespace"
+require_relative "attribute"
+require_relative "cdata"
+require_relative "xpath"
+require_relative "parseexception"
 
 module REXML
   # An implementation note about namespaces:
@@ -713,7 +713,7 @@ def write(output=$stdout, indent=-1, transitive=false, ie_hack=false)
       Kernel.warn("#{self.class.name}.write is deprecated.  See REXML::Formatters", uplevel: 1)
       formatter = if indent > -1
           if transitive
-            require "rexml/formatters/transitive"
+            require_relative "formatters/transitive"
             REXML::Formatters::Transitive.new( indent, ie_hack )
           else
             REXML::Formatters::Pretty.new( indent, ie_hack )
@@ -1033,6 +1033,7 @@ def length
     #    p attr.expanded_name+" => "+attr.value
     #  }
     def each_attribute # :yields: attribute
+      return to_enum(__method__) unless block_given?
       each_value do |val|
         if val.kind_of? Attribute
           yield val
@@ -1048,6 +1049,7 @@ def each_attribute # :yields: attribute
     #  doc = Document.new '<a x="1" y="2"/>'
     #  doc.root.attributes.each {|name, value| p name+" => "+value }
     def each
+      return to_enum(__method__) unless block_given?
       each_attribute do |attr|
         yield [attr.expanded_name, attr.value]
       end
@@ -1130,16 +1132,18 @@ def []=( name, value )
         old_attr[value.prefix] = value
       elsif old_attr.prefix != value.prefix
         # Check for conflicting namespaces
-        raise ParseException.new(
-          "Namespace conflict in adding attribute \"#{value.name}\": "+
-          "Prefix \"#{old_attr.prefix}\" = "+
-          "\"#{@element.namespace(old_attr.prefix)}\" and prefix "+
-          "\"#{value.prefix}\" = \"#{@element.namespace(value.prefix)}\"") if
-          value.prefix != "xmlns" and old_attr.prefix != "xmlns" and
-          @element.namespace( old_attr.prefix ) ==
-            @element.namespace( value.prefix )
-          store value.name, { old_attr.prefix   => old_attr,
-            value.prefix                => value }
+        if value.prefix != "xmlns" and old_attr.prefix != "xmlns"
+          old_namespace = old_attr.namespace
+          new_namespace = value.namespace
+          if old_namespace == new_namespace
+            raise ParseException.new(
+                    "Namespace conflict in adding attribute \"#{value.name}\": "+
+                    "Prefix \"#{old_attr.prefix}\" = \"#{old_namespace}\" and "+
+                    "prefix \"#{value.prefix}\" = \"#{new_namespace}\"")
+          end
+        end
+        store value.name, {old_attr.prefix => old_attr,
+                           value.prefix    => value}
       else
         store value.name, value
       end
diff --git a/lib/rexml/entity.rb b/lib/rexml/entity.rb
index 97c7b6b..89a9e84 100644
--- a/lib/rexml/entity.rb
+++ b/lib/rexml/entity.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: false
-require 'rexml/child'
-require 'rexml/source'
-require 'rexml/xmltokens'
+require_relative 'child'
+require_relative 'source'
+require_relative 'xmltokens'
 
 module REXML
   class Entity < Child
@@ -90,7 +90,7 @@ def normalized
     # object itself is valid.)
     #
     # out::
-    #   An object implementing <TT>&lt;&lt;<TT> to which the entity will be
+    #   An object implementing <TT>&lt;&lt;</TT> to which the entity will be
     #   output
     # indent::
     #   *DEPRECATED* and ignored
diff --git a/lib/rexml/formatters/default.rb b/lib/rexml/formatters/default.rb
index c375f14..811b2ff 100644
--- a/lib/rexml/formatters/default.rb
+++ b/lib/rexml/formatters/default.rb
@@ -1,4 +1,5 @@
 # frozen_string_literal: false
+
 module REXML
   module Formatters
     class Default
@@ -101,11 +102,14 @@ def write_cdata( node, output )
       end
 
       def write_instruction( node, output )
-        output << Instruction::START.sub(/\\/u, '')
+        output << Instruction::START
         output << node.target
-        output << ' '
-        output << node.content
-        output << Instruction::STOP.sub(/\\/u, '')
+        content = node.content
+        if content
+          output << ' '
+          output << content
+        end
+        output << Instruction::STOP
       end
     end
   end
diff --git a/lib/rexml/formatters/pretty.rb b/lib/rexml/formatters/pretty.rb
index a80274b..562ef94 100644
--- a/lib/rexml/formatters/pretty.rb
+++ b/lib/rexml/formatters/pretty.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require 'rexml/formatters/default'
+require_relative 'default'
 
 module REXML
   module Formatters
diff --git a/lib/rexml/formatters/transitive.rb b/lib/rexml/formatters/transitive.rb
index 81e67f3..5ff51e1 100644
--- a/lib/rexml/formatters/transitive.rb
+++ b/lib/rexml/formatters/transitive.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require 'rexml/formatters/pretty'
+require_relative 'pretty'
 
 module REXML
   module Formatters
diff --git a/lib/rexml/functions.rb b/lib/rexml/functions.rb
index cd879fd..77926bf 100644
--- a/lib/rexml/functions.rb
+++ b/lib/rexml/functions.rb
@@ -66,11 +66,11 @@ def Functions::count( node_set )
     def Functions::id( object )
     end
 
-    # UNTESTED
-    def Functions::local_name( node_set=nil )
-      get_namespace( node_set ) do |node|
+    def Functions::local_name(node_set=nil)
+      get_namespace(node_set) do |node|
         return node.local_name
       end
+      ""
     end
 
     def Functions::namespace_uri( node_set=nil )
@@ -86,10 +86,14 @@ def Functions::name( node_set=nil )
     # Helper method.
     def Functions::get_namespace( node_set = nil )
       if node_set == nil
-        yield @@context[:node] if defined? @@context[:node].namespace
+        yield @@context[:node] if @@context[:node].respond_to?(:namespace)
       else
         if node_set.respond_to? :each
-          node_set.each { |node| yield node if defined? node.namespace }
+          result = []
+          node_set.each do |node|
+            result << yield(node) if node.respond_to?(:namespace)
+          end
+          result
         elsif node_set.respond_to? :namespace
           yield node_set
         end
@@ -131,22 +135,38 @@ def Functions::get_namespace( node_set = nil )
     #
     # An object of a type other than the four basic types is converted to a
     # string in a way that is dependent on that type.
-    def Functions::string( object=nil )
-      #object = @context unless object
-      if object.instance_of? Array
-        string( object[0] )
-      elsif defined? object.node_type
-        if object.node_type == :attribute
+    def Functions::string( object=@@context[:node] )
+      if object.respond_to?(:node_type)
+        case object.node_type
+        when :attribute
           object.value
-        elsif object.node_type == :element || object.node_type == :document
+        when :element
           string_value(object)
+        when :document
+          string_value(object.root)
+        when :processing_instruction
+          object.content
         else
           object.to_s
         end
-      elsif object.nil?
-        return ""
       else
-        object.to_s
+        case object
+        when Array
+          string(object[0])
+        when Float
+          if object.nan?
+            "NaN"
+          else
+            integer = object.to_i
+            if object == integer
+              "%d" % integer
+            else
+              object.to_s
+            end
+          end
+        else
+          object.to_s
+        end
       end
     end
 
@@ -167,9 +187,12 @@ def Functions::string_value( o )
       rv
     end
 
-    # UNTESTED
     def Functions::concat( *objects )
-      objects.join
+      concatenated = ""
+      objects.each do |object|
+        concatenated << string(object)
+      end
+      concatenated
     end
 
     # Fixed by Mike Stok
@@ -292,18 +315,23 @@ def Functions::translate( string, tr1, tr2 )
       end
     end
 
-    # UNTESTED
-    def Functions::boolean( object=nil )
-      if object.kind_of? String
-        if object =~ /\d+/u
-          return object.to_f != 0
-        else
-          return object.size > 0
-        end
-      elsif object.kind_of? Array
-        object = object.find{|x| x and true}
+    def Functions::boolean(object=@@context[:node])
+      case object
+      when true, false
+        object
+      when Float
+        return false if object.zero?
+        return false if object.nan?
+        true
+      when Numeric
+        not object.zero?
+      when String
+        not object.empty?
+      when Array
+        not object.empty?
+      else
+        object ? true : false
       end
-      return object ? true : false
     end
 
     # UNTESTED
@@ -357,25 +385,23 @@ def Functions::compare_language lang1, lang2
     #
     # an object of a type other than the four basic types is converted to a
     # number in a way that is dependent on that type
-    def Functions::number( object=nil )
-      object = @@context[:node] unless object
+    def Functions::number(object=@@context[:node])
       case object
       when true
         Float(1)
       when false
         Float(0)
       when Array
-        number(string( object ))
+        number(string(object))
       when Numeric
         object.to_f
       else
-        str = string( object )
-        # If XPath ever gets scientific notation...
-        #if str =~ /^\s*-?(\d*\.?\d+|\d+\.)([Ee]\d*)?\s*$/
-        if str =~ /^\s*-?(\d*\.?\d+|\d+\.)\s*$/
-          str.to_f
+        str = string(object)
+        case str.strip
+        when /\A\s*(-?(?:\d+(?:\.\d*)?|\.\d+))\s*\z/
+          $1.to_f
         else
-          (0.0 / 0.0)
+          Float::NAN
         end
       end
     end
@@ -397,7 +423,7 @@ def Functions::round( number )
       number = number(number)
       begin
         neg = number.negative?
-        number = number.abs.round(half: :up)
+        number = number.abs.round
         neg ? -number : number
       rescue FloatDomainError
         number
diff --git a/lib/rexml/instruction.rb b/lib/rexml/instruction.rb
index c4f65ee..318741f 100644
--- a/lib/rexml/instruction.rb
+++ b/lib/rexml/instruction.rb
@@ -1,13 +1,14 @@
 # frozen_string_literal: false
-require "rexml/child"
-require "rexml/source"
+
+require_relative "child"
+require_relative "source"
 
 module REXML
   # Represents an XML Instruction; IE, <? ... ?>
   # TODO: Add parent arg (3rd arg) to constructor
   class Instruction < Child
-    START = '<\?'
-    STOP = '\?>'
+    START = "<?"
+    STOP = "?>"
 
     # target is the "name" of the Instruction; IE, the "tag" in <?tag ...?>
     # content is everything else.
@@ -17,20 +18,25 @@ class Instruction < Child
     # @param target can be one of a number of things.  If String, then
     # the target of this instruction is set to this.  If an Instruction,
     # then the Instruction is shallowly cloned (target and content are
-    # copied).  If a Source, then the source is scanned and parsed for
-    # an Instruction declaration.
+    # copied).
     # @param content Must be either a String, or a Parent.  Can only
     # be a Parent if the target argument is a Source.  Otherwise, this
     # String is set as the content of this instruction.
     def initialize(target, content=nil)
-      if target.kind_of? String
+      case target
+      when String
         super()
         @target = target
         @content = content
-      elsif target.kind_of? Instruction
+      when Instruction
         super(content)
         @target = target.target
         @content = target.content
+      else
+        message =
+          "processing instruction target must be String or REXML::Instruction: "
+        message << "<#{target.inspect}>"
+        raise ArgumentError, message
       end
       @content.strip! if @content
     end
@@ -45,11 +51,13 @@ def clone
     def write writer, indent=-1, transitive=false, ie_hack=false
       Kernel.warn( "#{self.class.name}.write is deprecated", uplevel: 1)
       indent(writer, indent)
-      writer << START.sub(/\\/u, '')
+      writer << START
       writer << @target
-      writer << ' '
-      writer << @content
-      writer << STOP.sub(/\\/u, '')
+      if @content
+        writer << ' '
+        writer << @content
+      end
+      writer << STOP
     end
 
     # @return true if other is an Instruction, and the content and target
diff --git a/lib/rexml/light/node.rb b/lib/rexml/light/node.rb
index d58119a..01177c6 100644
--- a/lib/rexml/light/node.rb
+++ b/lib/rexml/light/node.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require 'rexml/xmltokens'
+require_relative '../xmltokens'
 
 # [ :element, parent, name, attributes, children* ]
   # a = Node.new
diff --git a/lib/rexml/namespace.rb b/lib/rexml/namespace.rb
index 90ba7cc..924edf9 100644
--- a/lib/rexml/namespace.rb
+++ b/lib/rexml/namespace.rb
@@ -1,5 +1,6 @@
 # frozen_string_literal: false
-require 'rexml/xmltokens'
+
+require_relative 'xmltokens'
 
 module REXML
   # Adds named attributes to an object.
@@ -14,14 +15,24 @@ module Namespace
     # Sets the name and the expanded name
     def name=( name )
       @expanded_name = name
-      name =~ NAMESPLIT
-      if $1
-        @prefix = $1
+      case name
+      when NAMESPLIT
+        if $1
+          @prefix = $1
+        else
+          @prefix = ""
+          @namespace = ""
+        end
+        @name = $2
+      when ""
+        @prefix = nil
+        @namespace = nil
+        @name = nil
       else
-        @prefix = ""
-        @namespace = ""
+        message = "name must be \#{PREFIX}:\#{LOCAL_NAME} or \#{LOCAL_NAME}: "
+        message += "<#{name.inspect}>"
+        raise ArgumentError, message
       end
-      @name = $2
     end
 
     # Compares names optionally WITH namespaces
diff --git a/lib/rexml/node.rb b/lib/rexml/node.rb
index 52337ad..081caba 100644
--- a/lib/rexml/node.rb
+++ b/lib/rexml/node.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: false
-require "rexml/parseexception"
-require "rexml/formatters/pretty"
-require "rexml/formatters/default"
+require_relative "parseexception"
+require_relative "formatters/pretty"
+require_relative "formatters/default"
 
 module REXML
   # Represents a node in the tree.  Nodes are never encountered except as
diff --git a/lib/rexml/output.rb b/lib/rexml/output.rb
index 96dfea5..88a5fb3 100644
--- a/lib/rexml/output.rb
+++ b/lib/rexml/output.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require 'rexml/encoding'
+require_relative 'encoding'
 
 module REXML
   class Output
diff --git a/lib/rexml/parent.rb b/lib/rexml/parent.rb
index 3bd0a96..6a53b37 100644
--- a/lib/rexml/parent.rb
+++ b/lib/rexml/parent.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require "rexml/child"
+require_relative "child"
 
 module REXML
   # A parent has children, and has methods for accessing them.  The Parent
diff --git a/lib/rexml/parsers/baseparser.rb b/lib/rexml/parsers/baseparser.rb
index 80eeb0f..305b120 100644
--- a/lib/rexml/parsers/baseparser.rb
+++ b/lib/rexml/parsers/baseparser.rb
@@ -1,8 +1,9 @@
 # frozen_string_literal: false
-require 'rexml/parseexception'
-require 'rexml/undefinednamespaceexception'
-require 'rexml/source'
+require_relative '../parseexception'
+require_relative '../undefinednamespaceexception'
+require_relative '../source'
 require 'set'
+require "strscan"
 
 module REXML
   module Parsers
@@ -32,8 +33,12 @@ class BaseParser
       COMBININGCHAR = '' # TODO
       EXTENDER = ''      # TODO
 
-      NCNAME_STR= "[#{LETTER}_:][-[:alnum:]._:#{COMBININGCHAR}#{EXTENDER}]*"
-      NAME_STR= "(?:(#{NCNAME_STR}):)?(#{NCNAME_STR})"
+      NCNAME_STR= "[#{LETTER}_][-[:alnum:]._#{COMBININGCHAR}#{EXTENDER}]*"
+      QNAME_STR= "(?:(#{NCNAME_STR}):)?(#{NCNAME_STR})"
+      QNAME = /(#{QNAME_STR})/
+
+      # Just for backward compatibility. For example, kramdown uses this.
+      # It's not used in REXML.
       UNAME_STR= "(?:#{NCNAME_STR}:)?#{NCNAME_STR}"
 
       NAMECHAR = '[\-\w\.:]'
@@ -45,8 +50,7 @@ class BaseParser
 
       DOCTYPE_START = /\A\s*<!DOCTYPE\s/um
       DOCTYPE_END = /\A\s*\]\s*>/um
-      DOCTYPE_PATTERN = /\s*<!DOCTYPE\s+(.*?)(\[|>)/um
-      ATTRIBUTE_PATTERN = /\s*(#{NAME_STR})\s*=\s*(["'])(.*?)\4/um
+      ATTRIBUTE_PATTERN = /\s*(#{QNAME_STR})\s*=\s*(["'])(.*?)\4/um
       COMMENT_START = /\A<!--/u
       COMMENT_PATTERN = /<!--(.*?)-->/um
       CDATA_START = /\A<!\[CDATA\[/u
@@ -55,16 +59,15 @@ class BaseParser
       XMLDECL_START = /\A<\?xml\s/u;
       XMLDECL_PATTERN = /<\?xml\s+(.*?)\?>/um
       INSTRUCTION_START = /\A<\?/u
-      INSTRUCTION_PATTERN = /<\?(.*?)(\s+.*?)?\?>/um
-      TAG_MATCH = /^<((?>#{NAME_STR}))\s*((?>\s+#{UNAME_STR}\s*=\s*(["']).*?\5)*)\s*(\/)?>/um
-      CLOSE_MATCH = /^\s*<\/(#{NAME_STR})\s*>/um
+      INSTRUCTION_PATTERN = /<\?#{NAME}(\s+.*?)?\?>/um
+      TAG_MATCH = /\A<((?>#{QNAME_STR}))/um
+      CLOSE_MATCH = /\A\s*<\/(#{QNAME_STR})\s*>/um
 
       VERSION = /\bversion\s*=\s*["'](.*?)['"]/um
       ENCODING = /\bencoding\s*=\s*["'](.*?)['"]/um
       STANDALONE = /\bstandalone\s*=\s*["'](.*?)['"]/um
 
       ENTITY_START = /\A\s*<!ENTITY/
-      IDENTITY = /^([!\*\w\-]+)(\s+#{NCNAME_STR})?(\s+["'](.*?)['"])?(\s+['"](.*?)["'])?/u
       ELEMENTDECL_START = /\A\s*<!ELEMENT/um
       ELEMENTDECL_PATTERN = /\A\s*(<!ELEMENT.*?)>/um
       SYSTEMENTITY = /\A\s*(%.*?;)\s*$/um
@@ -78,9 +81,6 @@ class BaseParser
       ATTDEF_RE = /#{ATTDEF}/
       ATTLISTDECL_START = /\A\s*<!ATTLIST/um
       ATTLISTDECL_PATTERN = /\A\s*<!ATTLIST\s+#{NAME}(?:#{ATTDEF})*\s*>/um
-      NOTATIONDECL_START = /\A\s*<!NOTATION/um
-      PUBLIC = /\A\s*<!NOTATION\s+(\w[\-\w]*)\s+(PUBLIC)\s+(["'])(.*?)\3(?:\s+(["'])(.*?)\5)?\s*>/um
-      SYSTEM = /\A\s*<!NOTATION\s+(\w[\-\w]*)\s+(SYSTEM)\s+(["'])(.*?)\3\s*>/um
 
       TEXT_PATTERN = /\A([^<]*)/um
 
@@ -98,6 +98,11 @@ class BaseParser
       GEDECL = "<!ENTITY\\s+#{NAME}\\s+#{ENTITYDEF}\\s*>"
       ENTITYDECL = /\s*(?:#{GEDECL})|(?:#{PEDECL})/um
 
+      NOTATIONDECL_START = /\A\s*<!NOTATION/um
+      EXTERNAL_ID_PUBLIC = /\A\s*PUBLIC\s+#{PUBIDLITERAL}\s+#{SYSTEMLITERAL}\s*/um
+      EXTERNAL_ID_SYSTEM = /\A\s*SYSTEM\s+#{SYSTEMLITERAL}\s*/um
+      PUBLIC_ID = /\A\s*PUBLIC\s+#{PUBIDLITERAL}\s*/um
+
       EREFERENCE = /&(?!#{NAME};)/
 
       DEFAULT_ENTITIES = {
@@ -107,13 +112,6 @@ class BaseParser
         "apos" => [/&apos;/, "&apos;", "'", /'/]
       }
 
-
-      ######################################################################
-      # These are patterns to identify common markup errors, to make the
-      # error messages more informative.
-      ######################################################################
-      MISSING_ATTRIBUTE_QUOTES = /^<#{NAME_STR}\s+#{NAME_STR}\s*=\s*[^"']/um
-
       def initialize( source )
         self.stream = source
         @listeners = []
@@ -197,11 +195,9 @@ def pull_event
         return [ :end_document ] if empty?
         return @stack.shift if @stack.size > 0
         #STDERR.puts @source.encoding
-        @source.read if @source.buffer.size<2
         #STDERR.puts "BUFFER = #{@source.buffer.inspect}"
         if @document_status == nil
-          #@source.consume( /^\s*/um )
-          word = @source.match( /^((?:\s+)|(?:<[^>]*>))/um )
+          word = @source.match( /\A((?:\s+)|(?:<[^>]*>))/um )
           word = word[1] unless word.nil?
           #STDERR.puts "WORD = #{word.inspect}"
           case word
@@ -224,40 +220,51 @@ def pull_event
             standalone = standalone[1] unless standalone.nil?
             return [ :xmldecl, version, encoding, standalone ]
           when INSTRUCTION_START
-            return [ :processing_instruction, *@source.match(INSTRUCTION_PATTERN, true)[1,2] ]
+            return process_instruction
           when DOCTYPE_START
-            md = @source.match( DOCTYPE_PATTERN, true )
+            base_error_message = "Malformed DOCTYPE"
+            @source.match(DOCTYPE_START, true)
             @nsstack.unshift(curr_ns=Set.new)
-            identity = md[1]
-            close = md[2]
-            identity =~ IDENTITY
-            name = $1
-            raise REXML::ParseException.new("DOCTYPE is missing a name") if name.nil?
-            pub_sys = $2.nil? ? nil : $2.strip
-            long_name = $4.nil? ? nil : $4.strip
-            uri = $6.nil? ? nil : $6.strip
-            args = [ :start_doctype, name, pub_sys, long_name, uri ]
-            if close == ">"
+            name = parse_name(base_error_message)
+            if @source.match(/\A\s*\[/um, true)
+              id = [nil, nil, nil]
+              @document_status = :in_doctype
+            elsif @source.match(/\A\s*>/um, true)
+              id = [nil, nil, nil]
               @document_status = :after_doctype
-              @source.read if @source.buffer.size<2
-              md = @source.match(/^\s*/um, true)
-              @stack << [ :end_doctype ]
             else
-              @document_status = :in_doctype
+              id = parse_id(base_error_message,
+                            accept_external_id: true,
+                            accept_public_id: false)
+              if id[0] == "SYSTEM"
+                # For backward compatibility
+                id[1], id[2] = id[2], nil
+              end
+              if @source.match(/\A\s*\[/um, true)
+                @document_status = :in_doctype
+              elsif @source.match(/\A\s*>/um, true)
+                @document_status = :after_doctype
+              else
+                message = "#{base_error_message}: garbage after external ID"
+                raise REXML::ParseException.new(message, @source)
+              end
+            end
+            args = [:start_doctype, name, *id]
+            if @document_status == :after_doctype
+              @source.match(/\A\s*/um, true)
+              @stack << [ :end_doctype ]
             end
             return args
-          when /^\s+/
+          when /\A\s+/
           else
             @document_status = :after_doctype
-            @source.read if @source.buffer.size<2
-            md = @source.match(/\s*/um, true)
             if @source.encoding == "UTF-8"
               @source.buffer.force_encoding(::Encoding::UTF_8)
             end
           end
         end
         if @document_status == :in_doctype
-          md = @source.match(/\s*(.*?>)/um)
+          md = @source.match(/\A\s*(.*?>)/um)
           case md[1]
           when SYSTEMENTITY
             match = @source.match( SYSTEMENTITY, true )[1]
@@ -314,33 +321,49 @@ def pull_event
             end
             return [ :attlistdecl, element, pairs, contents ]
           when NOTATIONDECL_START
-            md = nil
-            if @source.match( PUBLIC )
-              md = @source.match( PUBLIC, true )
-              vals = [md[1],md[2],md[4],md[6]]
-            elsif @source.match( SYSTEM )
-              md = @source.match( SYSTEM, true )
-              vals = [md[1],md[2],nil,md[4]]
-            else
-              raise REXML::ParseException.new( "error parsing notation: no matching pattern", @source )
+            base_error_message = "Malformed notation declaration"
+            unless @source.match(/\A\s*<!NOTATION\s+/um, true)
+              if @source.match(/\A\s*<!NOTATION\s*>/um)
+                message = "#{base_error_message}: name is missing"
+              else
+                message = "#{base_error_message}: invalid declaration name"
+              end
+              raise REXML::ParseException.new(message, @source)
+            end
+            name = parse_name(base_error_message)
+            id = parse_id(base_error_message,
+                          accept_external_id: true,
+                          accept_public_id: true)
+            unless @source.match(/\A\s*>/um, true)
+              message = "#{base_error_message}: garbage before end >"
+              raise REXML::ParseException.new(message, @source)
             end
-            return [ :notationdecl, *vals ]
+            return [:notationdecl, name, *id]
           when DOCTYPE_END
             @document_status = :after_doctype
             @source.match( DOCTYPE_END, true )
             return [ :end_doctype ]
           end
         end
+        if @document_status == :after_doctype
+          @source.match(/\A\s*/um, true)
+        end
         begin
+          @source.read if @source.buffer.size<2
           if @source.buffer[0] == ?<
             if @source.buffer[1] == ?/
               @nsstack.shift
               last_tag = @tags.pop
-              #md = @source.match_to_consume( '>', CLOSE_MATCH)
               md = @source.match( CLOSE_MATCH, true )
-              raise REXML::ParseException.new( "Missing end tag for "+
-                "'#{last_tag}' (got \"#{md[1]}\")",
-                @source) unless last_tag == md[1]
+              if md and !last_tag
+                message = "Unexpected top-level end tag (got '#{md[1]}')"
+                raise REXML::ParseException.new(message, @source)
+              end
+              if md.nil? or last_tag != md[1]
+                message = "Missing end tag for '#{last_tag}'"
+                message << " (got '#{md[1]}')" if md
+                raise REXML::ParseException.new(message, @source)
+              end
               return [ :end_element, last_tag ]
             elsif @source.buffer[1] == ?!
               md = @source.match(/\A(\s*[^>]*>)/um)
@@ -362,52 +385,18 @@ def pull_event
               raise REXML::ParseException.new( "Declarations can only occur "+
                 "in the doctype declaration.", @source)
             elsif @source.buffer[1] == ??
-              md = @source.match( INSTRUCTION_PATTERN, true )
-              return [ :processing_instruction, md[1], md[2] ] if md
-              raise REXML::ParseException.new( "Bad instruction declaration",
-                @source)
+              return process_instruction
             else
               # Get the next tag
               md = @source.match(TAG_MATCH, true)
               unless md
-                # Check for missing attribute quotes
-                raise REXML::ParseException.new("missing attribute quote", @source) if @source.match(MISSING_ATTRIBUTE_QUOTES )
                 raise REXML::ParseException.new("malformed XML: missing tag start", @source)
               end
-              attributes = {}
+              @document_status = :in_element
               prefixes = Set.new
               prefixes << md[2] if md[2]
               @nsstack.unshift(curr_ns=Set.new)
-              if md[4].size > 0
-                attrs = md[4].scan( ATTRIBUTE_PATTERN )
-                raise REXML::ParseException.new( "error parsing attributes: [#{attrs.join ', '}], excess = \"#$'\"", @source) if $' and $'.strip.size > 0
-                attrs.each do |attr_name, prefix, local_part, quote, value|
-                  if prefix == "xmlns"
-                    if local_part == "xml"
-                      if value != "http://www.w3.org/XML/1998/namespace"
-                        msg = "The 'xml' prefix must not be bound to any other namespace "+
-                        "(http://www.w3.org/TR/REC-xml-names/#ns-decl)"
-                        raise REXML::ParseException.new( msg, @source, self )
-                      end
-                    elsif local_part == "xmlns"
-                      msg = "The 'xmlns' prefix must not be declared "+
-                      "(http://www.w3.org/TR/REC-xml-names/#ns-decl)"
-                      raise REXML::ParseException.new( msg, @source, self)
-                    end
-                    curr_ns << local_part
-                  elsif prefix
-                    prefixes << prefix unless prefix == "xml"
-                  end
-
-                  if attributes.has_key?(attr_name)
-                    msg = "Duplicate attribute #{attr_name.inspect}"
-                    raise REXML::ParseException.new(msg, @source, self)
-                  end
-
-                  attributes[attr_name] = value
-                end
-              end
-
+              attributes, closed = parse_attributes(prefixes, curr_ns)
               # Verify that all of the prefixes have been defined
               for prefix in prefixes
                 unless @nsstack.find{|k| k.member?(prefix)}
@@ -415,7 +404,7 @@ def pull_event
                 end
               end
 
-              if md[6]
+              if closed
                 @closed = md[1]
                 @nsstack.shift
               else
@@ -438,7 +427,7 @@ def pull_event
           raise
         rescue REXML::ParseException
           raise
-        rescue Exception, NameError => error
+        rescue => error
           raise REXML::ParseException.new( "Exception parsing",
             @source, self, (error ? error : $!) )
         end
@@ -508,6 +497,178 @@ def need_source_encoding_update?(xml_declaration_encoding)
         return false if /\AUTF-16\z/i =~ xml_declaration_encoding
         true
       end
+
+      def parse_name(base_error_message)
+        md = @source.match(/\A\s*#{NAME}/um, true)
+        unless md
+          if @source.match(/\A\s*\S/um)
+            message = "#{base_error_message}: invalid name"
+          else
+            message = "#{base_error_message}: name is missing"
+          end
+          raise REXML::ParseException.new(message, @source)
+        end
+        md[1]
+      end
+
+      def parse_id(base_error_message,
+                   accept_external_id:,
+                   accept_public_id:)
+        if accept_external_id and (md = @source.match(EXTERNAL_ID_PUBLIC, true))
+          pubid = system = nil
+          pubid_literal = md[1]
+          pubid = pubid_literal[1..-2] if pubid_literal # Remove quote
+          system_literal = md[2]
+          system = system_literal[1..-2] if system_literal # Remove quote
+          ["PUBLIC", pubid, system]
+        elsif accept_public_id and (md = @source.match(PUBLIC_ID, true))
+          pubid = system = nil
+          pubid_literal = md[1]
+          pubid = pubid_literal[1..-2] if pubid_literal # Remove quote
+          ["PUBLIC", pubid, nil]
+        elsif accept_external_id and (md = @source.match(EXTERNAL_ID_SYSTEM, true))
+          system = nil
+          system_literal = md[1]
+          system = system_literal[1..-2] if system_literal # Remove quote
+          ["SYSTEM", nil, system]
+        else
+          details = parse_id_invalid_details(accept_external_id: accept_external_id,
+                                             accept_public_id: accept_public_id)
+          message = "#{base_error_message}: #{details}"
+          raise REXML::ParseException.new(message, @source)
+        end
+      end
+
+      def parse_id_invalid_details(accept_external_id:,
+                                   accept_public_id:)
+        public = /\A\s*PUBLIC/um
+        system = /\A\s*SYSTEM/um
+        if (accept_external_id or accept_public_id) and @source.match(/#{public}/um)
+          if @source.match(/#{public}(?:\s+[^'"]|\s*[\[>])/um)
+            return "public ID literal is missing"
+          end
+          unless @source.match(/#{public}\s+#{PUBIDLITERAL}/um)
+            return "invalid public ID literal"
+          end
+          if accept_public_id
+            if @source.match(/#{public}\s+#{PUBIDLITERAL}\s+[^'"]/um)
+              return "system ID literal is missing"
+            end
+            unless @source.match(/#{public}\s+#{PUBIDLITERAL}\s+#{SYSTEMLITERAL}/um)
+              return "invalid system literal"
+            end
+            "garbage after system literal"
+          else
+            "garbage after public ID literal"
+          end
+        elsif accept_external_id and @source.match(/#{system}/um)
+          if @source.match(/#{system}(?:\s+[^'"]|\s*[\[>])/um)
+            return "system literal is missing"
+          end
+          unless @source.match(/#{system}\s+#{SYSTEMLITERAL}/um)
+            return "invalid system literal"
+          end
+          "garbage after system literal"
+        else
+          unless @source.match(/\A\s*(?:PUBLIC|SYSTEM)\s/um)
+            return "invalid ID type"
+          end
+          "ID type is missing"
+        end
+      end
+
+      def process_instruction
+        match_data = @source.match(INSTRUCTION_PATTERN, true)
+        unless match_data
+          message = "Invalid processing instruction node"
+          raise REXML::ParseException.new(message, @source)
+        end
+        [:processing_instruction, match_data[1], match_data[2]]
+      end
+
+      def parse_attributes(prefixes, curr_ns)
+        attributes = {}
+        closed = false
+        match_data = @source.match(/^(.*?)(\/)?>/um, true)
+        if match_data.nil?
+          message = "Start tag isn't ended"
+          raise REXML::ParseException.new(message, @source)
+        end
+
+        raw_attributes = match_data[1]
+        closed = !match_data[2].nil?
+        return attributes, closed if raw_attributes.nil?
+        return attributes, closed if raw_attributes.empty?
+
+        scanner = StringScanner.new(raw_attributes)
+        until scanner.eos?
+          if scanner.scan(/\s+/)
+            break if scanner.eos?
+          end
+
+          pos = scanner.pos
+          loop do
+            break if scanner.scan(ATTRIBUTE_PATTERN)
+            unless scanner.scan(QNAME)
+              message = "Invalid attribute name: <#{scanner.rest}>"
+              raise REXML::ParseException.new(message, @source)
+            end
+            name = scanner[0]
+            unless scanner.scan(/\s*=\s*/um)
+              message = "Missing attribute equal: <#{name}>"
+              raise REXML::ParseException.new(message, @source)
+            end
+            quote = scanner.scan(/['"]/)
+            unless quote
+              message = "Missing attribute value start quote: <#{name}>"
+              raise REXML::ParseException.new(message, @source)
+            end
+            unless scanner.scan(/.*#{Regexp.escape(quote)}/um)
+              match_data = @source.match(/^(.*?)(\/)?>/um, true)
+              if match_data
+                scanner << "/" if closed
+                scanner << ">"
+                scanner << match_data[1]
+                scanner.pos = pos
+                closed = !match_data[2].nil?
+                next
+              end
+              message =
+                "Missing attribute value end quote: <#{name}>: <#{quote}>"
+              raise REXML::ParseException.new(message, @source)
+            end
+          end
+          name = scanner[1]
+          prefix = scanner[2]
+          local_part = scanner[3]
+          # quote = scanner[4]
+          value = scanner[5]
+          if prefix == "xmlns"
+            if local_part == "xml"
+              if value != "http://www.w3.org/XML/1998/namespace"
+                msg = "The 'xml' prefix must not be bound to any other namespace "+
+                  "(http://www.w3.org/TR/REC-xml-names/#ns-decl)"
+                raise REXML::ParseException.new( msg, @source, self )
+              end
+            elsif local_part == "xmlns"
+              msg = "The 'xmlns' prefix must not be declared "+
+                "(http://www.w3.org/TR/REC-xml-names/#ns-decl)"
+              raise REXML::ParseException.new( msg, @source, self)
+            end
+            curr_ns << local_part
+          elsif prefix
+            prefixes << prefix unless prefix == "xml"
+          end
+
+          if attributes.has_key?(name)
+            msg = "Duplicate attribute #{name.inspect}"
+            raise REXML::ParseException.new(msg, @source, self)
+          end
+
+          attributes[name] = value
+        end
+        return attributes, closed
+      end
     end
   end
 end
diff --git a/lib/rexml/parsers/lightparser.rb b/lib/rexml/parsers/lightparser.rb
index f0601ae..bdc0827 100644
--- a/lib/rexml/parsers/lightparser.rb
+++ b/lib/rexml/parsers/lightparser.rb
@@ -1,7 +1,7 @@
 # frozen_string_literal: false
-require 'rexml/parsers/streamparser'
-require 'rexml/parsers/baseparser'
-require 'rexml/light/node'
+require_relative 'streamparser'
+require_relative 'baseparser'
+require_relative '../light/node'
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/pullparser.rb b/lib/rexml/parsers/pullparser.rb
index 8c49217..f8b232a 100644
--- a/lib/rexml/parsers/pullparser.rb
+++ b/lib/rexml/parsers/pullparser.rb
@@ -1,9 +1,9 @@
 # frozen_string_literal: false
 require 'forwardable'
 
-require 'rexml/parseexception'
-require 'rexml/parsers/baseparser'
-require 'rexml/xmltokens'
+require_relative '../parseexception'
+require_relative 'baseparser'
+require_relative '../xmltokens'
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/sax2parser.rb b/lib/rexml/parsers/sax2parser.rb
index 1386f69..6a24ce2 100644
--- a/lib/rexml/parsers/sax2parser.rb
+++ b/lib/rexml/parsers/sax2parser.rb
@@ -1,8 +1,8 @@
 # frozen_string_literal: false
-require 'rexml/parsers/baseparser'
-require 'rexml/parseexception'
-require 'rexml/namespace'
-require 'rexml/text'
+require_relative 'baseparser'
+require_relative '../parseexception'
+require_relative '../namespace'
+require_relative '../text'
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/streamparser.rb b/lib/rexml/parsers/streamparser.rb
index f6a8bfa..9e0eb0b 100644
--- a/lib/rexml/parsers/streamparser.rb
+++ b/lib/rexml/parsers/streamparser.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require "rexml/parsers/baseparser"
+require_relative "baseparser"
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/treeparser.rb b/lib/rexml/parsers/treeparser.rb
index fc0993c..bf9a425 100644
--- a/lib/rexml/parsers/treeparser.rb
+++ b/lib/rexml/parsers/treeparser.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: false
-require 'rexml/validation/validationexception'
-require 'rexml/undefinednamespaceexception'
+require_relative '../validation/validationexception'
+require_relative '../undefinednamespaceexception'
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/ultralightparser.rb b/lib/rexml/parsers/ultralightparser.rb
index 6571d11..e0029f4 100644
--- a/lib/rexml/parsers/ultralightparser.rb
+++ b/lib/rexml/parsers/ultralightparser.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: false
-require 'rexml/parsers/streamparser'
-require 'rexml/parsers/baseparser'
+require_relative 'streamparser'
+require_relative 'baseparser'
 
 module REXML
   module Parsers
diff --git a/lib/rexml/parsers/xpathparser.rb b/lib/rexml/parsers/xpathparser.rb
index 32b70bb..d01d325 100644
--- a/lib/rexml/parsers/xpathparser.rb
+++ b/lib/rexml/parsers/xpathparser.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: false
-require 'rexml/namespace'
-require 'rexml/xmltokens'
+require_relative '../namespace'
+require_relative '../xmltokens'
 
 module REXML
   module Parsers
@@ -185,7 +185,7 @@ def predicate_to_string( path, &block )
       #  | '/' RelativeLocationPath?
       #  | '//' RelativeLocationPath
       def LocationPath path, parsed
-        path = path.strip
+        path = path.lstrip
         if path[0] == ?/
           parsed << :document
           if path[1] == ?/
@@ -209,7 +209,12 @@ def LocationPath path, parsed
       #  | RelativeLocationPath '//' Step
       AXIS = /^(ancestor|ancestor-or-self|attribute|child|descendant|descendant-or-self|following|following-sibling|namespace|parent|preceding|preceding-sibling|self)::/
       def RelativeLocationPath path, parsed
-        while path.size > 0
+        loop do
+          original_path = path
+          path = path.lstrip
+
+          return original_path if path.empty?
+
           # (axis or @ or <child::>) nodetest predicate  >
           # OR                                          >  / Step
           # (. or ..)                                    >
@@ -239,28 +244,25 @@ def RelativeLocationPath path, parsed
             n = []
             path = NodeTest( path, n)
 
-            if path[0] == ?[
-              path = Predicate( path, n )
-            end
+            path = Predicate( path, n )
 
             parsed.concat(n)
           end
 
-          if path.size > 0
-            if path[0] == ?/
-              if path[1] == ?/
-                parsed << :descendant_or_self
-                parsed << :node
-                path = path[2..-1]
-              else
-                path = path[1..-1]
-              end
-            else
-              return path
-            end
+          original_path = path
+          path = path.lstrip
+          return original_path if path.empty?
+
+          return original_path if path[0] != ?/
+
+          if path[1] == ?/
+            parsed << :descendant_or_self
+            parsed << :node
+            path = path[2..-1]
+          else
+            path = path[1..-1]
           end
         end
-        return path
       end
 
       # Returns a 1-1 map of the nodeset
@@ -269,15 +271,26 @@ def RelativeLocationPath path, parsed
       #   String, if a name match
       #NodeTest
       #  | ('*' | NCNAME ':' '*' | QNAME)                NameTest
-      #  | NODE_TYPE '(' ')'                              NodeType
+      #  | '*' ':' NCNAME                                NameTest since XPath 2.0
+      #  | NODE_TYPE '(' ')'                             NodeType
       #  | PI '(' LITERAL ')'                            PI
       #    | '[' expr ']'                                Predicate
-      NCNAMETEST= /^(#{NCNAME_STR}):\*/u
+      PREFIX_WILDCARD = /^\*:(#{NCNAME_STR})/u
+      LOCAL_NAME_WILDCARD = /^(#{NCNAME_STR}):\*/u
       QNAME     = Namespace::NAMESPLIT
       NODE_TYPE  = /^(comment|text|node)\(\s*\)/m
       PI        = /^processing-instruction\(/
       def NodeTest path, parsed
+        original_path = path
+        path = path.lstrip
         case path
+        when PREFIX_WILDCARD
+          prefix = nil
+          name = $1
+          path = $'
+          parsed << :qname
+          parsed << prefix
+          parsed << name
         when /^\*/
           path = $'
           parsed << :any
@@ -297,7 +310,7 @@ def NodeTest path, parsed
           end
           parsed << :processing_instruction
           parsed << (literal || '')
-        when NCNAMETEST
+        when LOCAL_NAME_WILDCARD
           prefix = $1
           path = $'
           parsed << :namespace
@@ -310,13 +323,17 @@ def NodeTest path, parsed
           parsed << :qname
           parsed << prefix
           parsed << name
+        else
+          path = original_path
         end
         return path
       end
 
       # Filters the supplied nodeset on the predicate(s)
       def Predicate path, parsed
-        return nil unless path[0] == ?[
+        original_path = path
+        path = path.lstrip
+        return original_path unless path[0] == ?[
         predicates = []
         while path[0] == ?[
           path, expr = get_group(path)
@@ -421,13 +438,13 @@ def RelationalExpr path, parsed
         rest
       end
 
-      #| AdditiveExpr ('+' | S '-') MultiplicativeExpr
+      #| AdditiveExpr ('+' | '-') MultiplicativeExpr
       #| MultiplicativeExpr
       def AdditiveExpr path, parsed
         n = []
         rest = MultiplicativeExpr( path, n )
         if rest != path
-          while rest =~ /^\s*(\+| -)\s*/
+          while rest =~ /^\s*(\+|-)\s*/
             if $1[0] == ?+
               n = [ :plus, n, [] ]
             else
@@ -509,13 +526,14 @@ def UnionExpr path, parsed
       #| LocationPath
       #| FilterExpr ('/' | '//') RelativeLocationPath
       def PathExpr path, parsed
-        path =~ /^\s*/
-        path = $'
+        path = path.lstrip
         n = []
         rest = FilterExpr( path, n )
         if rest != path
           if rest and rest[0] == ?/
-            return RelativeLocationPath(rest, n)
+            rest = RelativeLocationPath(rest, n)
+            parsed.concat(n)
+            return rest
           end
         end
         rest = LocationPath(rest, n) if rest =~ /\A[\/\.\@\[\w*]/
@@ -528,7 +546,7 @@ def PathExpr path, parsed
       def FilterExpr path, parsed
         n = []
         path = PrimaryExpr( path, n )
-        path = Predicate(path, n) if path and path[0] == ?[
+        path = Predicate(path, n)
         parsed.concat(n)
         path
       end
diff --git a/lib/rexml/quickpath.rb b/lib/rexml/quickpath.rb
index 5d6c77c..a0466b2 100644
--- a/lib/rexml/quickpath.rb
+++ b/lib/rexml/quickpath.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: false
-require 'rexml/functions'
-require 'rexml/xmltokens'
+require_relative 'functions'
+require_relative 'xmltokens'
 
 module REXML
   class QuickPath
diff --git a/lib/rexml/rexml.gemspec b/lib/rexml/rexml.gemspec
new file mode 100644
index 0000000..263f013
--- /dev/null
+++ b/lib/rexml/rexml.gemspec
@@ -0,0 +1,84 @@
+begin
+  require_relative "lib/rexml/rexml"
+rescue LoadError
+  # for Ruby core repository
+  require_relative "rexml"
+end
+
+Gem::Specification.new do |spec|
+  spec.name          = "rexml"
+  spec.version       = REXML::VERSION
+  spec.authors       = ["Kouhei Sutou"]
+  spec.email         = ["kou@cozmixng.org"]
+
+  spec.summary       = %q{An XML toolkit for Ruby}
+  spec.description   = %q{An XML toolkit for Ruby}
+  spec.homepage      = "https://github.com/ruby/rexml"
+  spec.license       = "BSD-2-Clause"
+
+  spec.files         = [
+    ".gitignore",
+    ".travis.yml",
+    "Gemfile",
+    "LICENSE.txt",
+    "NEWS.md",
+    "README.md",
+    "Rakefile",
+    "lib/rexml/attlistdecl.rb",
+    "lib/rexml/attribute.rb",
+    "lib/rexml/cdata.rb",
+    "lib/rexml/child.rb",
+    "lib/rexml/comment.rb",
+    "lib/rexml/doctype.rb",
+    "lib/rexml/document.rb",
+    "lib/rexml/dtd/attlistdecl.rb",
+    "lib/rexml/dtd/dtd.rb",
+    "lib/rexml/dtd/elementdecl.rb",
+    "lib/rexml/dtd/entitydecl.rb",
+    "lib/rexml/dtd/notationdecl.rb",
+    "lib/rexml/element.rb",
+    "lib/rexml/encoding.rb",
+    "lib/rexml/entity.rb",
+    "lib/rexml/formatters/default.rb",
+    "lib/rexml/formatters/pretty.rb",
+    "lib/rexml/formatters/transitive.rb",
+    "lib/rexml/functions.rb",
+    "lib/rexml/instruction.rb",
+    "lib/rexml/light/node.rb",
+    "lib/rexml/namespace.rb",
+    "lib/rexml/node.rb",
+    "lib/rexml/output.rb",
+    "lib/rexml/parent.rb",
+    "lib/rexml/parseexception.rb",
+    "lib/rexml/parsers/baseparser.rb",
+    "lib/rexml/parsers/lightparser.rb",
+    "lib/rexml/parsers/pullparser.rb",
+    "lib/rexml/parsers/sax2parser.rb",
+    "lib/rexml/parsers/streamparser.rb",
+    "lib/rexml/parsers/treeparser.rb",
+    "lib/rexml/parsers/ultralightparser.rb",
+    "lib/rexml/parsers/xpathparser.rb",
+    "lib/rexml/quickpath.rb",
+    "lib/rexml/rexml.rb",
+    "lib/rexml/sax2listener.rb",
+    "lib/rexml/security.rb",
+    "lib/rexml/source.rb",
+    "lib/rexml/streamlistener.rb",
+    "lib/rexml/text.rb",
+    "lib/rexml/undefinednamespaceexception.rb",
+    "lib/rexml/validation/relaxng.rb",
+    "lib/rexml/validation/validation.rb",
+    "lib/rexml/validation/validationexception.rb",
+    "lib/rexml/xmldecl.rb",
+    "lib/rexml/xmltokens.rb",
+    "lib/rexml/xpath.rb",
+    "lib/rexml/xpath_parser.rb",
+    "rexml.gemspec",
+  ]
+  spec.bindir        = "exe"
+  spec.executables   = spec.files.grep(%r{^exe/}) { |f| File.basename(f) }
+  spec.require_paths = ["lib"]
+
+  spec.add_development_dependency "bundler"
+  spec.add_development_dependency "rake"
+end
diff --git a/lib/rexml/rexml.rb b/lib/rexml/rexml.rb
index bc78f70..3c991a1 100644
--- a/lib/rexml/rexml.rb
+++ b/lib/rexml/rexml.rb
@@ -1,4 +1,4 @@
-# -*- encoding: utf-8 -*-
+# -*- coding: utf-8 -*-
 # frozen_string_literal: false
 # REXML is an XML toolkit for Ruby[http://www.ruby-lang.org], in Ruby.
 #
@@ -24,8 +24,8 @@
 module REXML
   COPYRIGHT = "Copyright  2001-2008 Sean Russell <ser@germane-software.com>"
   DATE = "2008/019"
-  VERSION = "3.1.7.3"
-  REVISION = %w$Revision: 53141 $[1] || ''
+  VERSION = "3.2.3.1"
+  REVISION = ""
 
   Copyright = COPYRIGHT
   Version = VERSION
diff --git a/lib/rexml/source.rb b/lib/rexml/source.rb
index af65cf4..90b370b 100644
--- a/lib/rexml/source.rb
+++ b/lib/rexml/source.rb
@@ -1,6 +1,6 @@
 # coding: US-ASCII
 # frozen_string_literal: false
-require 'rexml/encoding'
+require_relative 'encoding'
 
 module REXML
   # Generates Source-s.  USE THIS CLASS.
@@ -200,7 +200,7 @@ def scan(pattern, cons=false)
         end
         rv = super
       end
-      rv.taint
+      rv.taint if RUBY_VERSION < '2.7'
       rv
     end
 
@@ -228,7 +228,7 @@ def match( pattern, cons=false )
           @source = nil
         end
       end
-      rv.taint
+      rv.taint if RUBY_VERSION < '2.7'
       rv
     end
 
@@ -254,6 +254,7 @@ def current_line
           end
         rescue
         end
+        @er_source.seek(pos)
       rescue IOError
         pos = -1
         line = -1
diff --git a/lib/rexml/text.rb b/lib/rexml/text.rb
index 86269de..050b09c 100644
--- a/lib/rexml/text.rb
+++ b/lib/rexml/text.rb
@@ -1,10 +1,10 @@
 # frozen_string_literal: false
-require 'rexml/security'
-require 'rexml/entity'
-require 'rexml/doctype'
-require 'rexml/child'
-require 'rexml/doctype'
-require 'rexml/parseexception'
+require_relative 'security'
+require_relative 'entity'
+require_relative 'doctype'
+require_relative 'child'
+require_relative 'doctype'
+require_relative 'parseexception'
 
 module REXML
   # Represents text nodes in an XML document
@@ -96,27 +96,28 @@ def initialize(arg, respect_whitespace=false, parent=nil, raw=nil,
 
       @raw = false
       @parent = nil
+      @entity_filter = nil
 
       if parent
         super( parent )
         @raw = parent.raw
       end
 
-      @raw = raw unless raw.nil?
-      @entity_filter = entity_filter
-      clear_cache
-
       if arg.kind_of? String
         @string = arg.dup
-        @string.squeeze!(" \n\t") unless respect_whitespace
       elsif arg.kind_of? Text
-        @string = arg.to_s
+        @string = arg.instance_variable_get(:@string).dup
         @raw = arg.raw
-      elsif
+        @entity_filter = arg.instance_variable_get(:@entity_filter)
+      else
         raise "Illegal argument of type #{arg.type} for Text constructor (#{arg})"
       end
 
-      @string.gsub!( /\r\n?/, "\n" )
+      @string.squeeze!(" \n\t") unless respect_whitespace
+      @string.gsub!(/\r\n?/, "\n")
+      @raw = raw unless raw.nil?
+      @entity_filter = entity_filter if entity_filter
+      clear_cache
 
       Text.check(@string, illegal, doctype) if @raw
     end
@@ -136,7 +137,7 @@ def Text.check string, pattern, doctype
             case c.ord
             when *VALID_CHAR
             else
-              raise "Illegal character #{c.inspect} in raw string \"#{string}\""
+              raise "Illegal character #{c.inspect} in raw string #{string.inspect}"
             end
           end
         else
@@ -144,7 +145,7 @@ def Text.check string, pattern, doctype
             case c.unpack('U')
             when *VALID_CHAR
             else
-              raise "Illegal character #{c.inspect} in raw string \"#{string}\""
+              raise "Illegal character #{c.inspect} in raw string #{string.inspect}"
             end
           end
         end
@@ -153,13 +154,13 @@ def Text.check string, pattern, doctype
       # context sensitive
       string.scan(pattern) do
         if $1[-1] != ?;
-          raise "Illegal character '#{$1}' in raw string \"#{string}\""
+          raise "Illegal character #{$1.inspect} in raw string #{string.inspect}"
         elsif $1[0] == ?&
           if $5 and $5[0] == ?#
             case ($5[1] == ?x ? $5[2..-1].to_i(16) : $5[1..-1].to_i)
             when *VALID_CHAR
             else
-              raise "Illegal character '#{$1}' in raw string \"#{string}\""
+              raise "Illegal character #{$1.inspect} in raw string #{string.inspect}"
             end
           # FIXME: below can't work but this needs API change.
           # elsif @parent and $3 and !SUBSTITUTES.include?($1)
@@ -181,7 +182,7 @@ def empty?
 
 
     def clone
-      return Text.new(self)
+      return Text.new(self, true)
     end
 
 
@@ -226,9 +227,7 @@ def doctype
     #   u.to_s   #-> "sean russell"
     def to_s
       return @string if @raw
-      return @normalized if @normalized
-
-      @normalized = Text::normalize( @string, doctype, @entity_filter )
+      @normalized ||= Text::normalize( @string, doctype, @entity_filter )
     end
 
     def inspect
@@ -249,8 +248,7 @@ def inspect
     #   u = Text.new( "sean russell", false, nil, true )
     #   u.value   #-> "sean russell"
     def value
-      return @unnormalized if @unnormalized
-      @unnormalized = Text::unnormalize( @string, doctype )
+      @unnormalized ||= Text::unnormalize( @string, doctype )
     end
 
     # Sets the contents of this text node.  This expects the text to be
@@ -266,16 +264,16 @@ def value=( val )
       @raw = false
     end
 
-     def wrap(string, width, addnewline=false)
-       # Recursively wrap string at width.
-       return string if string.length <= width
-       place = string.rindex(' ', width) # Position in string with last ' ' before cutoff
-       if addnewline then
-         return "\n" + string[0,place] + "\n" + wrap(string[place+1..-1], width)
-       else
-         return string[0,place] + "\n" + wrap(string[place+1..-1], width)
-       end
-     end
+    def wrap(string, width, addnewline=false)
+      # Recursively wrap string at width.
+      return string if string.length <= width
+      place = string.rindex(' ', width) # Position in string with last ' ' before cutoff
+      if addnewline then
+        return "\n" + string[0,place] + "\n" + wrap(string[place+1..-1], width)
+      else
+        return string[0,place] + "\n" + wrap(string[place+1..-1], width)
+      end
+    end
 
     def indent_text(string, level=1, style="\t", indentfirstline=true)
       return string if level < 0
diff --git a/lib/rexml/undefinednamespaceexception.rb b/lib/rexml/undefinednamespaceexception.rb
index e522ed5..492a098 100644
--- a/lib/rexml/undefinednamespaceexception.rb
+++ b/lib/rexml/undefinednamespaceexception.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require 'rexml/parseexception'
+require_relative 'parseexception'
 module REXML
   class UndefinedNamespaceException < ParseException
     def initialize( prefix, source, parser )
diff --git a/lib/rexml/validation/relaxng.rb b/lib/rexml/validation/relaxng.rb
index fb52438..f29a2c0 100644
--- a/lib/rexml/validation/relaxng.rb
+++ b/lib/rexml/validation/relaxng.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: false
-require "rexml/validation/validation"
-require "rexml/parsers/baseparser"
+require_relative "validation"
+require_relative "../parsers/baseparser"
 
 module REXML
   module Validation
diff --git a/lib/rexml/validation/validation.rb b/lib/rexml/validation/validation.rb
index f0c76f9..0ad6ada 100644
--- a/lib/rexml/validation/validation.rb
+++ b/lib/rexml/validation/validation.rb
@@ -1,5 +1,5 @@
 # frozen_string_literal: false
-require 'rexml/validation/validationexception'
+require_relative 'validationexception'
 
 module REXML
   module Validation
diff --git a/lib/rexml/xmldecl.rb b/lib/rexml/xmldecl.rb
index a37e9f3..d19407c 100644
--- a/lib/rexml/xmldecl.rb
+++ b/lib/rexml/xmldecl.rb
@@ -1,17 +1,18 @@
 # frozen_string_literal: false
-require 'rexml/encoding'
-require 'rexml/source'
+
+require_relative 'encoding'
+require_relative 'source'
 
 module REXML
   # NEEDS DOCUMENTATION
   class XMLDecl < Child
     include Encoding
 
-    DEFAULT_VERSION = "1.0";
-    DEFAULT_ENCODING = "UTF-8";
-    DEFAULT_STANDALONE = "no";
-    START = '<\?xml';
-    STOP = '\?>';
+    DEFAULT_VERSION = "1.0"
+    DEFAULT_ENCODING = "UTF-8"
+    DEFAULT_STANDALONE = "no"
+    START = "<?xml"
+    STOP = "?>"
 
     attr_accessor :version, :standalone
     attr_reader :writeencoding, :writethis
@@ -25,6 +26,7 @@ def initialize(version=DEFAULT_VERSION, encoding=nil, standalone=nil)
         self.encoding = version.encoding
         @writeencoding = version.writeencoding
         @standalone = version.standalone
+        @writethis = version.writethis
       else
         super()
         @version = version
@@ -46,9 +48,9 @@ def clone
     #   Ignored
     def write(writer, indent=-1, transitive=false, ie_hack=false)
       return nil unless @writethis or writer.kind_of? Output
-      writer << START.sub(/\\/u, '')
+      writer << START
       writer << " #{content encoding}"
-      writer << STOP.sub(/\\/u, '')
+      writer << STOP
     end
 
     def ==( other )
@@ -102,14 +104,26 @@ def dowrite
     end
 
     def inspect
-      START.sub(/\\/u, '') + " ... " + STOP.sub(/\\/u, '')
+      "#{START} ... #{STOP}"
     end
 
     private
     def content(enc)
-      rv = "version='#@version'"
-      rv << " encoding='#{enc}'" if @writeencoding || enc !~ /\Autf-8\z/i
-      rv << " standalone='#@standalone'" if @standalone
+      context = nil
+      context = parent.context if parent
+      if context and context[:prologue_quote] == :quote
+        quote = "\""
+      else
+        quote = "'"
+      end
+
+      rv = "version=#{quote}#{@version}#{quote}"
+      if @writeencoding or enc !~ /\Autf-8\z/i
+        rv << " encoding=#{quote}#{enc}#{quote}"
+      end
+      if @standalone
+        rv << " standalone=#{quote}#{@standalone}#{quote}"
+      end
       rv
     end
   end
diff --git a/lib/rexml/xpath.rb b/lib/rexml/xpath.rb
index f1cb99b..a0921bd 100644
--- a/lib/rexml/xpath.rb
+++ b/lib/rexml/xpath.rb
@@ -1,6 +1,6 @@
 # frozen_string_literal: false
-require 'rexml/functions'
-require 'rexml/xpath_parser'
+require_relative 'functions'
+require_relative 'xpath_parser'
 
 module REXML
   # Wrapper class.  Use this class to access the XPath functions.
@@ -28,10 +28,10 @@ class XPath
     #  XPath.first( doc, "//b"} )
     #  XPath.first( node, "a/x:b", { "x"=>"http://doofus" } )
     #  XPath.first( node, '/book/publisher/text()=$publisher', {}, {"publisher"=>"O'Reilly"})
-    def XPath::first element, path=nil, namespaces=nil, variables={}
+    def XPath::first(element, path=nil, namespaces=nil, variables={}, options={})
       raise "The namespaces argument, if supplied, must be a hash object." unless namespaces.nil? or namespaces.kind_of?(Hash)
       raise "The variables argument, if supplied, must be a hash object." unless variables.kind_of?(Hash)
-      parser = XPathParser.new
+      parser = XPathParser.new(**options)
       parser.namespaces = namespaces
       parser.variables = variables
       path = "*" unless path
@@ -57,10 +57,10 @@ def XPath::first element, path=nil, namespaces=nil, variables={}
     #  XPath.each( node, 'ancestor::x' ) { |el| ... }
     #  XPath.each( node, '/book/publisher/text()=$publisher', {}, {"publisher"=>"O'Reilly"}) \
     #    {|el| ... }
-    def XPath::each element, path=nil, namespaces=nil, variables={}, &block
+    def XPath::each(element, path=nil, namespaces=nil, variables={}, options={}, &block)
       raise "The namespaces argument, if supplied, must be a hash object." unless namespaces.nil? or namespaces.kind_of?(Hash)
       raise "The variables argument, if supplied, must be a hash object." unless variables.kind_of?(Hash)
-      parser = XPathParser.new
+      parser = XPathParser.new(**options)
       parser.namespaces = namespaces
       parser.variables = variables
       path = "*" unless path
@@ -69,8 +69,8 @@ def XPath::each element, path=nil, namespaces=nil, variables={}, &block
     end
 
     # Returns an array of nodes matching a given XPath.
-    def XPath::match element, path=nil, namespaces=nil, variables={}
-      parser = XPathParser.new
+    def XPath::match(element, path=nil, namespaces=nil, variables={}, options={})
+      parser = XPathParser.new(**options)
       parser.namespaces = namespaces
       parser.variables = variables
       path = "*" unless path
diff --git a/lib/rexml/xpath_parser.rb b/lib/rexml/xpath_parser.rb
index 181b2b6..b989725 100644
--- a/lib/rexml/xpath_parser.rb
+++ b/lib/rexml/xpath_parser.rb
@@ -1,9 +1,11 @@
 # frozen_string_literal: false
-require 'rexml/namespace'
-require 'rexml/xmltokens'
-require 'rexml/attribute'
-require 'rexml/syncenumerator'
-require 'rexml/parsers/xpathparser'
+
+require "pp"
+
+require_relative 'namespace'
+require_relative 'xmltokens'
+require_relative 'attribute'
+require_relative 'parsers/xpathparser'
 
 class Object
   # provides a unified +clone+ operation, for REXML::XPathParser
@@ -47,10 +49,15 @@ class XPathParser
     include XMLTokens
     LITERAL    = /^'([^']*)'|^"([^"]*)"/u
 
-    def initialize( )
+    DEBUG = (ENV["REXML_XPATH_PARSER_DEBUG"] == "true")
+
+    def initialize(strict: false)
+      @debug = DEBUG
       @parser = REXML::Parsers::XPathParser.new
       @namespaces = nil
       @variables = {}
+      @nest = 0
+      @strict = strict
     end
 
     def namespaces=( namespaces={} )
@@ -75,7 +82,7 @@ def get_first path, nodeset
 
     def predicate path, nodeset
       path_stack = @parser.parse( path )
-      expr( path_stack, nodeset )
+      match( path_stack, nodeset )
     end
 
     def []=( variable_name, value )
@@ -123,13 +130,24 @@ def first( path_stack, node )
     end
 
 
-    def match( path_stack, nodeset )
-      r = expr( path_stack, nodeset )
-      r
+    def match(path_stack, nodeset)
+      nodeset = nodeset.collect.with_index do |node, i|
+        position = i + 1
+        XPathNode.new(node, position: position)
+      end
+      result = expr(path_stack, nodeset)
+      case result
+      when Array # nodeset
+        unnode(result)
+      else
+        [result]
+      end
     end
 
     private
-
+    def strict?
+      @strict
+    end
 
     # Returns a String namespace for a node, given a prefix
     # The rules are:
@@ -148,343 +166,477 @@ def get_namespace( node, prefix )
 
     # Expr takes a stack of path elements and a set of nodes (either a Parent
     # or an Array and returns an Array of matching nodes
-    ALL = [ :attribute, :element, :text, :processing_instruction, :comment ]
-    ELEMENTS = [ :element ]
     def expr( path_stack, nodeset, context=nil )
-      node_types = ELEMENTS
+      enter(:expr, path_stack, nodeset) if @debug
       return nodeset if path_stack.length == 0 || nodeset.length == 0
       while path_stack.length > 0
+        trace(:while, path_stack, nodeset) if @debug
         if nodeset.length == 0
           path_stack.clear
           return []
         end
-        case (op = path_stack.shift)
+        op = path_stack.shift
+        case op
         when :document
-          nodeset = [ nodeset[0].root_node ]
-
-        when :qname
-          prefix = path_stack.shift
-          name = path_stack.shift
-          nodeset.delete_if do |node|
-            # FIXME: This DOUBLES the time XPath searches take
-            ns = get_namespace( node, prefix )
-            if node.node_type == :element
-              if node.name == name
-              end
-            end
-            !(node.node_type == :element and
-              node.name == name and
-              node.namespace == ns )
-          end
-          node_types = ELEMENTS
-
-        when :any
-          nodeset.delete_if { |node| !node_types.include?(node.node_type) }
-
+          first_raw_node = nodeset.first.raw_node
+          nodeset = [XPathNode.new(first_raw_node.root_node, position: 1)]
         when :self
-          # This space left intentionally blank
-
-        when :processing_instruction
-          target = path_stack.shift
-          nodeset.delete_if do |node|
-            (node.node_type != :processing_instruction) or
-            ( target!='' and ( node.target != target ) )
+          nodeset = step(path_stack) do
+            [nodeset]
           end
-
-        when :text
-          nodeset.delete_if { |node| node.node_type != :text }
-
-        when :comment
-          nodeset.delete_if { |node| node.node_type != :comment }
-
-        when :node
-          # This space left intentionally blank
-          node_types = ALL
-
         when :child
-          new_nodeset = []
-          nt = nil
-          nodeset.each do |node|
-            nt = node.node_type
-            new_nodeset += node.children if nt == :element or nt == :document
+          nodeset = step(path_stack) do
+            child(nodeset)
           end
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
         when :literal
+          trace(:literal, path_stack, nodeset) if @debug
           return path_stack.shift
-
         when :attribute
-          new_nodeset = []
-          case path_stack.shift
-          when :qname
-            prefix = path_stack.shift
-            name = path_stack.shift
-            for element in nodeset
-              if element.node_type == :element
-                attrib = element.attribute( name, get_namespace(element, prefix) )
-                new_nodeset << attrib if attrib
+          nodeset = step(path_stack, any_type: :attribute) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              next unless raw_node.node_type == :element
+              attributes = raw_node.attributes
+              next if attributes.empty?
+              nodesets << attributes.each_attribute.collect.with_index do |attribute, i|
+                XPathNode.new(attribute, position: i + 1)
               end
             end
-          when :any
-            for element in nodeset
-              if element.node_type == :element
-                new_nodeset += element.attributes.to_a
+            nodesets
+          end
+        when :namespace
+          pre_defined_namespaces = {
+            "xml" => "http://www.w3.org/XML/1998/namespace",
+          }
+          nodeset = step(path_stack, any_type: :namespace) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              case raw_node.node_type
+              when :element
+                if @namespaces
+                  nodesets << pre_defined_namespaces.merge(@namespaces)
+                else
+                  nodesets << pre_defined_namespaces.merge(raw_node.namespaces)
+                end
+              when :attribute
+                if @namespaces
+                  nodesets << pre_defined_namespaces.merge(@namespaces)
+                else
+                  nodesets << pre_defined_namespaces.merge(raw_node.element.namespaces)
+                end
               end
             end
+            nodesets
           end
-          nodeset = new_nodeset
-
         when :parent
-          nodeset = nodeset.collect{|n| n.parent}.compact
-          #nodeset = expr(path_stack.dclone, nodeset.collect{|n| n.parent}.compact)
-          node_types = ELEMENTS
-
-        when :ancestor
-          new_nodeset = []
-          nodeset.each do |node|
-            while node.parent
-              node = node.parent
-              new_nodeset << node unless new_nodeset.include? node
+          nodeset = step(path_stack) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              if raw_node.node_type == :attribute
+                parent = raw_node.element
+              else
+                parent = raw_node.parent
+              end
+              nodesets << [XPathNode.new(parent, position: 1)] if parent
             end
+            nodesets
           end
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
-        when :ancestor_or_self
-          new_nodeset = []
-          nodeset.each do |node|
-            if node.node_type == :element
-              new_nodeset << node
-              while ( node.parent )
-                node = node.parent
-                new_nodeset << node unless new_nodeset.include? node
+        when :ancestor
+          nodeset = step(path_stack) do
+            nodesets = []
+            # new_nodes = {}
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              new_nodeset = []
+              while raw_node.parent
+                raw_node = raw_node.parent
+                # next if new_nodes.key?(node)
+                new_nodeset << XPathNode.new(raw_node,
+                                             position: new_nodeset.size + 1)
+                # new_nodes[node] = true
               end
+              nodesets << new_nodeset unless new_nodeset.empty?
             end
+            nodesets
           end
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
-        when :predicate
-          new_nodeset = []
-          subcontext = { :size => nodeset.size }
-          pred = path_stack.shift
-          nodeset.each_with_index { |node, index|
-            subcontext[ :node ] = node
-            subcontext[ :index ] = index+1
-            pc = pred.dclone
-            result = expr( pc, [node], subcontext )
-            result = result[0] if result.kind_of? Array and result.length == 1
-            if result.kind_of? Numeric
-              new_nodeset << node if result == (index+1)
-            elsif result.instance_of? Array
-              if result.size > 0 and result.inject(false) {|k,s| s or k}
-                new_nodeset << node if result.size > 0
+        when :ancestor_or_self
+          nodeset = step(path_stack) do
+            nodesets = []
+            # new_nodes = {}
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              next unless raw_node.node_type == :element
+              new_nodeset = [XPathNode.new(raw_node, position: 1)]
+              # new_nodes[node] = true
+              while raw_node.parent
+                raw_node = raw_node.parent
+                # next if new_nodes.key?(node)
+                new_nodeset << XPathNode.new(raw_node,
+                                             position: new_nodeset.size + 1)
+                # new_nodes[node] = true
               end
-            else
-              new_nodeset << node if result
+              nodesets << new_nodeset unless new_nodeset.empty?
             end
-          }
-          nodeset = new_nodeset
-=begin
-          predicate = path_stack.shift
-          ns = nodeset.clone
-          result = expr( predicate, ns )
-          if result.kind_of? Array
-            nodeset = result.zip(ns).collect{|m,n| n if m}.compact
-          else
-            nodeset = result ? nodeset : []
+            nodesets
           end
-=end
-
         when :descendant_or_self
-          rv = descendant_or_self( path_stack, nodeset )
-          path_stack.clear
-          nodeset = rv
-          node_types = ELEMENTS
-
+          nodeset = step(path_stack) do
+            descendant(nodeset, true)
+          end
         when :descendant
-          results = []
-          nt = nil
-          nodeset.each do |node|
-            nt = node.node_type
-            results += expr( path_stack.dclone.unshift( :descendant_or_self ),
-              node.children ) if nt == :element or nt == :document
+          nodeset = step(path_stack) do
+            descendant(nodeset, false)
           end
-          nodeset = results
-          node_types = ELEMENTS
-
         when :following_sibling
-          results = []
-          nodeset.each do |node|
-            next if node.parent.nil?
-            all_siblings = node.parent.children
-            current_index = all_siblings.index( node )
-            following_siblings = all_siblings[ current_index+1 .. -1 ]
-            results += expr( path_stack.dclone, following_siblings )
+          nodeset = step(path_stack) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              next unless raw_node.respond_to?(:parent)
+              next if raw_node.parent.nil?
+              all_siblings = raw_node.parent.children
+              current_index = all_siblings.index(raw_node)
+              following_siblings = all_siblings[(current_index + 1)..-1]
+              next if following_siblings.empty?
+              nodesets << following_siblings.collect.with_index do |sibling, i|
+                XPathNode.new(sibling, position: i + 1)
+              end
+            end
+            nodesets
           end
-          nodeset = results
-
         when :preceding_sibling
-          results = []
-          nodeset.each do |node|
-            next if node.parent.nil?
-            all_siblings = node.parent.children
-            current_index = all_siblings.index( node )
-            preceding_siblings = all_siblings[ 0, current_index ].reverse
-            results += preceding_siblings
+          nodeset = step(path_stack, order: :reverse) do
+            nodesets = []
+            nodeset.each do |node|
+              raw_node = node.raw_node
+              next unless raw_node.respond_to?(:parent)
+              next if raw_node.parent.nil?
+              all_siblings = raw_node.parent.children
+              current_index = all_siblings.index(raw_node)
+              preceding_siblings = all_siblings[0, current_index].reverse
+              next if preceding_siblings.empty?
+              nodesets << preceding_siblings.collect.with_index do |sibling, i|
+                XPathNode.new(sibling, position: i + 1)
+              end
+            end
+            nodesets
           end
-          nodeset = results
-          node_types = ELEMENTS
-
         when :preceding
-          new_nodeset = []
-          nodeset.each do |node|
-            new_nodeset += preceding( node )
+          nodeset = step(path_stack, order: :reverse) do
+            unnode(nodeset) do |node|
+              preceding(node)
+            end
           end
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
         when :following
-          new_nodeset = []
-          nodeset.each do |node|
-            new_nodeset += following( node )
-          end
-          nodeset = new_nodeset
-          node_types = ELEMENTS
-
-        when :namespace
-          new_nodeset = []
-          prefix = path_stack.shift
-          nodeset.each do |node|
-            if (node.node_type == :element or node.node_type == :attribute)
-              if @namespaces
-                namespaces = @namespaces
-              elsif (node.node_type == :element)
-                namespaces = node.namespaces
-              else
-                namespaces = node.element.namesapces
-              end
-              if (node.namespace == namespaces[prefix])
-                new_nodeset << node
-              end
+          nodeset = step(path_stack) do
+            unnode(nodeset) do |node|
+              following(node)
             end
           end
-          nodeset = new_nodeset
-
         when :variable
           var_name = path_stack.shift
-          return @variables[ var_name ]
+          return [@variables[var_name]]
 
-        # :and, :or, :eq, :neq, :lt, :lteq, :gt, :gteq
-        # TODO: Special case for :or and :and -- not evaluate the right
-        # operand if the left alone determines result (i.e. is true for
-        # :or and false for :and).
-        when :eq, :neq, :lt, :lteq, :gt, :gteq, :or
+        when :eq, :neq, :lt, :lteq, :gt, :gteq
           left = expr( path_stack.shift, nodeset.dup, context )
           right = expr( path_stack.shift, nodeset.dup, context )
           res = equality_relational_compare( left, op, right )
+          trace(op, left, right, res) if @debug
           return res
 
+        when :or
+          left = expr(path_stack.shift, nodeset.dup, context)
+          return true if Functions.boolean(left)
+          right = expr(path_stack.shift, nodeset.dup, context)
+          return Functions.boolean(right)
+
         when :and
-          left = expr( path_stack.shift, nodeset.dup, context )
-          return [] unless left
-          if left.respond_to?(:inject) and !left.inject(false) {|a,b| a | b}
-            return []
+          left = expr(path_stack.shift, nodeset.dup, context)
+          return false unless Functions.boolean(left)
+          right = expr(path_stack.shift, nodeset.dup, context)
+          return Functions.boolean(right)
+
+        when :div, :mod, :mult, :plus, :minus
+          left = expr(path_stack.shift, nodeset, context)
+          right = expr(path_stack.shift, nodeset, context)
+          left = unnode(left) if left.is_a?(Array)
+          right = unnode(right) if right.is_a?(Array)
+          left = Functions::number(left)
+          right = Functions::number(right)
+          case op
+          when :div
+            return left / right
+          when :mod
+            return left % right
+          when :mult
+            return left * right
+          when :plus
+            return left + right
+          when :minus
+            return left - right
+          else
+            raise "[BUG] Unexpected operator: <#{op.inspect}>"
           end
-          right = expr( path_stack.shift, nodeset.dup, context )
-          res = equality_relational_compare( left, op, right )
-          return res
-
-        when :div
-          left = Functions::number(expr(path_stack.shift, nodeset, context)).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context)).to_f
-          return (left / right)
-
-        when :mod
-          left = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          return (left % right)
-
-        when :mult
-          left = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          return (left * right)
-
-        when :plus
-          left = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          return (left + right)
-
-        when :minus
-          left = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          right = Functions::number(expr(path_stack.shift, nodeset, context )).to_f
-          return (left - right)
-
         when :union
           left = expr( path_stack.shift, nodeset, context )
           right = expr( path_stack.shift, nodeset, context )
+          left = unnode(left) if left.is_a?(Array)
+          right = unnode(right) if right.is_a?(Array)
           return (left | right)
-
         when :neg
           res = expr( path_stack, nodeset, context )
-          return -(res.to_f)
-
+          res = unnode(res) if res.is_a?(Array)
+          return -Functions.number(res)
         when :not
         when :function
           func_name = path_stack.shift.tr('-','_')
           arguments = path_stack.shift
-          subcontext = context ? nil : { :size => nodeset.size }
-
-          res = []
-          cont = context
-          nodeset.each_with_index { |n, i|
-            if subcontext
-              subcontext[:node]  = n
-              subcontext[:index] = i
-              cont = subcontext
+
+          if nodeset.size != 1
+            message = "[BUG] Node set size must be 1 for function call: "
+            message += "<#{func_name}>: <#{nodeset.inspect}>: "
+            message += "<#{arguments.inspect}>"
+            raise message
+          end
+
+          node = nodeset.first
+          if context
+            target_context = context
+          else
+            target_context = {:size => nodeset.size}
+            if node.is_a?(XPathNode)
+              target_context[:node]  = node.raw_node
+              target_context[:index] = node.position
+            else
+              target_context[:node]  = node
+              target_context[:index] = 1
             end
-            arg_clone = arguments.dclone
-            args = arg_clone.collect { |arg|
-              expr( arg, [n], cont )
-            }
-            Functions.context = cont
-            res << Functions.send( func_name, *args )
-          }
-          return res
+          end
+          args = arguments.dclone.collect do |arg|
+            result = expr(arg, nodeset, target_context)
+            result = unnode(result) if result.is_a?(Array)
+            result
+          end
+          Functions.context = target_context
+          return Functions.send(func_name, *args)
 
+        else
+          raise "[BUG] Unexpected path: <#{op.inspect}>: <#{path_stack.inspect}>"
         end
       end # while
       return nodeset
+    ensure
+      leave(:expr, path_stack, nodeset) if @debug
     end
 
+    def step(path_stack, any_type: :element, order: :forward)
+      nodesets = yield
+      begin
+        enter(:step, path_stack, nodesets) if @debug
+        nodesets = node_test(path_stack, nodesets, any_type: any_type)
+        while path_stack[0] == :predicate
+          path_stack.shift # :predicate
+          predicate_expression = path_stack.shift.dclone
+          nodesets = evaluate_predicate(predicate_expression, nodesets)
+        end
+        if nodesets.size == 1
+          ordered_nodeset = nodesets[0]
+        else
+          raw_nodes = []
+          nodesets.each do |nodeset|
+            nodeset.each do |node|
+              if node.respond_to?(:raw_node)
+                raw_nodes << node.raw_node
+              else
+                raw_nodes << node
+              end
+            end
+          end
+          ordered_nodeset = sort(raw_nodes, order)
+        end
+        new_nodeset = []
+        ordered_nodeset.each do |node|
+          # TODO: Remove duplicated
+          new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
+        end
+        new_nodeset
+      ensure
+        leave(:step, path_stack, new_nodeset) if @debug
+      end
+    end
 
-    ##########################################################
-    # FIXME
-    # The next two methods are BAD MOJO!
-    # This is my achilles heel.  If anybody thinks of a better
-    # way of doing this, be my guest.  This really sucks, but
-    # it is a wonder it works at all.
-    # ########################################################
+    def node_test(path_stack, nodesets, any_type: :element)
+      enter(:node_test, path_stack, nodesets) if @debug
+      operator = path_stack.shift
+      case operator
+      when :qname
+        prefix = path_stack.shift
+        name = path_stack.shift
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            case raw_node.node_type
+            when :element
+              if prefix.nil?
+                raw_node.name == name
+              elsif prefix.empty?
+                if strict?
+                  raw_node.name == name and raw_node.namespace == ""
+                else
+                  # FIXME: This DOUBLES the time XPath searches take
+                  ns = get_namespace(raw_node, prefix)
+                  raw_node.name == name and raw_node.namespace == ns
+                end
+              else
+                # FIXME: This DOUBLES the time XPath searches take
+                ns = get_namespace(raw_node, prefix)
+                raw_node.name == name and raw_node.namespace == ns
+              end
+            when :attribute
+              if prefix.nil?
+                raw_node.name == name
+              elsif prefix.empty?
+                raw_node.name == name and raw_node.namespace == ""
+              else
+                # FIXME: This DOUBLES the time XPath searches take
+                ns = get_namespace(raw_node.element, prefix)
+                raw_node.name == name and raw_node.namespace == ns
+              end
+            else
+              false
+            end
+          end
+        end
+      when :namespace
+        prefix = path_stack.shift
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            case raw_node.node_type
+            when :element
+              namespaces = @namespaces || raw_node.namespaces
+              raw_node.namespace == namespaces[prefix]
+            when :attribute
+              namespaces = @namespaces || raw_node.element.namespaces
+              raw_node.namespace == namespaces[prefix]
+            else
+              false
+            end
+          end
+        end
+      when :any
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            raw_node.node_type == any_type
+          end
+        end
+      when :comment
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            raw_node.node_type == :comment
+          end
+        end
+      when :text
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            raw_node.node_type == :text
+          end
+        end
+      when :processing_instruction
+        target = path_stack.shift
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            raw_node = node.raw_node
+            (raw_node.node_type == :processing_instruction) and
+              (target.empty? or (raw_node.target == target))
+          end
+        end
+      when :node
+        new_nodesets = nodesets.collect do |nodeset|
+          filter_nodeset(nodeset) do |node|
+            true
+          end
+        end
+      else
+        message = "[BUG] Unexpected node test: " +
+          "<#{operator.inspect}>: <#{path_stack.inspect}>"
+        raise message
+      end
+      new_nodesets
+    ensure
+      leave(:node_test, path_stack, new_nodesets) if @debug
+    end
 
-    def descendant_or_self( path_stack, nodeset )
-      rs = []
-      d_o_s( path_stack, nodeset, rs )
-      document_order(rs.flatten.compact)
-      #rs.flatten.compact
+    def filter_nodeset(nodeset)
+      new_nodeset = []
+      nodeset.each do |node|
+        next unless yield(node)
+        new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
+      end
+      new_nodeset
     end
 
-    def d_o_s( p, ns, r )
-      nt = nil
-      ns.each_index do |i|
-        n = ns[i]
-        x = expr( p.dclone, [ n ] )
-        nt = n.node_type
-        d_o_s( p, n.children, x ) if nt == :element or nt == :document and n.children.size > 0
-        r.concat(x) if x.size > 0
+    def evaluate_predicate(expression, nodesets)
+      enter(:predicate, expression, nodesets) if @debug
+      new_nodesets = nodesets.collect do |nodeset|
+        new_nodeset = []
+        subcontext = { :size => nodeset.size }
+        nodeset.each_with_index do |node, index|
+          if node.is_a?(XPathNode)
+            subcontext[:node] = node.raw_node
+            subcontext[:index] = node.position
+          else
+            subcontext[:node] = node
+            subcontext[:index] = index + 1
+          end
+          result = expr(expression.dclone, [node], subcontext)
+          trace(:predicate_evaluate, expression, node, subcontext, result) if @debug
+          result = result[0] if result.kind_of? Array and result.length == 1
+          if result.kind_of? Numeric
+            if result == node.position
+              new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
+            end
+          elsif result.instance_of? Array
+            if result.size > 0 and result.inject(false) {|k,s| s or k}
+              if result.size > 0
+                new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
+              end
+            end
+          else
+            if result
+              new_nodeset << XPathNode.new(node, position: new_nodeset.size + 1)
+            end
+          end
+        end
+        new_nodeset
       end
+      new_nodesets
+    ensure
+      leave(:predicate, new_nodesets) if @debug
     end
 
+    def trace(*args)
+      indent = "  " * @nest
+      PP.pp(args, "").each_line do |line|
+        puts("#{indent}#{line}")
+      end
+    end
+
+    def enter(tag, *args)
+      trace(:enter, tag, *args)
+      @nest += 1
+    end
+
+    def leave(tag, *args)
+      @nest -= 1
+      trace(:leave, tag, *args)
+    end
 
     # Reorders an array of nodes so that they are in document order
     # It tries to do this efficiently.
@@ -494,7 +646,7 @@ def d_o_s( p, ns, r )
     # in and out of function calls.  If I knew what the index of the nodes was,
     # I wouldn't have to do this.  Maybe add a document IDX for each node?
     # Problems with mutable documents.  Or, rewrite everything.
-    def document_order( array_of_nodes )
+    def sort(array_of_nodes, order)
       new_arry = []
       array_of_nodes.each { |node|
         node_idx = []
@@ -505,42 +657,68 @@ def document_order( array_of_nodes )
         end
         new_arry << [ node_idx.reverse, node ]
       }
-      new_arry.sort{ |s1, s2| s1[0] <=> s2[0] }.collect{ |s| s[1] }
+      ordered = new_arry.sort_by do |index, node|
+        if order == :forward
+          index
+        else
+          -index
+        end
+      end
+      ordered.collect do |_index, node|
+        node
+      end
     end
 
-
-    def recurse( nodeset, &block )
-      for node in nodeset
-        yield node
-        recurse( node, &block ) if node.node_type == :element
+    def descendant(nodeset, include_self)
+      nodesets = []
+      nodeset.each do |node|
+        new_nodeset = []
+        new_nodes = {}
+        descendant_recursive(node.raw_node, new_nodeset, new_nodes, include_self)
+        nodesets << new_nodeset unless new_nodeset.empty?
       end
+      nodesets
     end
 
+    def descendant_recursive(raw_node, new_nodeset, new_nodes, include_self)
+      if include_self
+        return if new_nodes.key?(raw_node)
+        new_nodeset << XPathNode.new(raw_node, position: new_nodeset.size + 1)
+        new_nodes[raw_node] = true
+      end
 
+      node_type = raw_node.node_type
+      if node_type == :element or node_type == :document
+        raw_node.children.each do |child|
+          descendant_recursive(child, new_nodeset, new_nodes, true)
+        end
+      end
+    end
 
     # Builds a nodeset of all of the preceding nodes of the supplied node,
     # in reverse document order
     # preceding:: includes every element in the document that precedes this node,
     # except for ancestors
-    def preceding( node )
+    def preceding(node)
       ancestors = []
-      p = node.parent
-      while p
-        ancestors << p
-        p = p.parent
+      parent = node.parent
+      while parent
+        ancestors << parent
+        parent = parent.parent
       end
 
-      acc = []
-      p = preceding_node_of( node )
-      while p
-        if ancestors.include? p
-          ancestors.delete(p)
+      precedings = []
+      preceding_node = preceding_node_of(node)
+      while preceding_node
+        if ancestors.include?(preceding_node)
+          ancestors.delete(preceding_node)
         else
-          acc << p
+          precedings << XPathNode.new(preceding_node,
+                                      position: precedings.size + 1)
         end
-        p = preceding_node_of( p )
+        preceding_node = preceding_node_of(preceding_node)
       end
-      acc
+      precedings
     end
 
     def preceding_node_of( node )
@@ -558,14 +736,15 @@ def preceding_node_of( node )
       psn
     end
 
-    def following( node )
-      acc = []
-      p = next_sibling_node( node )
-      while p
-        acc << p
-        p = following_node_of( p )
+    def following(node)
+      followings = []
+      following_node = next_sibling_node(node)
+      while following_node
+        followings << XPathNode.new(following_node,
+                                    position: followings.size + 1)
+        following_node = following_node_of(following_node)
       end
-      acc
+      followings
     end
 
     def following_node_of( node )
@@ -587,45 +766,68 @@ def next_sibling_node(node)
       return psn
     end
 
+    def child(nodeset)
+      nodesets = []
+      nodeset.each do |node|
+        raw_node = node.raw_node
+        node_type = raw_node.node_type
+        # trace(:child, node_type, node)
+        case node_type
+        when :element
+          nodesets << raw_node.children.collect.with_index do |child_node, i|
+            XPathNode.new(child_node, position: i + 1)
+          end
+        when :document
+          new_nodeset = []
+          raw_node.children.each do |child|
+            case child
+            when XMLDecl, Text
+              # Ignore
+            else
+              new_nodeset << XPathNode.new(child, position: new_nodeset.size + 1)
+            end
+          end
+          nodesets << new_nodeset unless new_nodeset.empty?
+        end
+      end
+      nodesets
+    end
+
     def norm b
       case b
       when true, false
         return b
       when 'true', 'false'
         return Functions::boolean( b )
-      when /^\d+(\.\d+)?$/
+      when /^\d+(\.\d+)?$/, Numeric
         return Functions::number( b )
       else
         return Functions::string( b )
       end
     end
 
-    def equality_relational_compare( set1, op, set2 )
+    def equality_relational_compare(set1, op, set2)
+      set1 = unnode(set1) if set1.is_a?(Array)
+      set2 = unnode(set2) if set2.is_a?(Array)
+
       if set1.kind_of? Array and set2.kind_of? Array
-        if set1.size == 1 and set2.size == 1
-          set1 = set1[0]
-          set2 = set2[0]
-        elsif set1.size == 0 or set2.size == 0
-          nd = set1.size==0 ? set2 : set1
-          rv = nd.collect { |il| compare( il, op, nil ) }
-          return rv
-        else
-          res = []
-          SyncEnumerator.new( set1, set2 ).each { |i1, i2|
-            i1 = norm( i1 )
-            i2 = norm( i2 )
-            res << compare( i1, op, i2 )
-          }
-          return res
+        # If both objects to be compared are node-sets, then the
+        # comparison will be true if and only if there is a node in the
+        # first node-set and a node in the second node-set such that the
+        # result of performing the comparison on the string-values of
+        # the two nodes is true.
+        set1.product(set2).any? do |node1, node2|
+          node_string1 = Functions.string(node1)
+          node_string2 = Functions.string(node2)
+          compare(node_string1, op, node_string2)
         end
-      end
-      # If one is nodeset and other is number, compare number to each item
-      # in nodeset s.t. number op number(string(item))
-      # If one is nodeset and other is string, compare string to each item
-      # in nodeset s.t. string op string(item)
-      # If one is nodeset and other is boolean, compare boolean to each item
-      # in nodeset s.t. boolean op boolean(item)
-      if set1.kind_of? Array or set2.kind_of? Array
+      elsif set1.kind_of? Array or set2.kind_of? Array
+        # If one is nodeset and other is number, compare number to each item
+        # in nodeset s.t. number op number(string(item))
+        # If one is nodeset and other is string, compare string to each item
+        # in nodeset s.t. string op string(item)
+        # If one is nodeset and other is boolean, compare boolean to each item
+        # in nodeset s.t. boolean op boolean(item)
         if set1.kind_of? Array
           a = set1
           b = set2
@@ -636,15 +838,23 @@ def equality_relational_compare( set1, op, set2 )
 
         case b
         when true, false
-          return a.collect {|v| compare( Functions::boolean(v), op, b ) }
+          each_unnode(a).any? do |unnoded|
+            compare(Functions.boolean(unnoded), op, b)
+          end
         when Numeric
-          return a.collect {|v| compare( Functions::number(v), op, b )}
-        when /^\d+(\.\d+)?$/
-          b = Functions::number( b )
-          return a.collect {|v| compare( Functions::number(v), op, b )}
+          each_unnode(a).any? do |unnoded|
+            compare(Functions.number(unnoded), op, b)
+          end
+        when /\A\d+(\.\d+)?\z/
+          b = Functions.number(b)
+          each_unnode(a).any? do |unnoded|
+            compare(Functions.number(unnoded), op, b)
+          end
         else
-          b = Functions::string( b )
-          return a.collect { |v| compare( Functions::string(v), op, b ) }
+          b = Functions::string(b)
+          each_unnode(a).any? do |unnoded|
+            compare(Functions::string(unnoded), op, b)
+          end
         end
       else
         # If neither is nodeset,
@@ -654,32 +864,52 @@ def equality_relational_compare( set1, op, set2 )
         #     Else, convert to string
         #   Else
         #     Convert both to numbers and compare
-        s1 = set1.to_s
-        s2 = set2.to_s
-        if s1 == 'true' or s1 == 'false' or s2 == 'true' or s2 == 'false'
-          set1 = Functions::boolean( set1 )
-          set2 = Functions::boolean( set2 )
+        compare(set1, op, set2)
+      end
+    end
+
+    def value_type(value)
+      case value
+      when true, false
+        :boolean
+      when Numeric
+        :number
+      when String
+        :string
+      else
+        raise "[BUG] Unexpected value type: <#{value.inspect}>"
+      end
+    end
+
+    def normalize_compare_values(a, operator, b)
+      a_type = value_type(a)
+      b_type = value_type(b)
+      case operator
+      when :eq, :neq
+        if a_type == :boolean or b_type == :boolean
+          a = Functions.boolean(a) unless a_type == :boolean
+          b = Functions.boolean(b) unless b_type == :boolean
+        elsif a_type == :number or b_type == :number
+          a = Functions.number(a) unless a_type == :number
+          b = Functions.number(b) unless b_type == :number
         else
-          if op == :eq or op == :neq
-            if s1 =~ /^\d+(\.\d+)?$/ or s2 =~ /^\d+(\.\d+)?$/
-              set1 = Functions::number( s1 )
-              set2 = Functions::number( s2 )
-            else
-              set1 = Functions::string( set1 )
-              set2 = Functions::string( set2 )
-            end
-          else
-            set1 = Functions::number( set1 )
-            set2 = Functions::number( set2 )
-          end
+          a = Functions.string(a) unless a_type == :string
+          b = Functions.string(b) unless b_type == :string
         end
-        return compare( set1, op, set2 )
+      when :lt, :lteq, :gt, :gteq
+        a = Functions.number(a) unless a_type == :number
+        b = Functions.number(b) unless b_type == :number
+      else
+        message = "[BUG] Unexpected compare operator: " +
+          "<#{operator.inspect}>: <#{a.inspect}>: <#{b.inspect}>"
+        raise message
       end
-      return false
+      [a, b]
     end
 
-    def compare a, op, b
-      case op
+    def compare(a, operator, b)
+      a, b = normalize_compare_values(a, operator, b)
+      case operator
       when :eq
         a == b
       when :neq
@@ -692,13 +922,47 @@ def compare a, op, b
         a > b
       when :gteq
         a >= b
-      when :and
-        a and b
-      when :or
-        a or b
       else
-        false
+        message = "[BUG] Unexpected compare operator: " +
+          "<#{operator.inspect}>: <#{a.inspect}>: <#{b.inspect}>"
+        raise message
+      end
+    end
+
+    def each_unnode(nodeset)
+      return to_enum(__method__, nodeset) unless block_given?
+      nodeset.each do |node|
+        if node.is_a?(XPathNode)
+          unnoded = node.raw_node
+        else
+          unnoded = node
+        end
+        yield(unnoded)
+      end
+    end
+
+    def unnode(nodeset)
+      each_unnode(nodeset).collect do |unnoded|
+        unnoded = yield(unnoded) if block_given?
+        unnoded
+      end
+    end
+  end
+
+  # @private
+  class XPathNode
+    attr_reader :raw_node, :context
+    def initialize(node, context=nil)
+      if node.is_a?(XPathNode)
+        @raw_node = node.raw_node
+      else
+        @raw_node = node
       end
+      @context = context || {}
+    end
+
+    def position
+      @context[:position]
     end
   end
 end
diff --git a/test/rexml/data/t75.xml b/test/rexml/data/t75.xml
index 0911fb1..eb3ccce 100644
--- a/test/rexml/data/t75.xml
+++ b/test/rexml/data/t75.xml
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="ISO-8859-1"?><?pos="3"?>
+<?xml version="1.0" encoding="ISO-8859-1"?>
 <!-- generated by hnb 1.9.17 (http://hnb.sourceforge.net) -->
 
 <!DOCTYPE tree[
diff --git a/test/rexml/formatter/test_default.rb b/test/rexml/formatter/test_default.rb
new file mode 100644
index 0000000..b5b1317
--- /dev/null
+++ b/test/rexml/formatter/test_default.rb
@@ -0,0 +1,19 @@
+require_relative "../rexml_test_utils"
+
+module REXMLTests
+  class DefaultFormatterTest < Test::Unit::TestCase
+    def format(node)
+      formatter = REXML::Formatters::Default.new
+      output = ""
+      formatter.write(node, output)
+      output
+    end
+
+    class InstructionTest < self
+      def test_content_nil
+        instruction = REXML::Instruction.new("target")
+        assert_equal("<?target?>", format(instruction))
+      end
+    end
+  end
+end
diff --git a/test/rexml/functions/test_base.rb b/test/rexml/functions/test_base.rb
new file mode 100644
index 0000000..74dc1a3
--- /dev/null
+++ b/test/rexml/functions/test_base.rb
@@ -0,0 +1,261 @@
+# frozen_string_literal: false
+require "test/unit/testcase"
+
+require "rexml/document"
+
+# TODO: Split me
+module REXMLTests
+  class FunctionsTester < Test::Unit::TestCase
+    include REXML
+
+    def setup
+      super
+      REXML::Functions.context = nil
+    end
+
+    def test_functions
+      # trivial text() test
+      # confuse-a-function
+      source = "<a>more <b id='1'/><b id='2'>dumb</b><b id='3'/><c/> text</a>"
+      doc = Document.new source
+      res = ""
+      XPath::each(doc.root, "text()") {|val| res << val.to_s}
+      assert_equal "more  text", res
+
+      res = XPath::first(doc.root, "b[last()]")
+      assert_equal '3', res.attributes['id']
+      res = XPath::first(doc.root, "b[position()=2]")
+      assert_equal '2', res.attributes['id']
+      res = XPath::first(doc.root, "*[name()='c']")
+      assert_equal "c", res.name
+    end
+
+    # Contributed by Mike Stok
+    def test_starts_with
+      source = <<-EOF
+        <foo>
+        <a href="mailto:a@b.c">a@b.c</a>
+        <a href="http://www.foo.com">http://www.foo.com</a>
+        </foo>
+      EOF
+      doc = Document.new source
+      mailtos = doc.elements.to_a("//a[starts-with(@href, 'mailto:')]")
+      assert_equal 1, mailtos.size
+      assert_equal "mailto:a@b.c", mailtos[0].attributes['href']
+
+      ailtos = doc.elements.to_a("//a[starts-with(@href, 'ailto:')]")
+      assert_equal 0, ailtos.size
+    end
+
+    def test_string_length
+      doc = Document.new <<-EOF
+        <AAA>
+        <Q/>
+        <SSSS/>
+        <BB/>
+        <CCC/>
+        <DDDDDDDD/>
+        <EEEE/>
+        </AAA>
+      EOF
+      assert doc, "create doc"
+
+      set = doc.elements.to_a("//*[string-length(name()) = 3]")
+      assert_equal 2, set.size, "nodes with names length = 3"
+
+      set = doc.elements.to_a("//*[string-length(name()) < 3]")
+      assert_equal 2, set.size, "nodes with names length < 3"
+
+      set = doc.elements.to_a("//*[string-length(name()) > 3]")
+      assert_equal 3, set.size, "nodes with names length > 3"
+    end
+
+    # Test provided by Mike Stok
+    def test_contains
+      source = <<-EOF
+        <foo>
+        <a href="mailto:a@b.c">a@b.c</a>
+        <a href="http://www.foo.com">http://www.foo.com</a>
+        </foo>
+      EOF
+      doc = Document.new source
+
+      [['o', 2], ['foo', 1], ['bar', 0]].each { |test|
+        search, expected = test
+        set = doc.elements.to_a("//a[contains(@href, '#{search}')]")
+        assert_equal expected, set.size
+      }
+    end
+
+    # Mike Stok and Sean Russell
+    def test_substring
+      # examples from http://www.w3.org/TR/xpath#function-substring
+      doc = Document.new('<test string="12345" />')
+
+      #puts XPath.first(d, 'node()[0 + 1]')
+      #d = Document.new("<a b='1'/>")
+      #puts XPath.first(d, 'a[0 mod 0]')
+      [ [1.5, 2.6, '234'],
+        [0, 3, '12'],
+        [0, '0 div 0', ''],
+        [1, '0 div 0', ''],
+        ['-42', '1 div 0', '12345'],
+                          ['-1 div 0', '1 div 0', '']
+      ].each { |start, length, expected|
+        set = doc.elements.to_a("//test[substring(@string, #{start}, #{length}) = '#{expected}']")
+        assert_equal 1, set.size, "#{start}, #{length}, '#{expected}'"
+      }
+    end
+
+    def test_substring_angrez
+      testString = REXML::Functions::substring_after("helloworld","hello")
+      assert_equal( 'world', testString )
+    end
+
+    def test_translate
+      source = <<-EOF
+      <doc>
+      <case name='w3c one' result='BAr' />        <!-- w3c -->
+      <case name='w3c two' result='AAA' />        <!-- w3c -->
+      <case name='alchemy' result="gold" />   <!-- mike -->
+      <case name='vbxml one' result='A Space Odyssey' />
+      <case name='vbxml two' result='AbCdEf' />
+      </doc>
+      EOF
+
+      doc = Document.new(source)
+
+      [ ['bar', 'abc', 'ABC', 'w3c one'],
+        ['--aaa--','abc-','ABC', 'w3c two'],
+        ['lead', 'dear language', 'doll groover', 'alchemy'],
+        ['A Space Odissei', 'i', 'y', 'vbxml one'],
+        ['abcdefg', 'aceg', 'ACE', 'vbxml two'],
+      ].each { |arg1, arg2, arg3, name|
+        translate = "translate('#{arg1}', '#{arg2}', '#{arg3}')"
+        set = doc.elements.to_a("//case[@result = #{translate}]")
+        assert_equal 1, set.size, translate
+        assert_equal name, set[0].attributes['name']
+      }
+    end
+
+    def test_name
+      d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
+      assert_equal 1, d.root.elements.to_a('*[name() = "b"]').size
+      assert_equal 1, d.elements.to_a('//*[name() = "x:b"]').size
+    end
+
+    def test_local_name
+      d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
+      assert_equal 2, d.root.elements.to_a('*[local_name() = "b"]').size
+      assert_equal 2, d.elements.to_a('//*[local_name() = "b"]').size
+    end
+
+    def test_substring2
+      doc = Document.new('<test string="12345" />')
+      assert_equal(1,doc.elements.to_a("//test[substring(@string,2)='2345']").size)
+    end
+
+    # Submitted by Kouhei
+    def test_floor_ceiling_round
+      source = "<a><b id='1'/><b id='2'/><b id='3'/></a>"
+      doc = REXML::Document.new(source)
+
+      id_1 = doc.elements["/a/b[@id='1']"]
+      id_2 = doc.elements["/a/b[@id='2']"]
+      id_3 = doc.elements["/a/b[@id='3']"]
+
+      good = {
+        "floor" => [[], [id_1], [id_2], [id_3]],
+        "ceiling" => [[id_1], [id_2], [id_3], []],
+        "round" => [[id_1], [id_2], [id_3], []]
+      }
+      good.each do |key, value|
+        (0..3).each do |i|
+          xpath = "//b[number(@id) = #{key}(#{i+0.5})]"
+          assert_equal(value[i], REXML::XPath.match(doc, xpath))
+        end
+      end
+
+      good["round"] = [[], [id_1], [id_2], [id_3]]
+      good.each do |key, value|
+        (0..3).each do |i|
+          xpath = "//b[number(@id) = #{key}(#{i+0.4})]"
+          assert_equal(value[i], REXML::XPath.match(doc, xpath))
+        end
+      end
+    end
+
+    # Submitted by Kou
+    def test_lang
+      d = Document.new(<<-XML)
+      <a xml:lang="en">
+      <b xml:lang="ja">
+      <c xml:lang="fr"/>
+      <d/>
+      <e xml:lang="ja-JP"/>
+      <f xml:lang="en-US"/>
+      </b>
+      </a>
+      XML
+
+      assert_equal(1, d.elements.to_a("//*[lang('fr')]").size)
+      assert_equal(3, d.elements.to_a("//*[lang('ja')]").size)
+      assert_equal(2, d.elements.to_a("//*[lang('en')]").size)
+      assert_equal(1, d.elements.to_a("//*[lang('en-us')]").size)
+
+      d = Document.new(<<-XML)
+      <root>
+      <para xml:lang="en"/>
+      <div xml:lang="en"><para/></div>
+      <para xml:lang="EN"/>
+      <para xml:lang="en-us"/>
+      </root>
+      XML
+
+      assert_equal(5, d.elements.to_a("//*[lang('en')]").size)
+    end
+
+    def test_ticket_60
+      document = REXML::Document.new("<a><b>A</b><b>1</b></a>")
+      assert_equal( "A", REXML::XPath.first(document, '//b[.="A"]').text )
+      assert_equal( "1", REXML::XPath.first(document, '//b[.="1"]').text )
+    end
+
+    def test_normalize_space
+      source = "<a><!--COMMENT A--><b><!-- COMMENT A --></b></a>"
+      doc = REXML::Document.new(source)
+      predicate = "string(.)=normalize_space('\nCOMMENT    \n A \n\n ')"
+      m = REXML::XPath.match(doc, "//comment()[#{predicate}]")
+      assert_equal( [REXML::Comment.new("COMMENT A")], m )
+    end
+
+    def test_string_nil_without_context
+      doc = REXML::Document.new(<<-XML)
+      <?xml version="1.0" encoding="UTF-8"?>
+      <root>
+      <foo bar="baz"/>
+      <foo bar=""/>
+      </root>
+      XML
+
+      assert_equal([doc.root.elements[2]],
+                   REXML::XPath.match(doc,
+                                      "//foo[@bar=$n]",
+                                      nil,
+                                      {"n" => nil}))
+    end
+
+    def test_unregistered_method
+      doc = Document.new("<root/>")
+      assert_nil(XPath::first(doc.root, "to_s()"))
+    end
+
+    def test_nonexistent_function
+      doc = Document.new("<root><nonexistent/></root>")
+      # TODO: Maybe, this is not XPath spec behavior.
+      # This behavior must be reconsidered.
+      assert_equal(doc.root.elements[1],
+                   XPath::first(doc.root, "nonexistent()"))
+    end
+  end
+end
diff --git a/test/rexml/functions/test_boolean.rb b/test/rexml/functions/test_boolean.rb
new file mode 100644
index 0000000..b3e2117
--- /dev/null
+++ b/test/rexml/functions/test_boolean.rb
@@ -0,0 +1,75 @@
+# frozen_string_literal: false
+
+require "test/unit"
+require "rexml/document"
+require "rexml/functions"
+
+module REXMLTests
+  class TestFunctionsBoolean < Test::Unit::TestCase
+    def setup
+      REXML::Functions.context = nil
+    end
+
+    def test_true
+      assert_equal(true, REXML::Functions.boolean(true))
+    end
+
+    def test_false
+      assert_equal(false, REXML::Functions.boolean(false))
+    end
+
+    def test_integer_true
+      assert_equal(true, REXML::Functions.boolean(1))
+    end
+
+    def test_integer_positive_zero
+      assert_equal(false, REXML::Functions.boolean(0))
+    end
+
+    def test_integer_negative_zero
+      assert_equal(false, REXML::Functions.boolean(-0))
+    end
+
+    def test_float_true
+      assert_equal(true, REXML::Functions.boolean(1.1))
+    end
+
+    def test_float_positive_zero
+      assert_equal(false, REXML::Functions.boolean(-0.0))
+    end
+
+    def test_float_negative_zero
+      assert_equal(false, REXML::Functions.boolean(-0.0))
+    end
+
+    def test_float_nan
+      assert_equal(false, REXML::Functions.boolean(Float::NAN))
+    end
+
+    def test_string_true
+      assert_equal(true, REXML::Functions.boolean("content"))
+    end
+
+    def test_string_empty
+      assert_equal(false, REXML::Functions.boolean(""))
+    end
+
+    def test_node_set_true
+      root = REXML::Document.new("<root/>").root
+      assert_equal(true, REXML::Functions.boolean([root]))
+    end
+
+    def test_node_set_empty
+      assert_equal(false, REXML::Functions.boolean([]))
+    end
+
+    def test_nil
+      assert_equal(false, REXML::Functions.boolean(nil))
+    end
+
+    def test_context
+      REXML::Functions.context = {node: true}
+      assert_equal(true, REXML::Functions.boolean())
+    end
+  end
+end
diff --git a/test/rexml/functions/test_local_name.rb b/test/rexml/functions/test_local_name.rb
new file mode 100644
index 0000000..97c9e74
--- /dev/null
+++ b/test/rexml/functions/test_local_name.rb
@@ -0,0 +1,44 @@
+# frozen_string_literal: false
+
+require "test/unit"
+require "rexml/document"
+require "rexml/functions"
+
+module REXMLTests
+  class TestFunctionsLocalName < Test::Unit::TestCase
+    def setup
+      REXML::Functions.context = nil
+    end
+
+    def test_one
+      document = REXML::Document.new(<<-XML)
+<root xmlns:x="http://example.com/x/">
+  <x:child/>
+</root>
+      XML
+      node_set = document.root.children
+      assert_equal("child", REXML::Functions.local_name(node_set))
+    end
+
+    def test_multiple
+      document = REXML::Document.new(<<-XML)
+<root xmlns:x="http://example.com/x/">
+  <x:child1/>
+  <x:child2/>
+</root>
+      XML
+      node_set = document.root.children
+      assert_equal("child1", REXML::Functions.local_name(node_set))
+    end
+
+    def test_nonexistent
+      assert_equal("", REXML::Functions.local_name([]))
+    end
+
+    def test_context
+      document = REXML::Document.new("<root/>")
+      REXML::Functions.context = {node: document.root}
+      assert_equal("root", REXML::Functions.local_name())
+    end
+  end
+end
diff --git a/test/rexml/functions/test_number.rb b/test/rexml/functions/test_number.rb
new file mode 100644
index 0000000..16e6357
--- /dev/null
+++ b/test/rexml/functions/test_number.rb
@@ -0,0 +1,38 @@
+# frozen_string_literal: false
+
+require "test/unit"
+require "rexml/document"
+require "rexml/functions"
+
+module REXMLTests
+  class TestFunctionsNumber < Test::Unit::TestCase
+    def setup
+      REXML::Functions.context = nil
+    end
+
+    def test_true
+      assert_equal(1, REXML::Functions.number(true))
+    end
+
+    def test_false
+      assert_equal(0, REXML::Functions.number(false))
+    end
+
+    def test_numeric
+      assert_equal(29, REXML::Functions.number(29))
+    end
+
+    def test_string_integer
+      assert_equal(100, REXML::Functions.number("100"))
+    end
+
+    def test_string_float
+      assert_equal(-9.13, REXML::Functions.number("-9.13"))
+    end
+
+    def test_node_set
+      root = REXML::Document.new("<root>100</root>").root
+      assert_equal(100, REXML::Functions.number([root]))
+    end
+  end
+end
diff --git a/test/rexml/parse/test_document_type_declaration.rb b/test/rexml/parse/test_document_type_declaration.rb
index 80f7088..5571390 100644
--- a/test/rexml/parse/test_document_type_declaration.rb
+++ b/test/rexml/parse/test_document_type_declaration.rb
@@ -5,17 +5,187 @@
 module REXMLTests
   class TestParseDocumentTypeDeclaration < Test::Unit::TestCase
     private
-    def xml(internal_subset)
-      <<-XML
-<!DOCTYPE r SYSTEM "urn:x-rexml:test" [
-#{internal_subset}
-]>
+    def parse(doctype)
+      REXML::Document.new(<<-XML).doctype
+#{doctype}
 <r/>
       XML
     end
 
-    def parse(internal_subset)
-      REXML::Document.new(xml(internal_subset)).doctype
+    class TestName < self
+      def test_valid
+        doctype = parse(<<-DOCTYPE)
+<!DOCTYPE r>
+        DOCTYPE
+        assert_equal("r", doctype.name)
+      end
+
+      def test_garbage_plus_before_name_at_line_start
+        exception = assert_raise(REXML::ParseException) do
+          parse(<<-DOCTYPE)
+<!DOCTYPE +
+r SYSTEM "urn:x-rexml:test" [
+]>
+          DOCTYPE
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed DOCTYPE: invalid name
+Line: 5
+Position: 51
+Last 80 unconsumed characters:
++ r SYSTEM "urn:x-rexml:test" [ ]>  <r/> 
+        DETAIL
+      end
+    end
+
+    class TestExternalID < self
+      class TestSystem < self
+        def test_left_bracket_in_system_literal
+          doctype = parse(<<-DOCTYPE)
+<!DOCTYPE r SYSTEM "urn:x-rexml:[test" [
+]>
+          DOCTYPE
+          assert_equal([
+                         "r",
+                         "SYSTEM",
+                         nil,
+                         "urn:x-rexml:[test",
+                       ],
+                       [
+                         doctype.name,
+                         doctype.external_id,
+                         doctype.public,
+                         doctype.system,
+                       ])
+        end
+
+        def test_greater_than_in_system_literal
+          doctype = parse(<<-DOCTYPE)
+<!DOCTYPE r SYSTEM "urn:x-rexml:>test" [
+]>
+          DOCTYPE
+          assert_equal([
+                         "r",
+                         "SYSTEM",
+                         nil,
+                         "urn:x-rexml:>test",
+                       ],
+                       [
+                         doctype.name,
+                         doctype.external_id,
+                         doctype.public,
+                         doctype.system,
+                       ])
+        end
+
+        def test_no_literal
+          exception = assert_raise(REXML::ParseException) do
+            parse(<<-DOCTYPE)
+<!DOCTYPE r SYSTEM>
+            DOCTYPE
+          end
+          assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed DOCTYPE: system literal is missing
+Line: 3
+Position: 26
+Last 80 unconsumed characters:
+ SYSTEM>  <r/> 
+          DETAIL
+        end
+
+        def test_garbage_after_literal
+          exception = assert_raise(REXML::ParseException) do
+            parse(<<-DOCTYPE)
+<!DOCTYPE r SYSTEM 'r.dtd'x'>
+            DOCTYPE
+          end
+          assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed DOCTYPE: garbage after external ID
+Line: 3
+Position: 36
+Last 80 unconsumed characters:
+x'>  <r/> 
+          DETAIL
+        end
+
+        def test_single_quote
+          doctype = parse(<<-DOCTYPE)
+<!DOCTYPE r SYSTEM 'r".dtd'>
+          DOCTYPE
+          assert_equal("r\".dtd", doctype.system)
+        end
+
+        def test_double_quote
+          doctype = parse(<<-DOCTYPE)
+<!DOCTYPE r SYSTEM "r'.dtd">
+          DOCTYPE
+          assert_equal("r'.dtd", doctype.system)
+        end
+      end
+
+      class TestPublic < self
+        class TestPublicIDLiteral < self
+          def test_content_double_quote
+            exception = assert_raise(REXML::ParseException) do
+              parse(<<-DOCTYPE)
+<!DOCTYPE r PUBLIC 'double quote " is invalid' "r.dtd">
+              DOCTYPE
+            end
+            assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed DOCTYPE: invalid public ID literal
+Line: 3
+Position: 62
+Last 80 unconsumed characters:
+ PUBLIC 'double quote " is invalid' "r.dtd">  <r/> 
+            DETAIL
+          end
+
+          def test_single_quote
+            doctype = parse(<<-DOCTYPE)
+<!DOCTYPE r PUBLIC 'public-id-literal' "r.dtd">
+            DOCTYPE
+            assert_equal("public-id-literal", doctype.public)
+          end
+
+          def test_double_quote
+            doctype = parse(<<-DOCTYPE)
+<!DOCTYPE r PUBLIC "public'-id-literal" "r.dtd">
+            DOCTYPE
+            assert_equal("public'-id-literal", doctype.public)
+          end
+        end
+
+        class TestSystemLiteral < self
+          def test_garbage_after_literal
+            exception = assert_raise(REXML::ParseException) do
+              parse(<<-DOCTYPE)
+<!DOCTYPE r PUBLIC 'public-id-literal' 'system-literal'x'>
+              DOCTYPE
+            end
+            assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed DOCTYPE: garbage after external ID
+Line: 3
+Position: 65
+Last 80 unconsumed characters:
+x'>  <r/> 
+           DETAIL
+          end
+
+          def test_single_quote
+            doctype = parse(<<-DOCTYPE)
+<!DOCTYPE r PUBLIC "public-id-literal" 'system"-literal'>
+            DOCTYPE
+            assert_equal("system\"-literal", doctype.system)
+          end
+
+          def test_double_quote
+            doctype = parse(<<-DOCTYPE)
+<!DOCTYPE r PUBLIC "public-id-literal" "system'-literal">
+            DOCTYPE
+            assert_equal("system'-literal", doctype.system)
+          end
+        end
+      end
     end
 
     class TestMixed < self
@@ -45,6 +215,15 @@ def test_notation_attlist
         assert_equal([REXML::NotationDecl, REXML::AttlistDecl],
                      doctype.children.collect(&:class))
       end
+
+      private
+      def parse(internal_subset)
+        super(<<-DOCTYPE)
+<!DOCTYPE r SYSTEM "urn:x-rexml:test" [
+#{internal_subset}
+]>
+        DOCTYPE
+      end
     end
   end
 end
diff --git a/test/rexml/parse/test_element.rb b/test/rexml/parse/test_element.rb
new file mode 100644
index 0000000..9f172a2
--- /dev/null
+++ b/test/rexml/parse/test_element.rb
@@ -0,0 +1,77 @@
+require "test/unit"
+require "rexml/document"
+
+module REXMLTests
+  class TestParseElement < Test::Unit::TestCase
+    def parse(xml)
+      REXML::Document.new(xml)
+    end
+
+    class TestInvalid < self
+      def test_top_level_end_tag
+        exception = assert_raise(REXML::ParseException) do
+          parse("</a>")
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Unexpected top-level end tag (got 'a')
+Line: 1
+Position: 4
+Last 80 unconsumed characters:
+
+        DETAIL
+      end
+
+      def test_no_end_tag
+        exception = assert_raise(REXML::ParseException) do
+          parse("<a></")
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Missing end tag for 'a'
+Line: 1
+Position: 5
+Last 80 unconsumed characters:
+</
+        DETAIL
+      end
+
+      def test_empty_namespace_attribute_name
+        exception = assert_raise(REXML::ParseException) do
+          parse("<x :a=\"\"></x>")
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Invalid attribute name: <:a="">
+Line: 1
+Position: 9
+Last 80 unconsumed characters:
+
+        DETAIL
+      end
+
+      def test_garbage_less_than_before_root_element_at_line_start
+        exception = assert_raise(REXML::ParseException) do
+          parse("<\n<x/>")
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+malformed XML: missing tag start
+Line: 2
+Position: 6
+Last 80 unconsumed characters:
+< <x/>
+        DETAIL
+      end
+
+      def test_garbage_less_than_slash_before_end_tag_at_line_start
+        exception = assert_raise(REXML::ParseException) do
+          parse("<x></\n</x>")
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Missing end tag for 'x'
+Line: 2
+Position: 10
+Last 80 unconsumed characters:
+</ </x>
+        DETAIL
+      end
+    end
+  end
+end
diff --git a/test/rexml/parse/test_notation_declaration.rb b/test/rexml/parse/test_notation_declaration.rb
index 0d29f0d..19a0536 100644
--- a/test/rexml/parse/test_notation_declaration.rb
+++ b/test/rexml/parse/test_notation_declaration.rb
@@ -23,10 +23,100 @@ def test_name
         doctype = parse("<!NOTATION name PUBLIC 'urn:public-id'>")
         assert_equal("name", doctype.notation("name").name)
       end
+
+      def test_no_name
+        exception = assert_raise(REXML::ParseException) do
+          parse(<<-INTERNAL_SUBSET)
+<!NOTATION>
+          INTERNAL_SUBSET
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: name is missing
+Line: 5
+Position: 72
+Last 80 unconsumed characters:
+ <!NOTATION>  ]> <r/> 
+        DETAIL
+      end
+
+      def test_invalid_name
+        exception = assert_raise(REXML::ParseException) do
+          parse(<<-INTERNAL_SUBSET)
+<!NOTATION '>
+          INTERNAL_SUBSET
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: invalid name
+Line: 5
+Position: 74
+Last 80 unconsumed characters:
+'>  ]> <r/> 
+        DETAIL
+      end
+
+      def test_no_id_type
+        exception = assert_raise(REXML::ParseException) do
+          parse(<<-INTERNAL_SUBSET)
+<!NOTATION name>
+          INTERNAL_SUBSET
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: invalid ID type
+Line: 5
+Position: 77
+Last 80 unconsumed characters:
+>  ]> <r/> 
+        DETAIL
+      end
+
+      def test_invalid_id_type
+        exception = assert_raise(REXML::ParseException) do
+          parse(<<-INTERNAL_SUBSET)
+<!NOTATION name INVALID>
+          INTERNAL_SUBSET
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: invalid ID type
+Line: 5
+Position: 85
+Last 80 unconsumed characters:
+ INVALID>  ]> <r/> 
+        DETAIL
+      end
     end
 
     class TestExternalID < self
       class TestSystem < self
+        def test_no_literal
+          exception = assert_raise(REXML::ParseException) do
+            parse(<<-INTERNAL_SUBSET)
+<!NOTATION name SYSTEM>
+            INTERNAL_SUBSET
+          end
+          assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: system literal is missing
+Line: 5
+Position: 84
+Last 80 unconsumed characters:
+ SYSTEM>  ]> <r/> 
+          DETAIL
+        end
+
+        def test_garbage_after_literal
+          exception = assert_raise(REXML::ParseException) do
+            parse(<<-INTERNAL_SUBSET)
+<!NOTATION name SYSTEM 'system-literal'x'>
+            INTERNAL_SUBSET
+          end
+          assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: garbage before end >
+Line: 5
+Position: 103
+Last 80 unconsumed characters:
+x'>  ]> <r/> 
+          DETAIL
+        end
+
         def test_single_quote
           doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION name SYSTEM 'system-literal'>
@@ -44,6 +134,21 @@ def test_double_quote
 
       class TestPublic < self
         class TestPublicIDLiteral < self
+          def test_content_double_quote
+            exception = assert_raise(REXML::ParseException) do
+              parse(<<-INTERNAL_SUBSET)
+<!NOTATION name PUBLIC 'double quote " is invalid' "system-literal">
+              INTERNAL_SUBSET
+            end
+            assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: invalid public ID literal
+Line: 5
+Position: 129
+Last 80 unconsumed characters:
+ PUBLIC 'double quote " is invalid' "system-literal">  ]> <r/> 
+            DETAIL
+          end
+
           def test_single_quote
             doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION name PUBLIC 'public-id-literal' "system-literal">
@@ -60,6 +165,21 @@ def test_double_quote
         end
 
         class TestSystemLiteral < self
+          def test_garbage_after_literal
+            exception = assert_raise(REXML::ParseException) do
+              parse(<<-INTERNAL_SUBSET)
+<!NOTATION name PUBLIC 'public-id-literal' 'system-literal'x'>
+              INTERNAL_SUBSET
+            end
+            assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: garbage before end >
+Line: 5
+Position: 123
+Last 80 unconsumed characters:
+x'>  ]> <r/> 
+           DETAIL
+          end
+
           def test_single_quote
             doctype = parse(<<-INTERNAL_SUBSET)
 <!NOTATION name PUBLIC "public-id-literal" 'system-literal'>
@@ -96,5 +216,66 @@ def test_public_system
         end
       end
     end
+
+    class TestPublicID < self
+      def test_no_literal
+        exception = assert_raise(REXML::ParseException) do
+          parse(<<-INTERNAL_SUBSET)
+<!NOTATION name PUBLIC>
+          INTERNAL_SUBSET
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: public ID literal is missing
+Line: 5
+Position: 84
+Last 80 unconsumed characters:
+ PUBLIC>  ]> <r/> 
+        DETAIL
+      end
+
+      def test_literal_content_double_quote
+        exception = assert_raise(REXML::ParseException) do
+          parse(<<-INTERNAL_SUBSET)
+<!NOTATION name PUBLIC 'double quote " is invalid in PubidLiteral'>
+          INTERNAL_SUBSET
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: invalid public ID literal
+Line: 5
+Position: 128
+Last 80 unconsumed characters:
+ PUBLIC 'double quote \" is invalid in PubidLiteral'>  ]> <r/> 
+        DETAIL
+      end
+
+      def test_garbage_after_literal
+        exception = assert_raise(REXML::ParseException) do
+          parse(<<-INTERNAL_SUBSET)
+<!NOTATION name PUBLIC 'public-id-literal'x'>
+          INTERNAL_SUBSET
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Malformed notation declaration: garbage before end >
+Line: 5
+Position: 106
+Last 80 unconsumed characters:
+x'>  ]> <r/> 
+        DETAIL
+      end
+
+      def test_literal_single_quote
+        doctype = parse(<<-INTERNAL_SUBSET)
+<!NOTATION name PUBLIC 'public-id-literal'>
+        INTERNAL_SUBSET
+        assert_equal("public-id-literal", doctype.notation("name").public)
+      end
+
+      def test_literal_double_quote
+        doctype = parse(<<-INTERNAL_SUBSET)
+<!NOTATION name PUBLIC "public-id-literal">
+        INTERNAL_SUBSET
+        assert_equal("public-id-literal", doctype.notation("name").public)
+      end
+    end
   end
 end
diff --git a/test/rexml/parse/test_processing_instruction.rb b/test/rexml/parse/test_processing_instruction.rb
new file mode 100644
index 0000000..f0c0c24
--- /dev/null
+++ b/test/rexml/parse/test_processing_instruction.rb
@@ -0,0 +1,44 @@
+require "test/unit"
+require "rexml/document"
+
+module REXMLTests
+  class TestParseProcessinInstruction < Test::Unit::TestCase
+    def parse(xml)
+      REXML::Document.new(xml)
+    end
+
+    class TestInvalid < self
+      def test_no_name
+        exception = assert_raise(REXML::ParseException) do
+          parse("<??>")
+        end
+        assert_equal(<<-DETAIL.chomp, exception.to_s)
+Invalid processing instruction node
+Line: 1
+Position: 4
+Last 80 unconsumed characters:
+<??>
+        DETAIL
+      end
+
+      def test_garbage_text
+        # TODO: This should be parse error.
+        # Create test/parse/test_document.rb or something and move this to it.
+        doc = parse(<<-XML)
+x<?x y
+<!--?><?x -->?>
+<r/>
+        XML
+        pi = doc.children[1]
+        assert_equal([
+                       "x",
+                       "y\n<!--",
+                     ],
+                     [
+                       pi.target,
+                       pi.content,
+                     ])
+      end
+    end
+  end
+end
diff --git a/test/rexml/parser/test_tree.rb b/test/rexml/parser/test_tree.rb
index 7ab0add..8a5d9d1 100644
--- a/test/rexml/parser/test_tree.rb
+++ b/test/rexml/parser/test_tree.rb
@@ -12,7 +12,7 @@ def test_unmatched_close_tag
         parse(xml)
       end
       assert_equal(<<-MESSAGE, exception.to_s)
-Missing end tag for 'root' (got "not-root")
+Missing end tag for 'root' (got 'not-root')
 Line: 1
 Position: #{xml.bytesize}
 Last 80 unconsumed characters:
diff --git a/test/rexml/parser/test_ultra_light.rb b/test/rexml/parser/test_ultra_light.rb
index c48a13d..44fd1d1 100644
--- a/test/rexml/parser/test_ultra_light.rb
+++ b/test/rexml/parser/test_ultra_light.rb
@@ -16,7 +16,6 @@ def test_entity_declaration
                        nil,
                        [:entitydecl, "name", "value"]
                      ],
-                     [:text, "\n"],
                      [:start_element, :parent, "root", {}],
                      [:text, "\n"],
                    ],
@@ -55,7 +54,7 @@ def normalize_child(child)
         normalized_doctype[1] = normalized_parent
         normalized_doctype
       when :start_element
-        tag, parent, name, attributes, *children = child
+        tag, _parent, name, attributes, *children = child
         normalized_parent = :parent
         normalized_children = children.collect do |sub_child|
           normalize_child(sub_child)
diff --git a/test/rexml/rexml_test_utils.rb b/test/rexml/rexml_test_utils.rb
index 7c59629..8bb002c 100644
--- a/test/rexml/rexml_test_utils.rb
+++ b/test/rexml/rexml_test_utils.rb
@@ -1,5 +1,8 @@
 # frozen_string_literal: false
-require 'test/unit'
+
+require "test/unit"
+require "rexml/document"
+
 module REXMLTestUtils
   def fixture_path(*components)
     File.join(File.dirname(__FILE__), "data", *components)
diff --git a/test/rexml/test_attribute.rb b/test/rexml/test_attribute.rb
new file mode 100644
index 0000000..5175bd4
--- /dev/null
+++ b/test/rexml/test_attribute.rb
@@ -0,0 +1,14 @@
+require_relative "rexml_test_utils"
+
+module REXMLTests
+  class AttributeTest < Test::Unit::TestCase
+    def test_empty_prefix
+      error = assert_raise(ArgumentError) do
+        REXML::Attribute.new(":x")
+      end
+      assert_equal("name must be " +
+                   "\#{PREFIX}:\#{LOCAL_NAME} or \#{LOCAL_NAME}: <\":x\">",
+                   error.message)
+    end
+  end
+end
diff --git a/test/rexml/test_core.rb b/test/rexml/test_core.rb
index 0071063..26e5ecd 100644
--- a/test/rexml/test_core.rb
+++ b/test/rexml/test_core.rb
@@ -1,4 +1,4 @@
-# coding: binary
+# -*- coding: utf-8 -*-
 # frozen_string_literal: false
 
 require_relative "rexml_test_utils"
@@ -116,6 +116,54 @@ def test_attribute
         name4='test4'/>).join(' '), e.to_s
     end
 
+    def test_attribute_namespace_conflict
+      # https://www.w3.org/TR/xml-names/#uniqAttrs
+      message = <<-MESSAGE
+Duplicate attribute "a"
+Line: 4
+Position: 140
+Last 80 unconsumed characters:
+      MESSAGE
+      assert_raise_with_message(REXML::ParseException, message) do
+        Document.new(<<-XML)
+<!-- http://www.w3.org is bound to n1 and n2 -->
+<x xmlns:n1="http://www.w3.org"
+   xmlns:n2="http://www.w3.org" >
+  <bad a="1"     a="2" />
+  <bad n1:a="1"  n2:a="2" />
+</x>
+        XML
+      end
+    end
+
+    def test_attribute_default_namespace
+      # https://www.w3.org/TR/xml-names/#uniqAttrs
+      document = Document.new(<<-XML)
+<!-- http://www.w3.org is bound to n1 and is the default -->
+<x xmlns:n1="http://www.w3.org"
+   xmlns="http://www.w3.org" >
+  <good a="1"     b="2" />
+  <good a="1"     n1:a="2" />
+</x>
+      XML
+      attributes = document.root.elements.collect do |element|
+        element.attributes.each_attribute.collect do |attribute|
+          [attribute.prefix, attribute.namespace, attribute.name]
+        end
+      end
+      assert_equal([
+                     [
+                       ["", "", "a"],
+                       ["", "", "b"],
+                     ],
+                     [
+                       ["", "", "a"],
+                       ["n1", "http://www.w3.org", "a"],
+                     ],
+                   ],
+                   attributes)
+    end
+
     def test_cdata
       test = "The quick brown fox jumped
         & < & < \" '
@@ -877,18 +925,18 @@ def test_ticket_51
       EOL
 
       # The most common case.  People not caring about the namespaces much.
-      assert_equal( "XY", XPath.match( doc, "/test/a/text()" ).join )
-      assert_equal( "XY", XPath.match( doc, "/test/x:a/text()" ).join )
+      assert_equal( "XY", XPath.match( doc, "/*:test/*:a/text()" ).join )
+      assert_equal( "XY", XPath.match( doc, "/*:test/x:a/text()" ).join )
       # Surprising?  I don't think so, if you believe my definition of the "common case"
-      assert_equal( "XYZ", XPath.match( doc, "//a/text()" ).join )
+      assert_equal( "XYZ", XPath.match( doc, "//*:a/text()" ).join )
 
       # These are the uncommon cases.  Namespaces are actually important, so we define our own
       # mappings, and pass them in.
       assert_equal( "XY", XPath.match( doc, "/f:test/f:a/text()", { "f" => "1" } ).join )
       # The namespaces are defined, and override the original mappings
-      assert_equal( "", XPath.match( doc, "/test/a/text()", { "f" => "1" } ).join )
+      assert_equal( "XY", XPath.match( doc, "/*:test/*:a/text()", { "f" => "1" } ).join )
       assert_equal( "", XPath.match( doc, "/x:test/x:a/text()", { "f" => "1" } ).join )
-      assert_equal( "", XPath.match( doc, "//a/text()", { "f" => "1" } ).join )
+      assert_equal( "XYZ", XPath.match( doc, "//*:a/text()", { "f" => "1" } ).join )
     end
 
     def test_processing_instruction
@@ -995,7 +1043,7 @@ def test_write_doctype
       document.write(s)
 
       ## XML Doctype
-      str = '<!DOCTYPE foo "bar">'
+      str = '<!DOCTYPE foo SYSTEM "bar">'
       source  = REXML::Source.new(str)
       doctype = REXML::DocType.new(source)
       document.add(doctype)
@@ -1274,14 +1322,15 @@ def test_ticket_76
 
     def test_ticket_21
       src = "<foo bar=value/>"
-      assert_raise( ParseException, "invalid XML should be caught" ) {
-        Document.new(src)
-      }
-      begin
+      exception = assert_raise(ParseException) do
         Document.new(src)
-      rescue
-        assert_match( /missing attribute quote/, $!.message )
       end
+      assert_equal(<<-DETAIL, exception.to_s)
+Missing attribute value start quote: <bar>
+Line: 1
+Position: 16
+Last 80 unconsumed characters:
+      DETAIL
     end
 
     def test_ticket_63
@@ -1390,8 +1439,8 @@ def test_ticket_95
 
     def test_ticket_102
       doc = REXML::Document.new '<doc xmlns="ns"><item name="foo"/></doc>'
-      assert_equal( "foo", doc.root.elements["item"].attribute("name","ns").to_s )
-      assert_equal( "item", doc.root.elements["item[@name='foo']"].name )
+      assert_equal( "foo", doc.root.elements["*:item"].attribute("name","ns").to_s )
+      assert_equal( "item", doc.root.elements["*:item[@name='foo']"].name )
     end
 
     def test_ticket_14
@@ -1420,11 +1469,11 @@ def test_ticket_121
       doc = REXML::Document.new(
         '<doc xmlns="ns" xmlns:phantom="ns"><item name="foo">text</item></doc>'
       )
-      assert_equal 'text', doc.text( "/doc/item[@name='foo']" )
+      assert_equal 'text', doc.text( "/*:doc/*:item[@name='foo']" )
       assert_equal "name='foo'",
-        doc.root.elements["item"].attribute("name", "ns").inspect
+        doc.root.elements["*:item"].attribute("name", "ns").inspect
       assert_equal "<item name='foo'>text</item>",
-        doc.root.elements["item[@name='foo']"].to_s
+        doc.root.elements["*:item[@name='foo']"].to_s
     end
 
     def test_ticket_135
diff --git a/test/rexml/test_doctype.rb b/test/rexml/test_doctype.rb
index 91de05b..915717d 100644
--- a/test/rexml/test_doctype.rb
+++ b/test/rexml/test_doctype.rb
@@ -1,68 +1,82 @@
 # frozen_string_literal: false
-require 'test/unit'
-require 'rexml/document'
+
+require_relative "rexml_test_utils"
 
 module REXMLTests
   class TestDocTypeAccessor < Test::Unit::TestCase
-
     def setup
       @sysid = "urn:x-test:sysid1"
-      @notid1 = "urn:x-test:notation1"
-      @notid2 = "urn:x-test:notation2"
-      document_string1 = <<-"XMLEND"
-      <!DOCTYPE r SYSTEM "#{@sysid}" [
-        <!NOTATION n1 SYSTEM "#{@notid1}">
-        <!NOTATION n2 SYSTEM "#{@notid2}">
+      @notation_id1 = "urn:x-test:notation1"
+      @notation_id2 = "urn:x-test:notation2"
+      xml_system = <<-XML
+      <!DOCTYPE root SYSTEM "#{@sysid}" [
+        <!NOTATION n1 SYSTEM "#{@notation_id1}">
+        <!NOTATION n2 SYSTEM "#{@notation_id2}">
       ]>
-      <r/>
-      XMLEND
-      @doctype1 = REXML::Document.new(document_string1).doctype
+      <root/>
+      XML
+      @doc_type_system = REXML::Document.new(xml_system).doctype
 
       @pubid = "TEST_ID"
-      document_string2 = <<-"XMLEND"
-      <!DOCTYPE r PUBLIC "#{@pubid}">
-      <r/>
-      XMLEND
-      @doctype2 = REXML::Document.new(document_string2).doctype
+      xml_public_system = <<-XML
+      <!DOCTYPE root PUBLIC "#{@pubid}" "#{@sysid}">
+      <root/>
+      XML
+      @doc_type_public_system = REXML::Document.new(xml_public_system).doctype
+    end
 
-      document_string3 = <<-"XMLEND"
-      <!DOCTYPE r PUBLIC "#{@pubid}" "#{@sysid}">
-      <r/>
-      XMLEND
-      @doctype3 = REXML::Document.new(document_string3).doctype
+    def test_public
+      assert_equal([
+                     nil,
+                     @pubid,
+                   ],
+                   [
+                     @doc_type_system.public,
+                     @doc_type_public_system.public,
+                   ])
+    end
 
+    def test_to_s
+      assert_equal("<!DOCTYPE root PUBLIC \"#{@pubid}\" \"#{@sysid}\">",
+                   @doc_type_public_system.to_s)
     end
 
-    def test_public
-      assert_equal(nil, @doctype1.public)
-      assert_equal(@pubid, @doctype2.public)
-      assert_equal(@pubid, @doctype3.public)
+    def test_to_s_apostrophe
+      @doc_type_public_system.parent.context[:prologue_quote] = :apostrophe
+      assert_equal("<!DOCTYPE root PUBLIC '#{@pubid}' '#{@sysid}'>",
+                   @doc_type_public_system.to_s)
     end
 
     def test_system
-      assert_equal(@sysid, @doctype1.system)
-      assert_equal(nil, @doctype2.system)
-      assert_equal(@sysid, @doctype3.system)
+      assert_equal([
+                     @sysid,
+                     @sysid,
+                   ],
+                   [
+                     @doc_type_system.system,
+                     @doc_type_public_system.system,
+                   ])
     end
 
     def test_notation
-      assert_equal(@notid1, @doctype1.notation("n1").system)
-      assert_equal(@notid2, @doctype1.notation("n2").system)
+      assert_equal([
+                     @notation_id1,
+                     @notation_id2,
+                   ],
+                   [
+                     @doc_type_system.notation("n1").system,
+                     @doc_type_system.notation("n2").system,
+                   ])
     end
 
     def test_notations
-      notations = @doctype1.notations
-      assert_equal(2, notations.length)
-      assert_equal(@notid1, find_notation(notations, "n1").system)
-      assert_equal(@notid2, find_notation(notations, "n2").system)
-    end
-
-    def find_notation(notations, name)
-      notations.find { |notation|
-        name == notation.name
-      }
+      notations = @doc_type_system.notations
+      assert_equal([
+                     @notation_id1,
+                     @notation_id2,
+                   ],
+                   notations.collect(&:system))
     end
-
   end
 
   class TestNotationDeclPublic < Test::Unit::TestCase
@@ -82,6 +96,19 @@ def test_to_s_with_uri
                    decl(@id, @uri).to_s)
     end
 
+    def test_to_s_apostrophe
+      document = REXML::Document.new(<<-XML)
+      <!DOCTYPE root SYSTEM "urn:x-test:sysid" [
+        #{decl(@id, @uri).to_s}
+      ]>
+      <root/>
+      XML
+      document.context[:prologue_quote] = :apostrophe
+      notation = document.doctype.notations[0]
+      assert_equal("<!NOTATION #{@name} PUBLIC '#{@id}' '#{@uri}'>",
+                   notation.to_s)
+    end
+
     private
     def decl(id, uri)
       REXML::NotationDecl.new(@name, "PUBLIC", id, uri)
@@ -99,6 +126,19 @@ def test_to_s
                    decl(@id).to_s)
     end
 
+    def test_to_s_apostrophe
+      document = REXML::Document.new(<<-XML)
+      <!DOCTYPE root SYSTEM "urn:x-test:sysid" [
+        #{decl(@id).to_s}
+      ]>
+      <root/>
+      XML
+      document.context[:prologue_quote] = :apostrophe
+      notation = document.doctype.notations[0]
+      assert_equal("<!NOTATION #{@name} SYSTEM '#{@id}'>",
+                   notation.to_s)
+    end
+
     private
     def decl(id)
       REXML::NotationDecl.new(@name, "SYSTEM", id, nil)
diff --git a/test/rexml/test_functions.rb b/test/rexml/test_functions.rb
deleted file mode 100644
index a77be38..0000000
--- a/test/rexml/test_functions.rb
+++ /dev/null
@@ -1,238 +0,0 @@
-# frozen_string_literal: false
-require "test/unit/testcase"
-
-require "rexml/document"
-
-module REXMLTests
-  class FunctionsTester < Test::Unit::TestCase
-    include REXML
-    def test_functions
-      # trivial text() test
-      # confuse-a-function
-      source = "<a>more <b id='1'/><b id='2'>dumb</b><b id='3'/><c/> text</a>"
-      doc = Document.new source
-      res = ""
-      XPath::each(doc.root, "text()") {|val| res << val.to_s}
-      assert_equal "more  text", res
-
-      res = XPath::first(doc.root, "b[last()]")
-      assert_equal '3', res.attributes['id']
-      res = XPath::first(doc.root, "b[position()=2]")
-      assert_equal '2', res.attributes['id']
-      res = XPath::first(doc.root, "*[name()='c']")
-      assert_equal "c", res.name
-    end
-
-    # Contributed by Mike Stok
-    def test_starts_with
-      source = <<-EOF
-        <foo>
-        <a href="mailto:a@b.c">a@b.c</a>
-        <a href="http://www.foo.com">http://www.foo.com</a>
-        </foo>
-      EOF
-      doc = Document.new source
-      mailtos = doc.elements.to_a("//a[starts-with(@href, 'mailto:')]")
-      assert_equal 1, mailtos.size
-      assert_equal "mailto:a@b.c", mailtos[0].attributes['href']
-
-      ailtos = doc.elements.to_a("//a[starts-with(@href, 'ailto:')]")
-      assert_equal 0, ailtos.size
-    end
-
-    def test_string_length
-      doc = Document.new <<-EOF
-        <AAA>
-        <Q/>
-        <SSSS/>
-        <BB/>
-        <CCC/>
-        <DDDDDDDD/>
-        <EEEE/>
-        </AAA>
-      EOF
-      assert doc, "create doc"
-
-      set = doc.elements.to_a("//*[string-length(name()) = 3]")
-      assert_equal 2, set.size, "nodes with names length = 3"
-
-      set = doc.elements.to_a("//*[string-length(name()) < 3]")
-      assert_equal 2, set.size, "nodes with names length < 3"
-
-      set = doc.elements.to_a("//*[string-length(name()) > 3]")
-      assert_equal 3, set.size, "nodes with names length > 3"
-    end
-
-    # Test provided by Mike Stok
-    def test_contains
-      source = <<-EOF
-        <foo>
-        <a href="mailto:a@b.c">a@b.c</a>
-        <a href="http://www.foo.com">http://www.foo.com</a>
-        </foo>
-      EOF
-      doc = Document.new source
-
-      [['o', 2], ['foo', 1], ['bar', 0]].each { |test|
-        search, expected = test
-        set = doc.elements.to_a("//a[contains(@href, '#{search}')]")
-        assert_equal expected, set.size
-      }
-    end
-
-    # Mike Stok and Sean Russell
-    def test_substring
-      # examples from http://www.w3.org/TR/xpath#function-substring
-      doc = Document.new('<test string="12345" />')
-
-      #puts XPath.first(d, 'node()[0 + 1]')
-      #d = Document.new("<a b='1'/>")
-      #puts XPath.first(d, 'a[0 mod 0]')
-      [ [1.5, 2.6, '234'],
-        [0, 3, '12'],
-        [0, '0 div 0', ''],
-        [1, '0 div 0', ''],
-        ['-42', '1 div 0', '12345'],
-                          ['-1 div 0', '1 div 0', '']
-      ].each { |start, length, expected|
-        set = doc.elements.to_a("//test[substring(@string, #{start}, #{length}) = '#{expected}']")
-        assert_equal 1, set.size, "#{start}, #{length}, '#{expected}'"
-      }
-    end
-
-    def test_substring_angrez
-      testString = REXML::Functions::substring_after("helloworld","hello")
-      assert_equal( 'world', testString )
-    end
-
-    def test_translate
-      source = <<-EOF
-      <doc>
-      <case name='w3c one' result='BAr' />        <!-- w3c -->
-      <case name='w3c two' result='AAA' />        <!-- w3c -->
-      <case name='alchemy' result="gold" />   <!-- mike -->
-      <case name='vbxml one' result='A Space Odyssey' />
-      <case name='vbxml two' result='AbCdEf' />
-      </doc>
-      EOF
-
-      doc = Document.new(source)
-
-      [ ['bar', 'abc', 'ABC', 'w3c one'],
-        ['--aaa--','abc-','ABC', 'w3c two'],
-        ['lead', 'dear language', 'doll groover', 'alchemy'],
-        ['A Space Odissei', 'i', 'y', 'vbxml one'],
-        ['abcdefg', 'aceg', 'ACE', 'vbxml two'],
-      ].each { |arg1, arg2, arg3, name|
-        translate = "translate('#{arg1}', '#{arg2}', '#{arg3}')"
-        set = doc.elements.to_a("//case[@result = #{translate}]")
-        assert_equal 1, set.size, translate
-        assert_equal name, set[0].attributes['name']
-      }
-    end
-
-    def test_name
-      d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
-      assert_equal 1, d.root.elements.to_a('*[name() = "b"]').size
-      assert_equal 1, d.elements.to_a('//*[name() = "x:b"]').size
-    end
-
-    def test_local_name
-      d = REXML::Document.new("<a xmlns:x='foo'><b/><x:b/></a>")
-      assert_equal 2, d.root.elements.to_a('*[local_name() = "b"]').size
-      assert_equal 2, d.elements.to_a('//*[local_name() = "b"]').size
-    end
-
-    def test_substring2
-      doc = Document.new('<test string="12345" />')
-      assert_equal(1,doc.elements.to_a("//test[substring(@string,2)='2345']").size)
-    end
-
-    # Submitted by Kouhei
-    def test_floor_ceiling_round
-      source = "<a><b id='1'/><b id='2'/><b id='3'/></a>"
-      doc = REXML::Document.new(source)
-
-      id_1 = doc.elements["/a/b[@id='1']"]
-      id_2 = doc.elements["/a/b[@id='2']"]
-      id_3 = doc.elements["/a/b[@id='3']"]
-
-      good = {
-        "floor" => [[], [id_1], [id_2], [id_3]],
-        "ceiling" => [[id_1], [id_2], [id_3], []],
-        "round" => [[id_1], [id_2], [id_3], []]
-      }
-      good.each do |key, value|
-        (0..3).each do |i|
-          xpath = "//b[number(@id) = #{key}(#{i+0.5})]"
-          assert_equal(value[i], REXML::XPath.match(doc, xpath))
-        end
-      end
-
-      good["round"] = [[], [id_1], [id_2], [id_3]]
-      good.each do |key, value|
-        (0..3).each do |i|
-          xpath = "//b[number(@id) = #{key}(#{i+0.4})]"
-          assert_equal(value[i], REXML::XPath.match(doc, xpath))
-        end
-      end
-    end
-
-    # Submitted by Kou
-    def test_lang
-      d = Document.new(<<-XML)
-      <a xml:lang="en">
-      <b xml:lang="ja">
-      <c xml:lang="fr"/>
-      <d/>
-      <e xml:lang="ja-JP"/>
-      <f xml:lang="en-US"/>
-      </b>
-      </a>
-      XML
-
-      assert_equal(1, d.elements.to_a("//*[lang('fr')]").size)
-      assert_equal(3, d.elements.to_a("//*[lang('ja')]").size)
-      assert_equal(2, d.elements.to_a("//*[lang('en')]").size)
-      assert_equal(1, d.elements.to_a("//*[lang('en-us')]").size)
-
-      d = Document.new(<<-XML)
-      <root>
-      <para xml:lang="en"/>
-      <div xml:lang="en"><para/></div>
-      <para xml:lang="EN"/>
-      <para xml:lang="en-us"/>
-      </root>
-      XML
-
-      assert_equal(5, d.elements.to_a("//*[lang('en')]").size)
-    end
-
-    def test_ticket_60
-      document = REXML::Document.new("<a><b>A</b><b>1</b></a>")
-      assert_equal( "A", REXML::XPath.first(document, '//b[.="A"]').text )
-      assert_equal( "1", REXML::XPath.first(document, '//b[.="1"]').text )
-    end
-
-    def test_normalize_space
-      source = "<a><!--COMMENT A--><b><!-- COMMENT A --></b></a>"
-      doc = REXML::Document.new(source)
-      predicate = "string(.)=normalize_space('\nCOMMENT    \n A \n\n ')"
-      m = REXML::XPath.match(doc, "//comment()[#{predicate}]")
-      assert_equal( [REXML::Comment.new("COMMENT A")], m )
-    end
-
-    def test_unregistered_method
-      doc = Document.new("<root/>")
-      assert_nil(XPath::first(doc.root, "to_s()"))
-    end
-
-    def test_nonexistent_function
-      doc = Document.new("<root><nonexistent/></root>")
-      # TODO: Maybe, this is not XPath spec behavior.
-      # This behavior must be reconsidered.
-      assert_equal(doc.root.elements[1],
-                   XPath::first(doc.root, "nonexistent()"))
-    end
-  end
-end
diff --git a/test/rexml/test_functions_number.rb b/test/rexml/test_functions_number.rb
deleted file mode 100644
index 84ec5c7..0000000
--- a/test/rexml/test_functions_number.rb
+++ /dev/null
@@ -1,35 +0,0 @@
-# frozen_string_literal: false
-require 'rexml/document'
-require 'test/unit'
-require 'rexml/functions'
-
-module REXMLTests
-  class TC_Rexml_Functions_Number < Test::Unit::TestCase
-
-    def test_functions_number_int
-      telem = REXML::Element.new("elem")
-      telem.text="9"
-      assert_equal(9, REXML::Functions::number(telem))
-    end
-    def test_functions_number_float
-      telem = REXML::Element.new("elem")
-      telem.text="10.4"
-      assert_equal(10.4, REXML::Functions::number(telem))
-    end
-    def test_functions_number_negative_int
-      telem = REXML::Element.new("elem")
-      telem.text="-9"
-      assert_equal(-9, REXML::Functions::number(telem))
-    end
-    def test_functions_number_negative_float
-      telem = REXML::Element.new("elem")
-      telem.text="-9.13"
-      assert_equal(-9.13, REXML::Functions::number(telem))
-    end
-    #def test_functions_number_scientific_notation
-    #  telem = REXML::Element.new("elem")
-    #  telem.text="9.13E12"
-    #  assert_equal(9.13E12, REXML::Functions::number(telem))
-    #end
-  end
-end
diff --git a/test/rexml/test_instruction.rb b/test/rexml/test_instruction.rb
new file mode 100644
index 0000000..96fa909
--- /dev/null
+++ b/test/rexml/test_instruction.rb
@@ -0,0 +1,14 @@
+require_relative "rexml_test_utils"
+
+module REXMLTests
+  class InstructionTest < Test::Unit::TestCase
+    def test_target_nil
+      error = assert_raise(ArgumentError) do
+        REXML::Instruction.new(nil)
+      end
+      assert_equal("processing instruction target must be String or " +
+                   "REXML::Instruction: <nil>",
+                   error.message)
+    end
+  end
+end
diff --git a/test/rexml/test_jaxen.rb b/test/rexml/test_jaxen.rb
index 9cd7bee..9640b82 100644
--- a/test/rexml/test_jaxen.rb
+++ b/test/rexml/test_jaxen.rb
@@ -12,119 +12,120 @@ class JaxenTester < Test::Unit::TestCase
     include REXMLTestUtils
     include REXML
 
-    def test_axis ; test("axis") ; end
-    def test_basic ; test("basic") ; end
-    def test_basicupdate ; test("basicupdate") ; end
-    def test_contents ; test("contents") ; end
-    def test_defaultNamespace ; test("defaultNamespace") ; end
-    def test_fibo ; test("fibo") ; end
-    def test_id ; test("id") ; end
-    def test_jaxen24 ; test("jaxen24") ; end
-    def test_lang ; test("lang") ; end
-    def test_message ; test("message") ; end
-    def test_moreover ; test("moreover") ; end
-    def test_much_ado ; test("much_ado") ; end
-    def test_namespaces ; test("namespaces") ; end
-    def test_nitf ; test("nitf") ; end
-    def test_numbers ; test("numbers") ; end
-    def test_pi ; test("pi") ; end
-    def test_pi2 ; test("pi2") ; end
-    def test_simple ; test("simple") ; end
-    def test_testNamespaces ; test("testNamespaces") ; end
-    def test_text ; test("text") ; end
-    def test_underscore ; test("underscore") ; end
-    def test_web ; test("web") ; end
-    def test_web2 ; test("web2") ; end
+    def test_axis ; process_test_case("axis") ; end
+    def test_basic ; process_test_case("basic") ; end
+    def test_basicupdate ; process_test_case("basicupdate") ; end
+    def test_contents ; process_test_case("contents") ; end
+    def test_defaultNamespace ; process_test_case("defaultNamespace") ; end
+    def test_fibo ; process_test_case("fibo") ; end
+    def test_id ; process_test_case("id") ; end
+    def test_jaxen24 ; process_test_case("jaxen24") ; end
+    def test_lang ; process_test_case("lang") ; end
+    # document() function for XSLT isn't supported
+    def _test_message ; process_test_case("message") ; end
+    def test_moreover ; process_test_case("moreover") ; end
+    def test_much_ado ; process_test_case("much_ado") ; end
+    def test_namespaces ; process_test_case("namespaces") ; end
+    def test_nitf ; process_test_case("nitf") ; end
+    # Exception should be considered
+    def _test_numbers ; process_test_case("numbers") ; end
+    def test_pi ; process_test_case("pi") ; end
+    def test_pi2 ; process_test_case("pi2") ; end
+    def test_simple ; process_test_case("simple") ; end
+    # TODO: namespace node is needed
+    def _test_testNamespaces ; process_test_case("testNamespaces") ; end
+    # document() function for XSLT isn't supported
+    def _test_text ; process_test_case("text") ; end
+    def test_underscore ; process_test_case("underscore") ; end
+    def _test_web ; process_test_case("web") ; end
+    def test_web2 ; process_test_case("web2") ; end
 
     private
-    def test( fname )
-#      Dir.entries( xml_dir ).each { |fname|
-#        if fname =~ /\.xml$/
-          doc = File.open(fixture_path(fname+".xml")) do |file|
-            Document.new(file)
-          end
-          XPath.each( doc, "/tests/document" ) {|e| handleDocument(e)}
-#        end
-#      }
+    def process_test_case(name)
+      xml_path = "#{name}.xml"
+      doc = File.open(fixture_path(xml_path)) do |file|
+        Document.new(file)
+      end
+      test_doc = File.open(fixture_path("test/tests.xml")) do |file|
+        Document.new(file)
+      end
+      XPath.each(test_doc,
+                 "/tests/document[@url='xml/#{xml_path}']/context") do |context|
+        process_context(doc, context)
+      end
     end
 
     # processes a tests/document/context node
-    def handleContext( testDoc, ctxElement)
-      testCtx = XPath.match( testDoc, ctxElement.attributes["select"] )[0]
-      namespaces = {}
-      if testCtx.class == Element
-        testCtx.prefixes.each { |pre| handleNamespace( testCtx, pre, namespaces ) }
-      end
+    def process_context(doc, context)
+      test_context = XPath.match(doc, context.attributes["select"])
+      namespaces = context.namespaces
+      namespaces.delete("var")
+      namespaces = nil if namespaces.empty?
       variables = {}
-      XPath.each( ctxElement, "@*[namespace-uri() = 'http://jaxen.org/test-harness/var']") { |attrib| handleVariable(testCtx, variables, attrib) }
-      XPath.each( ctxElement, "valueOf") { |e| handleValueOf(testCtx, variables, namespaces, e) }
-      XPath.each( ctxElement, "test[not(@exception) or (@exception != 'true') ]") { |e| handleNominalTest(testCtx,variables, namespaces, e) }
-      XPath.each( ctxElement, "test[@exception = 'true']") { |e| handleExceptionalTest(testCtx,variables, namespaces, e) }
+      var_namespace = "http://jaxen.org/test-harness/var"
+      XPath.each(context,
+                 "@*[namespace-uri() = '#{var_namespace}']") do |attribute|
+        variables[attribute.name] = attribute.value
+      end
+      XPath.each(context, "valueOf") do |value|
+        process_value_of(test_context, variables, namespaces, value)
+      end
+      XPath.each(context,
+                 "test[not(@exception) or (@exception != 'true')]") do |test|
+        process_nominal_test(test_context, variables, namespaces, test)
+      end
+      XPath.each(context,
+                 "test[@exception = 'true']") do |test|
+        process_exceptional_test(test_context, variables, namespaces, test)
+      end
     end
 
     # processes a tests/document/context/valueOf or tests/document/context/test/valueOf node
-    def handleValueOf(ctx,variables, namespaces, valueOfElement)
-      expected = valueOfElement.text
-      got = XPath.match( ctx, valueOfElement.attributes["select"], namespaces, variables )[0]
-      assert_true( (got.nil? && expected.nil?) || !got.nil? )
-      case got.class
-      when Element
-        assert_equal( got.class, Element )
-      when Attribute, Text, Comment, TrueClass, FalseClass
-        assert_equal( expected, got.to_s )
-      when Instruction
-        assert_equal( expected, got.content )
-      when Integer
-        assert_equal( exected.to_f, got )
-      when String
-        # normalize values for comparison
-        got = "" if got == nil or got == ""
-        expected = "" if expected == nil or expected == ""
-        assert_equal( expected, got )
-      else
-        assert_fail( "Wassup?" )
-      end
-    end
+    def process_value_of(context, variables, namespaces, value_of)
+      expected = value_of.text
+      xpath = value_of.attributes["select"]
+      matched = XPath.match(context, xpath, namespaces, variables, strict: true)
 
+      message = user_message(context, xpath, matched)
+      assert_equal(expected || "",
+                   REXML::Functions.string(matched),
+                   message)
+    end
 
     # processes a tests/document/context/test node ( where @exception is false or doesn't exist )
-    def handleNominalTest(ctx, variables, namespaces, testElement)
-      expected = testElement.attributes["count"]
-      got = XPath.match( ctx, testElement.attributes["select"], namespaces, variables )
+    def process_nominal_test(context, variables, namespaces, test)
+      xpath = test.attributes["select"]
+      matched = XPath.match(context, xpath, namespaces, variables, strict: true)
       # might be a test with no count attribute, but nested valueOf elements
-      assert( expected == got.size.to_s ) if !expected.nil?
+      expected = test.attributes["count"]
+      if expected
+        assert_equal(Integer(expected, 10),
+                     matched.size,
+                     user_message(context, xpath, matched))
+      end
 
-      XPath.each( testElement, "valueOf") { |e|
-        handleValueOf(got, variables, namespaces, e)
-      }
+      XPath.each(test, "valueOf") do |value_of|
+        process_value_of(matched, variables, namespaces, value_of)
+      end
     end
 
     # processes a tests/document/context/test node ( where @exception is true )
-    def handleExceptionalTest(ctx, variables, namespaces, testElement)
-      assert_raise( Exception ) {
-        XPath.match( ctx, testElement.attributes["select"], namespaces, variables )
-      }
-    end
-
-    # processes a tests/document node
-    def handleDocument(docElement)
-      puts "- Processing document: #{docElement.attributes['url']}"
-      testFile = File.new( docElement.attributes["url"] )
-      testDoc = Document.new testFile
-      XPath.each( docElement, "context") { |e| handleContext(testDoc, e) }
-    end
-
-    # processes a variable definition in a namespace like <test var:foo="bar">
-    def handleVariable( ctx, variables, attrib )
-      puts "--- Found attribute: #{attrib.name}"
-      variables[attrib.name] = attrib.value
+    def process_exceptional_test(context, variables, namespaces, test)
+      xpath = test.attributes["select"]
+      assert_raise(REXML::ParseException) do
+        XPath.match(context, xpath, namespaces, variables, strict: true)
+      end
     end
 
-    # processes a namespace definition like <test xmlns:foo="fiz:bang:bam">
-    def handleNamespace( ctx, prefix, namespaces )
-      puts "--- Found namespace: #{prefix}"
-      namespaces[prefix] = ctx.namespaces[prefix]
+    def user_message(context, xpath, matched)
+      message = ""
+      context.each_with_index do |node, i|
+        message << "Node#{i}:\n"
+        message << "#{node}\n"
+      end
+      message << "XPath: <#{xpath}>\n"
+      message << "Matched <#{matched}>"
+      message
     end
-
   end
 end
diff --git a/test/rexml/test_martin_fowler.rb b/test/rexml/test_martin_fowler.rb
index da685a8..add3c82 100644
--- a/test/rexml/test_martin_fowler.rb
+++ b/test/rexml/test_martin_fowler.rb
@@ -3,7 +3,7 @@
 require 'rexml/document'
 
 module REXMLTests
-  class OrderTester < Test::Unit::TestCase
+  class OrderTesterMF < Test::Unit::TestCase
     DOC = <<END
 <paper>
 <title>Remove this element and figs order differently</title>
diff --git a/test/rexml/test_stream.rb b/test/rexml/test_stream.rb
index d7ceedc..08d4462 100644
--- a/test/rexml/test_stream.rb
+++ b/test/rexml/test_stream.rb
@@ -15,8 +15,8 @@ class StreamTester < Test::Unit::TestCase
     def test_listener
       data = %Q{<session1 user="han" password="rootWeiler" />\n<session2 user="han" password="rootWeiler" />}
 
-      b = RequestReader.new( data )
-      b = RequestReader.new( data )
+      RequestReader.new( data )
+      RequestReader.new( data )
     end
 
     def test_ticket_49
diff --git a/test/rexml/test_text.rb b/test/rexml/test_text.rb
index 3f8036e..e9a246e 100644
--- a/test/rexml/test_text.rb
+++ b/test/rexml/test_text.rb
@@ -1,10 +1,57 @@
 # frozen_string_literal: false
-require "rexml/text"
+
+require_relative "rexml_test_utils"
 
 module REXMLTests
   class TextTester < Test::Unit::TestCase
     include REXML
 
+    def test_new_text_response_whitespace_default
+      text = Text.new("a  b\t\tc", true)
+      assert_equal("a b\tc", Text.new(text).to_s)
+    end
+
+    def test_new_text_response_whitespace_true
+      text = Text.new("a  b\t\tc", true)
+      assert_equal("a  b\t\tc", Text.new(text, true).to_s)
+    end
+
+    def test_new_text_raw_default
+      text = Text.new("&amp;lt;", false, nil, true)
+      assert_equal("&amp;lt;", Text.new(text).to_s)
+    end
+
+    def test_new_text_raw_false
+      text = Text.new("&amp;lt;", false, nil, true)
+      assert_equal("&amp;amp;lt;", Text.new(text, false, nil, false).to_s)
+    end
+
+    def test_new_text_entity_filter_default
+      document = REXML::Document.new(<<-XML)
+<!DOCTYPE root [
+  <!ENTITY a "aaa">
+  <!ENTITY b "bbb">
+]>
+<root/>
+      XML
+      text = Text.new("aaa bbb", false, document.root, nil, ["a"])
+      assert_equal("aaa &b;",
+                   Text.new(text, false, document.root).to_s)
+    end
+
+    def test_new_text_entity_filter_custom
+      document = REXML::Document.new(<<-XML)
+<!DOCTYPE root [
+  <!ENTITY a "aaa">
+  <!ENTITY b "bbb">
+]>
+<root/>
+      XML
+      text = Text.new("aaa bbb", false, document.root, nil, ["a"])
+      assert_equal("&a; bbb",
+                   Text.new(text, false, document.root, nil, ["b"]).to_s)
+    end
+
     def test_shift_operator_chain
       text = Text.new("original\r\n")
       text << "append1\r\n" << "append2\r\n"
@@ -18,5 +65,11 @@ def test_shift_operator_cache
       text << "append3\r\n" << "append4\r\n"
       assert_equal("original\nappend1\nappend2\nappend3\nappend4\n", text.to_s)
     end
+
+    def test_clone
+      text = Text.new("&amp;lt; <")
+      assert_equal(text.to_s,
+                   text.clone.to_s)
+    end
   end
 end
diff --git a/test/rexml/test_xml_declaration.rb b/test/rexml/test_xml_declaration.rb
index a4d97c4..da70761 100644
--- a/test/rexml/test_xml_declaration.rb
+++ b/test/rexml/test_xml_declaration.rb
@@ -1,4 +1,3 @@
-# -*- coding: utf-8 -*-
 # frozen_string_literal: false
 #
 #  Created by Henrik Mrtensson on 2007-02-18.
@@ -10,11 +9,11 @@
 module REXMLTests
   class TestXmlDeclaration < Test::Unit::TestCase
     def setup
-      xml = <<-'END_XML'
+      xml = <<-XML
       <?xml encoding= 'UTF-8' standalone='yes'?>
       <root>
       </root>
-      END_XML
+      XML
       @doc = REXML::Document.new xml
       @root = @doc.root
       @xml_declaration = @doc.children[0]
@@ -32,5 +31,18 @@ def test_has_sibling
       assert_kind_of(REXML::XMLDecl, @root.previous_sibling.previous_sibling)
       assert_kind_of(REXML::Element, @xml_declaration.next_sibling.next_sibling)
     end
+
+    def test_write_prologue_quote
+      @doc.context[:prologue_quote] = :quote
+      assert_equal("<?xml version=\"1.0\" " +
+                   "encoding=\"UTF-8\" standalone=\"yes\"?>",
+                   @xml_declaration.to_s)
+    end
+
+    def test_is_writethis_attribute_copied_by_clone
+      assert_equal(true, @xml_declaration.clone.writethis)
+      @xml_declaration.nowrite
+      assert_equal(false, @xml_declaration.clone.writethis)
+    end
   end
 end
diff --git a/test/rexml/xpath/test_attribute.rb b/test/rexml/xpath/test_attribute.rb
index 9304db4..713d77b 100644
--- a/test/rexml/xpath/test_attribute.rb
+++ b/test/rexml/xpath/test_attribute.rb
@@ -7,7 +7,7 @@ class TestXPathAttribute < Test::Unit::TestCase
     def setup
       @xml = <<-XML
 <?xml version="1.0" encoding="UTF-8"?>
-<root>
+<root xmlns="http://example.com/">
   <child name="one">child1</child>
   <child name="two">child2</child>
   <child name="three">child3</child>
@@ -26,5 +26,13 @@ def test_xpath_each
       children = REXML::XPath.each(@document, "/root/child[@name='two']")
       assert_equal(["child2"], children.collect(&:text))
     end
+
+    def test_no_namespace
+      children = REXML::XPath.match(@document,
+                                    "/root/child[@nothing:name='two']",
+                                    "" => "http://example.com/",
+                                    "nothing" => "")
+      assert_equal(["child2"], children.collect(&:text))
+    end
   end
 end
diff --git a/test/rexml/xpath/test_base.rb b/test/rexml/xpath/test_base.rb
index 5079fdd..210d6c7 100644
--- a/test/rexml/xpath/test_base.rb
+++ b/test/rexml/xpath/test_base.rb
@@ -369,11 +369,15 @@ def test_complex
       assert_equal 2, c
     end
 
+    def match(xpath)
+      XPath.match(@@doc, xpath).collect(&:to_s)
+    end
+
     def test_grouping
-      t = XPath.first( @@doc, "a/d/*[name()='d' and (name()='f' or name()='q')]" )
-      assert_nil t
-      t = XPath.first( @@doc, "a/d/*[(name()='d' and name()='f') or name()='q']" )
-      assert_equal 'q', t.name
+      assert_equal([],
+                   match("a/d/*[name()='d' and (name()='f' or name()='q')]"))
+      assert_equal(["<q id='19'/>"],
+                   match("a/d/*[(name()='d' and name()='f') or name()='q']"))
     end
 
     def test_preceding
@@ -632,29 +636,36 @@ def test_spaces
           <c id='a'/>
         </b>
         <c id='b'/>
+        <c id='c'/>
+        <c/>
       </a>")
-      assert_equal( 1, REXML::XPath.match(doc,
-        "//*[local-name()='c' and @id='b']").size )
-      assert_equal( 1, REXML::XPath.match(doc,
-        "//*[ local-name()='c' and @id='b' ]").size )
-      assert_equal( 1, REXML::XPath.match(doc,
-        "//*[ local-name() = 'c' and @id = 'b' ]").size )
-      assert_equal( 1,
-        REXML::XPath.match(doc, '/a/c[@id]').size )
-      assert_equal( 1,
-        REXML::XPath.match(doc, '/a/c[(@id)]').size )
-      assert_equal( 1,
-        REXML::XPath.match(doc, '/a/c[ @id ]').size )
-      assert_equal( 1,
-        REXML::XPath.match(doc, '/a/c[ (@id) ]').size )
-      assert_equal( 1,
-        REXML::XPath.match(doc, '/a/c[( @id )]').size )
-      assert_equal( 1, REXML::XPath.match(doc.root,
-        '/a/c[ ( @id ) ]').size )
-      assert_equal( 1, REXML::XPath.match(doc,
-        '/a/c [ ( @id ) ] ').size )
-      assert_equal( 1, REXML::XPath.match(doc,
-        ' / a / c [ ( @id ) ] ').size )
+      match = lambda do |xpath|
+        REXML::XPath.match(doc, xpath).collect(&:to_s)
+      end
+      assert_equal(["<c id='b'/>"],
+                   match.call("//*[local-name()='c' and @id='b']"))
+      assert_equal(["<c id='b'/>"],
+                   match.call("//*[ local-name()='c' and @id='b' ]"))
+      assert_equal(["<c id='b'/>"],
+                   match.call("//*[ local-name() = 'c' and @id = 'b' ]"))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[@id]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[(@id)]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[ @id ]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[ (@id) ]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[( @id )]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c[ ( @id ) ]'))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/a/c [ ( @id ) ] '))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call(' / a / c [ ( @id ) ] '))
+      assert_equal(["<c id='b'/>", "<c id='c'/>"],
+                   match.call('/ a / child:: c [( @id )] /'))
     end
 
     def test_text_nodes
@@ -692,11 +703,22 @@ def test_auto_string_value
     end
 
     def test_ordering
-      source = "<a><b><c id='1'/><c id='2'/></b><b><d id='1'/><d id='2'/></b></a>"
+      source = <<-XML
+<a>
+  <b>
+    <c id='1'/>
+    <c id='2'/>
+  </b>
+  <b>
+    <d id='3'/>
+    <d id='4'/>
+  </b>
+</a>
+      XML
       d = REXML::Document.new( source )
       r = REXML::XPath.match( d, %q{/a/*/*[1]} )
-      assert_equal( 1, r.size )
-      r.each { |el| assert_equal( '1', el.attribute('id').value ) }
+      assert_equal(["1", "3"],
+                   r.collect {|element| element.attribute("id").value})
     end
 
     def test_descendant_or_self_ordering
@@ -830,31 +852,44 @@ def test_a_star_star_one
 </a>
       EOL
       d = REXML::Document.new( string )
-      c1 = XPath.match( d, '/a/*/*[1]' )
-      assert_equal( 1, c1.length )
-      assert_equal( 'c1', c1[0].name )
+      cs = XPath.match( d, '/a/*/*[1]' )
+      assert_equal(["c1", "c2"], cs.collect(&:name))
     end
 
     def test_sum
-      d = Document.new("<a>"+
-      "<b>1</b><b>2</b><b>3</b>"+
-      "<c><d>1</d><d>2</d></c>"+
-      "<e att='1'/><e att='2'/>"+
-      "</a>")
-
-      for v,p in [[6, "sum(/a/b)"],
-        [9, "sum(//b | //d)"],
-        [3, "sum(/a/e/@*)"] ]
-        assert_equal( v, XPath::match( d, p ).first )
-      end
+      d = Document.new(<<-XML)
+<a>
+  <b>1</b>
+  <b>2</b>
+  <b>3</b>
+  <c>
+    <d>1</d>
+    <d>2</d>
+  </c>
+  <e att='1'/>
+  <e att='2'/>
+</a>
+      XML
+
+      assert_equal([6], XPath::match(d, "sum(/a/b)"))
+      assert_equal([9], XPath::match(d, "sum(//b | //d)"))
+      assert_equal([3], XPath::match(d, "sum(/a/e/@*)"))
     end
 
     def test_xpath_namespace
-      d = REXML::Document.new("<tag1 xmlns='ns1'><tag2 xmlns='ns2'/><tada>xa</tada></tag1>")
-      x = d.root
-      num = 0
-      x.each_element('tada') {  num += 1 }
-      assert_equal(1, num)
+      d = REXML::Document.new(<<-XML)
+<tag1 xmlns='ns1'>
+  <tag2 xmlns='ns2'/>
+  <tada>xa</tada>
+  <tada xmlns=''>xb</tada>
+</tag1>
+      XML
+      actual = []
+      d.root.each_element('tada') do |element|
+        actual << element.to_s
+      end
+      assert_equal(["<tada>xa</tada>", "<tada xmlns=''>xb</tada>"],
+                   actual)
     end
 
     def test_ticket_39
@@ -990,7 +1025,7 @@ def test_ticket_59
       </a>"
       d = Document.new(data)
       res = d.elements.to_a( "//c" ).collect {|e| e.attributes['id'].to_i}
-      assert_equal( res, res.sort )
+      assert_equal((1..12).to_a, res)
     end
 
     def ticket_61_fixture(doc, xpath)
diff --git a/test/rexml/xpath/test_compare.rb b/test/rexml/xpath/test_compare.rb
new file mode 100644
index 0000000..bb666c9
--- /dev/null
+++ b/test/rexml/xpath/test_compare.rb
@@ -0,0 +1,256 @@
+# frozen_string_literal: false
+
+require_relative "../rexml_test_utils"
+
+require "rexml/document"
+
+module REXMLTests
+  class TestXPathCompare < Test::Unit::TestCase
+    def match(xml, xpath)
+      document = REXML::Document.new(xml)
+      REXML::XPath.match(document, xpath)
+    end
+
+    class TestEqual < self
+      class TestNodeSet < self
+        def test_boolean_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child/>
+  <child/>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child=true()"))
+        end
+
+        def test_boolean_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+</root>
+        XML
+          assert_equal([false],
+                       match(xml, "/root/child=true()"))
+        end
+
+        def test_number_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child=100"))
+        end
+
+        def test_number_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([false],
+                       match(xml, "/root/child=300"))
+        end
+
+        def test_string_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>text</child>
+  <child>string</child>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child='string'"))
+        end
+
+        def test_string_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>text</child>
+  <child>string</child>
+</root>
+          XML
+          assert_equal([false],
+                       match(xml, "/root/child='nonexistent'"))
+        end
+      end
+
+      class TestBoolean < self
+        def test_number_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "true()=1"))
+        end
+
+        def test_number_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "true()=0"))
+        end
+
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "true()='string'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "true()=''"))
+        end
+      end
+
+      class TestNumber < self
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "1='1'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "1='2'"))
+        end
+      end
+    end
+
+    class TestGreaterThan < self
+      class TestNodeSet < self
+        def test_boolean_truex
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child/>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child>false()"))
+        end
+
+        def test_boolean_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child/>
+</root>
+        XML
+          assert_equal([false],
+                       match(xml, "/root/child>true()"))
+        end
+
+        def test_number_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child>199"))
+        end
+
+        def test_number_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([false],
+                       match(xml, "/root/child>200"))
+        end
+
+        def test_string_true
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([true],
+                       match(xml, "/root/child>'199'"))
+        end
+
+        def test_string_false
+          xml = <<-XML
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+  <child>100</child>
+  <child>200</child>
+</root>
+          XML
+          assert_equal([false],
+                       match(xml, "/root/child>'200'"))
+        end
+      end
+
+      class TestBoolean < self
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "true()>'0'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "true()>'1'"))
+        end
+      end
+
+      class TestNumber < self
+        def test_boolean_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "true()>0"))
+        end
+
+        def test_number_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "true()>1"))
+        end
+
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "1>'0'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "1>'1'"))
+        end
+      end
+
+      class TestString < self
+        def test_string_true
+          xml = "<root/>"
+          assert_equal([true],
+                       match(xml, "'1'>'0'"))
+        end
+
+        def test_string_false
+          xml = "<root/>"
+          assert_equal([false],
+                       match(xml, "'1'>'1'"))
+        end
+      end
+    end
+  end
+end
