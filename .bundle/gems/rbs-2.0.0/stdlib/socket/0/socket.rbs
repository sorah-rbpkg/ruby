# Class `Socket` provides access to the underlying operating system socket
# implementations.  It can be used to provide more operating system specific
# functionality than the protocol-specific socket classes.
#
# The constants defined under Socket::Constants are also defined under Socket.
# For example, Socket::AF_INET is usable as well as Socket::Constants::AF_INET.
# See Socket::Constants for the list of constants.
#
# ### What's a socket?
#
# Sockets are endpoints of a bidirectional communication channel. Sockets can
# communicate within a process, between processes on the same machine or between
# different machines.  There are many types of socket: TCPSocket, UDPSocket or
# UNIXSocket for example.
#
# Sockets have their own vocabulary:
#
# **domain:** The family of protocols:
# *   Socket::PF_INET
# *   Socket::PF_INET6
# *   Socket::PF_UNIX
# *   etc.
#
#
# **type:** The type of communications between the two endpoints, typically
# *   Socket::SOCK_STREAM
# *   Socket::SOCK_DGRAM.
#
#
# **protocol:** Typically *zero*. This may be used to identify a variant of a
# protocol.
#
# **hostname:** The identifier of a network interface:
# *   a string (hostname, IPv4 or IPv6 address or `broadcast` which specifies a
#     broadcast address)
# *   a zero-length string which specifies INADDR_ANY
# *   an integer (interpreted as binary address in host byte order).
#
#
# ### Quick start
#
# Many of the classes, such as TCPSocket, UDPSocket or UNIXSocket, ease the use
# of sockets comparatively to the equivalent C programming interface.
#
# Let's create an internet socket using the IPv4 protocol in a C-like manner:
#
#     require 'socket'
#
#     s = Socket.new Socket::AF_INET, Socket::SOCK_STREAM
#     s.connect Socket.pack_sockaddr_in(80, 'example.com')
#
# You could also use the TCPSocket class:
#
#     s = TCPSocket.new 'example.com', 80
#
# A simple server might look like this:
#
#     require 'socket'
#
#     server = TCPServer.new 2000 # Server bound to port 2000
#
#     loop do
#       client = server.accept    # Wait for a client to connect
#       client.puts "Hello !"
#       client.puts "Time is #{Time.now}"
#       client.close
#     end
#
# A simple client may look like this:
#
#     require 'socket'
#
#     s = TCPSocket.new 'localhost', 2000
#
#     while line = s.gets # Read lines from socket
#       puts line         # and print them
#     end
#
#     s.close             # close socket when done
#
# ### Exception Handling
#
# Ruby's Socket implementation raises exceptions based on the error generated by
# the system dependent implementation.  This is why the methods are documented
# in a way that isolate Unix-based system exceptions from Windows based
# exceptions. If more information on a particular exception is needed, please
# refer to the Unix manual pages or the Windows WinSock reference.
#
# ### Convenience methods
#
# Although the general way to create socket is Socket.new, there are several
# methods of socket creation for most cases.
#
# TCP client socket
# :   Socket.tcp, TCPSocket.open
# TCP server socket
# :   Socket.tcp_server_loop, TCPServer.open
# UNIX client socket
# :   Socket.unix, UNIXSocket.open
# UNIX server socket
# :   Socket.unix_server_loop, UNIXServer.open
#
#
# ### Documentation by
#
# *   Zach Dennis
# *   Sam Roberts
# *   *Programming Ruby* from The Pragmatic Bookshelf.
#
#
# Much material in this documentation is taken with permission from *Programming
# Ruby* from The Pragmatic Bookshelf.
class Socket < BasicSocket
  # yield socket and client address for each a connection accepted via given
  # sockets.
  #
  # The arguments are a list of sockets. The individual argument should be a
  # socket or an array of sockets.
  #
  # This method yields the block sequentially. It means that the next connection
  # is not accepted until the block returns. So concurrent mechanism, thread for
  # example, should be used to service multiple clients at a time.
  #
  def self.accept_loop: (*_ToIO sockets) { (Socket) -> void } -> void

  # Obtains address information for *nodename*:*servname*.
  #
  # Note that Addrinfo.getaddrinfo provides the same functionality in an object
  # oriented style.
  #
  # *family* should be an address family such as: :INET, :INET6, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the family, and defaults to 0 for
  # the family.
  #
  # *flags* should be bitwise OR of Socket::AI_* constants.
  #
  #     Socket.getaddrinfo("www.ruby-lang.org", "http", nil, :STREAM)
  #     #=> [["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68", 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP
  #
  #     Socket.getaddrinfo("localhost", nil)
  #     #=> [["AF_INET", 0, "localhost", "127.0.0.1", 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP
  #     #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP
  #     #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP
  #
  # *reverse_lookup* directs the form of the third element, and has to be one of
  # below.  If *reverse_lookup* is omitted, the default value is `nil`.
  #
  #     +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.
  #     +false+, +:numeric+:  hostname is same as numeric address.
  #     +nil+:              obey to the current +do_not_reverse_lookup+ flag.
  #
  # If Addrinfo object is preferred, use Addrinfo.getaddrinfo.
  #
  def self.getaddrinfo: (String peer, String | Integer | nil protocol, ?(Integer | Symbol | nil) family, ?(Integer | Symbol | nil) socktype, ?(Integer | Symbol | nil) protocol, ?(Integer | nil) flags) -> [String, Integer, String, String, Integer, Integer, Integer]

  # Use Addrinfo#getnameinfo instead. This method is deprecated for the following
  # reasons:
  #
  # *   Uncommon address representation: 4/16-bytes binary string to represent
  #     IPv4/IPv6 address.
  # *   gethostbyaddr() may take a long time and it may block other threads. (GVL
  #     cannot be released since gethostbyname() is not thread safe.)
  # *   This method uses gethostbyname() function already removed from POSIX.
  #
  #
  # This method obtains the host information for *address*.
  #
  #     p Socket.gethostbyaddr([221,186,184,68].pack("CCCC"))
  #     #=> ["carbon.ruby-lang.org", [], 2, "\xDD\xBA\xB8D"]
  #
  #     p Socket.gethostbyaddr([127,0,0,1].pack("CCCC"))
  #     ["localhost", [], 2, "\x7F\x00\x00\x01"]
  #     p Socket.gethostbyaddr(([0]*15+[1]).pack("C"*16))
  #     #=> ["localhost", ["ip6-localhost", "ip6-loopback"], 10,
  #          "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01"]
  #
  def self.gethostbyaddr: (String ip) -> [String, Array[String], Integer, String]

  # Use Addrinfo.getaddrinfo instead. This method is deprecated for the following
  # reasons:
  #
  # *   The 3rd element of the result is the address family of the first address.
  #     The address families of the rest of the addresses are not returned.
  # *   Uncommon address representation: 4/16-bytes binary string to represent
  #     IPv4/IPv6 address.
  # *   gethostbyname() may take a long time and it may block other threads. (GVL
  #     cannot be released since gethostbyname() is not thread safe.)
  # *   This method uses gethostbyname() function already removed from POSIX.
  #
  #
  # This method obtains the host information for *hostname*.
  #
  #     p Socket.gethostbyname("hal") #=> ["localhost", ["hal"], 2, "\x7F\x00\x00\x01"]
  #
  def self.gethostbyname: (String name) -> [String, Array[String], Integer, String]

  # Returns the hostname.
  #
  #     p Socket.gethostname #=> "hal"
  #
  # Note that it is not guaranteed to be able to convert to IP address using
  # gethostbyname, getaddrinfo, etc. If you need local IP address, use
  # Socket.ip_address_list.
  #
  def self.gethostname: () -> String

  # Returns an array of interface addresses. An element of the array is an
  # instance of Socket::Ifaddr.
  #
  # This method can be used to find multicast-enabled interfaces:
  #
  #     pp Socket.getifaddrs.reject {|ifaddr|
  #       !ifaddr.addr.ip? || (ifaddr.flags & Socket::IFF_MULTICAST == 0)
  #     }.map {|ifaddr| [ifaddr.name, ifaddr.ifindex, ifaddr.addr] }
  #     #=> [["eth0", 2, #<Addrinfo: 221.186.184.67>],
  #     #    ["eth0", 2, #<Addrinfo: fe80::216:3eff:fe95:88bb%eth0>]]
  #
  # Example result on GNU/Linux:
  #     pp Socket.getifaddrs
  #     #=> [#<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 PACKET[protocol=0 lo hatype=772 HOST hwaddr=00:00:00:00:00:00]>,
  #     #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=00:16:3e:95:88:bb] broadcast=PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=ff:ff:ff:ff:ff:ff]>,
  #     #    #<Socket::Ifaddr sit0 NOARP PACKET[protocol=0 sit0 hatype=776 HOST hwaddr=00:00:00:00]>,
  #     #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 127.0.0.1 netmask=255.0.0.0>,
  #     #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 221.186.184.67 netmask=255.255.255.240 broadcast=221.186.184.79>,
  #     #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
  #     #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 fe80::216:3eff:fe95:88bb%eth0 netmask=ffff:ffff:ffff:ffff::>]
  #
  # Example result on FreeBSD:
  #     pp Socket.getifaddrs
  #     #=> [#<Socket::Ifaddr usbus0 UP,0x10000 LINK[usbus0]>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 LINK[re0 3a:d0:40:9a:fe:e8]>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 10.250.10.18 netmask=255.255.255.? (7 bytes for 16 bytes sockaddr_in) broadcast=10.250.10.255>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 fe80:2::38d0:40ff:fe9a:fee8 netmask=ffff:ffff:ffff:ffff::>,
  #     #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 2001:2e8:408:10::12 netmask=UNSPEC>,
  #     #    #<Socket::Ifaddr plip0 POINTOPOINT,MULTICAST,0x800 LINK[plip0]>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST LINK[lo0]>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST fe80:4::1 netmask=ffff:ffff:ffff:ffff::>,
  #     #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST 127.0.0.1 netmask=255.?.?.? (5 bytes for 16 bytes sockaddr_in)>]
  #
  def self.getifaddrs: () -> Array[Socket::Ifaddr]

  # Obtains name information for *sockaddr*.
  #
  # *sockaddr* should be one of follows.
  # *   packed sockaddr string such as Socket.sockaddr_in(80, "127.0.0.1")
  # *   3-elements array such as ["AF_INET", 80, "127.0.0.1"]
  # *   4-elements array such as ["AF_INET", 80, ignored, "127.0.0.1"]
  #
  #
  # *flags* should be bitwise OR of Socket::NI_* constants.
  #
  # Note: The last form is compatible with IPSocket#addr and IPSocket#peeraddr.
  #
  #     Socket.getnameinfo(Socket.sockaddr_in(80, "127.0.0.1"))       #=> ["localhost", "www"]
  #     Socket.getnameinfo(["AF_INET", 80, "127.0.0.1"])              #=> ["localhost", "www"]
  #     Socket.getnameinfo(["AF_INET", 80, "localhost", "127.0.0.1"]) #=> ["localhost", "www"]
  #
  # If Addrinfo object is preferred, use Addrinfo#getnameinfo.
  #
  def self.getnameinfo: ([String, Integer, String]) -> Array[String]
                      | ([String, Integer, String, String]) -> Array[String]
                      | (String sockaddr) -> Array[String]
  # Obtains the port number for *service_name*.
  #
  # If *protocol_name* is not given, "tcp" is assumed.
  #
  #     Socket.getservbyname("smtp")          #=> 25
  #     Socket.getservbyname("shell")         #=> 514
  #     Socket.getservbyname("syslog", "udp") #=> 514
  #
  #
  def self.getservbyname: (String service_proto) -> Integer
                        | (String service_proto, String layer4_proto) -> Integer

  # Obtains the port number for *port*.
  #
  # If *protocol_name* is not given, "tcp" is assumed.
  #
  #     Socket.getservbyport(80)         #=> "www"
  #     Socket.getservbyport(514, "tcp") #=> "shell"
  #     Socket.getservbyport(514, "udp") #=> "syslog"
  #
  def self.getservbyport: (Integer service_port) -> String
                        | (Integer service_port, String layer4_proto) -> String

  # Returns local IP addresses as an array.
  #
  # The array contains Addrinfo objects.
  #
  #     pp Socket.ip_address_list
  #     #=> [#<Addrinfo: 127.0.0.1>,
  #          #<Addrinfo: 192.168.0.128>,
  #          #<Addrinfo: ::1>,
  #          ...]
  #
  def self.ip_address_list: () -> Array[Addrinfo]

  # Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.
  #
  #     Socket.sockaddr_in(80, "127.0.0.1")
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  #     Socket.sockaddr_in(80, "::1")
  #     #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  #
  #
  def self.pack_sockaddr_in: (Integer port, String ip) -> String

  # Packs *path* as an AF_UNIX sockaddr string.
  #
  #     Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."
  #
  #
  def self.pack_sockaddr_un: (String sockpath) -> String

  # Creates a pair of sockets connected each other.
  #
  # *domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain, defaults to 0 for the
  # domain.
  #
  #     s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     s1.close
  #     p s2.recv(10) #=> "ab"
  #     p s2.recv(10) #=> ""
  #     p s2.recv(10) #=> ""
  #
  #     s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "a"
  #     p s2.recv(10) #=> "b"
  #
  #
  def self.pair: (Symbol sockdomain, Symbol socktype, Integer protocol) -> [instance, instance]

  # Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.
  #
  #     Socket.sockaddr_in(80, "127.0.0.1")
  #     #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #
  #     Socket.sockaddr_in(80, "::1")
  #     #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
  #
  #
  def self.sockaddr_in: (Integer port, String ip) -> String

  # Packs *path* as an AF_UNIX sockaddr string.
  #
  #     Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."
  #
  #
  def self.sockaddr_un: (String sockpath) -> String

  # Creates a pair of sockets connected each other.
  #
  # *domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* should be a protocol defined in the domain, defaults to 0 for the
  # domain.
  #
  #     s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     s1.close
  #     p s2.recv(10) #=> "ab"
  #     p s2.recv(10) #=> ""
  #     p s2.recv(10) #=> ""
  #
  #     s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
  #     s1.send "a", 0
  #     s1.send "b", 0
  #     p s2.recv(10) #=> "a"
  #     p s2.recv(10) #=> "b"
  #
  #
  def self.socketpair: (Symbol sockdomain, Symbol socktype, Integer protocol) -> [instance, instance]

  # creates a new socket object connected to host:port using TCP/IP.
  #
  # If local_host:local_port is given, the socket is bound to it.
  #
  # The optional last argument *opts* is options represented by a hash. *opts* may
  # have following options:
  #
  # :connect_timeout
  # :   specify the timeout in seconds.
  # :resolv_timeout
  # :   specify the name resolution timeout in seconds.
  #
  #
  # If a block is given, the block is called with the socket. The value of the
  # block is returned. The socket is closed when this method returns.
  #
  # If no block is given, the socket is returned.
  #
  #     Socket.tcp("www.ruby-lang.org", 80) {|sock|
  #       sock.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
  #       sock.close_write
  #       puts sock.read
  #     }
  #
  #
  def self.tcp: (String host, Integer port, ?String local_host, ?Integer local_port, ?resolv_timeout: Numeric, ?connect_timeout: Numeric) -> instance
              | (String host, Integer port, ?String local_host, ?Integer local_port, ?resolv_timeout: Numeric, ?connect_timeout: Numeric) { (instance) -> void } -> void

  # creates a TCP/IP server on *port* and calls the block for each connection
  # accepted. The block is called with a socket and a client_address as an
  # Addrinfo object.
  #
  # If *host* is specified, it is used with *port* to determine the server
  # addresses.
  #
  # The socket is **not** closed when the block returns. So application should
  # close it explicitly.
  #
  # This method calls the block sequentially. It means that the next connection is
  # not accepted until the block returns. So concurrent mechanism, thread for
  # example, should be used to service multiple clients at a time.
  #
  # Note that Addrinfo.getaddrinfo is used to determine the server socket
  # addresses. When Addrinfo.getaddrinfo returns two or more addresses, IPv4 and
  # IPv6 address for example, all of them are used. Socket.tcp_server_loop
  # succeeds if one socket can be used at least.
  #
  #     # Sequential echo server.
  #     # It services only one client at a time.
  #     Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  #       begin
  #         IO.copy_stream(sock, sock)
  #       ensure
  #         sock.close
  #       end
  #     }
  #
  #     # Threaded echo server
  #     # It services multiple clients at a time.
  #     # Note that it may accept connections too much.
  #     Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
  #       Thread.new {
  #         begin
  #           IO.copy_stream(sock, sock)
  #         ensure
  #           sock.close
  #         end
  #       }
  #     }
  #
  def self.tcp_server_loop: (?String host, Integer port) { (instance, Addrinfo) -> void } -> void

  # creates TCP/IP server sockets for *host* and *port*. *host* is optional.
  #
  # If no block given, it returns an array of listening sockets.
  #
  # If a block is given, the block is called with the sockets. The value of the
  # block is returned. The socket is closed when this method returns.
  #
  # If *port* is 0, actual port number is chosen dynamically. However all sockets
  # in the result has same port number.
  #
  #     # tcp_server_sockets returns two sockets.
  #     sockets = Socket.tcp_server_sockets(1296)
  #     p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
  #
  #     # The sockets contains IPv6 and IPv4 sockets.
  #     sockets.each {|s| p s.local_address }
  #     #=> #<Addrinfo: [::]:1296 TCP>
  #     #   #<Addrinfo: 0.0.0.0:1296 TCP>
  #
  #     # IPv6 and IPv4 socket has same port number, 53114, even if it is chosen dynamically.
  #     sockets = Socket.tcp_server_sockets(0)
  #     sockets.each {|s| p s.local_address }
  #     #=> #<Addrinfo: [::]:53114 TCP>
  #     #   #<Addrinfo: 0.0.0.0:53114 TCP>
  #
  #     # The block is called with the sockets.
  #     Socket.tcp_server_sockets(0) {|sockets|
  #       p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
  #     }
  #
  def self.tcp_server_sockets: (?String host, Integer port) -> Array[TCPServer]
                             | (?String host, Integer port) { (Array[TCPServer]) -> void } -> void

  # creates a UDP/IP server on *port* and calls the block for each message
  # arrived. The block is called with the message and its source information.
  #
  # This method allocates sockets internally using *port*. If *host* is specified,
  # it is used conjunction with *port* to determine the server addresses.
  #
  # The *msg* is a string.
  #
  # The *msg_src* is a Socket::UDPSource object. It is used for reply.
  #
  #     # UDP/IP echo server.
  #     Socket.udp_server_loop(9261) {|msg, msg_src|
  #       msg_src.reply msg
  #     }
  #
  #
  def self.udp_server_loop: (?String host, Integer port) { (String, Socket::UDPSource) -> void } -> void

  # Run UDP/IP server loop on the given sockets.
  #
  # The return value of Socket.udp_server_sockets is appropriate for the argument.
  #
  # It calls the block for each message received.
  #
  def self.udp_server_loop_on: (UDPSocket sockets) { (String, Socket::UDPSource) -> void } -> void

  # Receive UDP/IP packets from the given *sockets*. For each packet received, the
  # block is called.
  #
  # The block receives *msg* and *msg_src*. *msg* is a string which is the payload
  # of the received packet. *msg_src* is a Socket::UDPSource object which is used
  # for reply.
  #
  # Socket.udp_server_loop can be implemented using this method as follows.
  #
  #     udp_server_sockets(host, port) {|sockets|
  #       loop {
  #         readable, _, _ = IO.select(sockets)
  #         udp_server_recv(readable) {|msg, msg_src| ... }
  #       }
  #     }
  #
  def self.udp_server_recv: (Array[UDPSocket] sockets) { (String, Socket::UDPSource) -> void } -> void

  # Creates UDP/IP sockets for a UDP server.
  #
  # If no block given, it returns an array of sockets.
  #
  # If a block is given, the block is called with the sockets. The value of the
  # block is returned. The sockets are closed when this method returns.
  #
  # If *port* is zero, some port is chosen. But the chosen port is used for the
  # all sockets.
  #
  #     # UDP/IP echo server
  #     Socket.udp_server_sockets(0) {|sockets|
  #       p sockets.first.local_address.ip_port     #=> 32963
  #       Socket.udp_server_loop_on(sockets) {|msg, msg_src|
  #         msg_src.reply msg
  #       }
  #     }
  #
  def self.udp_server_sockets: (?String host, Integer port) { (UDPSocket) -> void } -> void

  # creates a new socket connected to path using UNIX socket socket.
  #
  # If a block is given, the block is called with the socket. The value of the
  # block is returned. The socket is closed when this method returns.
  #
  # If no block is given, the socket is returned.
  #
  #     # talk to /tmp/sock socket.
  #     Socket.unix("/tmp/sock") {|sock|
  #       t = Thread.new { IO.copy_stream(sock, STDOUT) }
  #       IO.copy_stream(STDIN, sock)
  #       t.join
  #     }
  #
  def self.unix: (String path) -> UNIXSocket
               | (String path) { (UNIXSocket) -> void } -> void

  # creates a UNIX socket server on *path*. It calls the block for each socket
  # accepted.
  #
  # If *host* is specified, it is used with *port* to determine the server ports.
  #
  # The socket is **not** closed when the block returns. So application should
  # close it.
  #
  # This method deletes the socket file pointed by *path* at first if the file is
  # a socket file and it is owned by the user of the application. This is safe
  # only if the directory of *path* is not changed by a malicious user. So don't
  # use /tmp/malicious-users-directory/socket. Note that /tmp/socket and
  # /tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit.
  #
  #     # Sequential echo server.
  #     # It services only one client at a time.
  #     Socket.unix_server_loop("/tmp/sock") {|sock, client_addrinfo|
  #       begin
  #         IO.copy_stream(sock, sock)
  #       ensure
  #         sock.close
  #       end
  #     }
  #
  def self.unix_server_loop: (String path) { (UNIXSocket, Addrinfo) -> void } -> void

  # creates a UNIX server socket on *path*
  #
  # If no block given, it returns a listening socket.
  #
  # If a block is given, it is called with the socket and the block value is
  # returned. When the block exits, the socket is closed and the socket file is
  # removed.
  #
  #     socket = Socket.unix_server_socket("/tmp/s")
  #     p socket                  #=> #<Socket:fd 3>
  #     p socket.local_address    #=> #<Addrinfo: /tmp/s SOCK_STREAM>
  #
  #     Socket.unix_server_socket("/tmp/sock") {|s|
  #       p s                     #=> #<Socket:fd 3>
  #       p s.local_address       #=> # #<Addrinfo: /tmp/sock SOCK_STREAM>
  #     }
  #
  def self.unix_server_socket: (String path) -> Socket
                             | (String path) { (Socket) -> void } -> void

  # Unpacks *sockaddr* into port and ip_address.
  #
  # *sockaddr* should be a string or an addrinfo for AF_INET/AF_INET6.
  #
  #     sockaddr = Socket.sockaddr_in(80, "127.0.0.1")
  #     p sockaddr #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
  #     p Socket.unpack_sockaddr_in(sockaddr) #=> [80, "127.0.0.1"]
  #
  def self.unpack_sockaddr_in: (String | Addrinfo sockaddr) -> [Integer, String]

  # Unpacks *sockaddr* into path.
  #
  # *sockaddr* should be a string or an addrinfo for AF_UNIX.
  #
  #     sockaddr = Socket.sockaddr_un("/tmp/sock")
  #     p Socket.unpack_sockaddr_un(sockaddr) #=> "/tmp/sock"
  #
  def self.unpack_sockaddr_un: (String path) -> String

  public

  # Accepts a next connection. Returns a new Socket object and Addrinfo object.
  #
  #     serv = Socket.new(:INET, :STREAM, 0)
  #     serv.listen(5)
  #     c = Socket.new(:INET, :STREAM, 0)
  #     c.connect(serv.connect_address)
  #     p serv.accept #=> [#<Socket:fd 6>, #<Addrinfo: 127.0.0.1:48555 TCP>]
  #
  def accept: () -> [Socket, Addrinfo]

  # Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
  # underlying file descriptor. It returns an array containing the accepted socket
  # for the incoming connection, *client_socket*, and an Addrinfo,
  # *client_addrinfo*.
  #
  # ### Example
  #     # In one script, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.bind(sockaddr)
  #     socket.listen(5)
  #     begin # emulate blocking accept
  #       client_socket, client_addrinfo = socket.accept_nonblock
  #     rescue IO::WaitReadable, Errno::EINTR
  #       IO.select([socket])
  #       retry
  #     end
  #     puts "The client said, '#{client_socket.readline.chomp}'"
  #     client_socket.puts "Hello from script one!"
  #     socket.close
  #
  #     # In another script, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.connect(sockaddr)
  #     socket.puts "Hello from script 2."
  #     puts "The server said, '#{socket.readline.chomp}'"
  #     socket.close
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # *accept_nonblock* fails.
  #
  # Socket#accept_nonblock may raise any error corresponding to accept(2) failure,
  # including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or
  # Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
  # used to rescue the exceptions for retrying accept_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # accept_nonblock should not raise an IO::WaitReadable exception, but return the
  # symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#accept
  #
  #
  def accept_nonblock: (?exception: boolish) -> ([Socket, Addrinfo] | :wait_readable)

  # Binds to the given local address.
  #
  # ### Parameter
  # *   `local_sockaddr` - the `struct` sockaddr contained in a string or an
  #     Addrinfo object
  #
  #
  # ### Example
  #     require 'socket'
  #
  #     # use Addrinfo
  #     socket = Socket.new(:INET, :STREAM, 0)
  #     socket.bind(Addrinfo.tcp("127.0.0.1", 2222))
  #     p socket.local_address #=> #<Addrinfo: 127.0.0.1:2222 TCP>
  #
  #     # use struct sockaddr
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #
  # ### Unix-based Exceptions
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *bind* fails:
  # *   Errno::EACCES - the specified *sockaddr* is protected and the current user
  #     does not have permission to bind to it
  # *   Errno::EADDRINUSE - the specified *sockaddr* is already in use
  # *   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
  #     local machine
  # *   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
  #     the family of the calling `socket`
  # *   Errno::EBADF - the *sockaddr* specified is not a valid file descriptor
  # *   Errno::EFAULT - the *sockaddr* argument cannot be accessed
  # *   Errno::EINVAL - the `socket` is already bound to an address, and the
  #     protocol does not support binding to the new *sockaddr* or the `socket`
  #     has been shut down.
  # *   Errno::EINVAL - the address length is not a valid length for the address
  #     family
  # *   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
  #     PATH_MAX
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOSR - there were insufficient STREAMS resources available to
  #     complete the operation
  # *   Errno::ENOTSOCK - the `socket` does not refer to a socket
  # *   Errno::EOPNOTSUPP - the socket type of the `socket` does not support
  #     binding to an address
  #
  #
  # On unix-based based systems if the address family of the calling `socket` is
  # Socket::AF_UNIX the follow exceptions may be raised if the call to *bind*
  # fails:
  # *   Errno::EACCES - search permission is denied for a component of the prefix
  #     path or write access to the `socket` is denied
  # *   Errno::EDESTADDRREQ - the *sockaddr* argument is a null pointer
  # *   Errno::EISDIR - same as Errno::EDESTADDRREQ
  # *   Errno::EIO - an i/o error occurred
  # *   Errno::ELOOP - too many symbolic links were encountered in translating the
  #     pathname in *sockaddr*
  # *   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
  #     characters, or an entire pathname exceeded PATH_MAX characters
  # *   Errno::ENOENT - a component of the pathname does not name an existing file
  #     or the pathname is an empty string
  # *   Errno::ENOTDIR - a component of the path prefix of the pathname in
  #     *sockaddr* is not a directory
  # *   Errno::EROFS - the name would reside on a read only filesystem
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *bind* fails:
  # *   Errno::ENETDOWN-- the network is down
  # *   Errno::EACCES - the attempt to connect the datagram socket to the
  #     broadcast address failed
  # *   Errno::EADDRINUSE - the socket's local address is already in use
  # *   Errno::EADDRNOTAVAIL - the specified address is not a valid address for
  #     this computer
  # *   Errno::EFAULT - the socket's internal address or address length parameter
  #     is too small or is not a valid part of the user space addressed
  # *   Errno::EINVAL - the `socket` is already bound to an address
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
  #
  #
  # ### See
  # *   bind manual pages on unix-based systems
  # *   bind function in Microsoft's Winsock functions reference
  #
  #
  def bind: (String | Addrinfo local_sockaddr) -> void

  # Requests a connection to be made on the given `remote_sockaddr`. Returns 0 if
  # successful, otherwise an exception is raised.
  #
  # ### Parameter
  # *   `remote_sockaddr` - the `struct` sockaddr contained in a string or
  #     Addrinfo object
  #
  #
  # ### Example:
  #     # Pull down Google's web page
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
  #     socket.connect( sockaddr )
  #     socket.write( "GET / HTTP/1.0\r\n\r\n" )
  #     results = socket.read
  #
  # ### Unix-based Exceptions
  # On unix-based systems the following system exceptions may be raised if the
  # call to *connect* fails:
  # *   Errno::EACCES - search permission is denied for a component of the prefix
  #     path or write access to the `socket` is denied
  # *   Errno::EADDRINUSE - the *sockaddr* is already in use
  # *   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
  #     local machine
  # *   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
  #     the address family of the specified `socket`
  # *   Errno::EALREADY - a connection is already in progress for the specified
  #     socket
  # *   Errno::EBADF - the `socket` is not a valid file descriptor
  # *   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
  #     connections refused the connection request
  # *   Errno::ECONNRESET - the remote host reset the connection request
  # *   Errno::EFAULT - the *sockaddr* cannot be accessed
  # *   Errno::EHOSTUNREACH - the destination host cannot be reached (probably
  #     because the host is down or a remote router cannot reach it)
  # *   Errno::EINPROGRESS - the O_NONBLOCK is set for the `socket` and the
  #     connection cannot be immediately established; the connection will be
  #     established asynchronously
  # *   Errno::EINTR - the attempt to establish the connection was interrupted by
  #     delivery of a signal that was caught; the connection will be established
  #     asynchronously
  # *   Errno::EISCONN - the specified `socket` is already connected
  # *   Errno::EINVAL - the address length used for the *sockaddr* is not a valid
  #     length for the address family or there is an invalid family in *sockaddr*
  # *   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
  #     PATH_MAX
  # *   Errno::ENETDOWN - the local interface used to reach the destination is
  #     down
  # *   Errno::ENETUNREACH - no route to the network is present
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOSR - there were insufficient STREAMS resources available to
  #     complete the operation
  # *   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the calling `socket` is listening and cannot be
  #     connected
  # *   Errno::EPROTOTYPE - the *sockaddr* has a different type than the socket
  #     bound to the specified peer address
  # *   Errno::ETIMEDOUT - the attempt to connect time out before a connection was
  #     made.
  #
  #
  # On unix-based systems if the address family of the calling `socket` is AF_UNIX
  # the follow exceptions may be raised if the call to *connect* fails:
  # *   Errno::EIO - an i/o error occurred while reading from or writing to the
  #     file system
  # *   Errno::ELOOP - too many symbolic links were encountered in translating the
  #     pathname in *sockaddr*
  # *   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
  #     characters, or an entire pathname exceeded PATH_MAX characters
  # *   Errno::ENOENT - a component of the pathname does not name an existing file
  #     or the pathname is an empty string
  # *   Errno::ENOTDIR - a component of the path prefix of the pathname in
  #     *sockaddr* is not a directory
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *connect* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use
  # *   Errno::EINTR - the socket was cancelled
  # *   Errno::EINPROGRESS - a blocking socket is in progress or the service
  #     provider is still processing a callback function. Or a nonblocking connect
  #     call is in progress on the `socket`.
  # *   Errno::EALREADY - see Errno::EINVAL
  # *   Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
  #     ADDR_ANY TODO check ADDRANY TO INADDR_ANY
  # *   Errno::EAFNOSUPPORT - addresses in the specified family cannot be used
  #     with with this `socket`
  # *   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
  #     connections refused the connection request
  # *   Errno::EFAULT - the socket's internal address or address length parameter
  #     is too small or is not a valid part of the user space address
  # *   Errno::EINVAL - the `socket` is a listening socket
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::ENETUNREACH - the network cannot be reached from this host at this
  #     time
  # *   Errno::EHOSTUNREACH - no route to the network is present
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
  # *   Errno::ETIMEDOUT - the attempt to connect time out before a connection was
  #     made.
  # *   Errno::EWOULDBLOCK - the socket is marked as nonblocking and the
  #     connection cannot be completed immediately
  # *   Errno::EACCES - the attempt to connect the datagram socket to the
  #     broadcast address failed
  #
  #
  # ### See
  # *   connect manual pages on unix-based systems
  # *   connect function in Microsoft's Winsock functions reference
  #
  #
  def connect: (String | Addrinfo remote_sockaddr) -> Integer

  # Requests a connection to be made on the given `remote_sockaddr` after
  # O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful,
  # otherwise an exception is raised.
  #
  # ### Parameter
  #     # +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object
  #
  # ### Example:
  #     # Pull down Google's web page
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(80, 'www.google.com')
  #     begin # emulate blocking connect
  #       socket.connect_nonblock(sockaddr)
  #     rescue IO::WaitWritable
  #       IO.select(nil, [socket]) # wait 3-way handshake completion
  #       begin
  #         socket.connect_nonblock(sockaddr) # check connection failure
  #       rescue Errno::EISCONN
  #       end
  #     end
  #     socket.write("GET / HTTP/1.0\r\n\r\n")
  #     results = socket.read
  #
  # Refer to Socket#connect for the exceptions that may be thrown if the call to
  # *connect_nonblock* fails.
  #
  # Socket#connect_nonblock may raise any error corresponding to connect(2)
  # failure, including Errno::EINPROGRESS.
  #
  # If the exception is Errno::EINPROGRESS, it is extended by IO::WaitWritable. So
  # IO::WaitWritable can be used to rescue the exceptions for retrying
  # connect_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # connect_nonblock should not raise an IO::WaitWritable exception, but return
  # the symbol `:wait_writable` instead.
  #
  # ### See
  #     # Socket#connect
  #
  def connect_nonblock: (untyped addr, ?exception: untyped) -> (Integer | :wait_writable)

  # enable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available.
  #
  def ipv6only!: () -> void

  # Listens for connections, using the specified `int` as the backlog. A call to
  # *listen* only applies if the `socket` is of type SOCK_STREAM or
  # SOCK_SEQPACKET.
  #
  # ### Parameter
  # *   `backlog` - the maximum length of the queue for pending connections.
  #
  #
  # ### Example 1
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #
  # ### Example 2 (listening on an arbitrary port, unix-based systems only):
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     socket.listen( 1 )
  #
  # ### Unix-based Exceptions
  # On unix based systems the above will work because a new `sockaddr` struct is
  # created on the address ADDR_ANY, for an arbitrary port number as handed off by
  # the kernel. It will not work on Windows, because Windows requires that the
  # `socket` is bound by calling *bind* before it can *listen*.
  #
  # If the *backlog* amount exceeds the implementation-dependent maximum queue
  # length, the implementation's maximum queue length will be used.
  #
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *listen* fails:
  # *   Errno::EBADF - the *socket* argument is not a valid file descriptor
  # *   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
  #     the protocol does not support listening on an unbound socket
  # *   Errno::EINVAL - the *socket* is already connected
  # *   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
  # *   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
  # *   Errno::EACCES - the calling process does not have appropriate privileges
  # *   Errno::EINVAL - the *socket* has been shut down
  # *   Errno::ENOBUFS - insufficient resources are available in the system to
  #     complete the call
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *listen* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EADDRINUSE - the socket's local address is already in use. This
  #     usually occurs during the execution of *bind* but could be delayed if the
  #     call to *bind* was to a partially wildcard address (involving ADDR_ANY)
  #     and if a specific address needs to be committed at the time of the call to
  #     *listen*
  # *   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
  #     service provider is still processing a callback function
  # *   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
  # *   Errno::EISCONN - the `socket` is already connected
  # *   Errno::EMFILE - no more socket descriptors are available
  # *   Errno::ENOBUFS - no buffer space is available
  # *   Errno::ENOTSOC - `socket` is not a socket
  # *   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
  #     the *listen* method
  #
  #
  # ### See
  # *   listen manual pages on unix-based systems
  # *   listen function in Microsoft's Winsock functions reference
  #
  #
  def listen: (Integer backlog_len) -> void

  # Receives up to *maxlen* bytes from `socket`. *flags* is zero or more of the
  # `MSG_` options. The first element of the results, *mesg*, is the data
  # received. The second element, *sender_addrinfo*, contains protocol-specific
  # address information of the sender.
  #
  # ### Parameters
  # *   `maxlen` - the maximum number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  #
  #
  # ### Example
  #     # In one file, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #     client, client_addrinfo = socket.accept
  #     data = client.recvfrom( 20 )[0].chomp
  #     puts "I only received 20 bytes '#{data}'"
  #     sleep 1
  #     socket.close
  #
  #     # In another file, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.connect( sockaddr )
  #     socket.puts "Watch this get cut short!"
  #     socket.close
  #
  # ### Unix-based Exceptions
  # On unix-based based systems the following system exceptions may be raised if
  # the call to *recvfrom* fails:
  # *   Errno::EAGAIN - the `socket` file descriptor is marked as O_NONBLOCK and
  #     no data is waiting to be received; or MSG_OOB is set and no out-of-band
  #     data is available and either the `socket` file descriptor is marked as
  #     O_NONBLOCK or the `socket` does not support blocking to wait for
  #     out-of-band-data
  # *   Errno::EWOULDBLOCK - see Errno::EAGAIN
  # *   Errno::EBADF - the `socket` is not a valid file descriptor
  # *   Errno::ECONNRESET - a connection was forcibly closed by a peer
  # *   Errno::EFAULT - the socket's internal buffer, address or address length
  #     cannot be accessed or written
  # *   Errno::EINTR - a signal interrupted *recvfrom* before any data was
  #     available
  # *   Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
  #     available
  # *   Errno::EIO - an i/o error occurred while reading from or writing to the
  #     filesystem
  # *   Errno::ENOBUFS - insufficient resources were available in the system to
  #     perform the operation
  # *   Errno::ENOMEM - insufficient memory was available to fulfill the request
  # *   Errno::ENOSR - there were insufficient STREAMS resources available to
  #     complete the operation
  # *   Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
  #     is not connected
  # *   Errno::ENOTSOCK - the `socket` does not refer to a socket
  # *   Errno::EOPNOTSUPP - the specified flags are not supported for this socket
  #     type
  # *   Errno::ETIMEDOUT - the connection timed out during connection
  #     establishment or due to a transmission timeout on an active connection
  #
  #
  # ### Windows Exceptions
  # On Windows systems the following system exceptions may be raised if the call
  # to *recvfrom* fails:
  # *   Errno::ENETDOWN - the network is down
  # *   Errno::EFAULT - the internal buffer and from parameters on `socket` are
  #     not part of the user address space, or the internal fromlen parameter is
  #     too small to accommodate the peer address
  # *   Errno::EINTR - the (blocking) call was cancelled by an internal call to
  #     the WinSock function WSACancelBlockingCall
  # *   Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
  #     the service provider is still processing a callback function
  # *   Errno::EINVAL - `socket` has not been bound with a call to *bind*, or an
  #     unknown flag was specified, or MSG_OOB was specified for a socket with
  #     SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal
  #     len parameter on `socket` was zero or negative
  # *   Errno::EISCONN - `socket` is already connected. The call to *recvfrom* is
  #     not permitted with a connected socket on a socket that is connection
  #     oriented or connectionless.
  # *   Errno::ENETRESET - the connection has been broken due to the keep-alive
  #     activity detecting a failure while the operation was in progress.
  # *   Errno::EOPNOTSUPP - MSG_OOB was specified, but `socket` is not
  #     stream-style such as type SOCK_STREAM. OOB data is not supported in the
  #     communication domain associated with `socket`, or `socket` is
  #     unidirectional and supports only send operations
  # *   Errno::ESHUTDOWN - `socket` has been shutdown. It is not possible to call
  #     *recvfrom* on a socket after *shutdown* has been invoked.
  # *   Errno::EWOULDBLOCK - `socket` is marked as nonblocking and a  call to
  #     *recvfrom* would block.
  # *   Errno::EMSGSIZE - the message was too large to fit into the specified
  #     buffer and was truncated.
  # *   Errno::ETIMEDOUT - the connection has been dropped, because of a network
  #     failure or because the system on the other end went down without notice
  # *   Errno::ECONNRESET - the virtual circuit was reset by the remote side
  #     executing a hard or abortive close. The application should close the
  #     socket; it is no longer usable. On a UDP-datagram socket this error
  #     indicates a previous send operation resulted in an ICMP Port Unreachable
  #     message.
  #
  #
  #
  def recvfrom: (Integer maxlen, ?Integer flags) -> [String, Addrinfo]

  # Receives up to *maxlen* bytes from `socket` using recvfrom(2) after O_NONBLOCK
  # is set for the underlying file descriptor. *flags* is zero or more of the
  # `MSG_` options. The first element of the results, *mesg*, is the data
  # received. The second element, *sender_addrinfo*, contains protocol-specific
  # address information of the sender.
  #
  # When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string
  # as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP,
  # etc.
  #
  # ### Parameters
  # *   `maxlen` - the maximum number of bytes to receive from the socket
  # *   `flags` - zero or more of the `MSG_` options
  # *   `outbuf` - destination String buffer
  # *   `opts` - keyword hash, supporting `exception: false`
  #
  #
  # ### Example
  #     # In one file, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.bind(sockaddr)
  #     socket.listen(5)
  #     client, client_addrinfo = socket.accept
  #     begin # emulate blocking recvfrom
  #       pair = client.recvfrom_nonblock(20)
  #     rescue IO::WaitReadable
  #       IO.select([client])
  #       retry
  #     end
  #     data = pair[0].chomp
  #     puts "I only received 20 bytes '#{data}'"
  #     sleep 1
  #     socket.close
  #
  #     # In another file, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
  #     sockaddr = Socket.sockaddr_in(2200, 'localhost')
  #     socket.connect(sockaddr)
  #     socket.puts "Watch this get cut short!"
  #     socket.close
  #
  # Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
  # *recvfrom_nonblock* fails.
  #
  # Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
  # failure, including Errno::EWOULDBLOCK.
  #
  # If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
  # IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
  # retrying recvfrom_nonblock.
  #
  # By specifying a keyword argument *exception* to `false`, you can indicate that
  # recvfrom_nonblock should not raise an IO::WaitReadable exception, but return
  # the symbol `:wait_readable` instead.
  #
  # ### See
  # *   Socket#recvfrom
  #
  #
  def recvfrom_nonblock: (Integer maxlen, ?Integer flags, ?untyped outbuf, ?exception: boolish) -> ([String, Addrinfo] | :wait_readable)

  # Accepts an incoming connection returning an array containing the (integer)
  # file descriptor for the incoming connection, *client_socket_fd*, and an
  # Addrinfo, *client_addrinfo*.
  #
  # ### Example
  #     # In one script, start this first
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.bind( sockaddr )
  #     socket.listen( 5 )
  #     client_fd, client_addrinfo = socket.sysaccept
  #     client_socket = Socket.for_fd( client_fd )
  #     puts "The client said, '#{client_socket.readline.chomp}'"
  #     client_socket.puts "Hello from script one!"
  #     socket.close
  #
  #     # In another script, start this second
  #     require 'socket'
  #     include Socket::Constants
  #     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
  #     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
  #     socket.connect( sockaddr )
  #     socket.puts "Hello from script 2."
  #     puts "The server said, '#{socket.readline.chomp}'"
  #     socket.close
  #
  # Refer to Socket#accept for the exceptions that may be thrown if the call to
  # *sysaccept* fails.
  #
  # ### See
  # *   Socket#accept
  #
  #
  def sysaccept: () -> [Integer, Addrinfo]

  private

  def __accept_nonblock: (untyped) -> untyped

  def __connect_nonblock: (untyped, untyped) -> untyped

  def __recvfrom_nonblock: (untyped, untyped, untyped, untyped) -> untyped

  # Creates a new socket object.
  #
  # *domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.
  #
  # *socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
  #
  # *protocol* is optional and should be a protocol defined in the domain. If
  # protocol is not given, 0 is used internally.
  #
  #     Socket.new(:INET, :STREAM) # TCP socket
  #     Socket.new(:INET, :DGRAM)  # UDP socket
  #     Socket.new(:UNIX, :STREAM) # UNIX stream socket
  #     Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket
  #
  def initialize: (Symbol domain, Symbol socktype, ?Integer protocol) -> untyped
end

# AppleTalk protocol
#
Socket::AF_APPLETALK: Integer

# CCITT (now ITU-T) protocols
#
Socket::AF_CCITT: Integer

# MIT CHAOS protocols
#
Socket::AF_CHAOS: Integer

# Computer Network Technology
#
Socket::AF_CNT: Integer

# Connection-oriented IP
#
Socket::AF_COIP: Integer

# Datakit protocol
#
Socket::AF_DATAKIT: Integer

# DEC Direct Data Link Interface protocol
#
Socket::AF_DLI: Integer

# CCITT (ITU-T) E.164 recommendation
#
Socket::AF_E164: Integer

# European Computer Manufacturers protocols
#
Socket::AF_ECMA: Integer

# NSC Hyperchannel protocol
#
Socket::AF_HYLINK: Integer

# ARPANET IMP protocol
#
Socket::AF_IMPLINK: Integer

# IPv4 protocol
#
Socket::AF_INET: Integer

# IPv6 protocol
#
Socket::AF_INET6: Integer

# IPX protocol
#
Socket::AF_IPX: Integer

# Integrated Services Digital Network
#
Socket::AF_ISDN: Integer

# ISO Open Systems Interconnection protocols
#
Socket::AF_ISO: Integer

# Local Area Transport protocol
#
Socket::AF_LAT: Integer

# Link layer interface
#
Socket::AF_LINK: Integer

# Host-internal protocols
#
Socket::AF_LOCAL: Integer

# Maximum address family for this platform
#
Socket::AF_MAX: Integer

# Native ATM access
#
Socket::AF_NATM: Integer

# Network driver raw access
#
Socket::AF_NDRV: Integer

# NetBIOS
#
Socket::AF_NETBIOS: Integer

# XEROX NS protocols
#
Socket::AF_NS: Integer

# ISO Open Systems Interconnection protocols
#
Socket::AF_OSI: Integer

# Point-to-Point Protocol
#
Socket::AF_PPP: Integer

# PARC Universal Packet protocol
#
Socket::AF_PUP: Integer

# Internal routing protocol
#
Socket::AF_ROUTE: Integer

# Simple Internet Protocol
#
Socket::AF_SIP: Integer

# IBM SNA protocol
#
Socket::AF_SNA: Integer

Socket::AF_SYSTEM: Integer

# UNIX sockets
#
Socket::AF_UNIX: Integer

# Unspecified protocol, any supported address family
#
Socket::AF_UNSPEC: Integer

# Accept only if any address is assigned
#
Socket::AI_ADDRCONFIG: Integer

# Allow all addresses
#
Socket::AI_ALL: Integer

# Fill in the canonical name
#
Socket::AI_CANONNAME: Integer

# Default flags for getaddrinfo
#
Socket::AI_DEFAULT: Integer

# Valid flag mask for getaddrinfo (not for application use)
#
Socket::AI_MASK: Integer

# Prevent host name resolution
#
Socket::AI_NUMERICHOST: Integer

# Prevent service name resolution
#
Socket::AI_NUMERICSERV: Integer

# Get address to use with bind()
#
Socket::AI_PASSIVE: Integer

# Accept IPv4-mapped IPv6 addresses
#
Socket::AI_V4MAPPED: Integer

# Accept IPv4 mapped addresses if the kernel supports it
#
Socket::AI_V4MAPPED_CFG: Integer

# Address family for hostname not supported
#
Socket::EAI_ADDRFAMILY: Integer

# Temporary failure in name resolution
#
Socket::EAI_AGAIN: Integer

# Invalid flags
#
Socket::EAI_BADFLAGS: Integer

# Invalid value for hints
#
Socket::EAI_BADHINTS: Integer

# Non-recoverable failure in name resolution
#
Socket::EAI_FAIL: Integer

# Address family not supported
#
Socket::EAI_FAMILY: Integer

# Maximum error code from getaddrinfo
#
Socket::EAI_MAX: Integer

# Memory allocation failure
#
Socket::EAI_MEMORY: Integer

# No address associated with hostname
#
Socket::EAI_NODATA: Integer

# Hostname nor servname, or not known
#
Socket::EAI_NONAME: Integer

# Argument buffer overflow
#
Socket::EAI_OVERFLOW: Integer

# Resolved protocol is unknown
#
Socket::EAI_PROTOCOL: Integer

# Servname not supported for socket type
#
Socket::EAI_SERVICE: Integer

# Socket type not supported
#
Socket::EAI_SOCKTYPE: Integer

# System error returned in errno
#
Socket::EAI_SYSTEM: Integer

# receive all multicast packets
#
Socket::IFF_ALLMULTI: Integer

# use alternate physical connection
#
Socket::IFF_ALTPHYS: Integer

# broadcast address valid
#
Socket::IFF_BROADCAST: Integer

# turn on debugging
#
Socket::IFF_DEBUG: Integer

# per link layer defined bit 0
#
Socket::IFF_LINK0: Integer

# per link layer defined bit 1
#
Socket::IFF_LINK1: Integer

# per link layer defined bit 2
#
Socket::IFF_LINK2: Integer

# loopback net
#
Socket::IFF_LOOPBACK: Integer

# supports multicast
#
Socket::IFF_MULTICAST: Integer

# no address resolution protocol
#
Socket::IFF_NOARP: Integer

# avoid use of trailers
#
Socket::IFF_NOTRAILERS: Integer

# transmission in progress
#
Socket::IFF_OACTIVE: Integer

# point-to-point link
#
Socket::IFF_POINTOPOINT: Integer

# receive all packets
#
Socket::IFF_PROMISC: Integer

# resources allocated
#
Socket::IFF_RUNNING: Integer

# can't hear own transmissions
#
Socket::IFF_SIMPLEX: Integer

# interface is up
#
Socket::IFF_UP: Integer

# Maximum interface name size
#
Socket::IFNAMSIZ: Integer

# Maximum interface name size
#
Socket::IF_NAMESIZE: Integer

# Multicast group for all systems on this subset
#
Socket::INADDR_ALLHOSTS_GROUP: Integer

# A socket bound to INADDR_ANY receives packets from all interfaces and sends
# from the default IP address
#
Socket::INADDR_ANY: Integer

# The network broadcast address
#
Socket::INADDR_BROADCAST: Integer

# The loopback address
#
Socket::INADDR_LOOPBACK: Integer

# The last local network multicast group
#
Socket::INADDR_MAX_LOCAL_GROUP: Integer

# A bitmask for matching no valid IP address
#
Socket::INADDR_NONE: Integer

# The reserved multicast group
#
Socket::INADDR_UNSPEC_GROUP: Integer

# Maximum length of an IPv6 address string
#
Socket::INET6_ADDRSTRLEN: Integer

# Maximum length of an IPv4 address string
#
Socket::INET_ADDRSTRLEN: Integer

# Default minimum address for bind or connect
#
Socket::IPPORT_RESERVED: Integer

# Default maximum address for bind or connect
#
Socket::IPPORT_USERRESERVED: Integer

# IP6 auth header
#
Socket::IPPROTO_AH: Integer

# IP6 destination option
#
Socket::IPPROTO_DSTOPTS: Integer

# Exterior Gateway Protocol
#
Socket::IPPROTO_EGP: Integer

# ISO cnlp
#
Socket::IPPROTO_EON: Integer

# IP6 Encapsulated Security Payload
#
Socket::IPPROTO_ESP: Integer

# IP6 fragmentation header
#
Socket::IPPROTO_FRAGMENT: Integer

# Gateway to Gateway Protocol
#
Socket::IPPROTO_GGP: Integer

# "hello" routing protocol
#
Socket::IPPROTO_HELLO: Integer

# IP6 hop-by-hop options
#
Socket::IPPROTO_HOPOPTS: Integer

# Control message protocol
#
Socket::IPPROTO_ICMP: Integer

# ICMP6
#
Socket::IPPROTO_ICMPV6: Integer

# XNS IDP
#
Socket::IPPROTO_IDP: Integer

# Group Management Protocol
#
Socket::IPPROTO_IGMP: Integer

# Dummy protocol for IP
#
Socket::IPPROTO_IP: Integer

# IP6 header
#
Socket::IPPROTO_IPV6: Integer

# Maximum IPPROTO constant
#
Socket::IPPROTO_MAX: Integer

# Sun net disk protocol
#
Socket::IPPROTO_ND: Integer

# IP6 no next header
#
Socket::IPPROTO_NONE: Integer

# PARC Universal Packet protocol
#
Socket::IPPROTO_PUP: Integer

# Raw IP packet
#
Socket::IPPROTO_RAW: Integer

# IP6 routing header
#
Socket::IPPROTO_ROUTING: Integer

# TCP
#
Socket::IPPROTO_TCP: Integer

# ISO transport protocol class 4
#
Socket::IPPROTO_TP: Integer

# UDP
#
Socket::IPPROTO_UDP: Integer

# Xpress Transport Protocol
#
Socket::IPPROTO_XTP: Integer

# Checksum offset for raw sockets
#
Socket::IPV6_CHECKSUM: Integer

# Don't fragment packets
#
Socket::IPV6_DONTFRAG: Integer

# Destination option
#
Socket::IPV6_DSTOPTS: Integer

# Hop limit
#
Socket::IPV6_HOPLIMIT: Integer

# Hop-by-hop option
#
Socket::IPV6_HOPOPTS: Integer

# Join a group membership
#
Socket::IPV6_JOIN_GROUP: Integer

# Leave a group membership
#
Socket::IPV6_LEAVE_GROUP: Integer

# IP6 multicast hops
#
Socket::IPV6_MULTICAST_HOPS: Integer

# IP6 multicast interface
#
Socket::IPV6_MULTICAST_IF: Integer

# IP6 multicast loopback
#
Socket::IPV6_MULTICAST_LOOP: Integer

# Next hop address
#
Socket::IPV6_NEXTHOP: Integer

# Retrieve current path MTU
#
Socket::IPV6_PATHMTU: Integer

# Receive packet information with datagram
#
Socket::IPV6_PKTINFO: Integer

# Receive all IP6 options for response
#
Socket::IPV6_RECVDSTOPTS: Integer

# Receive hop limit with datagram
#
Socket::IPV6_RECVHOPLIMIT: Integer

# Receive hop-by-hop options
#
Socket::IPV6_RECVHOPOPTS: Integer

# Receive current path MTU with datagram
#
Socket::IPV6_RECVPATHMTU: Integer

# Receive destination IP address and incoming interface
#
Socket::IPV6_RECVPKTINFO: Integer

# Receive routing header
#
Socket::IPV6_RECVRTHDR: Integer

# Receive traffic class
#
Socket::IPV6_RECVTCLASS: Integer

# Allows removal of sticky routing headers
#
Socket::IPV6_RTHDR: Integer

# Allows removal of sticky destination options header
#
Socket::IPV6_RTHDRDSTOPTS: Integer

# Routing header type 0
#
Socket::IPV6_RTHDR_TYPE_0: Integer

# Specify the traffic class
#
Socket::IPV6_TCLASS: Integer

# IP6 unicast hops
#
Socket::IPV6_UNICAST_HOPS: Integer

# Use the minimum MTU size
#
Socket::IPV6_USE_MIN_MTU: Integer

# Only bind IPv6 with a wildcard bind
#
Socket::IPV6_V6ONLY: Integer

# Add a multicast group membership
#
Socket::IP_ADD_MEMBERSHIP: Integer

# Add a multicast group membership
#
Socket::IP_ADD_SOURCE_MEMBERSHIP: Integer

# Block IPv4 multicast packets with a give source address
#
Socket::IP_BLOCK_SOURCE: Integer

# Default multicast loopback
#
Socket::IP_DEFAULT_MULTICAST_LOOP: Integer

# Default multicast TTL
#
Socket::IP_DEFAULT_MULTICAST_TTL: Integer

# Drop a multicast group membership
#
Socket::IP_DROP_MEMBERSHIP: Integer

# Drop a multicast group membership
#
Socket::IP_DROP_SOURCE_MEMBERSHIP: Integer

# Header is included with data
#
Socket::IP_HDRINCL: Integer

# IPsec security policy
#
Socket::IP_IPSEC_POLICY: Integer

# Maximum number multicast groups a socket can join
#
Socket::IP_MAX_MEMBERSHIPS: Integer

# Multicast source filtering
#
Socket::IP_MSFILTER: Integer

# IP multicast interface
#
Socket::IP_MULTICAST_IF: Integer

# IP multicast loopback
#
Socket::IP_MULTICAST_LOOP: Integer

# IP multicast TTL
#
Socket::IP_MULTICAST_TTL: Integer

# IP options to be included in packets
#
Socket::IP_OPTIONS: Integer

# Receive packet information with datagrams
#
Socket::IP_PKTINFO: Integer

# Set the port range for sockets with unspecified port numbers
#
Socket::IP_PORTRANGE: Integer

# Receive IP destination address with datagram
#
Socket::IP_RECVDSTADDR: Integer

# Receive interface information with datagrams
#
Socket::IP_RECVIF: Integer

# Receive all IP options with datagram
#
Socket::IP_RECVOPTS: Integer

# Receive all IP options for response
#
Socket::IP_RECVRETOPTS: Integer

# Receive TOS with incoming packets
#
Socket::IP_RECVTOS: Integer

# Receive IP TTL with datagrams
#
Socket::IP_RECVTTL: Integer

# IP options to be included in datagrams
#
Socket::IP_RETOPTS: Integer

# IP type-of-service
#
Socket::IP_TOS: Integer

# IP time-to-live
#
Socket::IP_TTL: Integer

# Unblock IPv4 multicast packets with a give source address
#
Socket::IP_UNBLOCK_SOURCE: Integer

# Retrieve peer credentials
#
Socket::LOCAL_PEERCRED: Integer

# Block multicast packets from this source
#
Socket::MCAST_BLOCK_SOURCE: Integer

# Exclusive multicast source filter
#
Socket::MCAST_EXCLUDE: Integer

# Inclusive multicast source filter
#
Socket::MCAST_INCLUDE: Integer

# Join a multicast group
#
Socket::MCAST_JOIN_GROUP: Integer

# Join a multicast source group
#
Socket::MCAST_JOIN_SOURCE_GROUP: Integer

# Leave a multicast group
#
Socket::MCAST_LEAVE_GROUP: Integer

# Leave a multicast source group
#
Socket::MCAST_LEAVE_SOURCE_GROUP: Integer

# Unblock multicast packets from this source
#
Socket::MCAST_UNBLOCK_SOURCE: Integer

# Control data lost before delivery
#
Socket::MSG_CTRUNC: Integer

# Send without using the routing tables
#
Socket::MSG_DONTROUTE: Integer

# This message should be non-blocking
#
Socket::MSG_DONTWAIT: Integer

# Data completes connection
#
Socket::MSG_EOF: Integer

# Data completes record
#
Socket::MSG_EOR: Integer

# Start of a hold sequence.  Dumps to so_temp
#
Socket::MSG_FLUSH: Integer

# Data ready to be read
#
Socket::MSG_HAVEMORE: Integer

# Hold fragment in so_temp
#
Socket::MSG_HOLD: Integer

# Process out-of-band data
#
Socket::MSG_OOB: Integer

# Peek at incoming message
#
Socket::MSG_PEEK: Integer

# Data remains in the current packet
#
Socket::MSG_RCVMORE: Integer

# Send the packet in so_temp
#
Socket::MSG_SEND: Integer

# Data discarded before delivery
#
Socket::MSG_TRUNC: Integer

# Wait for full request or error
#
Socket::MSG_WAITALL: Integer

# The service specified is a datagram service (looks up UDP ports)
#
Socket::NI_DGRAM: Integer

# Maximum length of a hostname
#
Socket::NI_MAXHOST: Integer

# Maximum length of a service name
#
Socket::NI_MAXSERV: Integer

# A name is required
#
Socket::NI_NAMEREQD: Integer

# An FQDN is not required for local hosts, return only the local part
#
Socket::NI_NOFQDN: Integer

# Return a numeric address
#
Socket::NI_NUMERICHOST: Integer

# Return the service name as a digit string
#
Socket::NI_NUMERICSERV: Integer

# AppleTalk protocol
#
Socket::PF_APPLETALK: Integer

# CCITT (now ITU-T) protocols
#
Socket::PF_CCITT: Integer

# MIT CHAOS protocols
#
Socket::PF_CHAOS: Integer

# Computer Network Technology
#
Socket::PF_CNT: Integer

# Connection-oriented IP
#
Socket::PF_COIP: Integer

# Datakit protocol
#
Socket::PF_DATAKIT: Integer

# DEC Direct Data Link Interface protocol
#
Socket::PF_DLI: Integer

# European Computer Manufacturers protocols
#
Socket::PF_ECMA: Integer

# NSC Hyperchannel protocol
#
Socket::PF_HYLINK: Integer

# ARPANET IMP protocol
#
Socket::PF_IMPLINK: Integer

# IPv4 protocol
#
Socket::PF_INET: Integer

# IPv6 protocol
#
Socket::PF_INET6: Integer

# IPX protocol
#
Socket::PF_IPX: Integer

# Integrated Services Digital Network
#
Socket::PF_ISDN: Integer

# ISO Open Systems Interconnection protocols
#
Socket::PF_ISO: Integer

Socket::PF_KEY: Integer

# Local Area Transport protocol
#
Socket::PF_LAT: Integer

# Link layer interface
#
Socket::PF_LINK: Integer

# Host-internal protocols
#
Socket::PF_LOCAL: Integer

# Maximum address family for this platform
#
Socket::PF_MAX: Integer

# Native ATM access
#
Socket::PF_NATM: Integer

# Network driver raw access
#
Socket::PF_NDRV: Integer

# NetBIOS
#
Socket::PF_NETBIOS: Integer

# XEROX NS protocols
#
Socket::PF_NS: Integer

# ISO Open Systems Interconnection protocols
#
Socket::PF_OSI: Integer

Socket::PF_PIP: Integer

# Point-to-Point Protocol
#
Socket::PF_PPP: Integer

# PARC Universal Packet protocol
#
Socket::PF_PUP: Integer

# Internal routing protocol
#
Socket::PF_ROUTE: Integer

Socket::PF_RTIP: Integer

# Simple Internet Protocol
#
Socket::PF_SIP: Integer

# IBM SNA protocol
#
Socket::PF_SNA: Integer

Socket::PF_SYSTEM: Integer

# UNIX sockets
#
Socket::PF_UNIX: Integer

# Unspecified protocol, any supported address family
#
Socket::PF_UNSPEC: Integer

# eXpress Transfer Protocol
#
Socket::PF_XTP: Integer

# Process credentials
#
Socket::SCM_CREDS: Integer

# Access rights
#
Socket::SCM_RIGHTS: Integer

# Timestamp (timeval)
#
Socket::SCM_TIMESTAMP: Integer

# Shut down the reading side of the socket
#
Socket::SHUT_RD: Integer

# Shut down the both sides of the socket
#
Socket::SHUT_RDWR: Integer

# Shut down the writing side of the socket
#
Socket::SHUT_WR: Integer

# A datagram socket provides connectionless, unreliable messaging
#
Socket::SOCK_DGRAM: Integer

# A raw socket provides low-level access for direct access or implementing
# network protocols
#
Socket::SOCK_RAW: Integer

# A reliable datagram socket provides reliable delivery of messages
#
Socket::SOCK_RDM: Integer

# A sequential packet socket provides sequenced, reliable two-way connection for
# datagrams
#
Socket::SOCK_SEQPACKET: Integer

# A stream socket provides a sequenced, reliable two-way connection for a byte
# stream
#
Socket::SOCK_STREAM: Integer

# Socket-level options
#
Socket::SOL_SOCKET: Integer

# Maximum connection requests that may be queued for a socket
#
Socket::SOMAXCONN: Integer

# Socket has had listen() called on it
#
Socket::SO_ACCEPTCONN: Integer

# Permit sending of broadcast messages
#
Socket::SO_BROADCAST: Integer

# Debug info recording
#
Socket::SO_DEBUG: Integer

# Use interface addresses
#
Socket::SO_DONTROUTE: Integer

# Retain unread data
#
Socket::SO_DONTTRUNC: Integer

# Get and clear the error status
#
Socket::SO_ERROR: Integer

# Keep connections alive
#
Socket::SO_KEEPALIVE: Integer

# Linger on close if data is present
#
Socket::SO_LINGER: Integer

# Install socket-level Network Kernel Extension
#
Socket::SO_NKE: Integer

# Don't SIGPIPE on EPIPE
#
Socket::SO_NOSIGPIPE: Integer

# Get first packet byte count
#
Socket::SO_NREAD: Integer

# Leave received out-of-band data in-line
#
Socket::SO_OOBINLINE: Integer

# Receive buffer size
#
Socket::SO_RCVBUF: Integer

# Receive low-water mark
#
Socket::SO_RCVLOWAT: Integer

# Receive timeout
#
Socket::SO_RCVTIMEO: Integer

# Allow local address reuse
#
Socket::SO_REUSEADDR: Integer

# Allow local address and port reuse
#
Socket::SO_REUSEPORT: Integer

# Send buffer size
#
Socket::SO_SNDBUF: Integer

# Send low-water mark
#
Socket::SO_SNDLOWAT: Integer

# Send timeout
#
Socket::SO_SNDTIMEO: Integer

# Receive timestamp with datagrams (timeval)
#
Socket::SO_TIMESTAMP: Integer

# Get the socket type
#
Socket::SO_TYPE: Integer

# Bypass hardware when possible
#
Socket::SO_USELOOPBACK: Integer

# Give a hint when more data is ready
#
Socket::SO_WANTMORE: Integer

# OOB data is wanted in MSG_FLAG on receive
#
Socket::SO_WANTOOBFLAG: Integer

# Reduce step of the handshake process (Linux 3.7, glibc 2.18)
#
Socket::TCP_FASTOPEN: Integer

# Maximum number of keepalive probes allowed before dropping a connection (Linux
# 2.4, glibc 2.2)
#
Socket::TCP_KEEPCNT: Integer

# Time between keepalive probes (Linux 2.4, glibc 2.2)
#
Socket::TCP_KEEPINTVL: Integer

# Set maximum segment size
#
Socket::TCP_MAXSEG: Integer

# Don't delay sending to coalesce packets
#
Socket::TCP_NODELAY: Integer

# Don't use TCP options
#
Socket::TCP_NOOPT: Integer

# Don't push the last block of write
#
Socket::TCP_NOPUSH: Integer

# Socket::Ifaddr represents a result of getifaddrs() function.
class Socket::Ifaddr
  public

  # Returns the address of *ifaddr*. nil is returned if address is not available
  # in *ifaddr*.
  #
  def addr: () -> Addrinfo?

  # Returns the broadcast address of *ifaddr*. nil is returned if the flags
  # doesn't have IFF_BROADCAST.
  #
  def broadaddr: () -> Addrinfo?

  # Returns the destination address of *ifaddr*. nil is returned if the flags
  # doesn't have IFF_POINTOPOINT.
  #
  def dstaddr: () -> Addrinfo?

  # Returns the flags of *ifaddr*.
  #
  def flags: () -> Integer

  # Returns the interface index of *ifaddr*.
  #
  def ifindex: () -> Integer

  # Returns a string to show contents of *ifaddr*.
  #
  def inspect: () -> String

  # Returns the interface name of *ifaddr*.
  #
  def name: () -> String

  # Returns the netmask address of *ifaddr*. nil is returned if netmask is not
  # available in *ifaddr*.
  #
  def netmask: () -> Addrinfo?
end

# UDP/IP address information used by Socket.udp_server_loop.
class Socket::UDPSource
  public

  def inspect: () -> String

  # Local address
  #
  def local_address: () -> Addrinfo

  # Address of the source
  #
  def remote_address: () -> Addrinfo

  # Sends the String `msg` to the source
  #
  def reply: (String msg) -> void

  private

  # `remote_address` is an Addrinfo object.
  #
  # `local_address` is an Addrinfo object.
  #
  # `reply_proc` is a Proc used to send reply back to the source.
  #
  def initialize: (Addrinfo remote_address, Addrinfo local_address) { (String) -> void } -> void
end

# Socket::AncillaryData represents the ancillary data (control information) used
# by sendmsg and recvmsg system call.  It contains socket #family, control
# message (cmsg) #level, cmsg #type and cmsg #data.
class Socket::AncillaryData
  # Creates a new Socket::AncillaryData object which contains a int as data.
  #
  # The size and endian is dependent on the host.
  #
  #     require 'socket'
  #
  #     p Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)
  #     #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>
  #
  def self.int: (Symbol, Symbol, Symbol, Symbol) -> instance

  # Returns new ancillary data for IP_PKTINFO.
  #
  # If spec_dst is not given, addr is used.
  #
  # IP_PKTINFO is not standard.
  #
  # Supported platform: GNU/Linux
  #
  #     addr = Addrinfo.ip("127.0.0.1")
  #     ifindex = 0
  #     spec_dst = Addrinfo.ip("127.0.0.1")
  #     p Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dst)
  #     #=> #<Socket::AncillaryData: INET IP PKTINFO 127.0.0.1 ifindex:0 spec_dst:127.0.0.1>
  #
  def self.ip_pktinfo: (Addrinfo addr, Integer ifindex, ?Addrinfo spec_dst) -> instance

  # Returns new ancillary data for IPV6_PKTINFO.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     p Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     #=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO ::1 ifindex:0>
  #
  def self.ipv6_pktinfo: (Addrinfo addr, Integer ifindex) -> instance

  # Creates a new Socket::AncillaryData object which contains file descriptors as
  # data.
  #
  #     p Socket::AncillaryData.unix_rights(STDERR)
  #     #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>
  #
  def self.unix_rights: (IO fd) -> instance

  public

  # tests the level and type of *ancillarydata*.
  #
  #     ancdata = Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")
  #     ancdata.cmsg_is?(Socket::IPPROTO_IPV6, Socket::IPV6_PKTINFO) #=> true
  #     ancdata.cmsg_is?(:IPV6, :PKTINFO)       #=> true
  #     ancdata.cmsg_is?(:IP, :PKTINFO)         #=> false
  #     ancdata.cmsg_is?(:SOCKET, :RIGHTS)      #=> false
  #
  def cmsg_is?: (Integer level, Integer ancillary_type) -> bool

  # returns the cmsg data as a string.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").data
  #     #=> ""
  #
  def data: () -> String

  # returns the socket family as an integer.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").family
  #     #=> 10
  #
  def family: () -> Integer

  # returns a string which shows ancillarydata in human-readable form.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").inspect
  #     #=> "#<Socket::AncillaryData: INET6 IPV6 PKTINFO \"\">"
  #
  def inspect: () -> String

  # Returns the data in *ancillarydata* as an int.
  #
  # The size and endian is dependent on the host.
  #
  #     ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)
  #     p ancdata.int #=> 2
  #
  def int: () -> Integer

  # Extracts addr, ifindex and spec_dst from IP_PKTINFO ancillary data.
  #
  # IP_PKTINFO is not standard.
  #
  # Supported platform: GNU/Linux
  #
  #     addr = Addrinfo.ip("127.0.0.1")
  #     ifindex = 0
  #     spec_dest = Addrinfo.ip("127.0.0.1")
  #     ancdata = Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dest)
  #     p ancdata.ip_pktinfo
  #     #=> [#<Addrinfo: 127.0.0.1>, 0, #<Addrinfo: 127.0.0.1>]
  #
  def ip_pktinfo: () -> [Addrinfo, Integer, Addrinfo]

  # Extracts addr and ifindex from IPV6_PKTINFO ancillary data.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     p ancdata.ipv6_pktinfo #=> [#<Addrinfo: ::1>, 0]
  #
  def ipv6_pktinfo: () -> [Addrinfo, Integer]

  # Extracts addr from IPV6_PKTINFO ancillary data.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     p ancdata.ipv6_pktinfo_addr #=> #<Addrinfo: ::1>
  #
  def ipv6_pktinfo_addr: () -> Addrinfo

  # Extracts ifindex from IPV6_PKTINFO ancillary data.
  #
  # IPV6_PKTINFO is defined by RFC 3542.
  #
  #     addr = Addrinfo.ip("::1")
  #     ifindex = 0
  #     ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)
  #     p ancdata.ipv6_pktinfo_ifindex #=> 0
  #
  def ipv6_pktinfo_ifindex: () -> Integer

  # returns the cmsg level as an integer.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").level
  #     #=> 41
  #
  def level: () -> Integer

  # returns the timestamp as a time object.
  #
  # *ancillarydata* should be one of following type:
  # *   SOL_SOCKET/SCM_TIMESTAMP (microsecond) GNU/Linux, FreeBSD, NetBSD,
  #     OpenBSD, Solaris, MacOS X
  # *   SOL_SOCKET/SCM_TIMESTAMPNS (nanosecond) GNU/Linux
  # *   SOL_SOCKET/SCM_BINTIME (2**(-64) second) FreeBSD
  #
  #     Addrinfo.udp("127.0.0.1", 0).bind {|s1|
  #         Addrinfo.udp("127.0.0.1", 0).bind {|s2|
  #           s1.setsockopt(:SOCKET, :TIMESTAMP, true)
  #           s2.send "a", 0, s1.local_address
  #           ctl = s1.recvmsg.last
  #           p ctl    #=> #<Socket::AncillaryData: INET SOCKET TIMESTAMP 2009-02-24 17:35:46.775581>
  #           t = ctl.timestamp
  #           p t      #=> 2009-02-24 17:35:46 +0900
  #           p t.usec #=> 775581
  #           p t.nsec #=> 775581000
  #         }
  #
  #     }
  #
  #
  def timestamp: () -> Time

  # returns the cmsg type as an integer.
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").type
  #     #=> 2
  #
  def type: () -> Integer

  # returns the array of IO objects for SCM_RIGHTS control message in UNIX domain
  # socket.
  #
  # The class of the IO objects in the array is IO or Socket.
  #
  # The array is attached to *ancillarydata* when it is instantiated. For example,
  # BasicSocket#recvmsg attach the array when receives a SCM_RIGHTS control
  # message and :scm_rights=>true option is given.
  #
  #     # recvmsg needs :scm_rights=>true for unix_rights
  #     s1, s2 = UNIXSocket.pair
  #     p s1                                         #=> #<UNIXSocket:fd 3>
  #     s1.sendmsg "stdin and a socket", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)
  #     _, _, _, ctl = s2.recvmsg(:scm_rights=>true)
  #     p ctl                                        #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>
  #     p ctl.unix_rights                            #=> [#<IO:fd 6>, #<Socket:fd 7>]
  #     p File.identical?(STDIN, ctl.unix_rights[0]) #=> true
  #     p File.identical?(s1, ctl.unix_rights[1])    #=> true
  #
  #     # If :scm_rights=>true is not given, unix_rights returns nil
  #     s1, s2 = UNIXSocket.pair
  #     s1.sendmsg "stdin and a socket", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)
  #     _, _, _, ctl = s2.recvmsg
  #     p ctl #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>
  #     p ctl.unix_rights #=> nil
  #
  def unix_rights: () -> Array[IO]?

  private

  # *family* should be an integer, a string or a symbol.
  # *   Socket::AF_INET, "AF_INET", "INET", :AF_INET, :INET
  # *   Socket::AF_UNIX, "AF_UNIX", "UNIX", :AF_UNIX, :UNIX
  # *   etc.
  #
  #
  # *cmsg_level* should be an integer, a string or a symbol.
  # *   Socket::SOL_SOCKET, "SOL_SOCKET", "SOCKET", :SOL_SOCKET and :SOCKET
  # *   Socket::IPPROTO_IP, "IP" and :IP
  # *   Socket::IPPROTO_IPV6, "IPV6" and :IPV6
  # *   Socket::IPPROTO_TCP, "TCP" and :TCP
  # *   etc.
  #
  #
  # *cmsg_type* should be an integer, a string or a symbol. If a string/symbol is
  # specified, it is interpreted depend on *cmsg_level*.
  # *   Socket::SCM_RIGHTS, "SCM_RIGHTS", "RIGHTS", :SCM_RIGHTS, :RIGHTS for
  #     SOL_SOCKET
  # *   Socket::IP_RECVTTL, "RECVTTL" and :RECVTTL for IPPROTO_IP
  # *   Socket::IPV6_PKTINFO, "PKTINFO" and :PKTINFO for IPPROTO_IPV6
  # *   etc.
  #
  #
  # *cmsg_data* should be a string.
  #
  #     p Socket::AncillaryData.new(:INET, :TCP, :NODELAY, "")
  #     #=> #<Socket::AncillaryData: INET TCP NODELAY "">
  #
  #     p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")
  #     #=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO "">
  #
  def initialize: (Symbol | String | Integer family, Symbol | String | Integer cmsg_level, Symbol | String | Integer cmsg_data, String cmsg_data) -> untyped
end
